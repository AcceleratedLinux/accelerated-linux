# Prints a config that includes only the symbols that are visible.

import os
import sys
import json
import pathlib
import kconfiglib
from kconfiglib import Symbol, BOOL, TRISTATE
from enum import IntEnum

HEADER = '''#
# Generated by Digi Accelerated Linux kcheck: DO NOT EDIT
#
'''


class TRISTATE_VAL(IntEnum):
    NO = 0
    MODULE = 1
    YES = 2


def configify(name):
    return name.upper().replace('-', '_')


def _as_list(o):
    """Returns `o` in a list, if it isn't a list already."""
    return o if isinstance(o, list) else [o]


def _set_Symbol_value(item, val):
    """ Convert the (probably string-valued) val into the
        appropriate type for the Symbol item, then update
        the Symbol's value. """
    success = True
    v = str(val)
    if (item.orig_type in (BOOL, TRISTATE)
            and item.choice and v != 'n'):
        item.choice.set_value(v)
        if item.choice.str_value != v:
            success = False
    item.set_value(v)
    if (item.orig_type in (BOOL, TRISTATE)
            and item.str_value != v):
        success = False
    return success


def _select_all_Symbols(node):
    """ Recursively return all Symbol-typed items in the node tree """
    while node:
        if isinstance(node.item, Symbol):
            yield node.item
        if node.list:
            for item in _select_all_Symbols(node.list):
                yield item
        node = node.next


def uniq(l):
    """ Remove duplicates from sorted list l """
    i = 1
    while i < len(l):
        if l[i - 1] == l[i]:
            del l[i]
        else:
            i += 1
    return l

def dirprefix(path):
    """ Returns the string that can be consistently prepended to
        another path to make it relative to the directory identified by
        the path argument.
        This means the following expression is always meanigful:
            dirprefix(dir) + filename
    """
    if path == "." or path == "./":
        return ""
    elif path == "" or path.endswith('/'):
        return path
    else:
        return path + '/'

class Section():
    def __init__(self,
                 config_dir,
                 predefined_product_config_file,
                 Kconfig_dir):
        self.config_dir = dirprefix(config_dir)
        self.root_dir = ""
        self.predefined_product_config_file = predefined_product_config_file
        self.Kconfig_dir = dirprefix(Kconfig_dir)
        if self.config_dir is None or self.config_dir == self.root_dir:
            self.config_file = (
                f"{self.root_dir}{self.Kconfig_dir}.config")
        else:
            self.config_file = (
                f"{self.config_dir}{self.predefined_product_config_file}")
        self._load_config()

    def _load_config(self):
        os.environ["srctree"] = f"{self.root_dir}{self.Kconfig_dir}"
        Kconfig_path = f"{self.root_dir}{self.Kconfig_dir}Kconfig"
        self.Kconfig = kconfiglib.Kconfig(Kconfig_path, False)
        self.Kconfig.load_config(self.config_file)
        self.item = dict()
        for item in self.get_config_items():
            self.item[item.name] = item

    def unset_values(self):
        self.Kconfig.unset_values()

    def get_config_items(self):
        return _select_all_Symbols(self.Kconfig.top_node)

    def _get_item(self, name):
        return self.item[name]

    def _get_value(self, name):
        return self._get_item(name).user_value

    def check_value(self, name, val=TRISTATE_VAL.YES):
        try:
            return self._get_value(name) == val
        except KeyError:
            return False

    def write(self):
        print(f"writing {self.config_file}", file=sys.stderr)
        self.Kconfig.write_config(self.config_file, HEADER)


class DeviceSection(Section):
    def _find_product(self, products):
        for product in products.values():
            name = configify(
                f"DEFAULTS_{product['vendor']}_{product['product']}")
            if self.check_value(name):
                print(f"Found {product['vendor']} {product['product']}",
                      file=sys.stderr)
                return product

        # Offer some useful error messages before raising
        # the missing product exception
        device_path = self.config_file.split('/')
        if len(device_path) > 2:
            # DEFAULTS_v_p missing because Kconfig is out of date
            guess_vendor, guess_product = device_path[-3:-1]
            defsym = configify(f"DEFAULTS_{guess_vendor}_{guess_product}")
            if defsym not in self.Kconfig.syms:
                device_cfg = self.Kconfig
                device_kfile = os.path.join(device_cfg.srctree,
                                            device_cfg.top_node.filename)
                print(f"error: {device_kfile}: "
                      f"missing {defsym} (try 'make Kconfig'?)",
                      file=sys.stderr)

            # Look for product.py mistakes
            product_file = sys.modules['product'].__file__
            if guess_vendor not in [p['vendor'] for p in products.values()]:
                print(f"error: {product_file}: "
                      f"no products with vendor={guess_vendor!r}",
                      file=sys.stderr)
            if guess_product not in [p['product'] for p in products.values()]:
                print(f"error: {product_file}: "
                      f"no products with product={guess_product!r}",
                      file=sys.stderr)
            else:
                vendor_matches = [p['vendor']
                                  for p in products.values()
                                  if p['product'] == guess_product]
                if vendor_matches != [guess_vendor]:
                    print(f"error: {product_file}: "
                          f"found product {guess_product!r} "
                          f"but with vendors {vendor_matches!r}",
                          file=sys.stderr)

        raise KeyError(f"{self.config_file}: product not found in products database")

    def write_product_info(self, product):
        with open(self.config_file, 'a') as f:
            f.write('CONFIG_VENDOR=%s\n' % product['vendor'])
            f.write('CONFIG_PRODUCT=%s\n' % product['product'])
            f.write('CONFIG_LINUXDIR=linux\n')
            f.write('CONFIG_LIBCDIR=%s\n' % product['libc'])


class SectionError(dict):
    def __init__(self, name):
        super().__init__()
        self["name"] = name
        self["mismatch"] = dict()
        self["missing"] = dict()
        self["unknown"] = list()
        self["unneeded"] = dict()

    @property
    def had_error(self):
        return self["mismatch"] or self["missing"] or self["unknown"]

    def _warn(self, *arg):
        """Prints the warning message `*arg` to stderr"""
        print(repr(self["name"]), *arg, file=sys.stderr)

    def add_mismatch(self, name, actual_val, expected_val, groups):
        self["mismatch"][name] = dict(
            expected_val=expected_val,
            actual_val=actual_val,
            groups=groups)

    def add_missing(self, name, val, groups):
        self["missing"][name] = dict(val=val, groups=groups)

    def add_unknown(self, name):
        self["unknown"].append(name)

    def add_unneeded(self, name, val, groups):
        self["unneeded"][name] = dict(val=val, groups=groups)

    def print(self, section, section_name):
        for kconfig_item in section.get_config_items():
            name = kconfig_item.name
            if name in self["mismatch"]:
                mismatch = self["mismatch"][name]
                self._warn(f"mismatch: {section_name}: "
                           f"{name}={kconfig_item.str_value}, "
                           f"expected {mismatch['expected_val']} "
                           f"by groups {mismatch['groups']}")

            if name in self["unknown"]:
                self._warn(f"unknown: section:{section_name} "
                           f"file:{section.config_file} "
                           f"{name}={kconfig_item.str_value}")

        for name, missing in self["missing"].items():
            self._warn(f"missing: {section_name}: {name}, "
                       f"expected {missing['val']} "
                       f"by groups {missing['groups']}")


class Config():
    def __init__(self, products, config_dir, product=None):

        device_section = DeviceSection(config_dir, "config.device", "")

        self.product = product or device_section._find_product(products)
        # Once the product has been determined some environment variables need
        # to be set up so that the other configs can be successfully loaded.
        # e.g. the 'linux' section requires the "CC" variable.
        os.environ['ARCH'] = self.product['arch']
        os.environ['SRCARCH'] = self.product['arch']
        os.environ['CC'] = self.product['tools'] + "-gcc"
        os.environ['CC_VERSION_TEXT'] = os.popen(
            '$CC --version 2> /dev/null | head -n 1 | tr -d "\n"').read()
        os.environ['LD'] = self.product['tools'] + "-ld"
        os.environ['KERNELVERSION'] = 'unknown'

        self.sections = dict(
            device=device_section,
            linux=Section(config_dir, "config.linux", "linux"),
            modules=Section(config_dir, "config.modules", "modules"),
            user=Section(config_dir, "config.vendor", "config")
        )

    def get_section_names(self):
        return self.sections.keys()

    def get_section(self, section_name):
        return self.sections[section_name]

    def write_all_sections(self):
        for section_name in self.get_section_names():
            self.sections[section_name].write()
        self.sections["device"].write_product_info(self.product)


class MultiValue:
    """Accumulates the value(-list)s assigned to a symbol
       and can be asked to resolve to the 'most-specific' assigned value. """

    def __init__(self, initial_value=None, initial_context='*init*', name="?"):
        self.groups = set()
        self.values = []
        self.name = name  # only used in warning messages
        self._resolved = False
        if initial_value is not None:
            self.add_value(initial_value, initial_context)

    def add_value(self, value, context):
        value = _as_list(value)
        self.groups.add(context)
        entry = (value, context)
        if entry not in self.values:
            self._resolved = False
        self.values.append(entry)

    def _resolve(self):
        minlen = min((len(value) for (value, c) in self.values), default=0)
        self._candidates = [v for (v, c) in self.values if len(v) == minlen]
        self._candidates.sort()
        uniq(self._candidates)
        return self._candidates[0][0] if minlen else None

    def check(self):
        self.resolve()

        if len(self._candidates) == 1:
            return

        v0 = uniq(sorted(v[0] for v in self._candidates))
        if len(v0) > 1:
            print(f"{self.name}: conflicting values assigned")
            for value, context in self.values:
                print(f"  {value!r} from {context}")
            print(f"  using {self.resolve_multi()}")

    def resolve(self):
        """ Resolve to the default value. """
        if not self._resolved:
            self._resolved_value = self._resolve()
            self._resolved = True
        return self._resolved_value

    def resolve_multi(self):
        """ Resolves to the list of permissible values """
        self.resolve()
        return self._candidates[0] if self._candidates else []


class Product():
    def __init__(self, config, products, groups):
        # products is unused.
        self.config = config
        self.groups = set()
        self._load(self.config.product, groups)

    def __repr__(self):
        nitems = sum(map(len, self.item.values()))
        return (f"<Product {self.name!r}" +
                f", {len(self.groups)} groups" +
                f", {sum(map(len, self.item.values()))} items" +
                f">")

    @property
    def _section_names(self):
        return self.config.get_section_names()

    def _load(self, product, groups):
        self.item = dict()
        self.name = product['name']
        self.product_name = product['product']
        self.vendor_name = product['vendor']
        for section_name in self._section_names:
            self.item[section_name] = dict()
        self._load_product(product, groups)

    def _load_product(self, product, groups):
        self.item['device'][configify(f"DEFAULTS_{product['vendor']}")] = \
            MultiValue('y')
        self.item['device'][
            configify(f"DEFAULTS_{product['vendor']}"
                      f"_{product['product']}")] = MultiValue('y')
        self.item['device'][configify(f"DEFAULTS_LIBC_{product['libc']}")] = \
            MultiValue('y')
        self._load_group(product, groups, product['name'])

    def _load_group(self, group, groups, context):
        if 'include' in group:
            # Load included groups in depth-first order
            for name in group['include']:
                self.groups.add(name)
                self._load_group(groups[name], groups, f"{context} > {name}")
        for section_name in self._section_names:
            if section_name in group:
                self._load_section(group, section_name, context)

    def _load_section(self, group, section_name, context):
        for sym_name, sym_value in group[section_name].items():
            if sym_name not in self.item[section_name]:
                self.item[section_name][sym_name] = MultiValue(
                    name=f"{section_name}:{sym_name}")
            self.item[section_name][sym_name].add_value(sym_value, context)

    def _check_section(self, section_name):
        errors = SectionError(section_name)
        items = self.config.get_section(section_name).item
        # Loop over the settings as specified in product.py.
        for name, multival in self.item[section_name].items():
            multival.check()
            vals = multival.resolve_multi()
            if len(vals) == 1:
                vals_repr = repr(vals[0])
            else:
                vals_repr = f"one of {vals!r}"
            if name in items:
                item = items[name]
                if item.str_value not in map(str, vals):
                    errors.add_mismatch(name, item.str_value, vals_repr,
                                        multival.groups)
                elif not item.assignable:
                    errors.add_unneeded(name, vals_repr, multival.groups)
                elif len(vals) > 1 and str(vals[0]) != item.str_value:
                    print(f"warning: {section_name}:{item.name}:"
                          f" using non-default value, {item.str_value}")
            else:
                # An item is present in product.py, but there is no Kconfig
                # item for it.
                errors.add_missing(name, vals_repr, multival.groups)
        for name, item in items.items():
            if (not item.user_value) or (name in self.item[section_name]):
                continue
            if TRISTATE_VAL.NO in item.assignable:
                # An unknown bool or tristate that is set 'm' or 'y'
                # unexpectedly and not forced on by "select".
                errors.add_unknown(name)
            elif item.type not in (BOOL, TRISTATE) \
                    and item.str_value != item._str_default():
                # Other field (e.g. string) is set to non-default unexpectedly
                errors.add_unknown(name)
        return errors

    def _print_section_errors(self, section_name, errors):
        errors.print(self.config.get_section(section_name), section_name)

    def _set_section(self, section_name, set_missing=True):
        section = self.config.get_section(section_name)
        for item in section.get_config_items():
            try:
                val = self.item[section_name][item.name]
                _set_Symbol_value(item, val.resolve())
            except KeyError:
                if set_missing and item.type in (BOOL, TRISTATE):
                    item.set_value('n')

    def _set_only_section(self, section_name):
        self._set_section(section_name, set_missing=False)

    def check(self):
        errors = dict()
        for section_name in self._section_names:
            errors[section_name] = (
                self._check_section(section_name))
        if any(section.had_error for section in errors.values()):
            return errors
        return dict()

    def set_only(self):
        for section_name in self._section_names:
            self._set_only_section(section_name)
        self.config.write_all_sections()

    def set(self):
        for section_name in self._section_names:
            self.config.get_section(section_name).unset_values()
            self._set_section(section_name)
        self.config.write_all_sections()

    def print_errors(self, errors):
        for section_name in self._section_names:
            if section_name in errors:
                self._print_section_errors(section_name, errors[section_name])


def test(product, rootdir = '.', schemapath = "prop/config/schema/accns.schema"):
    def get_name(schema):
        for name in ['title', 'label']:
            if name in schema:
                return schema[name]
        return None

    def get_expected_values(properties):
        expected_values = [
            'type',
            'device',
            'path',
            'port',
            'mode',
            'radio',
            'ssid'
        ]

        dictionary = {}
        for value in expected_values:
            if value in properties and 'default' in properties[value]:
                # some values, specifically 'port' (thanks IX30) can be the
                # names of keys or the names of objects.
                dictionary[value] = properties[value]['default']

        if 'modem' in properties:
            dictionary['modem'] = get_expected_values(
                properties['modem']['properties']
            )

        return dictionary

    def get_std_node(node, schema):
        if 'properties' not in schema[node]:
            return {}
        schema = schema[node]['properties']
        dictionary = {node + "_qty": len(schema)}
        dictionary[node] = {}

        for prop in schema:
            p_dict = get_expected_values(schema[prop]['properties'])
            p_dict['name'] = get_name(schema[prop])
            dictionary[node][prop] = p_dict

        return dictionary

    dictionary = {}

    content = pathlib.Path(rootdir, schemapath).read_text()
    schema = json.loads(content)

    prop = schema['properties']

    nodes = {
        'network': [
            'interface',
            'device',
            'bridge',
            'modem',
            'hotspot'
        ],
        'device': [
            'usb'
        ]
    }
    for toplevel in nodes:
        if toplevel in prop:
            node_prop = prop[toplevel]['properties']
            dictionary[toplevel] = {}
            for node in nodes[toplevel]:
                if node in node_prop:
                    dictionary[toplevel].update(
                        get_std_node(node, node_prop)
                    )

    if 'wifi' in prop['network']['properties']:
        # Wifi is a double deep node, we handle it separately
        node_prop = prop['network']['properties']['wifi']['properties']
        dictionary['wifi'] = {}
        for node in ['radio', 'ap', 'client']:
            dictionary['wifi'].update(
                get_std_node(node, node_prop)
            )

    if 'serial' in prop:
        # Serial is a toplevel node, we handle it separately
        dictionary.update(get_std_node('serial', prop))

    dictionary.update({'features': sorted(product.groups)})
    return dictionary
