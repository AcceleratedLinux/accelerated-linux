#!/bin/sh
#
# Action for AnywhereUSB 8/24 specific LED setting
#
##############################################################
# allow script override
[ -x /etc/config/led ] && exec /etc/config/led "$@"
##############################################################
#exec 2>> /tmp/led.log
#set -x

if [ "$(fw_printenv | grep model | cut -d= -f 2)" = "AW24" ]; then
	# power supplies are built in, so always present
	runt set system.chassis.psu1 "present"
	runt set system.chassis.psu2 "present"

	pwr_reg="$(grep 6c /sys/bus/i2c/drivers/awusb24_cpld/0-0059/cpld/regs | cut -d: -f 2)"
	if [ "$(( pwr_reg / 2  % 2 ))" = "1" ]; then
		runt set system.chassis.psu1_voltage "12"
		runt set system.chassis.psu1_power "yes"
	else
		runt set system.chassis.psu1_voltage "0"
		runt set system.chassis.psu1_power "no"
	fi

	if [ "$(( pwr_reg / 1  % 2 ))" = "1" ]; then
		runt set system.chassis.psu2_voltage "12"
		runt set system.chassis.psu2_power "yes"
	else
		runt set system.chassis.psu2_voltage "0"
		runt set system.chassis.psu2_power "no"
	fi
fi

fan_led_update()
{
	FAN=""
	fans="fan1"
	if [ "$(fw_printenv | grep model | cut -d= -f 2)" = "AW24" ]; then
		fans="${fans} fan2"
	fi

	# Set CPU temp alarms
	TEMP_HIGH_ALARM=$(cat /sys/class/hwmon/hwmon0/temp2_max_alarm)
	TEMP_CRIT_ALARM=$(cat /sys/class/hwmon/hwmon0/temp2_crit_alarm)
	runt set system.chassis.temp_high_alarm "$TEMP_HIGH_ALARM"
	runt set system.chassis.temp_crit_alarm "$TEMP_CRIT_ALARM"

	for fan in ${fans}; do
		RPM=$(cat /sys/class/hwmon/hwmon0/${fan}_input)
		FAN_ALARM=$(cat /sys/class/hwmon/hwmon0/${fan}_alarm)
		runt set system.chassis.${fan} "present"
		runt set system.chassis.${fan}_rpm "$RPM"
		# fan alarm is set after 3 minutes at fan max speed
		runt set system.chassis.${fan}_alarm "$FAN_ALARM"

		if [ "$RPM" -le "1000" ]; then
			# If the fan isn't spinning fast enough, then set an artificial "alarm"
			runt set system.chassis.${fan}_alarm "1"
			# Don't glitch the flash if we're already flashing
			if [ "$(cat /sys/class/leds/${fan}r/delay_on > /dev/null 2>&1)" != "250" ]; then
				FAN="$FAN -O ${fan}g -F ${fan}r"
			fi
		elif [ "$FAN_ALARM" = "1" ]; then
			# Don't glitch the flash if we're already flashing
			if [ "$(cat /sys/class/leds/${fan}r/delay_on > /dev/null 2>&1)" != "500" ]; then
				FAN="$FAN -O ${fan}g -f ${fan}r"
			fi
		else
			FAN="$FAN -o ${fan}g -O ${fan}r"
		fi
	done
}

wwan_led_update()
{
    WWAN_SERV="-O wanserg -O wanserr"
    WWAN_SIG="-O wansigg -O wansigr"

    eval "$(config stop)"
    eval "$(config start)"
    config load

    if config exists network.interface modem && \
        [ "$(config get network.interface.modem.enable)" = "1" ]; then
		MODEM_STATUS=$(runt get mm.persist.port.module.status)
		if [ "$MODEM_STATUS" = "Updating firmware" ]; then
			WWAN_SERV="-O wanserg -f wanserr"
			WWAN_SIG="-O wansigg -f wansigr"
		elif [ "$MODEM_STATUS" = "Recovering firmware" ]; then
			WWAN_SERV="-f wanserg -O wanserr"
			WWAN_SIG="-f wansigg -O wansigr"
		else
			modem_name="$(modem name)" 2>/dev/null
			if [ -z "$modem_name" ]; then
				if sim -m 2>/dev/null | grep -qw yes; then
					# Slow flash SERV while waiting for modem to appear
					WWAN_SERV="-f wanserg -O wanserr"
					WWAN_SIG="-O wansigg -O wansigr"
				else
					# No modem present at all. Everything off
					WWAN_SERV="-O wanserg -O wanserr"
					WWAN_SIG="-O wansigg -O wansigr"
				fi
			else
				case "$(runt get mm.modem.$modem_name.status.bars)" in
				5)   WWAN_SIG="-o wansigg -O wansigr" ;;
				4|3) WWAN_SIG="-F wansigg -O wansigr" ;;
				2|1) WWAN_SIG="-f wansigg -O wansigr" ;;
				0)   WWAN_SIG="-O wansigg -f wansigr" ;;
				*)   WWAN_SIG="-O wansigg -O wansigr" ;;
				esac

				if [ "$(runt get mm.modem.$modem_name.status.state)" = connected ]; then
					WWAN_SERV="-o wanserg -O wanserr"
				elif [ -z "$(runt get mm.modem.$modem_name.modem.imsi)" ]; then
					# No SIM present
					WWAN_SERV="-O wanserg -o wanserr"
				else
					# Connecting
					WWAN_SERV="-F wanserg -O wanserr"
				fi
			fi
		fi
	fi
    eval "$(config stop)"
}

wifi_led_update()
{
	WIFI_SERV=

	eval "$(config stop)"
	eval "$(config start)"
	config load

	error=0
	ap_status="off"
	client_status="off"
	if config exists network wifi; then
		runt update network.wifi
		aps=$(config keys network.wifi.ap)
		for ap in $aps ; do
			ap=${ap%%.*}
			device="$(runt get network.wifi.ap."$ap".device)"
			if [ -n "$device" ]; then
				if ip link show "$device" up 2>&1 | grep -q "state UP"; then
					ap_status="on"
				fi
			fi
		done

		clients=$(config keys network.wifi.client)
		for client in $clients ; do
			client=${client%%.*}
			device="$(runt get network.wifi.client."$client".device)"
			if [ -n "$device" ]; then
				if ip link show "$device" up 2>&1 | grep -q "state UP"; then
					client_status="connected"
				else
					client_status="searching"
				fi
			fi
		done
	fi
	eval "$(config stop)"
		
####################################################################################
#
# Wifi LED table
#
# We have wifig and wifir to work with.
#
#--------------------------------------------------------------------------|
# State                      |   wifig    |   wifir    |   Color           |
#--------------------------------------------------------------------------|
# Unconfigured               |    Off     |    Off     |      No Light     |
#--------------------------------------------------------------------------|
# Client Connected (No AP)   |    On      |    Off     |    Green Solid    |
#--------------------------------------------------------------------------|
# Client Searching (No AP)   | Slow Flash |    Off     |    Green Flash    |
#--------------------------------------------------------------------------|
# Client unconfig - AP up    |    On      |    On      |    Amber Solid    |
#--------------------------------------------------------------------------|
# Client Connected - AP up   |    On      |    On      |    Amber Solid    |
#--------------------------------------------------------------------------|
# Client Searching - AP up   |    On      | Slow Flash | Amber/Green Flash |
#--------------------------------------------------------------------------|
# Error                      |    Off     |    On      |     Red Solid     |
#--------------------------------------------------------------------------|
	if [ "$error" = "1" ]; then
		WIFI_SERV="-o wifir -O wifig"
	else
		if [ "$client_status" = "connected" ] && [ "$ap_status" = "off" ]; then
			WIFI_SERV="-o wifig -O wifir" # green
		elif [ "$client_status" = "off" ] && [ "$ap_status" = "on" ]; then
			WIFI_SERV="-o wifig -o wifir" # amber
		elif [ "$client_status" = "searching" ] && [ "$ap_status" = "off" ]; then
			# Don't glitch the flash if we're already flashing
			if [ "$(cat /sys/class/leds/wifig/delay_on)" != "500" ]; then
				WIFI_SERV="-f wifig -O wifir" # slow flash green
			fi
		elif [ "$client_status" = "connected" ] && [ "$ap_status" = "on" ]; then
			WIFI_SERV="-o wifig -o wifir" # amber
		elif [ "$client_status" = "searching" ] && [ "$ap_status" = "on" ]; then
			# Don't glitch the flash if we're already flashing
			if [ "$(cat /sys/class/leds/wifir/delay_on)" != "500" ]; then
				WIFI_SERV="-o wifig -f wifir" # slow flash amber/green
			fi
		else
			WIFI_SERV="-O wifig -O wifir"
		fi
	fi
}

findme_update()
{
	FINDME=
	if find-me state &>/dev/null; then
		FINDME="-o usrg -F usrr"
	else
		FINDME="-O usrg -O usrr"
	fi
}

case "$1" in
start|stop)
	ledcmd -O usrg -O usrr
	ledcmd -O wansigg -O wansigr
	ledcmd -O wanserg -O wanserr
	ledcmd -O wifig -O wifir
	ledcmd -O fan1g -O fan1r -O fan2g -O fan2r
	;;
reload)
	findme_update
	wwan_led_update
	wifi_led_update
	fan_led_update
	ledcmd $WWAN_SERV $WWAN_SIG $FINDME $WIFI_SERV $FAN
	;;
*)
	echo "Usage: $0 {start|stop|reload}"
	exit 1
	;;
esac

##############################################################
exit 0
