#!/bin/sh
#
# Action for Digi/TX54 LEDs
#
##############################################################
# allow script override
[ -x /etc/config/led ] && exec /etc/config/led "$@"
##############################################################

##############################################################
#exec 2>> /tmp/led.log
#set -x

##############################################################
# Cellular LEDs

# The number of modems and their names differ depending on platform variant.
# This information can be determined from the configuration.
eval $(config start)
config load
MODEM_NAMES="$(config keys network.modem)"
eval $(config stop)
NUM_MODEMS=$(echo "${MODEM_NAMES}" | wc -w)

# The script is used by both single and dual cellular TX54 models.
# Dual modem devices have more LEDs to update.
WWAN_LEDS="WWAN1"
[ "${NUM_MODEMS}" -eq 2 ] && WWAN_LEDS="${WWAN_LEDS} WWAN2"

findme_update() {
	FINDME=
	if find-me state &>/dev/null; then
		# flash WWAN service and signal strength LEDs green
		for wwan in ${WWAN_LEDS:="WWAN1 WWAN2"}; do
			FINDME="$FINDME -f ${wwan}_SERVICE_GREEN -f ${wwan}_SIGNAL_GREEN"
		done
		ledcmd $FINDME
		return 0
	fi
	return 1
}

case "$1" in
start)
	# Turn off all LEDs
	ledcmd -O ALL -o POWER

	exit 0
	;;
reload)
	# TX units have no way of setting an altbit on/off, so if FindMe is enabled we
	# use that to set the LED state instead of determining the LED states based off
	# of the cellular/Wi-Fi statuses using the logic after this case statement
	findme_update && exit 0
	;;
stop)
	# Flash POWER LED
	ledcmd -F POWER
	exit 0
	;;
*)
	echo "Usage: $0 {start|stop|reload}"
	exit 1
	;;
esac

LEDCMD=

##############################################################
# Update wifi leds
runt update network.wifi
eval $(config stop)
eval $(config start)
config load

WIFI1_LED_NAME="WIFI1"
WIFI2_LED_NAME=

case "$(runt get system.model)" in
	*Dual-Wi-Fi*)
		WIFI1_LED_NAME="WWAN2_SERVICE_GREEN"
		WIFI2_LED_NAME="WIFI1"
		;;
esac

wifi1_led="-O"
wifi2_led="-O"
aps=$(config keys network.wifi.ap)
for ap in $aps ; do
	ap=${ap%%.*}
	device="$(runt get network.wifi.ap.$ap.device)"
	if [ -n "$device" ]; then
		if ip link show $device up 2>/dev/null | grep -q "state UP"; then
			radio=$(config dump network.wifi.ap.$ap.radio)
			num="${radio//[^0-9]/}"
			[ $num = "1" ] && wifi1_led="-o" || wifi2_led="-o"
		fi
	fi
done

clients=$(config keys network.wifi.client)
for client in $clients ; do
	client=${client%%.*}
	device="$(runt get network.wifi.client.$client.device)"
	if [ -n "$device" ]; then
		if ip link show $device up 2>/dev/null | grep -q "state UP"; then
			radio=$(config dump network.wifi.client.$client.radio)
			num="${radio//[^0-9]/}"
			[ $num = "1" ] && wifi1_led="-o" || wifi2_led="-o"
		fi
	fi
done

LEDCMD="${LEDCMD} ${wifi1_led} ${WIFI1_LED_NAME}"
[ -z "${WIFI2_LED_NAME}" ] || LEDCMD="${LEDCMD} ${wifi2_led} ${WIFI2_LED_NAME}"

eval $(config stop)

# The TX54 has one LED per modem for signal strength
# Off: No service.
# Yellow: Poor / Fair signal.
# Green: Good / Excellent signal.
# Flashing Yellow with service: Modem firmware update
# Flashing Green with service: Modem firmware recovery
create_signal_led_args() {
	wwan=$1
	bars=$2

	case "$bars" in
		4|5) SIGNAL="-o ${wwan}_SIGNAL_GREEN -O ${wwan}_SIGNAL_YELLOW" ;;
		1|2|3) SIGNAL="-o ${wwan}_SIGNAL_YELLOW -O ${wwan}_SIGNAL_GREEN" ;;
		*) SIGNAL="-O ${wwan}_SIGNAL_YELLOW -O ${wwan}_SIGNAL_GREEN" ;;
	esac
}

# TX54 service LED
# Blinking Green: 2G/3G/4G connection is coming up.
# Solid Yellow: 2G or 3G connection is up.
# Solid Green: 4G connection is up.
# Off: Everything else.
# Flashing Yellow with signal: Modem firmware update
# Flashing Green with signal: Modem firmware recovery
create_service_led_args() {
	wwan=$1
	state=$2
	tech=$3

	if [ "$state" = connected ]; then
		case "$tech" in
			4g|5g) SERVICE="-o ${wwan}_SERVICE_GREEN -O ${wwan}_SERVICE_YELLOW" ;;
			3g|2g) SERVICE="-o ${wwan}_SERVICE_YELLOW -O ${wwan}_SERVICE_GREEN" ;;
			*) SERVICE="-O ${wwan}_SERVICE_YELLOW -O ${wwan}_SERVICE_GREEN" ;;
		esac
	elif [ "$state" = connecting ]; then
		SERVICE="-f ${wwan}_SERVICE_GREEN -O ${wwan}_SERVICE_YELLOW"
	else
		SERVICE="-O ${wwan}_SERVICE_YELLOW -O ${wwan}_SERVICE_GREEN"
	fi
}

get_modem_information() {
	modem_name=$1

	# Note that it can happen that although the port is present in runt,
	# nothing else (e.g. signal) relating to the modem is.
	state="$(runt get mm.modem.$modem_name.status.state)"
	if [ -n "$state" ]; then
		STATE="$state"
	fi

	bars="$(runt get mm.modem.$modem_name.status.bars)"
	if [ -n "$bars" ]; then
		BARS="$bars"
	fi

	tech="$(runt get mm.modem.$modem_name.status.gtech)"
	if [ -n "$tech" ]; then
		TECHNOLOGY="$tech"
	fi

	return
}

name_idx=1
for wwan in $WWAN_LEDS; do
	# Assign default modem states as the associated modem information may
	# not be available.
	STATE=disabled
	TECHNOLOGY=""
	BARS=0

	# Adjust the values if information is available from the associated modem.
	modem_name=$(echo ${MODEM_NAMES} | awk -v N=$name_idx '{print $N}')
	get_modem_information "$modem_name"

	MODEM_STATUS=$(runt get mm.persist.port.$modem_name.status)

	if [ "$MODEM_STATUS" = "updating" ]; then
		SERVICE="-O ${wwan}_SERVICE_GREEN -f ${wwan}_SERVICE_YELLOW"
		SIGNAL="-O ${wwan}_SIGNAL_GREEN -f ${wwan}_SIGNAL_YELLOW"
	elif [ "$MODEM_STATUS" = "recovering" ]; then
		SERVICE="-O ${wwan}_SERVICE_YELLOW -f ${wwan}_SERVICE_GREEN"
		SIGNAL="-O ${wwan}_SIGNAL_YELLOW -f ${wwan}_SIGNAL_GREEN"
	else
		create_signal_led_args "$wwan" "$BARS"
		create_service_led_args "$wwan" "$STATE" "$TECHNOLOGY"
	fi

	LEDCMD="${LEDCMD} ${SERVICE} ${SIGNAL}"
	name_idx=$(($name_idx + 1))
done

##############################################################
# GNSS LED
#
# Off: GNSS is disabled
# Flashing: GNSS is enabled but does not have a valid fix
# On: GNSS is enabled and has a valid fix
#
case "$(runt get location.state)" in
    "Enabled, signal") gnss_led_state="-o" ;;
    "Enabled, no signal") gnss_led_state="-f" ;;
    *) gnss_led_state="-O" ;;
esac

LEDCMD="${LEDCMD} $gnss_led_state GNSS"

##############################################################

[ -z "${LEDCMD}" ] || eval ledcmd ${LEDCMD}

exit 0
