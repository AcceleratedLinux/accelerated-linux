readonly REBOOT_TIME=3

readonly ROOTFS_SIZE_MAX=76546048
readonly SQUASHFS_IN_RAM=/tmp/squashfs
readonly UBI_NUM=0
readonly UBI_DEVICE=/dev/ubi${UBI_NUM}
readonly UBI_MTD=/dev/mtd11

readonly MOUNT_DIR=/mnt
readonly FIRMWARE_DIR="${MOUNT_DIR}/firmware"
readonly BOOTLOADER_FILE="${FIRMWARE_DIR}/bootloader.bin"
readonly FIRMWARE_FILE="${FIRMWARE_DIR}/firmware.bin"

error()
{
	echo "ERROR: $1"
	echo "Rebooting board in ${REBOOT_TIME} seconds..."

	# TODO: LED activity?

	reboot -d ${REBOOT_TIME}
}

get_rootfs_index()
{
	ROOTFS_INDEX=$(cat /proc/cmdline | sed -r 's/.*root=\/dev\/mtdblock([0-9]*).*/\1/g')
	case "${ROOTFS_INDEX}" in
		5|7) ;;
		*) error "invalid rootfs index"
	esac
}

cp_rootfs_2_ram()
{
	local rootfs_dev=/dev/mtd${ROOTFS_INDEX}

	# Dump squashfs header
	nanddump -f /tmp/squashfs_hdr -l 44 ${rootfs_dev} 2>/dev/null || error "couldn't read rootfs"

	# Verify if it is really a squashfs
	read -r -n 4 SQUASHFS_MAGIC < /tmp/squashfs_hdr || error "couldn't read squashfs magic"
	[ "${SQUASHFS_MAGIC}" = "hsqs" ] || error "invalid rootfs"

	# Get the squashfs size
	SQUASHFS_SIZE=$(hexdump -s 40 -n 4 -e '"0x%x"' /tmp/squashfs_hdr) || error "couldn't read rootfs size"
	SQUASHFS_SIZE=$(( (SQUASHFS_SIZE + 0xFFF) & 0xFFFFF000 + 96 ))

	rm -f /tmp/squashfs_hdr

	# Sanity check with rootfs partition size
	[ ${SQUASHFS_SIZE} -le ${ROOTFS_SIZE_MAX} ] || error "invalid rootfs size"

	# Copy squashfs image to the RAM
	nanddump -f "${SQUASHFS_IN_RAM}" -l ${SQUASHFS_SIZE} ${rootfs_dev} 2>/dev/null || error "couldn't copy rootfs to RAM"
}

create_ubi_partition()
{
	# Make sure UBI is not attached
	ubidetach -d ${UBI_NUM} 2>/dev/null

	# Create and attach the single, large UBI partition
	ubiformat -y ${UBI_MTD} || error "couldn't create UBI parititon"
	ubiattach -p ${UBI_MTD} || error "couldn't attach UBI partition"

	# Get full size of the UBI partition
	local lebs
	lebs=$(ubinfo -d${UBI_NUM} | grep "Amount of available")
	lebs=${lebs##*: }
	lebs=${lebs%% *}
	[ -n "${lebs}" ] || error "invalid UBI partition size"

	# We need to create 2 equal size volumes
	lebs=$((lebs / 2))

	# Create the filesystem volumes
	ubimkvol ${UBI_DEVICE} -N image -S ${lebs} && ubimkvol ${UBI_DEVICE} -N image1 -m || error "couldn't create UBI volumes"
}

update_partitions()
{
	local failed=0

	# Update first boot partition, and set that as valid
	if ubiupdatevol /dev/ubi0_0 "${FIRMWARE_FILE}"; then
		fw_setenv -s - << EOF
parta_valid 1
bootpart a
EOF
		# Third LED GREEN
		echo 1 > /sys/class/gpio/gpio401/value

	else
		echo "WARNING: couldn't write partition A"
		failed=$((failed + 1))

		# Third LED YELLOW
		echo 1 > /sys/class/gpio/gpio400/value
	fi

	# Update second boot partition, and set that as valid
	if ubiupdatevol /dev/ubi0_1 "${FIRMWARE_FILE}"; then
		fw_setenv -s - << EOF
partb_valid 1
bootpart b
EOF
		# Fourth LED GREEN
		echo 1 > /sys/class/gpio/gpio403/value
	else
		echo "WARNING: couldn't write partition B"
		failed=$((failed + 1))

		# Fourth LED YELLOW
		echo 1 > /sys/class/gpio/gpio402/value
	fi

	# Fail only if both writing failed
	[ ${failed} -lt 2 ] || error "failed to write both boot partitions"
}

set_env_vars()
{
	# Write both boot banks
	local count
	count=1
	while [ ${count} -gt 0 ]; do
		fw_setenv -s - << EOF
altbootcmd dboot flash alt
bootlimit 3
bootpretryperiod 5000
console ttyS1,115200
ethact eth0
fileaddr 83000000
loadfile image.bin
netretry yes
EOF

		count=$((count - 1))
	done
}

update_uboot()
{
	# Verify if bootloader image is really there
	[ -f "${BOOTLOADER_FILE}" ] || error "no bootloader update file found"

	flash_erase /dev/mtd1 0 0 &&
		nandwrite -m -p /dev/mtd1 "${BOOTLOADER_FILE}" || error "couldn't update bootloader"
}

echo "Mounting filesystems..."
mount -t proc proc /proc
mount -t sysfs sys /sys
mount -t devpts devpts /dev/pts
mount -t tmpfs -o size=96M tmpfs /tmp
mount -t tmpfs -o size=32M tmpfs /var
mkdir -m 1777 /var/tmp
mkdir -m 755 /var/log
mkdir -m 755 /var/run
mkdir -m 1777 /var/lock
mkdir -m 755 /var/empty

echo "Starting watchdog..."
watchdog /dev/watchdog

# make sure we dont see all errors
echo 6 > /proc/sys/kernel/printk

/etc/init_gpios start

echo "Initializing LED GPIO pins..."
# WIFI LED -- GPIO28 (508)
# WIFI GPS -- GPIO30 (510)
# WWAN1 SERVICE YELLOW LED -- I2C GPA7 (407)
# WWAN1 SERVICE GREEN LED -- I2C GPA6 (406)
# WWAN1 SIGNAL YELLOW LED -- I2C GPA5 (405)
# WWAN1 SIGNAL GREEN LED -- I2C GPA4 (404)
# WWAN2 SERVICE YELLOW LED -- I2C GPA3 (403)
# WWAN2 SERVICE GREEN LED -- I2C GPA2 (402)
# WWAN2 SIGNAL YELLOW LED -- I2C GPA1 (401)
# WWAN2 SIGNAL GREEN LED -- I2C GPA0 (400)
echo 508 > /sys/class/gpio/export
echo high > /sys/class/gpio/gpio508/direction
echo 1 > /sys/class/gpio/gpio508/active_low
echo 510 > /sys/class/gpio/export
echo high > /sys/class/gpio/gpio510/direction
echo 1 > /sys/class/gpio/gpio510/active_low
echo 400 > /sys/class/gpio/export
echo low > /sys/class/gpio/gpio400/direction
echo 401 > /sys/class/gpio/export
echo low > /sys/class/gpio/gpio401/direction
echo 402 > /sys/class/gpio/export
echo low > /sys/class/gpio/gpio402/direction
echo 403 > /sys/class/gpio/export
echo low > /sys/class/gpio/gpio403/direction
echo 404 > /sys/class/gpio/export
echo low > /sys/class/gpio/gpio404/direction
echo 405 > /sys/class/gpio/export
echo low > /sys/class/gpio/gpio405/direction
echo 406 > /sys/class/gpio/export
echo low > /sys/class/gpio/gpio406/direction
echo 407 > /sys/class/gpio/export
echo low > /sys/class/gpio/gpio407/direction

# Clear bootcount.
/etc/reset_bootcounter.sh

# Get rootfs index
get_rootfs_index

# Copy rootfs to RAM
echo "--- Moving files to RAM..."
cp_rootfs_2_ram

# Mount squashfs
mkdir "${MOUNT_DIR}"
mount "${SQUASHFS_IN_RAM}" "${MOUNT_DIR}" || error "couldn't mount rootfs"

# First LED GREEN
echo 1 > /sys/class/gpio/gpio405/value

# Create UBI partition and volumes
echo "--- Creating new filesystem..."
create_ubi_partition

# Second LED GREEN
echo 1 > /sys/class/gpio/gpio407/value

# Copy image to both boot banks, and update ENV vars
echo "--- Updating firmware partitions..."
update_partitions

# Set other ENV vars for the new OS
echo "--- Setting ENV vars..."
set_env_vars

# Fifth LED ON
echo 1 > /sys/class/gpio/gpio508/value

# Finally update the U-Boot
echo "--- Updating bootloader..."
update_uboot

# Sixth LED ON
echo 1 > /sys/class/gpio/gpio510/value

# And reboot the board
echo "SUCCESS!"
echo "Rebooting board..."
reboot -d 1
