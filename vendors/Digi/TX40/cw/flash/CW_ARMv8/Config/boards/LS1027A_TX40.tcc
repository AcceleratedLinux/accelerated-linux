<?xml version="1.0" encoding="ASCII"?>
<SelectedConfigurationModel:SelectedConfiguration xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:DebuggerDBModel="http://www.freescale.com/GTA/DebuggerDBModel_v2" xmlns:SelectedConfigurationModel="http://www.freescale.com/GTA/SelectedConfigurationModel_v3" targetInitFile="&quot;&quot;&quot;&#xA;Copyright 2018-2019 NXP.&#xA;All Rights Reserved&#xA;&#xA; This software is owned or controlled by NXP and may only be used strictly in accordance with the&#xA; applicable license terms.  By expressly accepting such terms or by downloading, installing,&#xA; activating and/or otherwise using the software, you are agreeing that you have read, and that you&#xA; agree to comply with and are bound by, such license terms.  If you do not agree to be bound by the&#xA; applicable license terms, then you may not retain, install, activate or otherwise use the software.&#xA;&quot;&quot;&quot;&#xA;import gdb&#xA;import time&#xA;&#xA;from cw.dbg import ta&#xA;from cw.dbg import flash&#xA;from cw.dbg.rcw import SPRcwValidation&#xA;from cw.utils import cw_info, cw_warn, cw_error&#xA;&#xA;from initialization import *&#xA;&#xA;CORE_CONTEXT = &quot;:ccs:LS1027A:CortexA72#0&quot;&#xA;SAP_CORE_CONTEXT = &quot;:ccs:LS1027A:SAP#0&quot;&#xA;&#xA;# In order to connect to a board with a broken RCW, set the following variable to True&#xA;# Override RCW using a safe hard-coded RCW option&#xA;USE_SAFE_RCW = True&#xA;# Base address for DCFG and Reset registers;&#xA;# they will be used to test if RCW and PBI phases were successful or not&#xA;DCFG_BASE_ADDRESS = 0x1E00000&#xA;RESET_BASE_ADDRESS = 0x1E60000&#xA;&#xA;DCSR_BASE_ADDRESS = 0x700000000&#xA;&#xA;FSPI_NAND = False&#xA;&#xA;# Set to True in order to enable memory access to Ethernet controller&#xA;# Set to False if target initializes the Ethernet controller (ex. uboot, Linux, etc.)&#xA;# Note:&#xA;# ENETC is configurable through RCW, which implies that PCIe functions 5 and 6&#xA;# may or may not be present.&#xA;# If ENETC PCIe function is disabled, accesses to ENETC PCIe function registers&#xA;# might put the target in a bad state.&#xA;# It is advised to avoid reading the ENETC registers of a disabled ENETC PCIe function.&#xA;PCI_INIT = True&#xA;&#xA;# Target access object&#xA;TA = ta.create()&#xA;&#xA;###################################################################&#xA;# Prepare environment/convenience variables&#xA;###################################################################&#xA;def Prepare_Env():&#xA;    set_init_params(context=CORE_CONTEXT, dcsr_addr=DCSR_BASE_ADDRESS)&#xA;    gdb.execute(&quot;set $ddr_addr = 0x80000000&quot;)&#xA;    gdb.execute(&quot;set $ocram_addr = 0x18000000&quot;)&#xA;&#xA;###################################################################&#xA;######### Reset&#xA;###################################################################&#xA;def Reset():&#xA;    if USE_SAFE_RCW:&#xA;        # Overridden RCW source&#xA;        TA.rcw.set_source(0x0)&#xA;&#xA;        # Overridden RCW to get the cores out of boothold off&#xA;        TA.rcw.set_data({9: 0x00000000})&#xA;        # Overridden RCW to enable ENETC PF5 and PF6&#xA;        if PCI_INIT:&#xA;            TA.rcw.set_data({27:0x000e6000})&#xA;&#xA;        TA.rcw.apply()&#xA;    else:&#xA;        # Perform a regular reset&#xA;        try:&#xA;            user_reset = int(gdb.parse_and_eval(&quot;$reset&quot;))&#xA;            user_reset_delay = int(gdb.parse_and_eval(&quot;$reset_delay&quot;))&#xA;        except gdb.error:&#xA;            user_reset = 1&#xA;            user_reset_delay = 0&#xA;&#xA;        if user_reset:&#xA;            try:&#xA;                gdb.execute(&quot;cw_reset %d&quot; % user_reset_delay)&#xA;            except gdb.error as exc:&#xA;                # Check if RCW or PBI phases were successful&#xA;                # Note: target accesses must be executed through SAP core&#xA;                target_access = ta.create()&#xA;                target_access.set_context(SAP_CORE_CONTEXT)&#xA;                SPRcwValidation(target_access, DCFG_BASE_ADDRESS, RESET_BASE_ADDRESS).check_for_rcw_or_pbi_error()&#xA;                # If check_for_rcw_or_pbi_error does not detect the error, forward the initial exception&#xA;                raise exc&#xA;&#xA;    Init_BRR()&#xA;&#xA;###################################################################&#xA;# Boot Release&#xA;###################################################################&#xA;def Init_BRR():&#xA;&#xA;    # TODO: when we can detect the current context,&#xA;    # release all cores for SMP, current core for AMP&#xA;&#xA;    # All cores must go to debug mode after release&#xA;    DCSR_LE_M(0x7002C, 0x00000003)&#xA;    # Write to BRR to release all cores&#xA;    CCSR_LE_M(0x01e60060, 0x00000003)&#xA;&#xA;    # Make sure the gdb threads are refreshed just after the BRR initialization&#xA;    TA.rc.refresh_threads()&#xA;&#xA;    # Make sure the cores are stopped&#xA;    TA.rc.halt()&#xA;&#xA;###################################################################&#xA;# PCI&#xA;###################################################################&#xA;def Init_PCI():&#xA;    # Small initialization to permit reading of ENETC registers&#xA;    # Enable MEM_ACCESS bit in PFx_PCI_HDR_TYPE0 register&#xA;    for id in range(7):&#xA;        CCSR_LE_M16(0x1F0000004 + id * 0x1000, 0x0002)&#xA;&#xA;###################################################################&#xA;# Adds Flash devices for this board&#xA;###################################################################&#xA;def Config_Flash_Devices():&#xA;    fl = flash.create(TA)&#xA;&#xA;    # Add FlexSPI device&#xA;    if FSPI_NAND:&#xA;        fl.add_device({&quot;alias&quot;: &quot;xspi&quot;, &quot;name&quot;: &quot;MT29F4G01ABBF&quot;, &quot;address&quot;: 0x0, &quot;ws_address&quot;: 0x18000000, &quot;ws_size&quot;: 0x1FFFF, &quot;geometry&quot;: &quot;8x1&quot;, &quot;controller&quot;: &quot;FSPI&quot;})&#xA;    else:&#xA;        fl.add_device({&quot;alias&quot;: &quot;xspi&quot;, &quot;name&quot;: &quot;MX25U12832F&quot;, &quot;address&quot;: 0x0, &quot;ws_address&quot;: 0x18000000, &quot;ws_size&quot;: 0x1FFFF, &quot;geometry&quot;: &quot;8x1&quot;, &quot;controller&quot;: &quot;FSPI&quot;})&#xA;&#xA;    #set xspi as current device&#xA;    fl.set_current_device(&quot;xspi&quot;)&#xA;&#xA;###################################################################&#xA;# TrustZone Initialization&#xA;###################################################################&#xA;def Init_TZASC():&#xA;    # TZASC&#xA;    CCSR_LE_M(0x01100004, 0x00000001)&#xA;    CCSR_LE_M(0x01100120, 0x00000000)&#xA;    CCSR_LE_M(0x01100124, 0x00000000)&#xA;    CCSR_LE_M(0x01100128, 0xffffffff)&#xA;    CCSR_LE_M(0x0110012C, 0xffffffff)&#xA;    CCSR_LE_M(0x01100130, 0xc0000001)&#xA;    CCSR_LE_M(0x01100134, 0xffffffff)&#xA;    CCSR_LE_M(0x01100008, 0x00010001)&#xA;&#xA;###################################################################&#xA;# FlexSPI Initialization&#xA;###################################################################&#xA;def Init_FSPI():&#xA;    pass&#xA;&#xA;###################################################################&#xA;# Detect DDR frequency&#xA;###################################################################&#xA;def Detect_DDR_Freq():&#xA;    # Detect DDR frequency using RCWSR1&#xA;&#xA;    # Hardcoded DDRCLK&#xA;    DDRCLK = 100.00&#xA;&#xA;    # Read RCWSR1 and obtain MEM_PLL_RAT&#xA;    RCWSR1 = CCSR_LE_D(DCFG_BASE_ADDRESS + 0x100)&#xA;    MEM_PLL_RAT = (RCWSR1 >> 10) &amp; 0x3F&#xA;    MEM_PLL_CFG_DIV = 1.0 / (((RCWSR1 >> 8) &amp; 0x3) + 1)&#xA;&#xA;    # Based on the reference clock for the DDR and PLLs config, compute DDR frequency&#xA;    DDR_FREQ = int(round(DDRCLK * MEM_PLL_RAT * MEM_PLL_CFG_DIV * 4)) # x4 is fixed&#xA;&#xA;    return DDR_FREQ&#xA;&#xA;###################################################################&#xA;# DDR Initialization&#xA;###################################################################&#xA;def Init_DDRC(ddr_freq):&#xA;    # DDR_CDR1&#xA;    CCSR_LE_M(0x01080b28, 0x80040000)&#xA;    # DDR_CDR2&#xA;    CCSR_LE_M(0x01080b2c, 0x0000A101)&#xA;    # DDR_SDRAM_CFG&#xA;    CCSR_LE_M(0x01080110, 0x470C0008)&#xA;    # CS0_BNDS&#xA;    CCSR_LE_M(0x01080000, 0x0000003F)&#xA;    # CS0_CONFIG&#xA;    CCSR_LE_M(0x01080080, 0x80044302)&#xA;    # TIMING_CFG_3&#xA;    CCSR_LE_M(0x01080100, 0x010E1000)&#xA;    # TIMING_CFG_0&#xA;    CCSR_LE_M(0x01080104, 0xA055000C)&#xA;    # TIMING_CFG_1&#xA;    CCSR_LE_M(0x01080108, 0xCEC48C46)&#xA;    # TIMING_CFG_2&#xA;    CCSR_LE_M(0x0108010c, 0x0040D128)&#xA;    # DDR_SDRAM_CFG_2&#xA;    CCSR_LE_M(0x01080114, 0x00401010)&#xA;    # DDR_SDRAM_MODE&#xA;    CCSR_LE_M(0x01080118, 0x00061C70)&#xA;    # DDR_SDRAM_MODE_2&#xA;    CCSR_LE_M(0x0108011c, 0x00180000)&#xA;    # DDR_SDRAM_MD_CNTL&#xA;    CCSR_LE_M(0x01080120, 0x00000000)&#xA;    # DDR_SDRAM_INTERVAL&#xA;    CCSR_LE_M(0x01080124, 0x18600618)&#xA;    # DDR_DATA_INIT&#xA;    CCSR_LE_M(0x01080128, 0x12345678)&#xA;    # DDR_SDRAM_CLK_CNTL&#xA;    CCSR_LE_M(0x01080130, 0x02800000)&#xA;    # TIMING_CFG_4&#xA;    CCSR_LE_M(0x01080160, 0x00000001)&#xA;    # TIMING_CFG_5&#xA;    CCSR_LE_M(0x01080164, 0x04401400)&#xA;    # TIMING_CFG_6&#xA;    CCSR_LE_M(0x01080168, 0x00000000)&#xA;    # TIMING_CFG_7&#xA;    CCSR_LE_M(0x0108016C, 0x13300000)&#xA;    # DDR_ZQ_CNTL&#xA;    CCSR_LE_M(0x01080170, 0x89080600)&#xA;    # DDR_WRLVL_CNTL&#xA;    CCSR_LE_M(0x01080174, 0x86550607)&#xA;    # DDR_WRLVL_CNTL_2&#xA;    CCSR_LE_M(0x01080190, 0x0708080A)&#xA;    # DDR_WRLVL_CNTL_3&#xA;    CCSR_LE_M(0x01080194, 0x0A0B0C09)&#xA;    # DDR_mode-9&#xA;    CCSR_LE_M(0x01080220, 0x00000000)&#xA;    # DDR_mode-10&#xA;    CCSR_LE_M(0x01080224, 0x00000000)&#xA;    # TIMING_CFG_8&#xA;    CCSR_LE_M(0x01080250, 0x00000000)&#xA;    # SDRAM_CFG_3&#xA;    CCSR_LE_M(0x01080260, 0x00000000)&#xA;&#xA;    CCSR_LE_M(0x01080280, 0xeeeeeeee)&#xA;    CCSR_LE_M(0x01080284, 0x11111111)&#xA;    CCSR_LE_M(0x01080288, 0xffffffff)&#xA;    CCSR_LE_M(0x01080290, 0xe1100001)&#xA;&#xA;    # DDR_ERR_SBE&#xA;    CCSR_LE_M(0x01080e58, 0x00010000)&#xA;&#xA;    # DQ_MAPPING_0&#xA;    CCSR_LE_M(0x01080400, 0x06106104)&#xA;&#xA;    # DQ_MAPPING_1&#xA;    CCSR_LE_M(0x01080404, 0x84184000)&#xA;&#xA;    # DQ_MAPPING_2&#xA;    CCSR_LE_M(0x01080408, 0x00000000)&#xA;&#xA;    # DQ_MAPPING_3&#xA;    CCSR_LE_M(0x0108040c, 0x00000000)&#xA;&#xA;    # Errata&#xA;    if ddr_freq &lt;= 1333:&#xA;        CCSR_LE_M(0x01080f70, 0x0080006a)&#xA;    elif ddr_freq &lt;= 1600:&#xA;        CCSR_LE_M(0x01080f70, 0x0070006f)&#xA;    elif ddr_freq &lt;= 1867:&#xA;        CCSR_LE_M(0x01080f70, 0x00700076)&#xA;    else:&#xA;        CCSR_LE_M(0x01080f70, 0x0060007b)&#xA;&#xA;    # DDR_SDRAM_CFG&#xA;    CCSR_LE_M(0x01080110, 0xC70C0008)&#xA;&#xA;    err_msg = &quot;&quot;&#xA;    # Poll for DDR to be initialized&#xA;    count = 0&#xA;    while True:&#xA;        time.sleep(0.2)&#xA;        SDRAM_CFG2 = CCSR_LE_D(0x01080114)&#xA;        D_INIT = SDRAM_CFG2 &amp; 0x10&#xA;        count = count + 1&#xA;        if (D_INIT == 0):&#xA;            break&#xA;        if (count > 20):&#xA;            err_msg += &quot;DDR: timeout while waiting for D_INIT.\n&quot;&#xA;            break&#xA;&#xA;    ERR_DETECT = CCSR_LE_D(0x01080E40)&#xA;    if (ERR_DETECT != 0):&#xA;        err_msg += &quot;DDR: initialization failed (ERR_DETECT = 0x%08x).&quot; % ERR_DETECT&#xA;&#xA;    if err_msg:&#xA;        cw_warn(err_msg, USE_SAFE_RCW, True)&#xA;&#xA;    time.sleep(1)&#xA;&#xA;    # Clear Terminate all barrier transactions bit of CCI-400 Control Register&#xA;    CCSR_LE_M(0x04090000, 0x08000000)&#xA;&#xA;&#xA;###################################################################&#xA;# This is the actual function called by debugger, flash, etc.&#xA;###################################################################&#xA;def run_init_file():&#xA;    Prepare_Env()&#xA;&#xA;    Reset()&#xA;&#xA;    Init_TZASC()&#xA;&#xA;    if PCI_INIT:&#xA;        Init_PCI()&#xA;&#xA;    DDR_freq = Detect_DDR_Freq()&#xA;    Init_DDRC(DDR_freq)&#xA;&#xA;    Config_Flash_Devices()&#xA;" useTargetInit="true" readme="##-------------------------------------------------------------------------------------#&#xA;##&#x9;LS1027A RDB README&#xA;##-------------------------------------------------------------------------------------#&#xA;&#xA;The LS1027A Reference Design Board (RDB) is a high-performance computing, evaluation, and&#xA;development platform that supports the QorIQ(TM) LS1027A LayerScape Architecture processor.&#xA;&#xA;##-------------------------------------------------------------------------------------#&#xA;##&#x9;Switch settings for LS1027A RDB&#xA;##-------------------------------------------------------------------------------------#&#xA;&#xA;&#xA;XSPI_NOR_BOOT:&#xA;---------&#xA;  SW2 : 0xF8 = 11111000  SW3 : 0x30 = 00110000  SW5 : 0x20 = 00100000&#xA;&#xA;  Where '1' = UP/ON&#xA;&#xA;##-------------------------------------------------------------------------------------#&#xA;##&#x9;Default RCW (please refer to the latest SDK for RCW binaries):&#xA;##-------------------------------------------------------------------------------------#&#xA;&#xA;   00000000: 34004010 00000030 00000000 00000000&#xA;   00000010: 00000000 008f0000 0030c000 00000000&#xA;   00000020: 006031a0 00002580 00000000 00003296&#xA;   00000030: 00000000 00000010 00000000 00000000&#xA;   00000040: 00000000 00000000 00000000 00000000&#xA;   00000050: 00000000 00000000 00000000 00000000&#xA;   00000060: 00000000 00000000 2006605a 00000000&#xA;   00000070: bb580000 00000000&#xA;&#xA;&#xA;##-------------------------------------------------------------------------------------#&#xA;##&#x9;GIC version&#xA;##-------------------------------------------------------------------------------------#&#xA;&#xA;Generic Interrupt Controller Architecture version 3 (GICv3)&#xA;Implementation: GIC-500&#xA;&#xA;##-------------------------------------------------------------------------------------#&#xA;##&#x9;Memory map and initialization&#xA;##-------------------------------------------------------------------------------------#&#xA;&#xA;    0x0000_0000_0000 - 0x0000_000F_FFFF    1MB CCSR - Boot ROM&#xA;    0x0000_0100_0000 - 0x0000_0FFF_FFFF  240MB CCSR&#xA;    0x0000_1800_0000 - 0x0000_183F_FFFF  256KB OCRAM&#xA;    0x0000_2000_0000 - 0x0000_2FFF_FFFF  256MB FlexSPI Region #1&#xA;    0x0000_8000_0000 - 0x0000_FFFF_FFFF 2048MB GPP DRAM Region #1 (2GB)&#xA;    0x0007_0000_0000 - 0x0007_3FFF_FFFF 1024MB DCSR&#xA;&#xA;##-------------------------------------------------------------------------------------#&#xA;##&#x9;XSPI Flash&#xA;##-------------------------------------------------------------------------------------#&#xA;&#xA;Please consult the Flash Programmer Release Notes for more details on flash programming&#xA;&#xA;The flash address range on LS1027A RDB is 0x20000000 - 0x23FFFFFF.&#xA;&#xA;&#xA;##-------------------------------------------------------------------------------------#&#xA;##&#x9;SD/eMMC Flash&#xA;##-------------------------------------------------------------------------------------#&#xA;&#xA;&#xA;The size of a sector is 512 bits, so the address that you use for any operation is&#xA;obtained by multiplying the wanted sector number with 512 (and transform the result&#xA;in hexa), regardless of the card type.&#xA;&#xA;The u-boot must be written at address 0x00001000 (sector 8), regardless of the card type.&#xA;&#xA;If the DDR is not functional, please change in the initialization file, in function&#xA;Config_Flash_Devices, the value for &quot;ws_address&quot; from the gdb command that adds your&#xA;SD/eMMC device with the value of the OCRAM (0x18000000). Also comment the call of&#xA;function Init_DDRC.&#xA;&#xA;##-------------------------------------------------------------------------------------#&#xA;##&#x9;CodeWarrior Stationery Project&#xA;##-------------------------------------------------------------------------------------#&#xA;&#xA;The ARMv8 Stationery C Project can be configured to generate a baremetal application&#xA;suitable for AMP or SMP mode. Please consult the '#define SMP' in start.S for more information.&#xA;&#xA;The default project configuration is suitable for both single-core (running on &quot;Core#0&quot;) and&#xA;multicore SMP (&quot;Use all cores&quot;) applications.&#xA;&#xA;SMP implies shared memory model. All the cores execute the same application image, the memory&#xA;is shared between cores, only the stack is established in different ranges for each core.&#xA;The SMP support is limited by the lack of multicore-enabled runtime available in the&#xA;baremetal toolchain. There is no support for SMP in the C++ stationery project.&#xA;&#xA;Symmetric Multi-Processing (SMP):&#xA;---------------------------------&#xA;&#xA;Please follow the below steps in order to debug the example application in SMP mode:&#xA;&#xA;- Open the corresponding Debug Configuration&#xA;- Go to Debugger tab:&#xA;    - Check &quot;Use all cores&quot;&#xA;- Go to Startup tab:&#xA;    - Uncheck &quot;Set breakpoint at&quot; and &quot;Resume&quot; in the Runtime Options&#xA;    - Enter the following commands in the Run Commands section:&#xA;&#xA;    set $elf_pc=$pc&#xA;    thread apply all set $pc=$elf_pc&#xA;    thread apply all flushregs&#xA;&#xA;Asymmetric Multi-Processing (AMP):&#xA;----------------------------------&#xA;&#xA;Please follow the below steps in order to create and debug example application in AMP mode:&#xA;&#xA;- Create new &quot;Bare board&quot; ASM, C or C++ projects, one for each AMP core you want to debug&#xA;- For each project coresponding to a secondary core:&#xA;        - Edit the startup file (src/start.S) and comment-out #define SMP line&#xA;        - Edit the linker file (Linker_Files/aarch64elf.x) and update the core number in line&#xA;        &quot;PROVIDE (___CORE_NUMBER = 0);&quot;&#xA;- Build the projects&#xA;- Open Debug Configurations (Run -> Debug Configurations) and perform the following changes to&#xA;  all debug configurations pertaining to secondary cores' projects:&#xA;   - In the Debugger tab:&#xA;        - uncheck &quot;Execute target initialization file&quot; checkbox&#xA;        - Selected the intended core from the &quot;Core&quot; combo box&#xA;   - In the Startup tab, un-check &quot;Reset and Delay (seconds)&quot; checkbox&#xA;- If needed, a multicore launch group can be created to easily launch all cores at once.&#xA;  Select Launch Group cathegory, right-click > New, click &quot;Add...&quot; button and select from&#xA;  &quot;GDB Hardware Debugging&quot; all debug configuration for the intended AMP cores&#xA;&#xA;A set of pre-configured projects for Core0 and Core1 AMP configurations is available in CodeWarrior.&#xA;You can use File > Import > General > Existing Projects into Workspace and navigate to&#xA;{CW_Install_Dir}\CW_ARMv8\ARMv8\CodeWarrior_Examples\HelloWorld_C_AMP_Bare&#xA;&#xA;The launch configuration for the first project is configured to reset and initialize the platform,&#xA;therefore projects for secondary cores expect to be launched only after Core#0's project has been launched.&#xA;&#xA;In AMP configuration, each core can be individually controlled.&#xA;&#xA;ROM target :&#xA;----------------------------------&#xA;&#xA;Please follow the below steps in order to create a ROM image example application:&#xA;&#xA;- Stationery projects have a predefined build target for ROM, which uses a separate linker file (Linker_Files/aarch64_ROM.x);&#xA;  this contains specific memory definitions for ROM based applications:&#xA;&#x9;- ___ROM_ADDRESS - boot address from flash device - XSPI, eSDHC&#xA;&#x9;- ___RELOC_DATA_ADDRESS - used to specify where initialized data will be relocated - set default to OCRAM address,&#xA;      but can be switched to DDR if user code does the initialization (see mem_init_hook() in rom_init.c)&#xA;&#x9;- Stack and heap size definitions can also be modified based on the size of the RAM&#xA;&#xA;- To change the target and build the ROM image use Right click on project -> Build configurations -> Set active -> ROM&#xA;- The .bin file will be created in the ROM target folder in the project root path.&#xA;&#xA;OCRAM target :&#xA;----------------------------------&#xA;Please follow the below steps in order to build and debug the OCRAM target example application:&#xA;- C and ASM Stationery projects have a predefined build target for OCRAM,&#xA;  which uses a separate linker file (Linker_Files/aarch64_OCRAM.x);&#xA;  This contains specific memory definitions for the OCRAM based application.&#xA;  NOTE: OCRAM address depends on the SoC memory map spec.&#xA;       ___OCRAM_ADDRESS must be set accordingly in the linker file.&#xA;- To select the OCRAM target and build it use Right click on&#xA;     project -> Build configurations -> Set active -> Debug OCRAM&#xA;- To debug the OCRAM target&#xA;    - open Debug Configurations&#xA;    - update debug launch configuration under &quot;GDB Hardware Debugging&quot;&#xA;        - Main tab: select your project and &quot;Debug_OCRAM/&lt;test>_Bare_OCRAM.elf&quot; as C/C++ application&#xA;        - Debugger tab:&#xA;          - select connection configuration&#xA;          - select core #0 and make sure &quot;Use all cores&quot; is not checked&#xA;    - Debug&#xA;Limitations of OCRAM target:&#xA;   NOTE: memset C runtime function should not be used on a memory region in OCRAM because&#xA;         it can generate alignment faults if cache specific instructions are executed (example &quot;dc zva&quot; instruction).&#xA;        The same limitation should be taken into consideration for other functions.&#xA;        The reason is that OCRAM is used as a Device type non-cacheble memory (hardware constrain).&#xA; - stack and heap size definitions are very limited&#xA; - stdio is too big for the OCRAM target, hence the printf statement will do nothing in this case&#xA; - it is a single-core example&#xA; - SMP is not supported&#xA;&#xA;##-------------------------------------------------------------------------------------#&#xA;##&#x9;CodeWarrior Debugger Console I/O&#xA;##-------------------------------------------------------------------------------------#&#xA;&#xA;The librarian I/O model is divided into 2 modes:&#xA; - UART_C_Static_Lib_Bare: printf support through UART port&#xA; - simrdimon: I/O operations through debugger console&#xA;&#xA;The default I/O mode is debugger console (in other words the simrdimon library is being used).&#xA;You can change to UART I/O if needed by modifying the project build settings: navigate to&#xA;C/C++ Build > Settings > Cross ARM C (or C++) Linker > Miscellaneous and change the text&#xA;in the Other linker flag text box, replacing simrdimon.specs with uart.specs, then re-build the&#xA;project&#xA;&#xA;To view the UART output, connect a null-modem serial cable from the serial port to your computer.&#xA;Open a terminal program and set it up to match these settings:&#xA;&#xA;Baud Rate: 115200&#xA;Data Bits: 8&#xA;Parity: None&#xA;Stop Bits: 1&#xA;Flow Control: None&#xA;&#xA;Specify device type - PC16552D&#xA;.LUARTDeviceType&#xA;        GEN_DWORD 0&#xA;&#xA;By default UART1 is used. In order to switch to a different UART port you need to specify&#xA;the appropriate port address in the start.S file included in the project:&#xA;&#xA;.LUARTPort:&#xA;/*&#xA;    For PL011&#xA;    UART1 - 0x21C0000&#xA;    UART2 - 0x21D0000&#xA;    UART3 - 0x21E0000&#xA;    UART4 - 0x21F0000&#xA;*/&#xA;        GEN_DWORD 0x21C0000  /* defaults to UART1 */&#xA;&#xA;##-------------------------------------------------------------------------------------#&#xA;##&#x9;Specifying the probe configuration&#xA;##-------------------------------------------------------------------------------------#&#xA;&#xA;Probe connection configuration and board initialization information are configured in&#xA;the Target Connection Configuration view. The wizard generates an appropriate launch&#xA;for this project. The TCC can be accessed from the Launch Configuration, Debugger tab,&#xA;Target Connection Configuration section.&#xA;&#xA;##-------------------------------------------------------------------------------------#&#xA;##&#x9;Recommended JTAG clock speeds&#xA;##-------------------------------------------------------------------------------------#&#xA;&#xA;CW TAP       : 16000 KHz&#xA;&#xA;##-------------------------------------------------------------------------------------#&#xA;##&#x9;Overriding RCW from JTAG&#xA;##-------------------------------------------------------------------------------------#&#xA;&#xA;You can have CodeWarrior override RCW_SRC and/or particular RCW values through JTAG.&#xA;For this you need to use the function provided in the initialization script.&#xA;&#xA;##-------------------------------------------------------------------------------------#&#xA;##&#x9;Contacting NXP&#xA;##-------------------------------------------------------------------------------------#&#xA;&#xA;You can contact us via email, newsgroups, voice, fax or the&#xA;CodeWarrior website.  For details on contacting NXP, visit&#xA;http://www.nxp.com/cw4net, or refer to the front of any&#xA;CodeWarrior manual.&#xA;&#xA;For questions, bug reports, and suggestions, please join the CodeWarrior&#xA;community forums at&#xA;https://community.nxp.com/community/codewarrior.&#xA;&#xA;http://www.nxp.com&#xA;" selectedProbe="//@probes.0">
  <processor procName="LS1027A">
    <cores name="CortexA72#0"/>
    <cores name="CortexA72#1"/>
    <connector flavor="hw" supportedProbes="//@probes.0"/>
  </processor>
  <probes xsi:type="DebuggerDBModel:CWTAP" name="CodeWarrior TAP" timeout="10" jtagspeed="16000" isEthernetConn="true">
    <ethernetConn ip="192.168.22.1"/>
    <usbConn/>
  </probes>
  <probes xsi:type="DebuggerDBModel:ARMv8sim" name="ARMv8 Simulator" timeout="10">
    <ethernetConn ip="127.0.0.1" portNumber="40969"/>
  </probes>
  <probes xsi:type="DebuggerDBModel:CmsisDap" name="CMSIS DAP" timeout="300" jtagspeed="6000" isUSBConn="true">
    <usbConn/>
  </probes>
</SelectedConfigurationModel:SelectedConfiguration>
