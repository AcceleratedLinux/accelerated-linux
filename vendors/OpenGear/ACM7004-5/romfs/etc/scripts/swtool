#!/bin/sh
# ACM7004-5 MV88E6350R switch tool
# There is only one switch (1) on this product
BUS="d0072004.mdio-mi"

# Print verbose messages
verbose=
verbose_printf () {
	if [ $verbose ]; then printf "$@" >&2; fi
	true
}

# Test when argument is non-zero
nz () { [ 0 -ne "$(($1 + 0))" ]; }
zero () { [ 0 -eq "$(($1 + 0))" ]; }

# bitmath() updates variable $var converting it from an expression like
# "[hi:lo]=n" to an integer value. This is intended to allow "writing"
# register values using a read-clr-set-write expression.
# For example, writing the value "[2:1]=3" to a register when the reg's
# old value was 8 will result in writing 11 into the reg. (Because bitmath
# computes '8 & ~6 | 3<<1' where 6 is the mask for bits [2:1]).
#
#  [n]                     treated the same as [n:n]
#  [m:n]=v [o:p]=w ...     chain with spaces
#
bitmath () { # var $oldval
	local lo hi exp n x _val=$2
	for exp in ${!1}; do
	    case $exp in
		"["*"]="*)
		    n=${exp#*]=}
		    x=${exp#[};
		    x=${x%%]=*}
		    case $x in
			*:*) hi=${x%:*} lo=${x#*:};;
			*)   let hi=x lo=x;;
		    esac
		    if [ $lo -gt $hi ]; then
			let x=lo lo=hi hi=x
			echo "${!1}: corrected bit range to [$hi:$lo]" >&2
		    fi
		    let _val=$((_val & ~( (1<<(hi+1) )-(1<<lo) ) | n<<lo))
		    ;;
		*)  let _val=$exp
		    ;;
	    esac
	done
	verbose_printf "%s -> 0x%04x\n" "${!1}" $_val
	let $1=_val
}

is_bitmath () { #var
	case ${!1} in
	    "["* | *" ["*) true;;
	    *)             false;;
	esac
}

bus_filename () {
	# Returns path to an MDIO bus virtual inode. e.g. Writes to the file
	# are converted into bus write operations to store into the register.
	local addr=$1 reg=$2
	printf "%s:%02x/%d" "/sys/class/mdio_bus/$BUS/device/$BUS" $addr $reg
}

bus_read () {
	# Reads an SMI register from a device on the MDIO bus
	local var=$1 addr=$2 reg=$3
	read $var <$(bus_filename $addr $reg) || return
	verbose_printf 'r 0x%04x:%d -> 0x%04x\n' $addr $reg ${!var}
}

bus_write () {
	# Writes to an SMI register on a device on the MDIO bus
	local addr=$1 reg=$2 val=$3
	verbose_printf 'w 0x%04x -> 0x%04x:%d\n' $val $addr $reg
	printf '0x%04x\n' $val >$(bus_filename $addr $reg)
}

# The 88E6350 switch on the MDIO bus has an SMI address depending on its
# ADDR[4:0] pins/strapping. Only two SMI registers are accessible, 0 and 1.
#
#    00 SMI Command Register
#       [15]    SMIBusy - host sets 1 to start, device clears on completion
#       [12]    SMIMode - 1=generate IEEE 802.3 clause 22 SMI frames; 0=don't
#       [11:10] SMIOp   - 0=rsvd; 1=write data; 2=read data; 3=rsvd
#       [9:5]   DevAddr - selects the (clause 22) device address during SMI op
#       [4:0]   RegAddr - selects the (clause 22) reg address during SMI op
#    01 SMI Data Register
#       [15:0]  SMIData - host sets this before starting a write
#                         device sets this before completing a read
#
# Valid DevAddr values on a switch are:
#    10..16   Port registers
#    1b       Global1 registers
#    1c       Global2 registers  (used for chained SMI operations)
#
# Port registers:    | 15 | 14 | 13 | 12 | 11 | 10 |  9 |  8 |  7 |  6 |  5 |  4 |  3 |  2 |  1 |  0 |
#    00 PortStatus   |  Pause  | HF | PD |   Port's mode     |  - | 2B | FlowCtl |  - |Config Mode   |
#    01 PhysicalCtrl | RGMII   |             -               | Force FC, Link, Speed, Duplex         |
#    02 JammingCtrl  |      LimitOut                         |           LimitIn                     |
#    03 SwitchId     |                   Product Number                          |    Revision       |
#    04 PortCtrl     | SADrop  | EH Mode |  H |  S |FrameMode| VT | TiB,Init Pri | EFloods |  PState |
#    05 PortCtrl1    | MP | TP |    -    |  Trunk ID         |               FID[11:8]               |
#    06 VlanMap      | FID[3:0]     | LD |           -            |           VLANTable              |
#    07 VlanDef      | DefFPRI | FV |                              DefaultVID                        |
#    08 PortCtrl2    | FG | AB |JumboMode|  QMode  | DT | DU | MD | AM | EM | IM |         -         |
#    09 EgressRate   |         -         |  Overead Offset   |  - |          Egress Dec              |
#    0a EgressRate2  |CountMode|Schedule |                 Egress Rate                               |
#    0b PortAssoc    | H1 | OI | LP | IW | RL |       -           |               PAV                |
#    0c ATUCtrl      | RC | LR | OI | KO |    -    |        LearnLimit/LearnCtr                      |
#    0d Override     | DAPriOv | SAPriOv |VTUPriOv |                       -                         |
#    0e PolicyCtrl   | DAPolcy | SAPolcy |VTUPolcy |ETypePlcy|PPPoEPlcy|VBASPlcy |Opt82Plcy| UDPPlcy |
#    0f PortEther    |                                 PortEType                                     |
#    10 InDiscardsLo |                                 InDiscards[0:15]                              |
#    11 InDiscardsHi |                                 InDiscards[16:31]                             |
#    12 InFilteredLo |                                 InFiltered[0:15]                              |
#    13 InFilteredHi |                                 InFiltered[16:31]                             |
#    16 LEDCtrl      |  U | Pointer      | -  |                                       LED Data       |
#    18 TagRemapLo   |  U |  TagRemap3   | -  |  TagRemap2   | -  |  TagRemap1   | -  |  TagRemap0   |
#    19 TagRemapHi   |  U |  TagRemap7   | -  |  TagRemap6   | -  |  TagRemap5   | -  |  TagRemap4   |
#    1b QueueCnt     |    Mode           | SI |    -    |          OutQ sizes and data               |
#                    | 15 | 14 | 13 | 12 | 11 | 10 |  9 |  8 |  7 |  6 |  5 |  4 |  3 |  2 |  1 |  0 |
#
# PHY registers: (accessed via Global2 regs 18,19) and paged with PHY register 22
#
#

switch_wait () {
	local switch=$1 r
	# It takes about 25 seconds to reset the whole switch
	# so 10 seconds waiting period is sensible
	local timeout=10
	while bus_read r $switch 0  &&  nz $((r & 0x8000)); do
		# Sleep 1 to ease MDIO traffic while polling
		sleep 1
		let timeout=timeout-1
		if [ $timeout -eq 0 ]; then
			echo "sw$switch: busy timeout" >&2
			return 1
		fi
	done
}

switch_read () {
	local var=$1 switch=$2 dev=$3 reg=$4
	switch_wait $switch &&
	bus_write $switch 0 $((0x9800 | dev << 5 | reg)) &&
	switch_wait $switch &&
	bus_read $var $switch 1
}

switch_write () {
	local switch=$1 dev=$2 reg=$3 val=$4 oval
	if is_bitmath val; then
	    switch_read oval $switch $dev $reg && bitmath val $oval
	fi &&
	switch_wait $switch &&
	bus_write $switch 1 $val &&
	bus_write $switch 0 $((0x9400 | dev << 5 | reg))
}

# Each switch's EEPROM is accessed though Global2 regs 0x14,0x15
#
# The internal PHYs for each port 0..4
# have registers accessed indirectly through the switch's "Global2"
# registers 0x18,0x19:
#
#  0x18 SMIPhyCmd
#       [15]    Busy
#       [14:13] SmiFunc
#       [12]    SmiMode
#       [11:10] SmiOp
#       [9:5]   DevAddr
#       [4:0]   RegAddr
#  0x19 SmiPhyData
#       [15:0]  Data
#
# The PHY registers are paged. There are 8 pages of 32 x 16-bit PHY registers.
# Register 0x16 (22) holds the current page address and is not paged.
# Only registers 0x10 and above are paged. Valid pages are 0,2,5,6,255
#
#  0x16 PageAddress
#       [15:8] Reserved (0)
#       [7:0]  Page number   (retained on soft reset)

phy_wait () {
	local switch=$1 r
	local timeout=10
	while switch_read r $switch 0x1c 0x18  &&  nz $((r & 0x8000)); do
		sleep 1
		let timeout=timeout-1
		if [ $timeout -eq 0 ]; then
			echo "sw$switch: busy timeout" >&2
			return 1
		fi
	done
}

# Setup the "Page Address" register for an ethernet port's PHY
# when the being accessed PHY register name is in the form of <reg>_<page>
_phy_page () {
	local page
	case $reg in
	    # if $reg ends with _<page>, issue a page request
	    # by writing to register 22_*, then cut the _<page> suffix
	    # from $reg.
	    *_*) page=${reg#*_} reg=${reg%_*}
		phy_wait $switch &&
		switch_write $switch 0x1c 0x19 $page && # 22 is page register
		switch_write $switch 0x1c 0x18 $((0x9400 | port << 5 | 22))	# port is the ethernet port being accessed
		;;
	esac
}

phy_read () {
	local var=$1 switch=$2 port=$3 reg=$4
	_phy_page &&
	phy_wait $switch &&
	switch_write $switch 0x1c 0x18 $((0x9800 | port << 5 | reg)) &&
	phy_wait $switch &&
	switch_read $var $switch 0x1c 0x19
}

phy_write () {
	local switch=$1 port=$2 reg=$3 val=$4 oval
	_phy_page &&
	if is_bitmath val; then
	    phy_read oval $switch $port $reg && bitmath val $oval
	fi &&
	phy_wait $switch &&
	switch_write $switch 0x1c 0x19 $val &&
	switch_write $switch 0x1c 0x18 $((0x9400 | port << 5 | reg))
}

sel () { # [-c] i val0 val1 val2...
	local n=
	case $1 in -?) n=$1; shift;; esac
	if [ $(($1 + 1)) -lt $# ]; then
	    shift $(($1 + 1))
	    case "$n:$1" in
		:*)  echo "$1";;
		-c:) :;;   # continue
		-c:*) echo -n " $1";;
	    esac
	fi
}

testbit () {
	local n=$1 bit=$2
	nz $(( n >> bit & 1 ))
}

# Dump status for diagnostics
diag () {
	local switch port
	local internal=

	# -i: show inter-switch links
	case $1 in -i) internal=1; shift;; esac

	echo "ACM7004-5 diagnostics"

	if [ ! -d /sys/class/mdio_bus/$BUS/device/$BUS:01 ]; then
	  echo "error: mdio bus '$BUS:01' was not found; bad dtb?" >&2
	  return 1
	fi

	# The switch is strapped into multi-address mode
	# with an SMBus interface at PHYAD=1
	switch=1
	local rid

	if ! switch_read rid $switch 0x16 3; then
	    echo "error: mvl88 switch $switch not responding" >&2
	    echo "diag: check for switch malfunction" >&2
	    continue
	fi

	if [ $internal ]; then
	    local product
	    case $((rid >> 4)) in
		881) product="Marvell 88E6350R/88E6350";; # 0x371
		885) product="Marvell 88E6351";; # 0x375
		*)   product="<unknown #$((rid >> 4))>";;
	    esac
	    product="$product rev $((rid & 15))"
	    echo "$BUS:$switch: found $product"

	    local sgcr; switch_read sgcr $switch 0x1b 4
	    local sgsr; switch_read sgsr $switch 0x1b 0

	    local sw_mode=$((sgsr >> 12 & 3))
	    echo "SW_MODE $sw_mode ($(sel $sw_mode test reserved unmanaged managed))"
	    echo -n "State:"
	    sel -c $((sgcr >> 15 & 1)) ready resetting
	    sel -c $((sgsr >> 15 & 1)) ppu-busy
	    sel -c $((sgsr >> 11 & 1)) init-busy
	    echo

	    switch_read r $switch 0x1b 0x1a # MonitorControl
	    if [ $r != 0xffff ]; then
		echo -n "Monitor:"
		[ $((r >> 12 & 15)) -eq 15 ] || echo -n " ingress->$((r >> 12 & 15))"
		[ $((r >> 8 & 15)) -eq 15 ] || echo -n " egress->$((r >> 8 & 15))"
		[ $((r >> 4 & 15)) -eq 15 ] || echo -n " cpu->$((r >> 4 & 15))"
		[ $((r & 15)) -eq 15 ] || echo -n " mirror->$((r & 15))"
		echo
	    fi
	fi

	local gc2; switch_read gc2 $switch 0x1b 0x1c  # Global Control 2
	local ctrmode=$((gc2 >> 5 & 1))  # 0=rxbad/rxgood 1=collis/tx

	for port in 0 1 2 3 ${internal:+4 5 6}; do
	    local name=""
	    if [[ $port < 4 ]]; then
		name="p$((port + 1))"
	    fi
	    if [ $internal ]; then
		if [ $port = 5 ]; then
		    name="cpu"
		fi
		name="$port${name:+[$name]}"
	    fi

	    # PortStatus register
	    # (Port registers are offset from 0x10 on this switch)
	    local rstatus
	    switch_read rstatus $switch $((port+0x10)) 0 || continue

	    # PortControl register
	    local rctrl
	    switch_read rctrl $switch $((port+0x10)) 4 || continue
	    local portstate=$(sel $((rctrl & 3)) disabled listening learning)

	    local mode=
	    if [ $internal ]; then
		case $((rstatus & 7)) in
		 0) mode="GMII";;
		 1) mode="RGMII";;
		 2) mode="MII@$(sel $((rstatus >> 6 & 1)) 100BASE 200BASE)";;
		 3) mode="MII@10BASE";;
		 4) mode=;; # internal PHY
		 *) mode="disabled";;
		esac
	    fi
	    local link=$((rstatus >> 11 & 1))
	    echo -n "$name: ${mode:+$mode, }$(sel $link "no link" "link")${portstate:+, $portstate}"
	    if [ ! $internal ] && zero $link; then
		echo
		continue
	    fi

	    if nz $link; then
		sel -c $((rstatus >> 8 & 3)) "10 Mb/s" "100 Mb/s" "1000 Mb/s"
		zero $((rstatus >> 10 & 1))&& echo -n " half-duplex"
		zero $((rstatus >> 5 & 1)) || echo -n " tx-paused"
		zero $((rstatus >> 4 & 1)) || echo -n " fc"
	    fi

	    sel -c $((rctrl >> 14 & 3)) "" \
		drop-on-lock drop-on-unlock drop-to-cpu
	    sel -c $((rctrl >> 12 & 3)) "" del-tag add-tag
	    sel -c $((rctrl >> 11 & 1)) "" add-header
	    sel -c $((rctrl >> 8 & 3))  "" tag-dsa tag-provider tag-etype
	    sel -c $((rctrl >> 7 & 1))  "" vlan-tunnel

	    # When there is a PHY, show some PHY information
	    case $port in [01234])
		phy_read r $switch $port 0_0
		zero $((r >> 11 & 1)) || echo -n " powered-down"

		phy_read r $switch $port 17_0
		if nz $link; then
		    zero $((r >> 11 & 1)) && echo -n " unresolved-autoneg"
		    zero $((r >> 6 & 1))  || echo -n " mdix"
		    zero $((r >> 5 & 1))  || echo -n " downshifted"
		    zero $((r >> 2 & 1))  || echo -n " dte-power-req"
		    zero $((r >> 1 & 1))  || echo -n " revpol"
		fi

		if [ $internal ]; then
		    phy_read r $switch $port 16_0
		    zero $((r >> 15 & 1)) || echo -n " nopulse"
		    zero $((r >> 11 & 1)) || echo -n " downshift"
		    zero $((r >> 10 & 1)) || echo -n " force-link"
		    sel -c $((r >> 5 & 3)) force-mdi force-mdix
		    zero $((r >> 3 & 1))  || echo -n " disable-tx"
		    zero $((r >> 2 & 1))  || echo -n " powerdown"
		    zero $((r >> 1 & 1))  || echo -n " norevpol"
		    zero $((r >> 0 & 1))  || echo -n " nojabber"
		fi

		phy_read r $switch $port 21_0
		zero $r || echo -n ", rxbad $r"

		phy_read r $switch $port 26_6
		zero $((r >> 5 & 1)) || echo -n ", temp $((r & 0x1f))"
		;;
	    esac

	    local r1 r2
	    switch_read r1 $switch $((port+0x10)) 0x10
	    switch_read r2 $switch $((port+0x10)) 0x11
	    r=$((r2 << 16 + r1))
	    zero $r || echo -n ", indisc $r"

	    switch_read r $switch $((port+0x10)) 0x12
	    zero $r || echo -n ", infilt $r"
	    switch_read r $switch $((port+0x10)) 0x13
	    zero $r || echo -n ", outfilt $r"

	    echo
	done
}

dump () {
	local r
	local switch=${1-1}
	for p in 0 1 2 3 4 5 6 gc1 gc2; do
	    local a name=$p
	    case $p in
		[0123456])
		    a=$((p+16))
		    name=port$p
		    ;;
		gc1) a=0x1b;;
		gc2) a=0x1c;;
		*) echo "bad $p" >&3; exit 1;;
	    esac

	    for reg in 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15; do
		switch_read r $switch $a $reg &&
		printf 'reg %02x %02x: %s\n' $a $reg $r
	    done
	    case $p in [0123])
		for reg in 0 9 16_0 26_0; do
		    phy_read r $switch $p $reg &&
		    printf 'phy %d %s: %s\n' $p $reg $r
		done;;
	    esac
	    echo
	done
}

case $1 in
    -v) verbose=1; shift;;
esac

cmd=$1; shift
val=
case $cmd:$# in
    read_switch:3)       switch_read   val "$@" && echo $val;;
    write_switch:4)      switch_write      "$@";;
    read_phy:3)          phy_read      val "$@" && echo $val;;
    write_phy:4)         phy_write         "$@";;
    dump:[01])           dump              "$@";;
    diag:?)              diag              "$@";;
    *) echo "\
usage: $0 [-v] read_switch  switch port        reg
       $0 [-v] write_switch switch port        reg val
       $0 [-v] read_phy     switch port        reg
       $0 [-v] write_phy    switch port        reg val
       $0 dump switch
       $0 diag [-i]" >&2
	exit 2
	;;
esac
