#!/bin/bash
#
# This script is invoked by conman to bring a cellular data link up.
#
# Importantly, it provides functions to be called by conman actions to
# manage data session and udhcpc daemon and keep an eye on their status
#
set +e

# Load configuration generated by the dialin configurator
CONN_NAME=$1
source /etc/config/$CONN_NAME.cfg

. /etc/scripts/cellctl-helper

# cellctld will independently update infod variables of cellmodem IPv6
# address and gateway address, which would have been nullified after the
# test_conn() returns a failure. Save them into attribute files so that
# the disconnect() function can remove them properly
#
# Similarly, only when the current bearer is connected would it be possible
# to get its interface from cellctld. Fall back on querying the interface
# attribute file
CELLMODEM_IPV6ADDRESS="/var/run/.modem/.cellmodem_ipv6address"
CELLMODEM_IPV6GATEWAY="/var/run/.modem/.cellmodem_ipv6gateway"
CELLMODEM_INTERFACE="/var/run/.modem/.cellmodem_interface"

IFACE=$(cc_get_net_device)
if [ -z "$IFACE" ]; then
	read IFACE < $CELLMODEM_INTERFACE
	if [ -z "$IFACE" ]; then
		IFACE="unknown"
	fi
fi

IPV6_NETWORK=""
IPV6_GATEWAY=""
DHCPC_RETRIES=8
DHCPC_TIMEOUT=3

ipv6GlobalEnabled=$(config -g config.system.ipv6.enabled | cut -d' ' -f2)
ipv6CellDisabled=$(config -g config.cellmodem.ipv6.disabled | cut -d' ' -f2)

is_cell_ipv6_enabled () {
	[ -n "$ipv6GlobalEnabled" -a -z "$ipv6CellDisabled" ]
}

# Write a syslog message
log () {
	logger -t "wwan-conn[$$]" "$@"
}

warn () {
	logger -t "wwan-conn[$$]" -p daemon.warn "$@"
}

# Shut down the data session
disconnect()
{
	# Disconnecting (either received a signal or lost connection) so remove modem backoff state
	rm -f /var/run/.modem/retry_count

	if /bin/cellctl -d; then
		log "$MODEM: disconnected"
	fi

	# Remove IPv6 address and gateway
	if is_cell_ipv6_enabled && [[ "$APNTYPE" == *v6* ]] ; then
		read IPV6_GATEWAY < $CELLMODEM_IPV6GATEWAY
		if [ ! -z "$IPV6_GATEWAY" ]; then
			log "$MODEM Clearing IPv6 gateway: $IPV6_GATEWAY"
			if ! /bin/ip -6 route del default via $IPV6_GATEWAY dev $IFACE
			then
				log "$MODEM ip -6 route del default via $IPV6_GATEWAY dev $IFACE failed"
			fi
		fi

		read IPV6_NETWORK < $CELLMODEM_IPV6ADDRESS
		if [ ! -z "$IPV6_NETWORK" ]; then
			log "$MODEM Clearing IPv6 address: $IPV6_NETWORK"
			if ! /bin/ip -6 addr del $IPV6_NETWORK dev $IFACE
			then
				log "$MODEM ip -6 addr del $IPV6_NETWORK dev $IFACE failed"
			fi
		else
			log "$MODEM Flushing global IPv6 addresses"
			if ! /bin/ip -6 addr flush dev $IFACE scope global
			then
				log "$MODEM ip -6 addr flush dev $IPV6_NETWORK scope global failed"
			fi
		fi
	fi

	# Remove IPv4 address
	/sbin/ifconfig $IFACE 0.0.0.0 down
	/etc/scripts/wwan-down $IFACE

	infod_client -o push -p config.cellmodem.status -d "disconnected"

	# Remove attribute files
	rm -f $CELLMODEM_INTERFACE
	rm -f $CELLMODEM_IPV6ADDRESS
	rm -f $CELLMODEM_IPV6GATEWAY
}

# Start the data session
connect()
{
	if /bin/cellctl --connstatus
	then
		warn "$MODEM already has data session established, nothing to do"
		return
	fi

	if [ -f /var/run/.modem/cellmodem_is_gobi ]; then
		# The MC7354 can get into a state when roaming (e.g. US SIM in Canada)
		# where it cannot see availible operators, AT+COPS=? updates
		# this list and breaks it out of the deadlock so it can connect. 
		cc=`/bin/cellctl -s`
		rs=`echo "$cc" | grep 'roaming-status ' | cut -d' ' -f2-`
		sm=`echo "$cc" | grep 'service-mode ' | cut -d' ' -f2-`
		# AT+COPS=? can take minutes to run in some circumstances,
		# so only run it when required as it blocks modem ops
		if [ "$rs" == "Roaming" -a "$sm" == "No service" ]; then
			log "$MODEM is roaming, forcing update of carrier list (this may take a while)"
			for (( i=0; i<3; ++i )) ; do
				COPS=$( ( COMMAND="AT+COPS=?" RESPONSE="OK" /bin/chat -t 120 -E -V -f /etc/scripts/command-chat < /dev/cellcommand01 > /dev/cellcommand01 ) 2>&1 )
				RC="$?"
				OUT=`echo "$COPS" | grep -v '^$'`
				ERROR=$( echo "$OUT" | grep '+CME ERROR:' )
				GREP="$?"
				log "$MODEM carrier list: $OUT"
				if [ "$RC" == "0" -a "$GREP" != "0" ]; then
					log "$MODEM carrier list updated: $OUT"
					break
				fi
				log "$MODEM carrier list update failed"
				sleep 1
			done
		fi
	fi

	# Remove any old backoff state
	rm -f /var/run/.modem/retry_count

	# Push status to infod - 'connecting'. This will be updated by wwan-up > dial-info script
	# when DHCP bound event is received
	infod_client -o push -p config.cellmodem.status -d "connecting"

	# Determine carrier from MCC/MNC first, since some cellmodem's firmware may be generic
	# fall back on the cell-carrier script if needed
	if [ -x /bin/cellctl ] ; then
		carrier=$(infod_client -o get -q -p "config.cellmodem.cellctl.status.carrier")

		if [ -z "$carrier" ]; then
			/etc/scripts/cell-carrier
			read carrier < /var/run/.modem/cellmodem_carrier
		fi
	fi

	mmpath=`mmcli -L | grep ModemManager1 | awk '{print $1}'`

	# This loop will be interrupted by conman once command timeout expiry is hit
	# and eventually conman will re-start the -simX-wwan conn
	# It's just convenient to implement the backoff algorithm here
	while [ 1 ]
	do
		if ! is_cell_ipv6_enabled ; then
			if echo "$APNTYPE" | grep "v6" ; then
				log "$MODEM IPv6 explicitly disabled."
				APNTYPE="ipv4"
			fi
		fi

		# Clear existing cached bearer interface
		[ -d /var/run/.modem ] || mkdir /var/run/.modem
		rm -f /var/run/.modem/.cellmodem_iface

		if [ "$carrier" = "Verizon Wireless" ] || [ "$carrier" = "verizon" ]; then
			# The Huawei ME209u/ME909u series modems do not work with the below code.
			# So keep the old logic of passing the APN directly to cellctl.
			is_MEX09u=$(/bin/infod_client -o get -q -p config.cellmodem.cellctl.info.product | grep -i "me209u\|me909u")
			if [ ! "$is_MEX09u" ]; then
				# Verizon firmware uses Profile slot 1 to kick off auto provisioning
				# (aka OTADM), which will download Profiles onto cellmodem.
				# Verizon firmware uses Profile slot 3 to start data connection
				default_profile_num=3

				# For debug purpose let CLI override the default Profile number
				profile_num=$(config -g config.cellmodem.default_profile_num | cut -f2- -d' ')
				if [ -n "$profile_num" ]; then
					default_profile_num=$profile_num
				fi

				qmicli -p -d /dev/cdc-wdm0 --device-open-qmi \
					--wds-set-default-profile-num=3gpp,${default_profile_num}

				log "$MODEM PDP context number: $default_profile_num is used"

				# Due to auto provisioning users shouldn't have to provide any APN,
				# however, if an APN is given anyway it is used to update the default
				# profile settings, useful to fix misconfiguration
				if [ -n "$mmpath" -a -n "$APN" ]; then
					# Get existing APN from like: <slot num>,"<apn>","<pdp-type>",...
					apn=$(mmcli -m $mmpath --command="+vzwapne?" | grep "^${default_profile_num}" | cut -d "\"" -f2)
					if [ -n "$APN" -a "$apn" != "$APN" ]; then
						# Verizon specific command must be used to change Profile slot APNs
						# otherwise Verizion firmware may be broken. Format:
						# +VZWAPNE=<wapn>,<apnclass>,<APN name>,<PDN type>,<technology>,<Enabled/Disabled>,<Inactivity timer>
						# "IPv4v6" is interpreted as "ipv4-or-ipv6"
						mmcli -m $mmpath --command="+VZWAPNE=${default_profile_num},${default_profile_num},\"$APN\",\"IPv4v6\",\"LTE\",\"Enabled\",0"
					fi
				fi

				# Pass empty APN to ModemManager so that the default Profile slot is used
				APN=""
			fi
		fi

		if /bin/cellctl --dip_connect --auth $AUTH --apn "$APN" --apn_type "$APNTYPE" \
			${USERNAME:+--username "$USERNAME" --password "$PASSWORD"}
		then
			# See RFC2460 and RFC791 for minimum MTU allowed for IPv6 and IPv4 respectively
			IPV4_MTU_MIN=68
			IPV6_MTU_MIN=1280

			MTU_FILE=/var/run/.modem/cellmodem_mtu
			IFACE=$(cc_get_net_device)
			IPV4_MTU=$(cc_get_ipv4_mtu)
			if [ -n "$IPV4_MTU" ] && [ "$IPV4_MTU" -ge "$IPV4_MTU_MIN" ]
			then
				log "$MODEM Default IPv4 MTU: $IPV4_MTU"
				echo $IPV4_MTU > $MTU_FILE
			fi

			IPV6_NETWORK=""
			IPV6_GATEWAY=""
			if is_cell_ipv6_enabled ; then
				# Only configure IPv6 if it is enabled
				IPV6_NETWORK=$(cc_get_ipv6_network)
				IPV6_GATEWAY=$(cc_get_ipv6_gateway)

				IPV6_MTU=$(cc_get_ipv6_mtu)
				if [ -n "$IPV6_MTU" ] && [ "$IPV6_MTU" -ge "$IPV6_MTU_MIN" ]
				then
					log "$MODEM Default IPv6 MTU: $IPV6_MTU"
					# Prefer IPv6 MTU over IPv4 MTU since IPv6 is essential to 4G
					# and the real MTU taken place will always be figured out by
					# IPv6 Path MTU Discovery
					echo $IPV6_MTU > $MTU_FILE
				fi
			fi

			# Ignore ModemManager's MTU (such as 1430) since customers reported that
			# Cellmodem connection doesn't work with them unless falling back to
			# the default MTU of 1500
			read mm_mtu < $MTU_FILE
			if [ -n "$mm_mtu" ]
			then
				log "$MODEM ModemManger suggested MTU $mm_mtu is ignored"
			fi

			# Apply user specified MTU if it is feasible
			config_mtu=$(config -g config.cellmodem.mtu | cut -f2- -d' ')
			if [ -n "$config_mtu" ] && [ "$config_mtu" -ge "$IPV6_MTU_MIN" ]
			then
				ip link set dev "$IFACE" mtu $config_mtu
			fi

			if [ ! -z "$IFACE" ]
			then
				# Cache bearer interface because when the bearer is disconnected
				# it is not available anymore through cellctld, but it is still
				# needed by the disconnect() function
				echo "$IFACE" > $CELLMODEM_INTERFACE

				if ! /sbin/ifconfig "$IFACE" up
				then
					log "$MODEM ifconfig $IFACE up failed"
				fi

				# TODO: the management of IPv6 addresses should better be scooped
				# out and handled in the -simX-dhcp conn. Perhaps running odhcp6c
				# on the cellmodem interface?
				if [[ "$APNTYPE" == *v6* ]]
				then
					echo 0 > /proc/sys/net/ipv6/conf/$IFACE/disable_ipv6

					if [ ! -z "$IPV6_NETWORK" ]
					then
						log "$MODEM Setting IPv6 address: $IPV6_NETWORK"
						if ! /bin/ip -6 addr add $IPV6_NETWORK dev $IFACE
						then
							log "$MODEM ip -6 addr add $IPV6_NETWORK dev $IFACE failed"
						fi
						echo "$IPV6_NETWORK" > $CELLMODEM_IPV6ADDRESS
					fi
					if [ ! -z "$IPV6_GATEWAY" ]
					then
						# Avoid setting metric since it is controlled by conman and respected by kernel
						#
						# If kernel may have automatically added a default route from RA, it will
						# fail to add another one without specifying a different metric, so use replace
						# instead of add command to ensure the one from ModemManager is added successfully
						# (and the one from RA will be restored upon reception of another RA)
						log "$MODEM Setting IPv6 gateway: $IPV6_GATEWAY"
						if ! /bin/ip -6 route replace default via $IPV6_GATEWAY dev $IFACE
						then
							log "$MODEM ip -6 route replace default via $IPV6_GATEWAY dev $IFACE failed"
						fi
						echo "$IPV6_GATEWAY" > $CELLMODEM_IPV6GATEWAY
					fi
				else
					echo 1 > /proc/sys/net/ipv6/conf/$IFACE/disable_ipv6
				fi

				# wwan-up script will eventually get called
				log "$MODEM: connected"

				# Connected successfully so remove modem backoff state
				rm -f /var/run/.modem/retry_count
				return
			fi
		fi

		/etc/scripts/modem-backoff
	done
}

# Test if data session is still established, which requires that:
# . ModemManager and the managed modem's dbus objects are created, and
# . at least one bearer has been connected
# . the bearer's interface is wwanX
test_conn()
{
	# Check if any ModemManager's dbus object is created
	mmpath=`mmcli -L | grep ModemManager1 | awk '{print $1}'`
	if [ -z "$mmpath" ]; then
		exit 1
	fi

	# Check if any bearer's dbus object is created
	BUS_NAME=org.freedesktop.ModemManager1
	OBJECT_PATH=$mmpath
	INTERFACE_NAME=org.freedesktop.ModemManager1.Modem
	PROPERTY_NAME=Bearers
	bearerpaths=`dbus-send --system --print-reply \
		--dest=$BUS_NAME \
		$OBJECT_PATH \
		org.freedesktop.DBus.Properties.Get string:$INTERFACE_NAME string:$PROPERTY_NAME \
		| grep "object path" | cut -d '"' -f 2`
	if [ -z "$bearerpaths" ]; then
		exit 1
	fi

	for i in $bearerpaths; do
		# Check if the bear has become connected
		if mmcli -b $i | grep connected | grep -q "no" ; then
			continue
		fi

		# Check if the bear has any interface
		device=`mmcli -b $i | grep interface | sed 's/.*\(wwan[0-9]\).*/\1/'`
		if [ -z "$device" -o "$device" = "unknown" ]; then
			continue;
		fi

		# so far so good
		exit 0
	done

	exit 1
}

start_dhcp()
{
	if [ -e /var/run/udhcpc-$IFACE.pid ]
	then
		DHCPC_PID=`cat /var/run/udhcpc-$IFACE.pid`
		if [ ! -z "$DHCPC_PID" ]
		then
			if ! kill -USR1 $DHCPC_PID
			then
				/sbin/udhcpc -i $IFACE -p /var/run/udhcpc-$IFACE.pid -s /etc/scripts/wwan-up -t $DHCPC_RETRIES -T $DHCPC_TIMEOUT
			fi
		else
			/sbin/udhcpc -i $IFACE -p /var/run/udhcpc-$IFACE.pid -s /etc/scripts/wwan-up -t $DHCPC_RETRIES -T $DHCPC_TIMEOUT
		fi
	else
		/sbin/udhcpc -i $IFACE -p /var/run/udhcpc-$IFACE.pid -s /etc/scripts/wwan-up -t $DHCPC_RETRIES -T $DHCPC_TIMEOUT
	fi
}

stop_dhcp()
{
	if [ -e /var/run/udhcpc-$IFACE.pid ]
	then
		DHCPC_PID=`cat /var/run/udhcpc-$IFACE.pid`
		if [ ! -z "$DHCPC_PID" ]
		then
			kill -TERM $DHCPC_PID
		fi

		rm -f /var/run/udhcpc-$IFACE.pid
	fi
}

# Test if udhcpc daemon on cellmodem is still running
test_dhcp()
{
	pidfile="/var/run/udhcpc-$IFACE.pid"
	if [ ! -f $pidfile ] || ! kill -0 `cat $pidfile`
	then
		exit 1
	fi

	# Check if the interface has any ipv4 address bound, but there
	# won't have any address left when ip passthrough is enabled
	if [ "$(config -g config.ippassthrough.enabled | cut -f2- -d' ')" != "on" ]; then
		addresses=`ip -4 -o a | grep $IFACE`
		if [ -z "$addresses" ]; then
			exit 1
		fi

		if ! echo $addresses | grep -q "inet" ; then
			exit 1
		fi
	fi
}

case "$2" in
	connect)
		connect
		;;
	disconnect)
		disconnect
		;;
	test_conn)
		test_conn
		;;
	start_dhcp)
		start_dhcp
		;;
	stop_dhcp)
		stop_dhcp
		;;
	test_dhcp)
		test_dhcp
		;;
esac

exit 0
