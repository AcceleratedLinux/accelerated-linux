#!/bin/sh

# This script is run by perifrouted when it maps/unmaps a table ID to an
# interface (link). This happens when a link is added or deleted.

chain=PerIfRoute
subchain=PerInterface

action=$1
ifname=$2
ifindex=$3
table=$4

disable_ipv6="/proc/sys/net/ipv6/conf/all/disable_ipv6"

# create the perif route subchain and add it to the PREROUTING
# chain of the mangle table
# $1 - cmd: iptables or ip6tables
# $2 - chain action: N (new chain) or X (delete chain)
# $3 - rule action: A (append) or D (delete)
do_PREROUTING()
{
	$1 -t mangle -$3 PREROUTING -i ipsec+ -j MARK --set-mark 0
	$1 -t mangle -$2 $chain
	$1 -t mangle -$3 PREROUTING -j $chain
}

# restore connections CONNMARK to packets MARK for egress traffic
# generated by local host
# $1 - cmd: iptables or ip6tables
# $2 - rule action: A (append) or D (delete)
do_OUTPUT()
{
	$1 -t mangle -$2 OUTPUT \
		-m state --state RELATED,ESTABLISHED \
		-m conntrack --ctdir REPLY \
		-j CONNMARK --restore-mark
}

# revoke CONNMARK setting for forwarded traffic (excluding DNAT-ed
# ones) since symmmetric routing for associated REPLY traffic is
# not required yet
# $1 - cmd: iptables or ip6tables
# $2 - rule action: A (append) or D (delete)
do_FORWARD()
{
	$1 -t mangle -$2 FORWARD \
		-m conntrack ! --ctstate DNAT \
		-m connmark ! --mark 0 \
		-j CONNMARK --set-xmark 0
}

# setup perIfRoute chain
# $1 - cmd: iptables or ip6tables
# $2 - chain action: N (new) or X (delete)
# $3 - rule action: A (append) or D (delete)
do_chain()
{
	# restore connections CONNMARK to packets MARK for passing by traffic
	$1 -t mangle -$3 $chain \
		-m state --state RELATED,ESTABLISHED \
		-m conntrack --ctdir REPLY \
		-j CONNMARK --restore-mark

	# setup perInterface subchain
	$1 -t mangle -$2 $subchain
	$1 -t mangle -$3 $chain -j $subchain

	# save connections CONNMARK and wipe out packets MARK to ensure
	# the main route table is looked upon for ingress traffic (regardless
	# of whether it is targeting local host or passing by)

	$1 -t mangle -$3 $chain \
		-m state --state NEW \
		-m connmark ! --mark 0x0 \
		-j CONNMARK --save-mark

	$1 -t mangle -$3 $chain \
		-m conntrack --ctdir ORIGINAL \
		-j MARK --set-xmark 0x0
}

# set connections CONNMARK with an unique number of the network
# interface that received them
# $1 - cmd: iptables or ip6tables
# $2 - rule action: A (append) or D (delete)
# $3 - interface name
# $4 - CONNMARK value
do_device()
{
	$1 -t mangle -$2 $subchain \
		-i $3 \
		-m state --state NEW \
		-j CONNMARK --set-xmark $4

	$1 -t mangle -$2 $subchain \
		-i $3 \
		-m state --state NEW \
		-m connmark --mark $4 \
		-j MARK --set-xmark $4
}

init_ipv4()
{
	do_OUTPUT "iptables" "A"
	do_FORWARD "iptables" "A"
	do_PREROUTING "iptables" "N" "A"
	do_chain "iptables" "N" "A"
}

init_ipv6()
{
	do_OUTPUT "ip6tables" "A"
	do_FORWARD "ip6tables" "A"
	do_PREROUTING "ip6tables" "N" "A"
	do_chain "ip6tables" "N" "A"
}

fini_ipv4()
{
	do_chain "iptables" "X" "D"
	do_PREROUTING "iptables" "X" "D"
	do_FORWARD "iptables" "D"
	do_OUTPUT "iptables" "D"
}

fini_ipv6()
{
	do_chain "ip6tables" "X" "D"
	do_PREROUTING "ip6tables" "X" "D"
	do_FORWARD "ip6tables" "D"
	do_OUTPUT "ip6tables" "D"
}

add_ipv4()
{
	do_device "iptables" "A" "$ifname" "$ifindex"
}

add_ipv6()
{
	do_device "ip6tables" "A" "$ifname" "$ifindex"
}

del_ipv4()
{
	do_device "iptables" "D" "$ifname" "$ifindex"
}

del_ipv6()
{
	do_device "ip6tables" "D" "$ifname" "$ifindex"
}

case $action in
	init)
		init_ipv4
		;;
	fini)
		fini_ipv4
		;;
	add)
		add_ipv4
		;;
	del)
		del_ipv4
		;;
esac

if [ -f $disable_ipv6 -a `cat $disable_ipv6` = "0" ]; then
	case $action in
		init)
			init_ipv6
			;;
		fini)
			fini_ipv6
			;;
		add)
			add_ipv6
			;;
		del)
			del_ipv6
			;;
esac
fi

exit 0
