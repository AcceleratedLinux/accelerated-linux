<sect>Empezando el Tutorial
<p>
<sect1>Un simple primer experimento
<p>
Para ver que todos los componentes están ejecutándose y funcionando, 
escoja 2 estaciones de trabajo Linux, ambas conectadas a la LAN.
Asegúrese de que tiene al menos la versión 1.1 de OpenH323 y OhPhone instalados.
En la primera máquina ejecute el gatekeeper y el ohphone (en
consolas diferentes:

<tscreen><verb>
jan@machine1 > gnugk -ttt
</verb></tscreen>

Ahora el gatekeeper está ejecutándose en modo directo.
La opción "<tt/-ttt/" le dice al gatekeeper que genere mucha salida para debug 
en la consola (puede dirigir esa salida a un fichero con "<tt/-o logfile/").

<tscreen><verb>
jan@machine1 > ohphone -l -a -u jan
</verb></tscreen>

Ahora el OhPhone está escuchando (<tt/-l/) para recibir llamadas y las aceptará 
automáticamente (<tt/-a/). Se ha registrado como usuario jan con el gatekeeper 
que será detectado automáticamente. (si la autodetección fallara por alguna 
razón, use "<tt/-g 1.2.3.4/" para especificar la IP donde está escuchando 
el gatekeeper).

En la segunda maquina ejecute solamente ohphone:

<tscreen><verb>
peter@machine2 > ohphone -u peter jan
</verb></tscreen>

La segunda instancia de OhPhone se registra con el autodetectado gatekeeper  
como usuario peter e intenta llamar al usuario jan.
El gatekeeper resolverá el nombre de usuario a la IP desde 
donde el usuario jan se registró (máquina1 en este caso) y OhPhone 
llamará la otra instancia de OhPhone en la maquina uno.

La primera instancia de OhPhone aceptará esta llamada y Peter y Jan podran hablar.

<sect1>Uso del Puerto de Estado para Monitorear el Gatekeeper
<p>
Ahora intente ver qué mensajes son manejados por el gatekeeper.
En la nueva consola en maquina1 vamos a usar telnet para conectar al gatekeeper:

<tscreen><verb>
jan@machine1 > telnet machine1 7000
</verb></tscreen>

Lo más probable es que recibiremos un mensaje de acceso denegado ("Access forbidden!"), porque 
no se le permite a todo el mundo espiar.

Ahora crearemos un fichero llamado <tt/gatekeeper.ini/ y lo colocaremos en el directorio
donde arrancamos el gatekeeper.
<tt/gatekeeper.ini/ solo contiene 4 lineas:

<tscreen><verb>
[Gatekeeper::Main]
Fortytwo=42
[GkStatus::Auth]
rule=allow
</verb></tscreen>

Detenga el gatekeeper con Ctrl-C y ejecútelo de nuevo.
Cuando hagamos el telnet de nuevo, estaremos conectados con el gatekeeper.
Ahora repita el primer experimento donde Peter llama a Jan y observe qué 
mensajes son manejados por el gatekeeper en modo no enrutado.
Hay un número de comandos que pueden ser emitidos en esta sesión telnet:
Teclee "help" para verlos.
Para finalizar la sesión de telnet con el gatekeeper teclee "quit" y presione Enter.

Pero esto es muy inseguro, todos podrían conectarse hacia la interfaz de estado y ver ésta.
Cambiemos entonces el archivo de configuración de la siguiente manera

<tscreen><verb>
[Gatekeeper::Main]
Fortytwo=42
[GkStatus::Auth]
rule=password
gkadmin=QC7VyAo5jEw=
</verb></tscreen>

La quinta línea es agregada por la utilidad addpasswd, ésta crea un usuario llamado "gkadmin" con 
una contraseña "secret" limitando de esta manera el acceso hacia el puerto de estado.
Reinicie el gatekeeper con esta nueva configuración y realice telnet nuevamente.
Ahora se le preguntará por un nombre de usuario (username) y una contraseña (password) antes de que pueda entrar.

Eche una mirada a la sección <ref id="gkstatusauth" name="GkStatus::Auth"> para más detalle sobre seguridad del puerto de estado.

<sect1>Arrancando el gatekeeper en modo enrutado.
<p>
Arrancar o ejecutar el gatekeeper en modo enrutado significa que el gatekeeper 
utiliza "señales de enrutado gatekeeper" para todas las llamadas. En este 
modo de gatekeeper todos los mensajes de señalización pasarán 
a través del gatekeeper y esto permite mucho mas control sobre las llamadas.

<tscreen><verb>
jan@machine1 > gnugk -r
</verb></tscreen>

Ahora el gatekeeper está ejecutándose en modo enrutado. Haga telnet al puerto de estado 
y realice una llamada para ver que mensajes son manejados ahora por el gatekeeper.

Recuerde que todos los paquetes multimedia (audio y video) son todavía enviados 
directamente entre los endpoints (las 2 instancias de ohphone).

<sect1>Un PBX virtual: Desconectando llamadas
<p>
Hasta ahora el gatekeeper ha actuado solamente como un mecanismo 
para resolver nombres simbólicos a direcciones IP. Es una función 
importante pero difícilmente excitante.

Puesto que el gatekeeper tiene un gran control sobre las llamadas, 
éste puede finalizarlas por ejemplo. Cuando estamos conectados 
al Puerto de Estado, podemos listar todas las llamadas activas 
con "<tt/PrintCurrentCalls/". Para finalizar una llamada, podemos decir 
"<tt/Disconnectip 1.2.3.4/" para uno de estos endpoints.

Uno puede por ejemplo escribir un script simple que conecte al 
puerto de estado y escuche todas las llamadas entrantes y las termine 
después de 5 minutos, así ningún usuario puede sobrepasar los recursos del sistema.

Eche un vistazo a las otras funciones de telefonía como TransferCall para ver que más hay disponible.

<sect1>Enrutando llamadas hacia un gateway para alcanzar usuarios externos
<p>
Sin usar un gateway usted solo puede llamar a otras personas con un 
teléfono IP a traves de internet. Para alcanzar gente con teléfonos 
convencionales debe de usar un gateway.

<tscreen><verb>
_________________          ______________
| endpoint "jan"|          |            |
| 192.168.88.35 |--------->| Gatekeeper |
|_______________|          |            |
_________________          |            |
| gateway "gw1" | saliente |            |
| 192.168.88.37 |<---------|____________|
|_______________|
</verb></tscreen>

El gatekeeper tiene que conocer qué llamadas deben de ser supuestamente enrutadas 
a través del gateway y que números deben ser llamados directamente.
Use la sección [RasSrv::GWPrefixes] del fichero de configuración para decirle 
al gatekeeper el prefijo de números que deben de ser enrutados a través del
gateway.

<tscreen><verb>
[RasSrv::GWPrefixes]
gw1=0
</verb></tscreen>

Esta entrada le dirá al gatekeeper que enrute todas las llamadas con numeros E.164 
que empiezen por 0 al gateway que se ha registrado con el alias "gw1". 
Si no hay ningun gateway registrado con este alias la llamada fallará. 
Recuerde que debe usar un alias para el gateway - no puede simplemente 
decirle al gatekeeper la IP del gateway.

<p>
Un prefijo puede contener los dígitos <tt/0-9/, <tt/#/ y <tt/*/. Tambien puede 
contener un caracter especial <tt/./ (un punto) que sustituye cualquier dígito 
y puede ser prefijado con <tt/!/ (un signo de exclamación final) para desactivar el prefijo.
La sustitución de prefijos se hace de acuerdo a la regla de sustitución de prefijos mas larga,
teniendo las reglas ! mayor prioridad si la longitud es igual. Algunos ejemplos:

<tscreen><verb>
[RasSrv::GWPrefixes]
; Esta entrada enrutará numeros que empiecen con 0048 (pero no con 004850 y 004860)
; al gw1
gw1=0048,!004850,!004860
; Esta entrada hará corresponder solamente 001 y 10 digitos a continuación
gw2=001..........
</verb></tscreen>

<sect1>Reescribiendo números E.164
<p>
Mientras este usando un gateway frecuentemente tendrá que usar internamente numeros diferentes 
y reescribirlos antes de enviarlos a través del gateway a una red telefónica. 
Puede usar la sección <ref id="rewrite" name="RasSrv::RewriteE164">
para configurar ésto.

Ejemplo:
Usted quiere llamar el número 12345 con su telefono IP y le gustaría 
alcanzar el número 08765 detrás de un gateway llamado "gw1".

<tscreen><verb>
[RasSrv::GWPrefixes]
gw1=0

[RasSrv::RewriteE164]
12345=08765
</verb></tscreen>

Usted puede además configurar la reescritura de números E.164 basándose desde qué gateway
usted está recibiendo la llamada o enviando una llamada para que utilice la sección
<ref id="gwrewrite" name="RasSrv::GWRewriteE164">.

Ejemplo:
Usted tiene dos gateways diferentes ("gw1" y "gw2") hacia los cuales usted está enviando
llamadas con prefijos 0044, pero los mismos requieren que sean agregado un prefijo diferente
en el número después de que el ruteo ha elegido el gateway. Esto 
podría ser para propósitos de identificación por ejemplo.

<tscreen><verb>
[RasSrv::GWPrefixes]
gw1=0044
gw2=0044

[RasSrv::GWRewriteE164]
gw1=out=0044=77770044
gw2=out=0044=88880044
</verb></tscreen>

Ejemplo:
Usted necesita identificar llamadas desde un gateway particular "gw1" con un prefijo
específico antes que pasen estas llamadas hacia otro gateway "gw2".

<tscreen><verb>
[RasSrv::GWPrefixes]
gw2=1

[RasSrv::GWRewriteE164]
gw1=in=00=123400
</verb></tscreen>

La reescritura de expresiones acepta los caracteres comodín como <tt/'.'/ y signos de porcentaje <tt/'%'/
para permitir construír reglas más generales. El caracter punto puede estar
en cuanquier lado de las expresiones (izquierda o derecha), el signo de porcentaje solo puede estar
a la izquierda. Use <tt/'.'/ para corresponder cualquier caracter y copiar éste
en la cadena reescrita y <tt/'%'/ para emparejar cualquier caracter e ignorar éste.
Aqui uno ejemplos simples:

<tscreen><verb>
[RasSrv::RewriteE164]
; Reescribe 0044 + 7 dígitos mínimo hacia 44 + 7 dígitos mínimo
0044.......=44.......
; Reescribe números que empiezan con 11 + 4 dígitos + 11  hacia 22 + 4 dígitos + 22
; (así 11333311 => 22333322, 110000112345 => 220000222345)
11....11=22....22
; quita los primeros cuatro dígitos de todos los nñumeros (11114858345 => 4858345)
; esto es equivalente a 10 reglas %%%%1=1, %%%%2=2, ... 
%%%%.=.
; inserta dos ceros en medio del núumero (111148581234 => 11110048581234)
....48=....0048
; incluso esto es posible (415161 => 041051061)
4.5.6=04.05.06
</verb></tscreen>

