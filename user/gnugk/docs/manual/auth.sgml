<sect>Authentication Configuration
<p>
The following sections in the config file can be used to configure authentication.

<sect1>Section &lsqb;Gatekeeper::Auth&rsqb;
<label id="gkauth">
<p>
The section defines the authentication mechanism for the gatekeeper.

<descrip>
<tag/Syntax:/
<tscreen><verb>
authrule=actions

 <authrule> := SimplePasswordAuth | AliasAuth | FileIPAuth | PrefixAuth | RadAuth | RadAliasAuth | SQLAuth | SQLAliasAuth | SQLPasswordAuth | CapacityControl | ...
 <actions>  := <control>[;<ras>|<q931>,<ras>|<q931>,...]
 <control>  := optional | required | sufficient
 <ras>      := GRQ | RRQ | URQ | ARQ | BRQ | DRQ | LRQ | IRQ
 <q931>     := Setup | SetupUnreg

</verb></tscreen>
</descrip>
A rule may results in one of the three codes: ok, fail, pass.
<itemize>
<item><tt/ok/ - The request is authenticated by this module.
<item><tt/fail/ - The authentication fails and should be rejected.
<item><tt/next/ - The rule cannot determine the request.
</itemize>
There are also three ways to control a rule:
<itemize>
<item><tt/optional/ - If the rule cannot determine the request, it is passed to next rule.
<item><tt/required/ - The requests should be authenticated by this module, or it would be rejected. The authenticated request would then be passed to next rule.
<item><tt/sufficient/ - If the request is authenticated, it is accepted, or it would be rejected. That is, the rule determines the fate of the request. No rule should be put after a sufficient rule, since it won't take effect.
</itemize>

Currently supported modules: (most of them only support a subset of the ras or q931 actions)
<itemize>
<item><tt>SimplePasswordAuth/SQLPasswordAuth</tt>
<p>
These modules check the <bf/tokens/ or <bf/cryptoTokens/ fields of RAS message.
The tokens should contain at least generalID and password.
For <bf/cryptoTokens/, <bf/cryptoEPPwdHash/ tokens hashed by simple MD5 and
<bf/nestedcryptoToken/ tokens hashed by HMAC-SHA1-96 (libssl must be installed!)
are supported now. For <bf/tokens/ tokens hashed by CAT (Cisco Access Token)
and a clear text username/password are supported now.
The ID and password are read from <ref id="password" name="[SimplePasswordAuth]"> section,
an SQL database for <tt/SimplePasswordAuth/ and <tt/SQLPasswordAuth/
modules. <tt/MySQLPasswordAuth/
module is supported for backward compatibility.

<item><tt>AliasAuth/SQLAliasAuth</tt>
<p>
The module can only be used to authenticate RegistrationRequest (RRQ).
The IP of an endpoint with a given alias should match a specified pattern.
For <tt/AliasAuth/ the pattern is defined in
<ref id="rrqauth" name="[RasSrv::RRQAuth]"> section.
For <tt/SQLAliasAuth/, the pattern is retrieved from an SQL database, 
defined in <ref id="sqlaliasauth" name="[SQLAliasAuth]"> section.

<item><tt>FileIPAuth</tt>
<p>
This module provides a simple way to restrict access to the gatekeeper
based on caller's IP/network.

<item><tt>PrefixAuth</tt>
<p>
The IP or aliases of a request with a given prefix must match a specified
pattern. See section <ref id="prefixauth" name="[PrefixAuth]"> for details.
Currently the module can only authorize
AdmissionRequest (ARQ) and LocationRequest (LRQ).

<item><tt>RadAuth</tt>
<p>
Provides authentication based on H.235 username/password
security scheme. Authenticates RRQ, ARQ and Q.931 Setup through remote
RADIUS servers. It passes to RADIUS servers usernames and passwords
extracted from CAT (Cisco Access Tokens) <bf/tokens/ carried
inside RRQ, ARQ or Setup packets. Therefore if your endpoints do not
support CATs or you do not need authentication scheme based on
individually assigned usernames/password - this module will not
work for you (but you may check <tt/RadAliasAuth/ module).
See section <ref id="radauth" name="[RadAuth]"> for details.

<item><tt>RadAliasAuth</tt>
<p>
Provides authentication based on endpoint aliases
and/or call signaling IP addresses with remote RADIUS servers.
It does not need any H.235 <bf/tokens/ inside RAS messages,
so it can be used on a wider range of systems as compared to <tt/RadAuth/.
RRQ, ARQ and Q.931 Setup messages can be authenticated using this module.
See section <ref id="radaliasauth" name="[RadAliasAuth]"> for details.

<item><tt>SQLAuth</tt>
<p>
A powerful module to authenticate and authorize RRQ, ARQ, LRQ and Setup
messages. It can perform checks based on various parameters, like
caller's number, destination number, username and more. It also supports
enforcing call duration limit, number rewriting, call routing, alias
verification and assignment.
See section <ref id="sqlauth" name="[SQLAuth]"> for more details.

<item><tt>CapacityControl</tt>
<p>
A flexible module to control inbound call volume with ability to configure
various conditions. IMPORTANT: It has to be used in conjunction with <tt/CapacityControl/
accounting module. See section <ref id="capctrl" name="[CapacityControl]"> for more details.
 
</itemize>

You can also configure a rule to check only for some particular RAS messages.
The following example configures <tt/SimplePasswordAuth/ as an optional rule
to check RRQ and ARQ. If an RRQ is not checked (not contains
<bf/tokens/ or <bf/cryptoTokens/ fields), it is checked by <tt/AliasAuth/.
The default is to accept all requests.

<descrip>
<tag/Example 1:/
<tt/SimplePasswordAuth=optional;RRQ,ARQ/<newline>
<tt/AliasAuth=sufficient;RRQ/<newline>
</descrip>

The example below authenticates all calls, checking signaling Setup
message details, using RadAliasAuth module.

<descrip>
<tag/Example 2:/
<tt/RadAliasAuth=required;Setup/<newline>
<tt/default=allow/
</descrip>

This example checks endpoint registrations (RRQ) and call admissions (ARQ)
either by means of username/password (RadAuth) or alias/IP (RadAliasAuth).
Additionally, if the call is from an unregistered endpoint (and therefore
no RRQ or ARQ authentication has been performed), Setup message authentication
using RadAliasAuth takes place (SetupUnreg).

<descrip>
<tag/Example 3:/
<tt/RadAuth=optional;RRQ,ARQ/<newline>
<tt/RadAliasAuth=required;RRQ,ARQ,SetupUnreg/<newline>
<tt/default=allow/
</descrip>

<sect1>Section &lsqb;FileIPAuth&rsqb;
<label id="fileipauth">
<p>
This section defines a list of IP addresses/networks which are allowed
to access gatekeeper resources. A list of allowed prefixes can be specified
together with an IP address. Supported Gatekeeper::Auth events are:
<tt/GRQ/, <tt/RRQ/, <tt/LRQ/, <tt/Setup/ and <tt/SetupUnreg/. Format
of a single entry is:
<p><tt/IP=[allow | reject][;prefix[,prefix...]]/
<p>
where IP is a single IP address, a network address (in A.B.C.D/M.M.M.M or A.B.C.D/LENGTH format) or a string <tt/'any'/ or <tt/'*'/ to match any address.
The access list can also be loaded from an external file using <tt/include/ directive. During authentication, network mask length defines a priority for each
entry, so rule 192.168.1.1=allow takes precedence over 192.168.1.0/24=reject.

<descrip><tag/Example #1:/
<tscreen><verb>
[Gatekeeper::Auth]
FileIPAuth=required;RRQ,LRQ,Setup

[FileIPAuth]
192.168.1.240=reject
192.168.1.0/24=allow
192.168.2.0/255.255.255.0=allow;48,49,44
any=reject
</verb></tscreen>
</descrip>

<descrip><tag/Example #2:/
<tscreen><verb>
[Gatekeeper::Auth]
FileIPAuth=required;Setup

[FileIPAuth]
include=/etc/gnugk/accesslist.ini

(EOF)

Contents of /etc/gnugk/accesslist.ini:

[FileIPAuth]
192.168.1.1=allow
192.168.1.100=allow
any=reject
</verb></tscreen>
</descrip>

<sect1>Section &lsqb;SimplePasswordAuth&rsqb;
<label id="password">
<p>
The section defines the userid and password pairs used by
<tt/SimplePasswordAuth/ module. All passwords are encrypted
using the <tt/addpasswd/ utility.

Usage:
<tscreen><verb>
addpasswd config section userid password
</verb></tscreen>

Example:
<tscreen><verb>
addpasswd config.ini SimplePasswordAuth frank secret
</verb></tscreen>

Options:
<itemize>
<item><tt/KeyFilled=123/<newline>
Default: <tt/0/<newline>
<p>
Default value to use as a padding byte during password encryption/decryption.

<item><tt/CheckID=1/<newline>
Default: <tt/0/<newline>
<p>
Check if the aliases match the ID in the tokens.

<item><tt/PasswordTimeout=120/<newline>
Default: <tt/-1/<newline>
<p>
The module <tt/SimplePasswordAuth/ and all its descendants will cache an
authenticated password. This field define the cache timeout value in second.
<tt/0/ means never cache the password, while a negative value
means the cache never expires.
</itemize>

<sect1>Section &lsqb;SQLPasswordAuth&rsqb;
<label id="sqlpasswordauth">
<p>
Authenticate H.235 enabled endpoints using passwords stored
in the SQL database. This section defines SQL driver to use,
SQL database connection parameters and the query to use to retrieve passwords.

<itemize>
<item><tt/Driver=MySQL | PostgreSQL | Firebird/<newline>
Default: <tt>N/A</tt><newline>
<p>
SQL database driver to use. Currently, <tt/MySQL/, <tt/PostgreSQL/ and <tt/Firebird/ drivers
are implemented.

<item><tt/Host=DNS[:PORT] | IP[:PORT]/<newline>
Default: <tt/localhost/<newline>
<p>
SQL server host address. Can be in the form of <tt/DNS[:PORT]/ or <tt/IP[:PORT]/.
Like <tt/sql.mycompany.com/ or <tt/sql.mycompany.com:3306/ or <tt/192.168.3.100/.

<item><tt/Database=billing/<newline>
Default: <tt/billing/<newline>
<p>
The database name to connect to.

<item><tt/Username=gnugk/<newline>
<p>
The username used to connect to the database.

<item><tt/Password=secret/<newline>
<p>
The password used to connect to the database.
If the password is not specified, a database connection attempt 
without any password will be made.
If <tt/EncryptAllPasswords/ is enabled, or a <tt/KeyFilled/ variable is defined
in this section, the password is in an encrypted form and should be created using
the <tt/addpasswd/ utility.

<item><tt/CacheTimeout=120/<newline>
Default: <tt/0/<newline>
<p>
This field defines how long (alias;password) pairs retrieved from the database 
will be cached in the local memory. The cache timeout value is expressed in seconds.
<tt/0/ means to not cache passwords, while a negative value
means the cache never expires (only <tt/reload/ command will refresh the cache).

<item><tt/MinPoolSize=5/<newline>
Default: <tt/1/<newline>
<p>
Define the number of active SQL connections. This allows better performance
under heavy load, because more than 1 concurrent query can be executed 
at the same time. <tt/MinPoolSize=1/ setting simulates old behavior, 
when access to the SQL database is serialized (one query at time).

<item><tt/Query=SELECT .../<newline>
Default: <tt>N/A</tt><newline>
<p>
Defines SQL query used to retrieve H.235 password from the database. The query
is parameterized - that means parameter replacement is made before each query
is executed. Parameter placeholders are denoted by <bf/%1/, <bf/%2/, ... strings.
Specify %% to embed a percent character before a digit into string (like <bf/%%1/),
specify <bf/%{1}/ to allow expansion inside complex expressions like <bf/%{1}123/.
For <tt/SQLPasswordAuth/ two parameters are defined:
<itemize>
<item><tt/%1/ - the actual alias to query the password for
<item><tt/%2/ - the gatekeeper identifier
</itemize>
<p>
Sample query strings:
<tscreen><verb>
SELECT h235password FROM users WHERE alias = '%1' AND active
SELECT h235password FROM users WHERE alias = '%1' AND gk = '%2'
</verb></tscreen>

</itemize>

<sect1>Section &lsqb;RasSrv::RRQAuth&rsqb;
<label id="rrqauth">
<p>
Specify the action on RRQ reception (confirm or deny) for <tt/AliasAuth/ module.
The first alias (this will mostly be an H323ID) of the endpoint to
register is looked up in this section. If a parameter is found the value will
apply as a rule. A rule consists of conditions separated by "&".
A registration is accepted when all conditions apply.

<descrip>
<tag/Syntax:/
<tscreen><verb>
&lt;authrules&gt; :=  empty  |  &lt;authrule&gt; "&" &lt;authrules&gt;

  &lt;authrule&gt;  := &lt;authtype&gt; ":" &lt;authparams&gt;
  &lt;authtype&gt;  := "sigaddr" | "sigip"
  &lt;autparams&gt; := [!&]*
</verb></tscreen>
</descrip>

The notation and meaning of <tt/&lt;authparams&gt;/ depends on
<tt/&lt;authtype&gt;/:

<itemize>
<item><tt/sigaddr/ - extended regular expression that has to match against the
``PrintOn(ostream)'' representation of the signal address of the request.
<p>
Example:
<tscreen><verb>
sigaddr:.*ipAddress .* ip = .* c0 a8 e2 a5 .*port = 1720.*
</verb></tscreen>

<item><tt/sigip/ - specialized form of `<tt/sigaddr/'.
Write the signaling IP address using (commonly used) decimal notation:
``<tt/byteA.byteB.byteC.byteD:port/''.
<p>
Example:
<tscreen><verb>
sigip:192.168.242.165:1720
</verb></tscreen>

<item><tt/allow/ - always accept the alias.

<item><tt/deny/ - always reject the alias.

</itemize>

<sect1>Section &lsqb;SQLAliasAuth&rsqb;
<label id="sqlaliasauth">
<p>
Authenticate endpoints using rules stored in the SQL database
(the rules conform to the format defined in the <ref id="rrqauth" name="[RasSrv::RRQAuth]"> section). 
This section defines SQL driver to use, SQL database connection parameters 
and the query to use to retrieve the patterns.

<itemize>
<item><tt/Driver=MySQL | PostgreSQL | Firebird/<newline>
Default: <tt>N/A</tt><newline>
<p>
SQL database driver to use. Currently, <tt/MySQL/, <tt/PostgreSQL/ and <tt/Firebird/ drivers
are implemented.

<item><tt/Host=DNS[:PORT] | IP[:PORT]/<newline>
Default: <tt/localhost/<newline>
<p>
SQL server host address. Can be in the form of <tt/DNS[:PORT]/ or <tt/IP[:PORT]/.
Like <tt/sql.mycompany.com/ or <tt/sql.mycompany.com:3306/ or <tt/192.168.3.100/.

<item><tt/Database=billing/<newline>
Default: <tt/billing/<newline>
<p>
The database name to connect to.

<item><tt/Username=gnugk/<newline>
<p>
The username used to connect to the database.

<item><tt/Password=secret/<newline>
<p>
The password used to connect to the database.
If the password is not specified, a database connection attempt 
without any password will be made.
If <tt/EncryptAllPasswords/ is enabled, or a <tt/KeyFilled/ variable is defined
in this section, the password is in encrypted form and should be created using
the <tt/addpasswd/ utility.

<item><tt/CacheTimeout=120/<newline>
Default: <tt/0/<newline>
<p>
This field defines how long (alias;authrule) pairs retrieved from the database 
will be cached in the local memory. The cache timeout value is expressed in seconds.
<tt/0/ means to not cache rules, while a negative value
means the cache never expires (only <tt/reload/ command will refresh the cache).

<item><tt/MinPoolSize=5/<newline>
Default: <tt/1/<newline>
<p>
Define the number of active SQL connections. This allows better performance
under heave load, because more than 1 concurrent query can be executed 
at the same time. <tt/MinPoolSize=1/ setting simulates old behavior, 
when access to the SQL database is serialized (one query at time).

<item><tt/Query=SELECT .../<newline>
Default: <tt>N/A</tt><newline>
<p>
Defines SQL query used to retrieve alias rule from the database. The query
is parameterized - that means parameter replacement is made before each query
is executed. Parameter placeholders are denoted by <bf/%1/, <bf/%2/, ... strings.
Specify %% to embed a percent character before a digit into string (like <bf/%%1/),
specify <bf/%{1}/ to allow expansion inside complex expressions like <bf/%{1}123/.
For <tt/SQLAliasAuth/ two parameters are defined:
<itemize>
<item><tt/%1/ - the actual alias to query the rule for
<item><tt/%2/ - the gatekeeper identifier
</itemize>
<p>
Sample query strings:
<tscreen><verb>
SELECT authrule FROM users WHERE alias = '%1' AND active
SELECT 'sigip:' || host(ip) || port FROM users WHERE alias = '%1'
</verb></tscreen>

</itemize>

<sect1>Section &lsqb;SQLAuth&rsqb;
<label id="sqlauth">
<p>
Authenticate and authorize endpoints/calls using an SQL database.
Support for RRQ, ARQ, LRQ and Setup events is provided.

<itemize>
<item><tt/Driver=MySQL | PostgreSQL | Firebird/<newline>
Default: <tt>N/A</tt><newline>
<p>
SQL database driver to use. Currently, <tt/MySQL/, <tt/PostgreSQL/ and <tt/Firebird/ drivers
are implemented.

<item><tt/Host=DNS[:PORT] | IP[:PORT]/<newline>
Default: <tt/localhost/<newline>
<p>
SQL server host address. Can be in the form of <tt/DNS[:PORT]/ or <tt/IP[:PORT]/.
Like <tt/sql.mycompany.com/ or <tt/sql.mycompany.com:3306/ or <tt/192.168.3.100/.

<item><tt/Database=billing/<newline>
Default: <tt/billing/<newline>
<p>
The database name to connect to.

<item><tt/Username=gnugk/<newline>
<p>
The username used to connect to the database.

<item><tt/Password=secret/<newline>
<p>
The password used to connect to the database.
If the password is not specified, a database connection attempt 
without any password will be made.
If <tt/EncryptAllPasswords/ is enabled, or a <tt/KeyFilled/ variable is defined
in this section, the password is in encrypted form and should be created using
the <tt/addpasswd/ utility.

<item><tt/MinPoolSize=5/<newline>
Default: <tt/1/<newline>
<p>
Define the number of active SQL connections. This allows better performance
under heave load, because more than 1 concurrent query can be executed 
at the same time. <tt/MinPoolSize=1/ setting simulates old behavior, 
when access to the SQL database is serialized (one query at time).

<item><tt/RegQuery=SELECT .../<newline>
Default: <tt>N/A</tt><newline>
<p>
Define an SQL query to be used to perform authentication and authorization
of endpoint registrations. The query is parameterized - that means parameter
replacement is made before each query is executed. The following parameters are defined:
<itemize>
<item><tt/%g/ - the gatekeeper identifier
<item><tt/%{gkip}/ - a gatekeeper IP the request has been received on
<item><tt/%u/ - username associated with an endpoint (usually an H.323 ID)
<item><tt/%{callerip}/ - caller's IP (the request has been received from - NAT IP for natted endpoints)
<item><tt/%{aliases}/ - a comma separated list of endpoint aliases
</itemize>
<p>
If the query returns no rows, the result is undefined, which basically
means failure for <tt/required/ rules and "try next" for optional rules.
Otherwise, the first result row is examined to determine authentication
result and get additional information:
<enum>
<item>The first column is converted into a boolean value (1, T, TRUE, allow, y, yes means true)
      and is an authentication result (accept/reject).
<item>If the registration is authenticated successfully, remaining columns 
      are examined:
<enum>
	<item>If there exists a column called <tt/'aliases'/, replace original endpoint
		aliases with these new ones
	<item>If there exists a column called <tt/'billingmode'/, set a billing mode
		associated with the endpoint (0 - credit, <>0 - debit)
	<item>If there exists a column called <tt/'creditamount'/, set account balance
		associated with the endpoint (this is an arbitrary string)
</enum>
</enum>
<p>
Query string examples:
<tscreen><verb>
SELECT 1, 0 AS billingmode, '12.00 USD' AS creditamount
SELECT NOT disabled, assignaliases AS aliases, balance FROM users WHERE h323id = '%u'
SELECT * FROM get_registration_auth('%g', '%u', '%{callerip}', '%{aliases}') AS result(accept, aliases, billingmode, creditamount)
</verb></tscreen>

<item><tt/NbQuery=SELECT .../<newline>
Default: <tt>N/A</tt><newline>
<p>
Define an SQL query to be used to perform authentication and authorization
of location requests sent from neighbors. The query is parameterized - that means parameter
replacement is made before each query is executed. The following parameters are defined:
<itemize>
<item><tt/%g/ - the gatekeeper identifier
<item><tt/%{gkip}/ - a gatekeeper IP the request has been received on
<item><tt/%{nbid/ - neighbor identifier from the config
<item><tt/%{nbip}/ - neighbor IP (the request has been received from)
<item><tt/%{Calling-Station-Id}/ - caller's number, if available
<item><tt/%{src-info}/ - content of sourceInfo LRQ field, if available
<item><tt/%{Called-Station-Id}/ - destination number
<item><tt/%{dest-info}/ - content of destinationInfo LRQ field
<item><tt/%{bandwidth}/ - requested bandwidth, if present in the LRQ
</itemize>
<p>
If the query returns no rows, the result is undefined, which basically
means failure for <tt/required/ rules and "try next" for optional rules.
Otherwise, the first result row is examined to determine authentication
result and get additional information:
<enum>
<item>The first column is converted into a boolean value (1, T, TRUE, allow, y, yes means true)
      and is an authentication result (accept/reject).
<item>If the request is authenticated successfully, remaining columns 
      are examined:
<enum>
	<item>If there exists a column called <tt/'destination'/, populate the original
		destinationInfo field with these new aliases - this may affect routing
		decision, which is made after auth step
</enum>
</enum>
<p>
Query string examples:
<tscreen><verb>
SELECT active FROM neighbors WHERE name = '%{nbid}' AND ip = '%{nbip}' UNION SELECT 0
</verb></tscreen>

<item><tt/CallQuery=SELECT .../<newline>
Default: <tt>N/A</tt><newline>
<p>
Define an SQL query to be used to perform authentication and authorization
of calls (ARQ and Setup). The query is parameterized - that means parameter
replacement is made before each query is executed. The following parameters are defined:
<itemize>
<item><tt/%g/ - the gatekeeper identifier
<item><tt/%{gkip}/ - a gatekeeper IP the request has been received on
<item><tt/%u/ - an username associated with the caller
<item><tt/%{callerip}/ - caller's IP (the request has been received from - NAT IP for natted endpoints)
<item><tt/%{Calling-Station-Id}/ - caller's number, if available
<item><tt/%{Called-Station-Id}/ - destination number
<item><tt/%{Dialed-Number}/ - original destination number (before rewrite)
<item><tt/%{bandwidth}/ - requested bandwidth, if present in the ARQ
<item><tt/%{answer}/ - 1, if the request is an answering ARQ
<item><tt/%{arq}/ - 1 for ARQ triggered query, 0 for Setup triggered query
</itemize>
<p>
If the query returns no rows, the result is undefined, which basically
means failure for <tt/required/ rules and "try next" for optional rules.
Otherwise, the first result row is examined to determine authentication
result and get additional information:
<enum>
<item>The first column is converted into a boolean value (1, T, TRUE, allow, y, yes means true)
      and is an authentication result (accept/reject the call).
<item>If the request is authenticated successfully, remaining columns 
      are examined:
<enum>
	<item>If there exists a column called <tt/'billingmode'/, set a billing mode
		associated with the endpoint (0 - credit, <>0 - debit)
	<item>If there exists a column called <tt/'creditamount'/, set account balance
		associated with the endpoint (this is an arbitrary string)
	<item>If there exists a column called <tt/'credittime'/, use its integer
          value to set call duration limit
	<item>If there exists a column called <tt/'redirectnumber'/, replace
          the original destination number with this one
	<item>If there exists a column called <tt/'redirectip'/, force the call
          to be sent to the specified IP (one can put multiple destinations
		  separated by a semicolon)
	<item>If there exists a column called <tt/'proxy'/, force the gatekeeper
          to enable/disable (depends on the 'proxy' column value) RTP proxy
          for this call
</enum>
</enum>
<p>
Query string examples:
<tscreen><verb>
SELECT 1, 360 AS credittime, 0 AS proxy
SELECT * FROM auth_call('%g', '%u', '%{Calling-Station-Id}', '%{callerip}', '%{Called-Station-Id}') AS result(accept, credittime)
SELECT 1, '1234' AS redirectnumber, '192.168.1.1' AS redirectip
</verb></tscreen>

</itemize>


<sect1>Section &lsqb;PrefixAuth&rsqb;
<label id="prefixauth">
<p>
The section defines the authentication rule for <tt/PrefixAuth/ module.
Currently, only ARQs and LRQs can be authorized by this module.

First, a most specific prefix is selected according to the <bf/destinationInfo/
field of the received request. Then the request is accepted or rejected
according to the matched rules with most specific netmask.
If no matched prefix is found,
and the <tt/default/ option is specified, the request is accepted
or rejected according to that. Otherwise
it is rejected or passed to next authentication module
according to the module requirement.

<descrip>
<tag/Format:/
<tscreen><verb>
prefix=authrule[|authrule|...]
</verb></tscreen>

<tag/Syntax:/
<tscreen><verb>
&lt;authrule&gt; :=  &lt;result&gt; &lt;authrule&gt;

  &lt;result&gt;    := deny | allow
  &lt;authrule&gt;  := [!]ipv4:&lt;iprule&gt; | [!]alias:&lt;aliasrule&gt;
</verb></tscreen>
</descrip>
Where <tt/&lt;iprule&gt;/ can be specified in decimal dot notation or
CIDR notation, <tt/&lt;aliasrule&gt;/ is expressed in regular expression.
If the `<tt/!/' flag precedes the rule, the sense is inverted.

<descrip>
<tag/Example:/
<tscreen><verb>
555=deny ipv4:10.0.0.0/27|allow ipv4:0/0
5555=allow ipv4:192.168.1.1|deny ipv4:192.168.1.0/255.255.255.0
86=deny !ipv4:172.16.0.0/24
09=deny alias:^188884.*
ALL=allow ipv4:ALL
</verb></tscreen>
</descrip>

In this configuration, all endpoints except from network <tt>10.0.0.0/27</tt>
are allow to call prefix 555 (except 5555).
Endpoints from <tt>192.168.1.0/24</tt> are not allowed to call prefix 5555,
except <tt/192.168.1.1/.
Endpoints <bf/not/ from <tt>172.16.0.0/24</tt> are denied to call prefix 86.
Endpoints having an alias beginning with 188884 are not allowed to call
prefix 09. All other situations are allowed.

<sect1>Section &lsqb;RadAuth&rsqb;
<label id="radauth">
<p>
This section defines configuration settings that enable
RADIUS authentication based on H.235 CATs (Cisco Access Tokens)
present in RRQ, ARQ RAS requests and Q.931 Setup messages.
<itemize>
<item><tt/Servers=SERVER1[:AUTH_PORT[:ACCT_PORT[:SECRET]]];SERVER2[:AUTH_PORT[:ACCT_PORT[:SECRET]]];.../<newline>
Default: <tt>N/A</tt><newline>
<p>
RADIUS servers to be used for authentication. The list can contain an arbitrary 
number of servers. The order of servers is important, because servers will 
be queried by the RADIUS module in the given order. If no port information 
is provided, port number from <tt/DefaultAuthPort/ will be used. If no secret is set, 
the default shared secret from <tt/SharedSecret/ is taken. 
Servers names can be IP addresses or DNS names.

<descrip>
<tag>Sample <tt/Servers/ lines:</tag>
<tt>Servers=192.168.1.1</tt><newline>
<tt>Servers=192.168.1.1:1645</tt><newline>
<tt>Servers=192.168.1.1:1645:1646:secret1</tt><newline>
<tt>Servers=radius1.mycompany.com:1812</tt><newline>
<tt>Servers=radius1.mycompany.com;radius2.mycompany.com</tt><newline>
<tt>Servers=radius1.mycompany.com:1812:1813:secret1;radius2.mycompany.com:1812:1813:secret2</tt><newline>
</descrip>

<item><tt/LocalInterface=IP_OR_FQDN/<newline>
Default: <tt>N/A</tt><newline>
<p>
Particular local network interface that RADIUS client should
use in order to communicate with RADIUS servers. This parameter
can be useful on NAT machines to restrict number of network
interfaces used for RADIUS communication. By default this value
is empty and allows RADIUS requests to be sent on any (best suitable)
network interface. If you are not sure what you are doing, it is
better to leave this option unset.

<item><tt/RadiusPortRange=10000-11000/<newline>
Default: <tt>N/A</tt><newline>
<p>
By default (if this option is not set) RADIUS client
allocates ports dynamically as specified by the operating system.
If you want to restrict RADIUS client to use ports from
a particular range only - set this parameter.

<item><tt/DefaultAuthPort=PORT_NO/<newline>
Default: <tt>1812</tt><newline>
<p>
Default port number to be used for RADIUS authentication requests
(Access-Request packets), if not overridden by <tt/Servers/ attribute.

<item><tt/SharedSecret=SECRET/<newline>
Default: <tt>N/A (empty string)</tt><newline>
<p>
Secret used to authenticate this GnuGk (NAS client) to RADIUS
server. It should be a cryptographically strong password. This is the default
value used, if no server-specific secret is set in the <tt/Servers/.
If <tt/EncryptAllPasswords/ is enabled, or a <tt/KeyFilled/ variable is defined
in this section, the password is in encrypted form and should be created using
the <tt/addpasswd/ utility.

<item><tt/RequestTimeout=TIMEOUT_MS/<newline>
Default: <tt/2000/ (milliseconds)<newline>
<p>
Timeout (milliseconds) for RADIUS server response to a request
sent by GnuGk. If no response is received within this time period,
next RADIUS server is queried.

<item><tt/IdCacheTimeout=TIMEOUT_MS/<newline>
Default: <tt/9000/ (milliseconds)<newline>
<p>
Timeout (milliseconds) for RADIUS request 8-bit identifiers to be
unique. If all 8-bit identifier range is exhausted within this period,
new client socket (UDP socket) is allocation by RADIUS module. Let's
take the example: we have approximately 60 RRQs/sec - after ca. 4 seconds
8-bit identifiers range gets exhausted - new socket allocated - after next
4 seconds the second 8-bit identifiers range gets exhausted - third socket
allocated - after 9th second identifiers from the pool 1 are available again
- ... . In general, too long timeout - too much resources consumed,
too short timeout - RADIUS server may take incoming packets as duplicated
and therefore drop it.

<item><tt/SocketDeleteTimeout=TIMEOUT_MS/<newline>
Default: <tt/60000/ (milliseconds) - 60 s<newline>
<p>
Timeout for unused RADIUS sockets to be closed. It is used
in conjunction with <tt/IdCacheTimeout/ - additional sockets
created during heavy GK load time periods for serving incoming
requests are closed during idle periods.

<item><tt/RequestRetransmissions=NUMBER/<newline>
Default: <tt/2/<newline>
<p>
How many times a single RADIUS request is transmitted to every
configured RADIUS server (if no response is received). 1 means
no retransmission, 2 - single retransmission, ... . Exact retransmission
method is defined by <tt/RoundRobinServers/ attribute.

<item><tt/RoundRobinServers=BOOLEAN/<newline>
Default: <tt/1/<newline>
<p>
RADIUS requests retransmission method.
<p>
If set to 1, RADIUS request
is transmitted in the following way (until response is received):
<tscreen><verb>
Server #1 Attempt #1, Server #2 Attempt #1, ..., Server #N Attempt #1
...
Server #1 Attempt #RequestRetransmissions, ..., Server #1 Attempt #RequestRetransmissions
</verb></tscreen>
<p>
If set to 0, the following sequence is preserved:
<tscreen><verb>
Server #1 Attempt #1, ..., Server #1 Attempt #RequestRetransmissions
...
Server #N Attempt #1, ..., Server #N Attempt #RequestRetransmissions
</verb></tscreen>

<item><tt/AppendCiscoAttributes=BOOLEAN/<newline>
Default: <tt/0/<newline>
<p>
If set, Cisco Vendor Specific RADIUS attributes are included
in RADIUS requests (h323-conf-id,h323-call-origin,h323-call-type).

<item><tt/IncludeTerminalAliases=BOOLEAN/<newline>
Default: <tt/1/<newline>
<p>
If set, Cisco VSA 'h323-ivr-out' attribute is sent with a list of aliases
the endpoint is registering (RRQ.m_terminalAlias). This attribute is provided
in order to provide fine control over the list of aliases the endpoint
is allowed to register with. Format of this attribute is:
<tscreen><verb>
	Cisco-AV-Pair = "h323-ivr-out=terminal-alias:" alias [,alias] [;]
Example:
	Cisco-AV-Pair = "h323-ivr-out=terminal-alias:helpdesk,support,77771;"
</verb></tscreen>

<item><tt/UseDialedNumber=BOOLEAN/<newline>
Default: <tt/0/<newline>
<p>
Select Called-Station-Id number type between the original one (as dialed
by the user) - <tt/UseDialedNumber=1/ - and the rewritten one - <tt/UseDialedNumber=0/.

</itemize>

<sect1>Section &lsqb;RadAliasAuth&rsqb;
<label id="radaliasauth">
<p>
This section defines configuration settings that enable
RADIUS authentication based on endpoint aliases and/or IP addresses
present in RRQ RAS requests, ARQ RAS request or Q.931 Setup request.
This authentication scheme is useful both for endpoints registered
at the gatekeeper (ARQ,RRQ) and calls from unregistered endpoints (Setup).

<itemize>
<item><tt/Servers=SERVER1[:AUTH_PORT[:ACCT_PORT[:SECRET]]];SERVER2[:AUTH_PORT[:ACCT_PORT[:SECRET]]];.../<newline>
Default: <tt>N/A</tt><newline>
<p>
RADIUS servers to be used for RAS requests authentication.
This list can contain an arbitrary number of servers. The order of servers 
is important, because servers will be queried by the RADIUS module 
in the given order. If no port information is specified, port number from 
<tt/DefaultAuthPort/ will be used. If no secret is set, 
the default shared secret from <tt/SharedSecret/ is used.
Servers can be IP addresses or DNS names.

<descrip>
<tag/Example:/
<tt/Servers=192.168.3.1:1645;192.168.3.2:1812:1813:mysecret;radius.mycompany.com/
</descrip>

<item><tt/LocalInterface=IP_OR_FQDN/<newline>
Default: <tt>N/A</tt><newline>
<p>
Particular local network interface that RADIUS client should
use in order to communicate with RADIUS servers. This parameter
can be useful on NAT machines to restrict number of network
interfaces used for RADIUS communication. By default this value
is empty and allows RADIUS requests to be sent on any (best suitable)
network interface. If you are not sure what you are doing, it is
better to leave this option unset.

<item><tt/RadiusPortRange=10000-11000/<newline>
Default: <tt>N/A</tt><newline>
<p>
By default (if this option is not set) RADIUS client
allocates ports dynamically as specified by the operating system.
If you want to restrict RADIUS client to use ports from
a particular range only - set this parameter.

<item><tt/DefaultAuthPort=PORT_NO/<newline>
Default: <tt>1812</tt><newline>
<p>
Default port number to be used for RADIUS authentication requests
(Access-Request packets), if not overridden by <tt/Servers/ attribute.

<item><tt/SharedSecret=SECRET/<newline>
Default: <tt>N/A (empty string)</tt><newline>
<p>
Secret used to authenticate this GnuGk (NAS client) to RADIUS
server. It should be a cryptographically strong password. This is the default
value used, if no server-specific secret is set in the <tt/Servers/.
If <tt/EncryptAllPasswords/ is enabled, or a <tt/KeyFilled/ variable is defined
in this section, the password is in encrypted form and should be created using
the <tt/addpasswd/ utility.

<item><tt/RequestTimeout=TIMEOUT_MS/<newline>
Default: <tt/2000/ (milliseconds)<newline>
<p>
Timeout (milliseconds) for RADIUS server response to a request
sent by GnuGk. If no response is received within this time period,
next RADIUS server is queried.

<item><tt/IdCacheTimeout=TIMEOUT_MS/<newline>
Default: <tt/9000/ (milliseconds)<newline>
<p>
Timeout (milliseconds) for RADIUS request 8-bit identifiers to be
unique. If all 8-bit identifier range is exhausted within this period,
new client socket (UDP socket) is allocation by RADIUS module. Let's
take the example: we have approximately 60 RRQs/sec - after ca. 4 seconds
8-bit identifiers range gets exhausted - new socket allocated - after next
4 seconds the second 8-bit identifiers range gets exhausted - third socket
allocated - after 9th second identifiers from the pool 1 are available again
- ... . In general, too long timeout - too much resources consumed,
too short timeout - RADIUS server may take incoming packets as duplicated
and therefore drop it.

<item><tt/SocketDeleteTimeout=TIMEOUT_MS/<newline>
Default: <tt/60000/ (milliseconds) - 60 s<newline>
<p>
Timeout for unused RADIUS sockets to be closed. It is used
in conjunction with <tt/IdCacheTimeout/ - additional sockets
created during heavy GK load time periods for serving incoming
requests are closed during idle periods.

<item><tt/RequestRetransmissions=NUMBER/<newline>
Default: <tt/2/<newline>
<p>
How many times a single RADIUS request is transmitted to every
configured RADIUS server (if no response is received). 1 means
no retransmission, 2 - single retransmission, ... . Exact retransmission
method is defined by <tt/RoundRobinServers/ attribute.

<item><tt/RoundRobinServers=BOOLEAN/<newline>
Default: <tt/1/<newline>
<p>
RADIUS requests retransmission method.
<p>
If set to 1, RADIUS request
is transmitted in the following way (until response is received):
<tscreen><verb>
Server #1 Attempt #1, Server #2 Attempt #1, ..., Server #N Attempt #1
...
Server #1 Attempt #RequestRetransmissions, ..., Server #1 Attempt #RequestRetransmissions
</verb></tscreen>
<p>
If set to 0, the following sequence is preserved:
<tscreen><verb>
Server #1 Attempt #1, ..., Server #1 Attempt #RequestRetransmissions
...
Server #N Attempt #1, ..., Server #N Attempt #RequestRetransmissions
</verb></tscreen>

<item><tt/AppendCiscoAttributes=BOOLEAN/<newline>
Default: <tt/1/<newline>
<p>
If set, Cisco Vendor Specific RADIUS attributes are included
in RADIUS requests (h323-conf-id,h323-call-origin,h323-call-type).

<item><tt/IncludeTerminalAliases=BOOLEAN/<newline>
Default: <tt/1/<newline>
<p>
If set, Cisco VSA 'h323-ivr-out' attribute is sent with a list of aliases
the endpoint is registering (RRQ.m_terminalAlias). This attribute is provided
in order to provide fine control over the list of aliases the endpoint
is allowed to register with. Format of this attribute is:
<tscreen><verb>
	Cisco-AV-Pair = "h323-ivr-out=terminal-alias:" alias [,alias] [;]
Example:
	Cisco-AV-Pair = "h323-ivr-out=terminal-alias:helpdesk,support,77771;"
</verb></tscreen>

<item><tt/FixedUsername/<newline>
Default: <tt>N/A</tt><newline>
<p>
If this parameter is set, it overwrites a value of User-Name RADIUS attribute
for outgoing RADIUS request. That means every Access-Request will be
authenticated as for user <tt/FixedUsername/.

<item><tt/FixedPassword/<newline>
Default: <tt>N/A</tt><newline>
<p>
If not set, User-Password is a copy of User-Name. For example, if User-Name
is 'john' then User-Password will also be set to 'john'. Setting this
parameter overrides this behavior and User-Password attribute will be
always set to the value of <tt/FixedPassword/.
If <tt/EncryptAllPasswords/ is enabled, or a <tt/KeyFilled/ variable is defined
in this section, the password is in encrypted form and should be created using
the <tt/addpasswd/ utility.

<descrip>
<tag/Example 1:/
<tscreen><verb>
(Neither FixedUsername nor FixedPassword set)
</verb></tscreen>
All endpoints will be authenticated using their alias as the username
and the password. That means, for example, endpoint 'EP1' will be authenticated
with the username 'EP1 and the password 'EP1'.
</descrip>

<descrip>
<tag/Example 2:/
<tscreen><verb>
(FixedUsername not set)
FixedPassword=ppp
</verb></tscreen>
All endpoints will be authenticated using their alias and the password 'ppp'.
</descrip>

<descrip>
<tag/Example 3:/
<tscreen><verb>
FixedUsername=ppp
FixedPassword=ppp
</verb></tscreen>
All endpoints will be authenticated using the username 'ppp'
and the password 'ppp'.
</descrip>

<item><tt/UseDialedNumber=BOOLEAN/<newline>
Default: <tt/0/<newline>
<p>
Select Called-Station-Id number type between the original one (as dialed
by the user) - <tt/UseDialedNumber=1/ - and the rewritten one - <tt/UseDialedNumber=0/.

</itemize>

<sect1>Section &lsqb;CapacityControl&rsqb;
<label id="capctrl">
<p>
This section contains a set of rules for controlling inbound call volume
depending on various conditions. In order this module to work, CapacityControl
authentication and accounting modules have to be enabled like this:
<tscreen><verb>
[Gatekeeper::Auth]
CapacityControl=required;Setup
 
[Gatekeeper::Acct]
CapacityControl=required;start,stop
</verb></tscreen>
<p>
A capacity rule can be matched by a caller's IP, caller's H.323 ID and/or
caller's number (CLI) - in the order specified. In addition, the match can
be narrowed by specifying a called number pattern. This module works by keeping
lists of current call volume for each inbound route (rule) - this is done
by having <tt/CapacityControl/ accounting module configured to add/remove
active calls from matching routes. <tt/CapacityControl/ authentication module
checks rules and accepts/rejects a call based on current/max call volume
for a matching inbound route.
<p>
<descrip>
<tag/Format for an inbound route rule:/
<tt>[ip:CALLER_IP|h323id:CALLER_H323ID|cli:CALLER_NUMBER]=[CALLED NUMBER REGEX PATTERN] MAX_CAPACITY</tt>
<p>
<tt/ip:/, <tt/h323id:/ and <tt/cli:/ prefixes define rule type. An inbound call
will be matched either by caller's IP, H.323ID or CLI. The optional <tt/CALLED NUMBER REGEX PATTERN/
is a regular expression that the called number should match to apply this rule to.
<tt/MAX_CAPACITY/ is maximum number of active calls for this route.
 
<tag/Example 1:/
<tscreen><verb>
[CapacityControl]
ip:192.168.1.0/24=30
ip:any=120
</verb></tscreen>
<p>
These rules tell that the 192.168.1.0/24 subnet can send up to 30 concurrent
calls, while all other IPs can send up to 120 concurrent calls.
 
<tag/Example 2:/
<tscreen><verb>
[CapacityControl]
%r1% cli:1001=30
%r2% cli:1001=^48(50|51) 5
</verb></tscreen>
<p>
These rules limit caller with CLI 1001 to send up to 5 calls to 4850/4851
destinations and up to 30 calls to other destinations. %r1% and %r2% are
special constructs to allow having the same <tt/cli:1001/ config key more
than once.
</descrip>
