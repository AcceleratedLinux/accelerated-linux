From 89016b299cb5c8accd9a2ea2adb5a91496692444 Mon Sep 17 00:00:00 2001
From: Anubhav Gupta <anubhav.gupta@digi.com>
Date: Thu, 11 May 2023 10:24:08 -0400
Subject: [PATCH] hostapd: Added file lock before acs scanning per phy

TX40 uses a Voxmicro (QCA6390) module which supports DBDC. If there are 2 AP's configured in DAL on different bands
with channel as auto, this causes 2 hostapd's to get started and collide trying to perform scan at the same time.
Added file locking such that each hostapd will wait for the lock before performing a scan. Voxmicro module has a single
phy but can runs 2 bands at the same time.
---
 src/ap/acs.c         | 53 +++++++++++++++++++++++++++++++++++++++++++-
 src/ap/acs.h         |  5 +++++
 src/ap/hostapd.c     |  1 +
 src/ap/hostapd.h     |  3 +++
 src/ap/hw_features.c |  2 ++
 5 files changed, 63 insertions(+), 1 deletion(-)

diff --git a/src/ap/acs.c b/src/ap/acs.c
index 0030edc2a..af9c75f92 100644
--- a/src/ap/acs.c
+++ b/src/ap/acs.c
@@ -9,6 +9,9 @@
 
 #include "utils/includes.h"
 #include <math.h>
+#include <sys/file.h>
+#include <fcntl.h>
+#include <stdlib.h>
 
 #include "utils/common.h"
 #include "utils/list.h"
@@ -246,6 +249,48 @@ static int acs_request_scan(struct hostapd_iface *iface);
 static int acs_survey_is_sufficient(struct freq_survey *survey);
 
 
+int get_lock(struct hostapd_iface *iface) {
+	int ret = -1;
+	char * lock_file = NULL;
+
+	if (iface->lockcnt == 0) {
+		if (asprintf(&lock_file, "/var/lock/hostapd_%s.lock", iface->phy) == -1)
+			goto out;
+
+		iface->lockfd = open(lock_file, O_RDWR|O_CREAT);
+		if (iface->lockfd == -1)
+			goto out;
+
+		int count = 0;
+		while (count <= 10) {
+			if (flock(iface->lockfd, LOCK_EX | LOCK_NB) == 0) {
+				wpa_printf(MSG_DEBUG, "ACS: Acquired file lock before scanning on %s", iface->phy);
+				iface->lockcnt++;
+				ret = 0;
+				goto out;
+			}
+
+			sleep(2);
+			count++;
+		}
+		close(iface->lockfd);
+		iface->lockfd = -1;
+	}
+
+	out:
+		free(lock_file);
+		return ret;
+}
+
+void release_lock(struct hostapd_iface *iface) {
+	if (--iface->lockcnt == 0) {
+		wpa_printf(MSG_DEBUG, "ACS: Released file lock after scanning on %s", iface->phy);
+		flock(iface->lockfd, LOCK_UN);
+		close(iface->lockfd);
+		iface->lockfd = -1;
+	}
+}
+
 static void acs_clean_chan_surveys(struct hostapd_channel_data *chan)
 {
 	struct freq_survey *survey, *tmp;
@@ -254,7 +299,7 @@ static void acs_clean_chan_surveys(struct hostapd_channel_data *chan)
 		return;
 
 	dl_list_for_each_safe(survey, tmp, &chan->survey_list,
-			      struct freq_survey, list) {
+						struct freq_survey, list) {
 		dl_list_del(&survey->list);
 		os_free(survey);
 	}
@@ -1109,6 +1154,7 @@ static int acs_request_scan(struct hostapd_iface *iface)
 		wpa_printf(MSG_ERROR, "ACS: Failed to request initial scan");
 		acs_cleanup(iface);
 		os_free(params.freqs);
+		release_lock(iface);
 		return -1;
 	}
 
@@ -1134,6 +1180,11 @@ enum hostapd_chan_status acs_init(struct hostapd_iface *iface)
 
 	acs_cleanup(iface);
 
+	if (get_lock(iface) != 0) {
+		wpa_printf(MSG_ERROR, "ACS: Failed to acquire file lock before scanning on %s", iface->phy);
+		return HOSTAPD_CHAN_INVALID;
+	}
+
 	if (acs_request_scan(iface) < 0)
 		return HOSTAPD_CHAN_INVALID;
 
diff --git a/src/ap/acs.h b/src/ap/acs.h
index ec84f0ee9..9a13c19df 100644
--- a/src/ap/acs.h
+++ b/src/ap/acs.h
@@ -14,6 +14,7 @@
 
 enum hostapd_chan_status acs_init(struct hostapd_iface *iface);
 void acs_cleanup(struct hostapd_iface *iface);
+void release_lock(struct hostapd_iface *iface);
 
 #else /* CONFIG_ACS */
 
@@ -27,6 +28,10 @@ static inline void acs_cleanup(struct hostapd_iface *iface)
 {
 }
 
+static inline void release_lock(struct hostapd_iface *iface)
+{
+}
+
 #endif /* CONFIG_ACS */
 
 #endif /* ACS_H */
diff --git a/src/ap/hostapd.c b/src/ap/hostapd.c
index 4b88641a2..f2d395084 100644
--- a/src/ap/hostapd.c
+++ b/src/ap/hostapd.c
@@ -2492,6 +2492,7 @@ struct hostapd_iface * hostapd_init(struct hapd_interfaces *interfaces,
 	if (hapd_iface == NULL)
 		goto fail;
 
+	hapd_iface->lockfd = -1;
 	hapd_iface->config_fname = os_strdup(config_file);
 	if (hapd_iface->config_fname == NULL)
 		goto fail;
diff --git a/src/ap/hostapd.h b/src/ap/hostapd.h
index f3ca7529a..ee8d9de86 100644
--- a/src/ap/hostapd.h
+++ b/src/ap/hostapd.h
@@ -452,6 +452,9 @@ struct hostapd_iface {
 	struct hostapd_config *conf;
 	char phy[16]; /* Name of the PHY (radio) */
 
+	int lockfd;	/* Lock file descriptor */
+	unsigned int lockcnt; /* Lock count */
+
 	enum hostapd_iface_state {
 		HAPD_IFACE_UNINITIALIZED,
 		HAPD_IFACE_DISABLED,
diff --git a/src/ap/hw_features.c b/src/ap/hw_features.c
index 4b66b02f4..6e61738a3 100644
--- a/src/ap/hw_features.c
+++ b/src/ap/hw_features.c
@@ -1061,11 +1061,13 @@ int hostapd_acs_completed(struct hostapd_iface *iface, int err)
 		goto out;
 	if (ret == 1) {
 		wpa_printf(MSG_DEBUG, "Interface initialization will be completed in a callback");
+		release_lock(iface);
 		return 0;
 	}
 
 	ret = 0;
 out:
+	release_lock(iface);
 	return hostapd_setup_interface_complete(iface, ret);
 }
 
-- 
2.34.1

