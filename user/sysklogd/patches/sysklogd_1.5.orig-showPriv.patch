diff -Naur sysklogd-1.5.origin/Makefile sysklogd-1.5/Makefile
--- sysklogd-1.5.origin/Makefile	2016-09-16 14:58:13.812544439 +1000
+++ sysklogd-1.5/Makefile	2016-09-16 15:38:37.315807685 +1000
@@ -20,7 +20,7 @@
 CC= gcc
 #SKFLAGS= -g -DSYSV -Wall
 #LDFLAGS= -g
-SKFLAGS= $(RPM_OPT_FLAGS) -O3 -DSYSV -fomit-frame-pointer -Wall -fno-strength-reduce
+SKFLAGS= $(RPM_OPT_FLAGS) $(CFLAGS) -O3 -DSYSV -fomit-frame-pointer -Wall -fno-strength-reduce
 # -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE
 # -D_FILE_OFFSET_BITS=64 -D_LARGEFILE64_SOURCE
 # $(shell getconf LFS_SKFLAGS)
@@ -120,7 +120,7 @@
 	${CC} ${SKFLAGS} -DTEST -o ksym_test.o -c ksym.c
 
 clean:
-	rm -f *.o *.log *~ *.orig
+	rm -f *.o *.log *~ *.orig *.rej
 	rm -f *.ko oops.mod.* Module.symvers
 
 clobber: clean
diff -Naur sysklogd-1.5.origin/syslogd.c sysklogd-1.5/syslogd.c
--- sysklogd-1.5.origin/syslogd.c	2016-09-16 14:58:13.812544439 +1000
+++ sysklogd-1.5/syslogd.c	2016-09-16 15:34:02.070048627 +1000
@@ -25,6 +25,19 @@
 static char sccsid[] = "@(#)syslogd.c	5.27 (Berkeley) 10/10/88";
 #endif /* not lint */
 
+
+#define CONSOLE_PRINT(s, ...) { \
+FILE *fp = fopen(_PATH_CONSOLE, "w"); \
+	if (fp) { \
+			fprintf(fp, s, ##__VA_ARG__); \
+			fclose(fp); \
+	} \
+}
+
+
+
+
+
 /*
  *  syslogd -- log system messages
  *
@@ -678,6 +691,7 @@
 	char	f_prevline[MAXSVLINE];		/* last message logged */
 	char	f_lasttime[16];			/* time of last occurrence */
 	char	f_prevhost[MAXHOSTNAMELEN+1];	/* host from which recd. */
+	int f_prevfac;			/* fac of f_prevline */
 	int	f_prevpri;			/* pri of f_prevline */
 	int	f_prevlen;			/* length of f_prevline */
 	int	f_prevcount;			/* repetition cnt of prevline */
@@ -1592,6 +1606,9 @@
  * the priority.
  */
 
+
+
+
 void logmsg(pri, msg, from, flags)
 	int pri;
 	char *msg;
@@ -1623,7 +1640,7 @@
 #endif
 #endif
 
-	/*
+	/*/
 	 * Check to see if msg looks non-standard.
 	 *
 	 * A message looks like
@@ -1648,6 +1665,7 @@
 	fac = LOG_FAC(pri);
 	prilev = LOG_PRI(pri);
 
+
 	/* log the message to the particular outputs */
 	if (!Initialized) {
 		f = &consfile;
@@ -1690,6 +1708,7 @@
 		/*
 		 * suppress duplicate lines to this file
 		 */
+
 		if ((flags & MARK) == 0 && msglen == f->f_prevlen &&
 		    !strcmp(msg, f->f_prevline) &&
 		    !strcmp(from, f->f_prevhost)) {
@@ -1741,12 +1760,16 @@
 #endif
 
 void fprintlog(f, from, flags, msg)
-	register struct filed *f;
-	char *from;
-	int flags;
-	char *msg;
+	register struct filed *f;	// File handle
+	char *from;								//
+	int flags;								// Flags (defined at the beginning) to add/rm features
+	char *msg;								// Message content
 {
+#ifdef LOG_PRIORITY
+	struct iovec iov[7];
+#else
 	struct iovec iov[6];
+#endif
 	register struct iovec *v = iov;
 	char repbuf[80];
 #ifdef SYSLOG_INET
@@ -1758,6 +1778,17 @@
 
 	dprintf("Called fprintlog, ");
 
+
+#ifdef LOG_PRIORITY
+	{
+		char tempCode[11] = "";
+		sprintf(tempCode, "[F%02d:P%02d] ", LOG_FAC(f->f_prevpri), LOG_PRI(f->f_prevpri));
+		v->iov_base = tempCode;			// Facility code, see uClibc/include/sys/syslog.h for details
+		v->iov_len = 10;
+		v++;
+	}
+#endif
+
 	v->iov_base = f->f_lasttime;
 	v->iov_len = 15;
 	v++;
@@ -1770,6 +1807,7 @@
 	v->iov_base = " ";
 	v->iov_len = 1;
 	v++;
+
 	if (msg) {
 		v->iov_base = msg;
 		v->iov_len = strlen(msg);
@@ -1848,7 +1886,7 @@
 	case F_FORW:
 		/* 
 		 * Don't send any message to a remote host if it
-		 * already comes from one. (we don't care 'bout who
+		 * already comes from one. (we don't care about who
 		 * sent the message, we don't send it anyway)  -Joey
 		 */
 	f_forw:
@@ -1881,85 +1919,89 @@
 #ifdef UNIXPC
 		if (1) {
 #else
-		if (flags & IGN_CONS) {	
+			if (flags & IGN_CONS) {	
 #endif
-			dprintf(" (ignored).\n");
-			break;
-		}
-		/* FALLTHROUGH */
+				dprintf(" (ignored).\n");
+				break;
+			}
+			/* FALLTHROUGH */
 
-	case F_TTY:
-	case F_FILE:
-	case F_PIPE:
-		f->f_time = now;
-		dprintf(" %s\n", f->f_un.f_fname);
-		if (f->f_type == F_TTY || f->f_type == F_CONSOLE) {
-			v->iov_base = "\r\n";
-			v->iov_len = 2;
-		} else {
-			v->iov_base = "\n";
-			v->iov_len = 1;
-		}
-	again:
-		/* f->f_file == -1 is an indicator that we couldn't
-		   open the file at startup. */
-		if (f->f_file == -1)
-			break;
+		case F_TTY:
+		case F_FILE:
+		case F_PIPE:
+			f->f_time = now;
+			dprintf(" %s\n", f->f_un.f_fname);
+			if (f->f_type == F_TTY || f->f_type == F_CONSOLE) {
+				v->iov_base = "\r\n";
+				v->iov_len = 2;
+			} else {
+				v->iov_base = "\n";
+				v->iov_len = 1;
+			}
+		again:
+			/* f->f_file == -1 is an indicator that we couldn't
+				 open the file at startup. */
+			if (f->f_file == -1)
+				break;
 
-		if (writev(f->f_file, iov, 6) < 0) {
-			int e = errno;
+#ifdef LOG_PRIORITY
+			if (writev(f->f_file, iov, 7) < 0) {
+#else
+			if (writev(f->f_file, iov, 6) < 0) {
+#endif
+				int e = errno;
 
-			/* If a named pipe is full, just ignore it for now */
-			if (f->f_type == F_PIPE && e == EAGAIN)
-				break;
+				/* If a named pipe is full, just ignore it for now */
+				if (f->f_type == F_PIPE && e == EAGAIN)
+					break;
 
-			/* If the filesystem is filled up, just ignore
-			   it for now and continue writing when
-			   possible */
-			if (f->f_type == F_FILE && e == ENOSPC)
-				break;
+				/* If the filesystem is filled up, just ignore
+					 it for now and continue writing when
+					 possible */
+				if (f->f_type == F_FILE && e == ENOSPC)
+					break;
 
-			(void) close(f->f_file);
-			/*
-			 * Check for EBADF on TTY's due to vhangup() XXX
-			 * Linux uses EIO instead (mrn 12 May 96)
-			 */
-			if ((f->f_type == F_TTY || f->f_type == F_CONSOLE)
+				(void) close(f->f_file);
+				/*
+				 * Check for EBADF on TTY's due to vhangup() XXX
+				 * Linux uses EIO instead (mrn 12 May 96)
+				 */
+				if ((f->f_type == F_TTY || f->f_type == F_CONSOLE)
 #ifdef linux
-				&& e == EIO) {
+					&& e == EIO) {
 #else
-				&& e == EBADF) {
+					&& e == EBADF) {
 #endif
-				f->f_file = open(f->f_un.f_fname, O_WRONLY|O_APPEND|O_NOCTTY);
-				if (f->f_file < 0) {
+					f->f_file = open(f->f_un.f_fname, O_WRONLY|O_APPEND|O_NOCTTY);
+					if (f->f_file < 0) {
+						f->f_type = F_UNUSED;
+						logerror(f->f_un.f_fname);
+					} else {
+						untty();
+						goto again;
+					}
+				} else {
 					f->f_type = F_UNUSED;
+					errno = e;
 					logerror(f->f_un.f_fname);
-				} else {
-					untty();
-					goto again;
 				}
-			} else {
-				f->f_type = F_UNUSED;
-				errno = e;
-				logerror(f->f_un.f_fname);
-			}
-		} else if (f->f_type == F_FILE && (f->f_flags & SYNC_FILE))
-			(void) fsync(f->f_file);
-		break;
+			} else if (f->f_type == F_FILE && (f->f_flags & SYNC_FILE))
+				(void) fsync(f->f_file);
+			break;
 
-	case F_USERS:
-	case F_WALL:
-		f->f_time = now;
-		dprintf("\n");
-		v->iov_base = "\r\n";
-		v->iov_len = 2;
-		wallmsg(f, iov);
-		break;
-	} /* switch */
-	if (f->f_type != F_FORW_UNKN)
-		f->f_prevcount = 0;
-	return;		
-}
+		case F_USERS:
+		case F_WALL:
+			f->f_time = now;
+			dprintf("\n");
+			v->iov_base = "\r\n";
+			v->iov_len = 2;
+			wallmsg(f, iov);
+			break;
+		} /* switch */
+		if (f->f_type != F_FORW_UNKN)
+			f->f_prevcount = 0;
+		return;		
+	}
 #if FALSE
 }} /* balance parentheses for emacs */
 #endif
@@ -2590,13 +2632,12 @@
 		else {
 			ignorepri = 0;
 		}
-		if ( *buf == '=' )
-		{
+		if ( *buf == '=' ) {
 			singlpri = 1;
 			pri = decode(&buf[1], PriNames);
 		}
 		else {
-		        singlpri = 0;
+		  singlpri = 0;
 			pri = decode(buf, PriNames);
 		}
 
