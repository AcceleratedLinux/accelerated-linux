From ebbf62aad2887042921a9b1509604fb664f3843c Mon Sep 17 00:00:00 2001
From: David McCullough <David.McCullough@digi.com>
Date: Tue, 25 Jan 2022 16:43:26 +0100
Subject: [PATCH 03/10] Add uclibc and generic DAL support

---
 clientloop.c  |  8 ++++++
 config.sub    |  4 +++
 pathnames.h   | 11 +++++++-
 readconf.c    |  2 +-
 readpass.c    |  9 +++++++
 scp.c         |  8 ++++++
 session.c     | 69 +++++++++++++++++++++++++++++++++++++++++++++++----
 ssh.c         |  8 ++++--
 ssh.h         |  3 +++
 ssh_config    |  6 +++++
 sshconnect.c  |  8 ++++++
 sshconnect2.c |  9 +++++++
 sshd.c        | 42 +++++++++++++++++++++++++++++++
 13 files changed, 178 insertions(+), 9 deletions(-)

diff --git a/clientloop.c b/clientloop.c
index da14d15..5d71a81 100644
--- a/clientloop.c
+++ b/clientloop.c
@@ -1069,14 +1069,22 @@ process_escapes(struct ssh *ssh, Channel *c,
 					fatal_fr(r, "sshbuf_putf");
 
 				/* Fork into background. */
+#ifdef __uClinux__
+				pid = vfork();
+#else
 				pid = fork();
+#endif
 				if (pid == -1) {
 					error("fork: %.100s", strerror(errno));
 					continue;
 				}
 				if (pid != 0) {	/* This is the parent. */
 					/* The parent just exits. */
+#ifdef __uClinux__
+					_exit(0);
+#else
 					exit(0);
+#endif
 				}
 				/* The child continues serving connections. */
 				/* fake EOF on stdin */
diff --git a/config.sub b/config.sub
index 973a298..0277611 100755
--- a/config.sub
+++ b/config.sub
@@ -313,6 +313,10 @@ case $1 in
 				basic_machine=m68k-ericsson
 				os=ose
 				;;
+			nios2 | nios2-* | nios2 | nios2-*)
+				basic_machine=nios2-altera
+				os=-linux
+				;;
 			gmicro)
 				basic_machine=tron-gmicro
 				os=sysv
diff --git a/pathnames.h b/pathnames.h
index f7ca5a7..cf174af 100644
--- a/pathnames.h
+++ b/pathnames.h
@@ -12,7 +12,16 @@
  * called by a name other than "ssh" or "Secure Shell".
  */
 
+#include <config/autoconf.h>
+
+#ifdef CONFIG_USER_FLATFSD_ETC_CONFIG
+#define ETCDIR				"/etc/config"
+#define SSHDIR				ETCDIR ""
+#endif
+
+#ifndef ETCDIR
 #define ETCDIR				"/etc"
+#endif
 
 #ifndef SSHDIR
 #define SSHDIR				ETCDIR "/ssh"
@@ -44,7 +53,7 @@
 #define _PATH_DH_MODULI			SSHDIR "/moduli"
 
 #ifndef _PATH_SSH_PROGRAM
-#define _PATH_SSH_PROGRAM		"/usr/bin/ssh"
+#define _PATH_SSH_PROGRAM		"/bin/ssh"
 #endif
 
 /*
diff --git a/readconf.c b/readconf.c
index 9c1c12f..e1d4b55 100644
--- a/readconf.c
+++ b/readconf.c
@@ -2536,7 +2536,7 @@ fill_default_options(Options * options)
 		add_identity_file(options, "~/", _PATH_SSH_CLIENT_ID_XMSS, 0);
 	}
 	if (options->escape_char == -1)
-		options->escape_char = '~';
+		options->escape_char = SSH_ESCAPECHAR_DEFAULT;
 	if (options->num_system_hostfiles == 0) {
 		options->system_hostfiles[options->num_system_hostfiles++] =
 		    xstrdup(_PATH_SSH_SYSTEM_HOSTFILE);
diff --git a/readpass.c b/readpass.c
index 39af25c..18065b3 100644
--- a/readpass.c
+++ b/readpass.c
@@ -66,7 +66,11 @@ ssh_askpass(char *askpass, const char *msg, const char *env_hint)
 		return NULL;
 	}
 	osigchld = ssh_signal(SIGCHLD, SIG_DFL);
+#ifdef __uClinux__
+	if ((pid = vfork()) == -1) {
+#else
 	if ((pid = fork()) == -1) {
+#endif
 		error_f("fork: %s", strerror(errno));
 		ssh_signal(SIGCHLD, osigchld);
 		return NULL;
@@ -79,6 +83,11 @@ ssh_askpass(char *askpass, const char *msg, const char *env_hint)
 			setenv("SSH_ASKPASS_PROMPT", env_hint, 1);
 		execlp(askpass, askpass, msg, (char *)NULL);
 		fatal_f("exec(%s): %s", askpass, strerror(errno));
+#ifdef __uClinux__
+		_exit(0);
+#else
+		exit(0);
+#endif
 	}
 	close(p[1]);
 
diff --git a/scp.c b/scp.c
index 73ce855..428bc7d 100644
--- a/scp.c
+++ b/scp.c
@@ -304,7 +304,11 @@ do_cmd(char *program, char *host, char *remuser, int port, int subsystem,
 	ssh_signal(SIGTTOU, suspchild);
 
 	/* Fork a child to execute the command on the remote host using ssh. */
+#ifdef __uClinux__
+	*pid = vfork();
+#else
 	*pid = fork();
+#endif
 	if (*pid == 0) {
 		/* Child. */
 		close(pin[1]);
@@ -389,7 +393,11 @@ do_cmd2(char *host, char *remuser, int port, char *cmd,
 
 		execvp(ssh_program, args.list);
 		perror(ssh_program);
+#ifdef __uClinux__
+		_exit(1);
+#else
 		exit(1);
+#endif
 	} else if (pid == -1) {
 		fatal("fork: %s", strerror(errno));
 	}
diff --git a/session.c b/session.c
index 5f423f9..b3b36f5 100644
--- a/session.c
+++ b/session.c
@@ -101,6 +101,10 @@
 #include <kafs.h>
 #endif
 
+#ifdef EMBED
+# include <syslog.h>
+#endif	/* EMBED */
+
 #ifdef WITH_SELINUX
 #include <selinux/selinux.h>
 #endif
@@ -437,7 +441,11 @@ do_exec_no_pty(struct ssh *ssh, Session *s, const char *command)
 	session_proctitle(s);
 
 	/* Fork the child. */
+#ifdef __uClinux__
+	switch ((pid = vfork())) {
+#else
 	switch ((pid = fork())) {
+#endif
 	case -1:
 		error_f("fork: %.100s", strerror(errno));
 #ifdef USE_PIPES
@@ -506,6 +514,11 @@ do_exec_no_pty(struct ssh *ssh, Session *s, const char *command)
 		/* Do processing for the child (exec command etc). */
 		do_child(ssh, s, command);
 		/* NOTREACHED */
+#ifdef __uClinux__
+		_exit(0);
+#else
+		exit(0);
+#endif
 	default:
 		break;
 	}
@@ -559,12 +572,14 @@ int
 do_exec_pty(struct ssh *ssh, Session *s, const char *command)
 {
 	int fdout, ptyfd, ttyfd, ptymaster;
+	int tfd;
 	pid_t pid;
 
 	if (s == NULL)
 		fatal("do_exec_pty: no session");
 	ptyfd = s->ptyfd;
 	ttyfd = s->ttyfd;
+	tfd = ttyfd;
 
 	/*
 	 * Create another descriptor of the pty master side for use as the
@@ -589,7 +604,11 @@ do_exec_pty(struct ssh *ssh, Session *s, const char *command)
 	}
 
 	/* Fork the child. */
+#ifdef __uClinux__
+	switch ((pid = vfork())) {
+#else
 	switch ((pid = fork())) {
+#endif
 	case -1:
 		error_f("fork: %.100s", strerror(errno));
 		close(fdout);
@@ -607,18 +626,19 @@ do_exec_pty(struct ssh *ssh, Session *s, const char *command)
 		close(ptyfd);
 
 		/* Make the pseudo tty our controlling tty. */
-		pty_make_controlling_tty(&ttyfd, s->tty);
+		pty_make_controlling_tty(&tfd, s->tty);
 
 		/* Redirect stdin/stdout/stderr from the pseudo tty. */
-		if (dup2(ttyfd, 0) == -1)
+		if (dup2(tfd, 0) == -1)
 			error("dup2 stdin: %s", strerror(errno));
-		if (dup2(ttyfd, 1) == -1)
+		if (dup2(tfd, 1) == -1)
 			error("dup2 stdout: %s", strerror(errno));
-		if (dup2(ttyfd, 2) == -1)
+		if (dup2(tfd, 2) == -1)
 			error("dup2 stderr: %s", strerror(errno));
 
 		/* Close the extra descriptor for the pseudo tty. */
-		close(ttyfd);
+		if (tfd > 2)
+			close(tfd);
 
 		/* record login, etc. similar to login(1) */
 #ifndef HAVE_OSF_SIA
@@ -1491,7 +1511,9 @@ child_close_fds(struct ssh *ssh)
 	 * Close any extra file descriptors.  Note that there may still be
 	 * descriptors left by system functions.  They will be closed later.
 	 */
+#ifndef __uClinux__
 	endpwent();
+#endif
 
 	/* Stop directing logs to a high-numbered fd before we close it */
 	log_redirect_stderr_to(NULL);
@@ -1523,7 +1545,9 @@ do_child(struct ssh *ssh, Session *s, const char *command)
 	sshpkt_fmt_connection_id(ssh, remote_id, sizeof(remote_id));
 
 	/* remove hostkey from the child's memory */
+#ifndef __uClinux__
 	destroy_sensitive_data();
+#endif
 	ssh_packet_clear_keys(ssh);
 
 	/* Force a password change */
@@ -1531,7 +1555,11 @@ do_child(struct ssh *ssh, Session *s, const char *command)
 		do_setusercontext(pw);
 		child_close_fds(ssh);
 		do_pwchange(s);
+#ifdef __uClinux__
+		_exit(1);
+#else
 		exit(1);
+#endif
 	}
 
 	/*
@@ -1560,7 +1588,11 @@ do_child(struct ssh *ssh, Session *s, const char *command)
 	if (options.use_pam && !is_pam_session_open()) {
 		debug3("PAM session not opened, exiting");
 		display_loginmsg();
+#ifdef __uClinux__
+		_exit(254);
+#else
 		exit(254);
+#endif
 	}
 #endif
 
@@ -1633,7 +1665,11 @@ do_child(struct ssh *ssh, Session *s, const char *command)
 			    strerror(errno));
 		}
 		if (r)
+#ifdef __uClinux__
+			_exit(1);
+#else
 			exit(1);
+#endif
 	}
 
 	closefrom(STDERR_FILENO + 1);
@@ -1665,7 +1701,11 @@ do_child(struct ssh *ssh, Session *s, const char *command)
 #ifdef WITH_SELINUX
 		ssh_selinux_change_context("sftpd_t");
 #endif
+#ifdef __uClinux__
+		_exit(sftp_server_main(i, argv, s->pw));
+#else
 		exit(sftp_server_main(i, argv, s->pw));
+#endif
 	}
 
 	fflush(NULL);
@@ -1691,7 +1731,11 @@ do_child(struct ssh *ssh, Session *s, const char *command)
 		    >= sizeof(argv0) - 1) {
 			errno = EINVAL;
 			perror(shell);
+#ifdef __uClinux__
+			_exit(1);
+#else
 			exit(1);
+#endif
 		}
 
 		/* Execute the shell. */
@@ -1701,7 +1745,11 @@ do_child(struct ssh *ssh, Session *s, const char *command)
 
 		/* Executing the shell failed. */
 		perror(shell);
+#ifdef __uClinux__
+		_exit(1);
+#else
 		exit(1);
+#endif
 	}
 	/*
 	 * Execute the command using the user's shell.  This uses the -c
@@ -1713,7 +1761,11 @@ do_child(struct ssh *ssh, Session *s, const char *command)
 	argv[3] = NULL;
 	execve(shell, argv, env);
 	perror(shell);
+#ifdef __uClinux__
+	_exit(1);
+#else
 	exit(1);
+#endif
 }
 
 void
@@ -1941,8 +1993,15 @@ session_pty_req(struct ssh *ssh, Session *s)
 	if ((r = sshpkt_get_end(ssh)) != 0)
 		sshpkt_fatal(ssh, r, "%s: parse packet", __func__);
 
+#ifndef EMBED
 	if (!use_privsep)
 		pty_setowner(s->pw, s->tty);
+#else
+	syslog(LOG_ALERT,
+			"WARNING: "
+			"currently everything is run as root on an embedded system "
+			":WARNING");
+#endif
 
 	/* Set window size from the packet. */
 	pty_change_window_size(s->ptyfd, s->row, s->col, s->xpixel, s->ypixel);
diff --git a/ssh.c b/ssh.c
index e799630..11aea5d 100644
--- a/ssh.c
+++ b/ssh.c
@@ -1757,7 +1757,9 @@ fork_postauth(void)
 		control_persist_detach();
 	debug("forking to background");
 	options.fork_after_authentication = 0;
+#ifndef __uClinux__
 	if (daemon(1, 1) == -1)
+#endif
 		fatal("daemon() failed: %.200s", strerror(errno));
 	if (stdfd_devnull(1, 1, !(log_is_on_stderr() && debug_flag)) == -1)
 		error_f("stdfd_devnull failed");
@@ -2210,8 +2212,10 @@ ssh_session2(struct ssh *ssh, const struct ssh_conn_info *cinfo)
 			fork_postauth();
 	}
 
-	return client_loop(ssh, tty_flag, tty_flag ?
-	    options.escape_char : SSH_ESCAPECHAR_NONE, id);
+	return client_loop(ssh, tty_flag,
+	    options.escape_char == SSH_ESCAPECHAR_DEFAULT
+	    ? (tty_flag ? '~' : SSH_ESCAPECHAR_NONE)
+	    : options.escape_char, id);
 }
 
 /* Loads all IdentityFile and CertificateFile keys */
diff --git a/ssh.h b/ssh.h
index 8110c06..fcd7617 100644
--- a/ssh.h
+++ b/ssh.h
@@ -87,6 +87,9 @@
 /* Used to identify ``EscapeChar none'' */
 #define SSH_ESCAPECHAR_NONE		-2
 
+/* Use default, which could be ~ or none (based on tty presence) */
+#define SSH_ESCAPECHAR_DEFAULT		-3
+
 /*
  * unprivileged user when UsePrivilegeSeparation=yes;
  * sshd will change its privileges to this user and its
diff --git a/ssh_config b/ssh_config
index 842ea86..b62fa9c 100644
--- a/ssh_config
+++ b/ssh_config
@@ -44,3 +44,9 @@
 #   ProxyCommand ssh -q -W %h:%p gateway.example.com
 #   RekeyLimit 1G 1h
 #   UserKnownHostsFile ~/.ssh/known_hosts.d/%k
+
+IdentityFile /etc/config/identity
+IdentityFile /etc/config/id_rsa
+IdentityFile /etc/config/id_dsa
+
+GlobalKnownHostsFile /etc/config/ssh_known_hosts                   
diff --git a/sshconnect.c b/sshconnect.c
index fcf87bb..35cf6bf 100644
--- a/sshconnect.c
+++ b/sshconnect.c
@@ -214,7 +214,11 @@ ssh_proxy_connect(struct ssh *ssh, const char *host, const char *host_arg,
 	debug("Executing proxy command: %.500s", command_string);
 
 	/* Fork and execute the proxy command. */
+#ifdef __uClinux__
+	if ((pid = vfork()) == 0) {
+#else
 	if ((pid = fork()) == 0) {
+#endif
 		char *argv[10];
 
 		/* Redirect stdin and stdout. */
@@ -250,7 +254,11 @@ ssh_proxy_connect(struct ssh *ssh, const char *host, const char *host_arg,
 		ssh_signal(SIGPIPE, SIG_DFL);
 		execv(argv[0], argv);
 		perror(argv[0]);
+#ifdef __uClinux__
+		_exit(1);
+#else
 		exit(1);
+#endif
 	}
 	/* Parent. */
 	if (pid == -1)
diff --git a/sshconnect2.c b/sshconnect2.c
index a0efb6e..cd335ff 100644
--- a/sshconnect2.c
+++ b/sshconnect2.c
@@ -2020,7 +2020,11 @@ ssh_keysign(struct ssh *ssh, struct sshkey *key, u_char **sigp, size_t *lenp,
 		error_f("pipe: %s", strerror(errno));
 		return -1;
 	}
+#ifdef __uClinux__
+	if ((pid = vfork()) == -1) {
+#else
 	if ((pid = fork()) == -1) {
+#endif
 		error_f("fork: %s", strerror(errno));
 		return -1;
 	}
@@ -2046,6 +2050,11 @@ ssh_keysign(struct ssh *ssh, struct sshkey *key, u_char **sigp, size_t *lenp,
 		execl(_PATH_SSH_KEY_SIGN, _PATH_SSH_KEY_SIGN, (char *)NULL);
 		fatal_f("exec(%s): %s", _PATH_SSH_KEY_SIGN,
 		    strerror(errno));
+#ifdef __uClinux__
+		_exit(0);
+#else
+		exit(0);
+#endif
 	}
 	close(from[1]);
 	close(to[0]);
diff --git a/sshd.c b/sshd.c
index 3b8a341..682bece 100644
--- a/sshd.c
+++ b/sshd.c
@@ -158,7 +158,11 @@ int debug_flag = 0;
 static int test_flag = 0;
 
 /* Flag indicating that the daemon is being started from inetd. */
+#ifdef __uClinux__
+static int inetd_flag = 1;
+#else
 static int inetd_flag = 0;
+#endif
 
 /* Flag indicating that sshd should not detach and become a daemon. */
 static int no_daemon_flag = 0;
@@ -477,6 +481,7 @@ privsep_preauth_child(void)
 static int
 privsep_preauth(struct ssh *ssh)
 {
+#ifndef __uClinux__
 	int status, r;
 	pid_t pid;
 	struct ssh_sandbox *box = NULL;
@@ -540,11 +545,16 @@ privsep_preauth(struct ssh *ssh)
 
 		return 0;
 	}
+#endif
 }
 
 static void
 privsep_postauth(struct ssh *ssh, Authctxt *authctxt)
 {
+#ifdef __uClinux__
+	fatal("vfork of unprivileged child failed");
+#endif
+
 #ifdef DISABLE_FD_PASSING
 	if (1) {
 #else
@@ -558,7 +568,11 @@ privsep_postauth(struct ssh *ssh, Authctxt *authctxt)
 	/* New socket pair */
 	monitor_reinit(pmonitor);
 
+#ifdef __uClinux__
+	pmonitor->m_pid = vfork();
+#else
 	pmonitor->m_pid = fork();
+#endif
 	if (pmonitor->m_pid == -1)
 		fatal("fork of unprivileged child failed");
 	else if (pmonitor->m_pid != 0) {
@@ -568,7 +582,11 @@ privsep_postauth(struct ssh *ssh, Authctxt *authctxt)
 		monitor_child_postauth(ssh, pmonitor);
 
 		/* NEVERREACHED */
+#ifdef __uClinux__
+		_exit(0);
+#else
 		exit(0);
+#endif
 	}
 
 	/* child */
@@ -1105,6 +1123,7 @@ listen_on_addrs(struct listenaddr *la)
 static void
 server_listen(void)
 {
+#ifndef __uClinux__
 	u_int i;
 
 	/* Initialise per-source limit tracking. */
@@ -1124,6 +1143,7 @@ server_listen(void)
 
 	if (!num_listen_socks)
 		fatal("Cannot bind any address.");
+#endif /*!__uClinux__*/
 }
 
 /*
@@ -1766,6 +1786,10 @@ main(int ac, char **av)
 	/* Fill in default values for those options not explicitly set. */
 	fill_default_server_options(&options);
 
+#ifdef __uClinux__
+	use_privsep = 0;
+#endif
+
 	/* Check that options are sensible */
 	if (options.authorized_keys_command_user == NULL &&
 	    (options.authorized_keys_command != NULL &&
@@ -2037,8 +2061,12 @@ main(int ac, char **av)
 	already_daemon = daemonized();
 	if (!(debug_flag || inetd_flag || no_daemon_flag || already_daemon)) {
 
+#ifndef __uClinux__
 		if (daemon(0, 0) == -1)
 			fatal("daemon() failed: %.200s", strerror(errno));
+#else
+		fatal("Cannot use daemon() under uClinux");
+#endif
 
 		disconnect_controlling_tty();
 	}
@@ -2059,9 +2087,14 @@ main(int ac, char **av)
 	ssh_signal(SIGPIPE, SIG_IGN);
 
 	/* Get a connection, either from inetd or a listening TCP socket */
+#ifndef __uClinux__
 	if (inetd_flag) {
+#else
+	if (1) {
+#endif /*!__uClinux__*/
 		server_accept_inetd(&sock_in, &sock_out);
 	} else {
+#ifndef __uClinux__
 		platform_pre_listen();
 		server_listen();
 
@@ -2089,6 +2122,7 @@ main(int ac, char **av)
 		/* Accept a connection and return in a forked child */
 		server_accept_loop(&sock_in, &sock_out,
 		    &newsock, config_s);
+#endif /*!__uClinux__*/
 	}
 
 	/* This is the child processing a new connection. */
@@ -2337,7 +2371,11 @@ main(int ac, char **av)
 	if (use_privsep)
 		mm_terminate();
 
+#ifdef __uClinux__
+	_exit(0);
+#else
 	exit(0);
+#endif
 }
 
 int
@@ -2461,5 +2499,9 @@ cleanup_exit(int i)
 	if (the_active_state != NULL && (!use_privsep || mm_is_monitor()))
 		audit_event(the_active_state, SSH_CONNECTION_ABANDON);
 #endif
+#ifdef __uClinux__
 	_exit(i);
+#else
+	exit(i);
+#endif
 }
-- 
2.30.2

