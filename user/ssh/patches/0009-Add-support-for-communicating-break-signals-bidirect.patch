From 67c83883a9e7349ee1d3992ac67d5bbdab976f70 Mon Sep 17 00:00:00 2001
From: Paul Ostebee <paul.ostebee@digi.com>
Date: Tue, 25 Jan 2022 21:48:33 +0100
Subject: [PATCH 09/10] Add support for communicating  break signals
 bidirectionally

Tunnelling serial communications requires us to be able to send and
receive break requests. This patch adds a new option
"bidirectionalbreak" to both ssh and sshd. When enabled break requests
will generate \377\0 as output and any literal \377 bytes will be
escaped as \377\377. If no escape char is defined the sequence
\377\0 will send a break request to remote peer.
---
 Makefile.in    |  2 +-
 break-filter.c | 72 ++++++++++++++++++++++++++++++++++++++++++++++++++
 break-filter.h | 17 ++++++++++++
 channels.c     | 29 +++++++++++++++++++-
 channels.h     |  3 +++
 clientloop.c   | 20 ++++++++++++++
 readconf.c     | 10 +++++++
 readconf.h     |  2 ++
 servconf.c     | 11 ++++++++
 servconf.h     |  1 +
 session.c      | 19 ++++++++++---
 11 files changed, 181 insertions(+), 5 deletions(-)
 create mode 100644 break-filter.c
 create mode 100644 break-filter.h

diff --git a/Makefile.in b/Makefile.in
index f70e83e..30756fb 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -109,7 +109,7 @@ LIBSSH_OBJS=${LIBOPENSSH_OBJS} \
 	kexgexc.o kexgexs.o \
 	kexsntrup761x25519.o sntrup761.o kexgen.o \
 	sftp-realpath.o platform-pledge.o platform-tracing.o platform-misc.o \
-	sshbuf-io.o
+	sshbuf-io.o break-filter.o
 
 SKOBJS=	ssh-sk-client.o
 
diff --git a/break-filter.c b/break-filter.c
new file mode 100644
index 0000000..6a357aa
--- /dev/null
+++ b/break-filter.c
@@ -0,0 +1,72 @@
+#include "includes.h"
+
+#include "break-filter.h"
+#include "openbsd-compat/sys-queue.h"
+#include "channels.h"
+#include "sshbuf.h"
+#include "xmalloc.h"
+#include "packet.h"
+#include "log.h"
+#include "ssherr.h"
+
+struct break_sequence {
+	int escape_pending;
+	int break_pending;
+	size_t break_off;
+};
+
+char const break_sequence[] = {'\377','\0'};
+
+int
+simple_break_filter(struct ssh *ssh, struct Channel *c, char *buf, int len)
+{
+	int r, bytes = 0;
+	u_int i;
+	u_char ch;
+	int * escape_pending = c->filter_ctx == NULL ?
+	    NULL : (int *)c->filter_ctx;
+
+	if (escape_pending == NULL || len <= 0)
+		return (0);
+
+	for (i = 0; i < (u_int)len; i++) {
+		/* Get one character at a time. */
+		ch = buf[i];
+		if (*escape_pending) {
+			*escape_pending = 0;
+
+			switch (ch) {
+			case '\0':
+				channel_request_start(ssh, c->self, "break", 0);
+				if ((r = sshpkt_put_u32(ssh, 1000)) != 0 ||
+				    (r = sshpkt_send(ssh)) != 0)
+					fatal_fr(r, "send packet");
+				continue;
+			case (u_char)'\377':
+				if ((r = sshbuf_put_u8(c->input, (u_char)'\377')) != 0)
+					fatal_fr(r, "buffer error");
+				bytes++;
+				continue;
+			}
+		} else if (ch == (u_char)'\377') {
+			*escape_pending = 1;
+			continue;
+		}
+		if ((r = sshbuf_put_u8(c->input, ch)) != 0)
+			fatal_fr(r, "buffer error");
+		bytes++;
+	}
+	return bytes;
+}
+
+void
+break_filter_cleanup(struct ssh *ssh, int cid, void *ctx)
+{
+	free(ctx);
+}
+
+void *
+new_break_filter_ctx(void)
+{
+	return xcalloc(1, sizeof (int));
+}
diff --git a/break-filter.h b/break-filter.h
new file mode 100644
index 0000000..42a8ffa
--- /dev/null
+++ b/break-filter.h
@@ -0,0 +1,17 @@
+#ifndef BREAK_FILTER_H
+#define BREAK_FILTER_H
+
+#define BREAK_SEQ_LEN 2
+
+struct ssh;
+
+int
+simple_break_filter(struct ssh *ssh, struct Channel *c, char *buf, int len);
+
+void
+break_filter_cleanup(struct ssh *ssh, int cid, void *ctx);
+
+void *
+new_break_filter_ctx(void);
+
+#endif
diff --git a/channels.c b/channels.c
index 1c714c8..3b21659 100644
--- a/channels.c
+++ b/channels.c
@@ -2955,7 +2955,7 @@ int
 channel_input_data(int type, u_int32_t seq, struct ssh *ssh)
 {
 	const u_char *data;
-	size_t data_len, win_len;
+	size_t data_len, win_len, i, escaped = 0;
 	Channel *c = channel_from_packet_id(ssh, __func__, "data");
 	int r;
 
@@ -2977,6 +2977,14 @@ channel_input_data(int type, u_int32_t seq, struct ssh *ssh)
 	win_len = data_len;
 	if (c->datagram)
 		win_len += 4;  /* string length header */
+	else if (c->escaped) {
+		for (i = 0; i < data_len; i++) {
+			if (data[i] == (u_char)'\377') {
+				escaped++;
+				win_len++;
+			}
+		}
+	}
 
 	/*
 	 * The sending side reduces its window as it sends data, so we
@@ -3004,6 +3012,25 @@ channel_input_data(int type, u_int32_t seq, struct ssh *ssh)
 	if (c->datagram) {
 		if ((r = sshbuf_put_string(c->output, data, data_len)) != 0)
 			fatal_fr(r, "channel %i: append datagram", c->self);
+	} else if (c->escaped && escaped > 0) {
+		r = 0;
+		while (data_len > 0 && escaped > 0) {
+			const u_char ch = *data;
+
+			if (ch == '\377') {
+				r = sshbuf_put_u8(c->output, ch);
+				escaped--;
+			}
+			if (r != 0 || (r = sshbuf_put_u8(c->output, ch)) != 0)
+				fatal("%s: channel %d: append data: %s",
+			    __func__, c->self, ssh_err(r));
+
+			data_len--;
+			data++;
+		}
+		if (data_len)
+			if ((r = sshbuf_put(c->output, data, data_len)) != 0)
+				fatal_fr(r, "channel %i: append data", c->self);
 	} else if ((r = sshbuf_put(c->output, data, data_len)) != 0)
 		fatal_fr(r, "channel %i: append data", c->self);
 
diff --git a/channels.h b/channels.h
index 6bf86b0..71b6252 100644
--- a/channels.h
+++ b/channels.h
@@ -199,6 +199,9 @@ struct Channel {
 	void			*mux_ctx;
 	int			mux_pause;
 	int			mux_downstream_id;
+
+	/* \377 escaped as \377\377 */
+	int				escaped;
 };
 
 #define CHAN_EXTENDED_IGNORE		0
diff --git a/clientloop.c b/clientloop.c
index 5d71a81..ff3450c 100644
--- a/clientloop.c
+++ b/clientloop.c
@@ -111,6 +111,7 @@
 #include "msg.h"
 #include "ssherr.h"
 #include "hostfile.h"
+#include "break-filter.h"
 
 /* import options */
 extern Options options;
@@ -131,6 +132,8 @@ extern char *host;
  */
 extern char *forward_agent_sock_path;
 
+extern char const break_sequence[];
+
 /*
  * Flag to indicate that we have received a window change signal which has
  * not yet been processed.  This will cause a message indicating the new
@@ -1292,15 +1295,24 @@ client_loop(struct ssh *ssh, int have_pty, int escape_char_arg,
 
 	session_ident = ssh2_chan_id;
 	if (session_ident != -1) {
+		struct Channel * c = channel_lookup(ssh, session_ident);
+
 		if (escape_char_arg != SSH_ESCAPECHAR_NONE) {
 			channel_register_filter(ssh, session_ident,
 			    client_simple_escape_filter, NULL,
 			    client_filter_cleanup,
 			    client_new_escape_filter_ctx(
 			    escape_char_arg));
+		} else if (options.bidirectional_break) {
+			channel_register_filter(ssh, session_ident,
+				simple_break_filter, NULL,
+				break_filter_cleanup,
+			    new_break_filter_ctx());
 		}
 		channel_register_cleanup(ssh, session_ident,
 		    client_channel_closed, 0);
+
+		c->escaped = options.bidirectional_break;
 	}
 
 	schedule_server_alive_check();
@@ -1768,6 +1780,14 @@ client_input_channel_req(int type, u_int32_t seq, struct ssh *ssh)
 		}
 		if ((r = sshpkt_get_end(ssh)) != 0)
 			goto out;
+	} else if (c->escaped && strcmp(rtype, "break") == 0) {
+		if ((r = sshpkt_get_u32(ssh, NULL)) != 0 || /* ignore */
+	    	(r = sshpkt_get_end(ssh)) != 0)
+			sshpkt_fatal(ssh, r, "%s: parse packet", __func__);
+
+		if ((r = sshbuf_put(c->output, break_sequence, BREAK_SEQ_LEN)) != 0)
+			fatal_fr(r, "channel %i: append data", c->self);
+		success = 1;
 	}
 	if (reply && c != NULL && !(c->flags & CHAN_CLOSE_SENT)) {
 		if (!c->have_remote_id)
diff --git a/readconf.c b/readconf.c
index e1d4b55..69f5d4c 100644
--- a/readconf.c
+++ b/readconf.c
@@ -175,6 +175,7 @@ typedef enum {
 	oFingerprintHash, oUpdateHostkeys, oHostbasedAcceptedAlgorithms,
 	oPubkeyAcceptedAlgorithms, oCASignatureAlgorithms, oProxyJump,
 	oSecurityKeyProvider, oKnownHostsCommand,
+	oBidirectionalBreak,
 	oIgnore, oIgnoredUnknownOption, oDeprecated, oUnsupported
 } OpCodes;
 
@@ -320,6 +321,7 @@ static struct {
 	{ "proxyjump", oProxyJump },
 	{ "securitykeyprovider", oSecurityKeyProvider },
 	{ "knownhostscommand", oKnownHostsCommand },
+	{ "bidirectionalbreak", oBidirectionalBreak },
 
 	{ NULL, oBadOption }
 };
@@ -2182,6 +2184,10 @@ parse_pubkey_algos:
 			*charptr = xstrdup(arg);
 		break;
 
+	case oBidirectionalBreak:
+		intptr = &options->bidirectional_break;
+		goto parse_flag;
+
 	case oDeprecated:
 		debug("%s line %d: Deprecated option \"%s\"",
 		    filename, linenum, keyword);
@@ -2429,6 +2435,7 @@ initialize_options(Options * options)
 	options->hostbased_accepted_algos = NULL;
 	options->pubkey_accepted_algos = NULL;
 	options->known_hosts_command = NULL;
+	options->bidirectional_break = -1;
 }
 
 /*
@@ -2625,6 +2632,8 @@ fill_default_options(Options * options)
 	if (options->sk_provider == NULL)
 		options->sk_provider = xstrdup("$SSH_SK_PROVIDER");
 #endif
+	if (options->bidirectional_break == -1)
+		options->bidirectional_break = 0;
 
 	/* Expand KEX name lists */
 	all_cipher = cipher_alg_list(',', 0);
@@ -3304,6 +3313,7 @@ dump_client_config(Options *o, const char *host)
 	dump_cfg_fmtint(oVerifyHostKeyDNS, o->verify_host_key_dns);
 	dump_cfg_fmtint(oVisualHostKey, o->visual_host_key);
 	dump_cfg_fmtint(oUpdateHostkeys, o->update_hostkeys);
+	dump_cfg_fmtint(oBidirectionalBreak, o->bidirectional_break);
 
 	/* Integer options */
 	dump_cfg_int(oCanonicalizeMaxDots, o->canonicalize_max_dots);
diff --git a/readconf.h b/readconf.h
index f24719f..1288dd0 100644
--- a/readconf.h
+++ b/readconf.h
@@ -177,6 +177,8 @@ typedef struct {
 	char   *known_hosts_command;
 
 	char	*ignored_unknown; /* Pattern list of unknown tokens to ignore */
+
+	int bidirectional_break;
 }       Options;
 
 #define SSH_CANONICALISE_NO	0
diff --git a/servconf.c b/servconf.c
index 575b936..44580ad 100644
--- a/servconf.c
+++ b/servconf.c
@@ -196,6 +196,7 @@ initialize_server_options(ServerOptions *options)
 	options->fingerprint_hash = -1;
 	options->disable_forwarding = -1;
 	options->expose_userauth_info = -1;
+	options->bidirectional_break = -1;
 }
 
 /* Returns 1 if a string option is unset or set to "none" or 0 otherwise. */
@@ -442,6 +443,8 @@ fill_default_server_options(ServerOptions *options)
 		options->expose_userauth_info = 0;
 	if (options->sk_provider == NULL)
 		options->sk_provider = xstrdup("internal");
+	if (options->bidirectional_break == -1)
+		options->bidirectional_break = 0;
 
 	assemble_algorithms(options);
 
@@ -519,6 +522,7 @@ typedef enum {
 	sAllowStreamLocalForwarding, sFingerprintHash, sDisableForwarding,
 	sVirtualUser,
 	sExposeAuthInfo, sRDomain, sPubkeyAuthOptions, sSecurityKeyProvider,
+	sBidirectionalBreak,
 	sDeprecated, sIgnore, sUnsupported
 } ServerOpCodes;
 
@@ -679,6 +683,7 @@ static struct {
 	{ "rdomain", sRDomain, SSHCFG_ALL },
 	{ "casignaturealgorithms", sCASignatureAlgorithms, SSHCFG_ALL },
 	{ "securitykeyprovider", sSecurityKeyProvider, SSHCFG_GLOBAL },
+	{ "bidirectionalbreak", sBidirectionalBreak, SSHCFG_ALL },
 	{ NULL, sBadOption, 0 }
 };
 
@@ -2449,6 +2454,10 @@ process_server_config_line_depth(ServerOptions *options, char *line,
 			*charptr = xstrdup(arg);
 		break;
 
+	case sBidirectionalBreak:
+		intptr = &options->bidirectional_break;
+		goto parse_flag;
+
 	case sDeprecated:
 	case sIgnore:
 	case sUnsupported:
@@ -2621,6 +2630,7 @@ copy_set_server_options(ServerOptions *dst, ServerOptions *src, int preauth)
 	M_CP_INTOPT(rekey_limit);
 	M_CP_INTOPT(rekey_interval);
 	M_CP_INTOPT(log_level);
+	M_CP_INTOPT(bidirectional_break);
 
 	/*
 	 * The bind_mask is a mode_t that may be unsigned, so we can't use
@@ -2930,6 +2940,7 @@ dump_config(ServerOptions *o)
 	dump_cfg_fmtint(sStreamLocalBindUnlink, o->fwd_opts.streamlocal_bind_unlink);
 	dump_cfg_fmtint(sFingerprintHash, o->fingerprint_hash);
 	dump_cfg_fmtint(sExposeAuthInfo, o->expose_userauth_info);
+	dump_cfg_fmtint(sBidirectionalBreak, o->bidirectional_break);
 
 	/* string arguments */
 	dump_cfg_string(sPidFile, o->pid_file);
diff --git a/servconf.h b/servconf.h
index a7ad3e0..d1e9f6e 100644
--- a/servconf.h
+++ b/servconf.h
@@ -231,6 +231,7 @@ typedef struct {
 	int	expose_userauth_info;
 	u_int64_t timing_secret;
 	char   *sk_provider;
+	int bidirectional_break;
 }       ServerOptions;
 
 /* Information about the incoming connection as used by Match */
diff --git a/session.c b/session.c
index b3b36f5..466d0ea 100644
--- a/session.c
+++ b/session.c
@@ -96,6 +96,7 @@
 #include "monitor_wrap.h"
 #include "sftp.h"
 #include "atomicio.h"
+#include "break-filter.h"
 
 #if defined(KRB5) && defined(USE_AFS)
 #include <kafs.h>
@@ -144,6 +145,7 @@ extern void destroy_sensitive_data(void);
 extern struct sshbuf *loginmsg;
 extern struct sshauthopt *auth_opts;
 extern char *tun_fwd_ifnames; /* serverloop.c */
+extern char const break_sequence[];
 
 /* original command from peer. */
 const char *original_command = NULL;
@@ -2113,7 +2115,7 @@ session_exec_req(struct ssh *ssh, Session *s)
 }
 
 static int
-session_break_req(struct ssh *ssh, Session *s)
+session_break_req(struct ssh *ssh, Session *s, Channel *c)
 {
 	int r;
 
@@ -2121,8 +2123,12 @@ session_break_req(struct ssh *ssh, Session *s)
 	    (r = sshpkt_get_end(ssh)) != 0)
 		sshpkt_fatal(ssh, r, "%s: parse packet", __func__);
 
-	if (s->ptymaster == -1 || tcsendbreak(s->ptymaster, 0) == -1)
+	if (c->escaped) {
+		if ((r = sshbuf_put(c->output, break_sequence, BREAK_SEQ_LEN)) != 0)
+			fatal_fr(r, "channel %i: append data", c->self);
+	} else if (s->ptymaster == -1 || tcsendbreak(s->ptymaster, 0) == -1)
 		return 0;
+
 	return 1;
 }
 
@@ -2273,6 +2279,13 @@ session_input_channel_req(struct ssh *ssh, Channel *c, const char *rtype)
 	if (c->type == SSH_CHANNEL_LARVAL) {
 		if (strcmp(rtype, "shell") == 0) {
 			success = session_shell_req(ssh, s);
+			if (success && options.bidirectional_break) {
+				channel_register_filter(ssh, c->self,
+					simple_break_filter, NULL,
+					break_filter_cleanup,
+			    	new_break_filter_ctx());
+				c->escaped = 1;
+			}
 		} else if (strcmp(rtype, "exec") == 0) {
 			success = session_exec_req(ssh, s);
 		} else if (strcmp(rtype, "pty-req") == 0) {
@@ -2290,7 +2303,7 @@ session_input_channel_req(struct ssh *ssh, Channel *c, const char *rtype)
 	if (strcmp(rtype, "window-change") == 0) {
 		success = session_window_change_req(ssh, s);
 	} else if (strcmp(rtype, "break") == 0) {
-		success = session_break_req(ssh, s);
+		success = session_break_req(ssh, s, c);
 	} else if (strcmp(rtype, "signal") == 0) {
 		success = session_signal_req(ssh, s);
 	}
-- 
2.30.2

