From 67c83883a9e7349ee1d3992ac67d5bbdab976f70 Mon Sep 17 00:00:00 2001
From: Paul Ostebee <paul.ostebee@digi.com>
Date: Tue, 25 Jan 2022 21:48:33 +0100
Subject: [PATCH 09/10] Add support for communicating  break signals
 bidirectionally

Tunnelling serial communications requires us to be able to send and
receive break requests. This patch adds a new option
"bidirectionalbreak" to both ssh and sshd. When enabled break requests
will generate \377\0 as output and any literal \377 bytes will be
escaped as \377\377. If no escape char is defined the sequence
\377\0 will send a break request to remote peer.
---
 Makefile.in    |  2 +-
 break-filter.c | 72 ++++++++++++++++++++++++++++++++++++++++++++++++++
 break-filter.h | 17 ++++++++++++
 channels.c     | 29 +++++++++++++++++++-
 channels.h     |  3 +++
 clientloop.c   | 20 ++++++++++++++
 readconf.c     | 10 +++++++
 readconf.h     |  2 ++
 servconf.c     | 11 ++++++++
 servconf.h     |  1 +
 session.c      | 19 ++++++++++---
 11 files changed, 181 insertions(+), 5 deletions(-)
 create mode 100644 break-filter.c
 create mode 100644 break-filter.h

Index: openssh-9.8p1/Makefile.in
===================================================================
--- openssh-9.8p1.orig/Makefile.in
+++ openssh-9.8p1/Makefile.in
@@ -114,7 +114,7 @@ LIBSSH_OBJS=${LIBOPENSSH_OBJS} \
 	kexgexc.o kexgexs.o \
 	kexsntrup761x25519.o sntrup761.o kexgen.o \
 	sftp-realpath.o platform-pledge.o platform-tracing.o platform-misc.o \
-	sshbuf-io.o
+	sshbuf-io.o break-filter.o
 
 SKOBJS=	ssh-sk-client.o
 
Index: openssh-9.8p1/break-filter.c
===================================================================
--- /dev/null
+++ openssh-9.8p1/break-filter.c
@@ -0,0 +1,72 @@
+#include "includes.h"
+
+#include "break-filter.h"
+#include "openbsd-compat/sys-queue.h"
+#include "channels.h"
+#include "sshbuf.h"
+#include "xmalloc.h"
+#include "packet.h"
+#include "log.h"
+#include "ssherr.h"
+
+struct break_sequence {
+	int escape_pending;
+	int break_pending;
+	size_t break_off;
+};
+
+char const break_sequence[] = {'\377','\0'};
+
+int
+simple_break_filter(struct ssh *ssh, struct Channel *c, char *buf, int len)
+{
+	int r, bytes = 0;
+	u_int i;
+	u_char ch;
+	int * escape_pending = c->filter_ctx == NULL ?
+	    NULL : (int *)c->filter_ctx;
+
+	if (escape_pending == NULL || len <= 0)
+		return (0);
+
+	for (i = 0; i < (u_int)len; i++) {
+		/* Get one character at a time. */
+		ch = buf[i];
+		if (*escape_pending) {
+			*escape_pending = 0;
+
+			switch (ch) {
+			case '\0':
+				channel_request_start(ssh, c->self, "break", 0);
+				if ((r = sshpkt_put_u32(ssh, 1000)) != 0 ||
+				    (r = sshpkt_send(ssh)) != 0)
+					fatal_fr(r, "send packet");
+				continue;
+			case (u_char)'\377':
+				if ((r = sshbuf_put_u8(c->input, (u_char)'\377')) != 0)
+					fatal_fr(r, "buffer error");
+				bytes++;
+				continue;
+			}
+		} else if (ch == (u_char)'\377') {
+			*escape_pending = 1;
+			continue;
+		}
+		if ((r = sshbuf_put_u8(c->input, ch)) != 0)
+			fatal_fr(r, "buffer error");
+		bytes++;
+	}
+	return bytes;
+}
+
+void
+break_filter_cleanup(struct ssh *ssh, int cid, void *ctx)
+{
+	free(ctx);
+}
+
+void *
+new_break_filter_ctx(void)
+{
+	return xcalloc(1, sizeof (int));
+}
Index: openssh-9.8p1/break-filter.h
===================================================================
--- /dev/null
+++ openssh-9.8p1/break-filter.h
@@ -0,0 +1,17 @@
+#ifndef BREAK_FILTER_H
+#define BREAK_FILTER_H
+
+#define BREAK_SEQ_LEN 2
+
+struct ssh;
+
+int
+simple_break_filter(struct ssh *ssh, struct Channel *c, char *buf, int len);
+
+void
+break_filter_cleanup(struct ssh *ssh, int cid, void *ctx);
+
+void *
+new_break_filter_ctx(void);
+
+#endif
Index: openssh-9.8p1/channels.c
===================================================================
--- openssh-9.8p1.orig/channels.c
+++ openssh-9.8p1/channels.c
@@ -3399,7 +3399,7 @@ int
 channel_input_data(int type, u_int32_t seq, struct ssh *ssh)
 {
 	const u_char *data;
-	size_t data_len, win_len;
+	size_t data_len, win_len, i, escaped = 0;
 	Channel *c = channel_from_packet_id(ssh, __func__, "data");
 	int r;
 
@@ -3421,6 +3421,14 @@ channel_input_data(int type, u_int32_t s
 	win_len = data_len;
 	if (c->datagram)
 		win_len += 4;  /* string length header */
+	else if (c->escaped) {
+		for (i = 0; i < data_len; i++) {
+			if (data[i] == (u_char)'\377') {
+				escaped++;
+				win_len++;
+			}
+		}
+	}
 
 	/*
 	 * The sending side reduces its window as it sends data, so we
@@ -3457,6 +3465,25 @@ channel_input_data(int type, u_int32_t s
 	if (c->datagram) {
 		if ((r = sshbuf_put_string(c->output, data, data_len)) != 0)
 			fatal_fr(r, "channel %i: append datagram", c->self);
+	} else if (c->escaped && escaped > 0) {
+		r = 0;
+		while (data_len > 0 && escaped > 0) {
+			const u_char ch = *data;
+
+			if (ch == '\377') {
+				r = sshbuf_put_u8(c->output, ch);
+				escaped--;
+			}
+			if (r != 0 || (r = sshbuf_put_u8(c->output, ch)) != 0)
+				fatal("%s: channel %d: append data: %s",
+			    __func__, c->self, ssh_err(r));
+
+			data_len--;
+			data++;
+		}
+		if (data_len)
+			if ((r = sshbuf_put(c->output, data, data_len)) != 0)
+				fatal_fr(r, "channel %i: append data", c->self);
 	} else if ((r = sshbuf_put(c->output, data, data_len)) != 0)
 		fatal_fr(r, "channel %i: append data", c->self);
 
Index: openssh-9.8p1/channels.h
===================================================================
--- openssh-9.8p1.orig/channels.h
+++ openssh-9.8p1/channels.h
@@ -211,6 +211,9 @@ struct Channel {
 	time_t			lastused;
 	/* Inactivity timeout deadline in seconds (0 = no timeout) */
 	int			inactive_deadline;
+
+	/* \377 escaped as \377\377 */
+	int			escaped;
 };
 
 #define CHAN_EXTENDED_IGNORE		0
Index: openssh-9.8p1/clientloop.c
===================================================================
--- openssh-9.8p1.orig/clientloop.c
+++ openssh-9.8p1/clientloop.c
@@ -114,6 +114,7 @@
 #include "msg.h"
 #include "ssherr.h"
 #include "hostfile.h"
+#include "break-filter.h"
 
 /* Permitted RSA signature algorithms for UpdateHostkeys proofs */
 #define HOSTKEY_PROOF_RSA_ALGS	"rsa-sha2-512,rsa-sha2-256"
@@ -140,6 +141,8 @@ extern char *host;
  */
 extern char *forward_agent_sock_path;
 
+extern char const break_sequence[];
+
 /*
  * Flag to indicate that we have received a window change signal which has
  * not yet been processed.  This will cause a message indicating the new
@@ -1526,15 +1529,24 @@ client_loop(struct ssh *ssh, int have_pt
 		enter_raw_mode(options.request_tty == REQUEST_TTY_FORCE);
 
 	if (session_ident != -1) {
+		struct Channel * c = channel_lookup(ssh, session_ident);
+
 		if (escape_char_arg != SSH_ESCAPECHAR_NONE) {
 			channel_register_filter(ssh, session_ident,
 			    client_simple_escape_filter, NULL,
 			    client_filter_cleanup,
 			    client_new_escape_filter_ctx(
 			    escape_char_arg));
+		} else if (options.bidirectional_break) {
+			channel_register_filter(ssh, session_ident,
+				simple_break_filter, NULL,
+				break_filter_cleanup,
+			    new_break_filter_ctx());
 		}
 		channel_register_cleanup(ssh, session_ident,
 		    client_channel_closed, 0);
+
+		c->escaped = options.bidirectional_break;
 	}
 
 	schedule_server_alive_check();
@@ -2002,6 +2014,14 @@ client_input_channel_req(int type, u_int
 		}
 		if ((r = sshpkt_get_end(ssh)) != 0)
 			goto out;
+	} else if (c->escaped && strcmp(rtype, "break") == 0) {
+		if ((r = sshpkt_get_u32(ssh, NULL)) != 0 || /* ignore */
+		(r = sshpkt_get_end(ssh)) != 0)
+			sshpkt_fatal(ssh, r, "%s: parse packet", __func__);
+
+		if ((r = sshbuf_put(c->output, break_sequence, BREAK_SEQ_LEN)) != 0)
+			fatal_fr(r, "channel %i: append data", c->self);
+		success = 1;
 	}
 	if (reply && c != NULL && !(c->flags & CHAN_CLOSE_SENT)) {
 		if (!c->have_remote_id)
Index: openssh-9.8p1/readconf.c
===================================================================
--- openssh-9.8p1.orig/readconf.c
+++ openssh-9.8p1/readconf.c
@@ -179,6 +179,7 @@ typedef enum {
 	oPubkeyAcceptedAlgorithms, oCASignatureAlgorithms, oProxyJump,
 	oSecurityKeyProvider, oKnownHostsCommand, oRequiredRSASize,
 	oEnableEscapeCommandline, oObscureKeystrokeTiming, oChannelTimeout,
+	oBidirectionalBreak,
 	oIgnore, oIgnoredUnknownOption, oDeprecated, oUnsupported
 } OpCodes;
 
@@ -329,6 +330,7 @@ static struct {
 	{ "enableescapecommandline", oEnableEscapeCommandline },
 	{ "obscurekeystroketiming", oObscureKeystrokeTiming },
 	{ "channeltimeout", oChannelTimeout },
+	{ "bidirectionalbreak", oBidirectionalBreak },
 
 	{ NULL, oBadOption }
 };
@@ -2388,6 +2390,10 @@ parse_pubkey_algos:
 		}
 		break;
 
+	case oBidirectionalBreak:
+		intptr = &options->bidirectional_break;
+		goto parse_flag;
+
 	case oDeprecated:
 		debug("%s line %d: Deprecated option \"%s\"",
 		    filename, linenum, keyword);
@@ -2644,6 +2650,7 @@ initialize_options(Options * options)
 	options->tag = NULL;
 	options->channel_timeouts = NULL;
 	options->num_channel_timeouts = 0;
+	options->bidirectional_break = -1;
 }
 
 /*
@@ -2850,6 +2857,8 @@ fill_default_options(Options * options)
 		options->obscure_keystroke_timing_interval =
 		    SSH_KEYSTROKE_DEFAULT_INTERVAL_MS;
 	}
+	if (options->bidirectional_break == -1)
+		options->bidirectional_break = 0;
 
 	/* Expand KEX name lists */
 	all_cipher = cipher_alg_list(',', 0);
@@ -3556,6 +3565,7 @@ dump_client_config(Options *o, const cha
 	dump_cfg_fmtint(oVisualHostKey, o->visual_host_key);
 	dump_cfg_fmtint(oUpdateHostkeys, o->update_hostkeys);
 	dump_cfg_fmtint(oEnableEscapeCommandline, o->enable_escape_commandline);
+	dump_cfg_fmtint(oBidirectionalBreak, o->bidirectional_break);
 
 	/* Integer options */
 	dump_cfg_int(oCanonicalizeMaxDots, o->canonicalize_max_dots);
Index: openssh-9.8p1/readconf.h
===================================================================
--- openssh-9.8p1.orig/readconf.h
+++ openssh-9.8p1/readconf.h
@@ -186,6 +186,8 @@ typedef struct {
 	u_int	num_channel_timeouts;
 
 	char	*ignored_unknown; /* Pattern list of unknown tokens to ignore */
+
+	int	bidirectional_break;
 }       Options;
 
 #define SSH_PUBKEY_AUTH_NO	0x00
Index: openssh-9.8p1/servconf.c
===================================================================
--- openssh-9.8p1.orig/servconf.c
+++ openssh-9.8p1/servconf.c
@@ -214,6 +214,7 @@ initialize_server_options(ServerOptions
 	options->num_channel_timeouts = 0;
 	options->unused_connection_timeout = -1;
 	options->sshd_session_path = NULL;
+	options->bidirectional_break = -1;
 }
 
 /* Returns 1 if a string option is unset or set to "none" or 0 otherwise. */
@@ -490,6 +491,8 @@ fill_default_server_options(ServerOption
 		options->unused_connection_timeout = 0;
 	if (options->sshd_session_path == NULL)
 		options->sshd_session_path = xstrdup(_PATH_SSHD_SESSION);
+	if (options->bidirectional_break == -1)
+		options->bidirectional_break = 0;
 
 	assemble_algorithms(options);
 
@@ -574,6 +577,7 @@ typedef enum {
 	sExposeAuthInfo, sRDomain, sPubkeyAuthOptions, sSecurityKeyProvider,
 	sRequiredRSASize, sChannelTimeout, sUnusedConnectionTimeout,
 	sSshdSessionPath,
+	sBidirectionalBreak,
 	sDeprecated, sIgnore, sUnsupported
 } ServerOpCodes;
 
@@ -742,6 +746,7 @@ static struct {
 	{ "channeltimeout", sChannelTimeout, SSHCFG_ALL },
 	{ "unusedconnectiontimeout", sUnusedConnectionTimeout, SSHCFG_ALL },
 	{ "sshdsessionpath", sSshdSessionPath, SSHCFG_GLOBAL },
+	{ "bidirectionalbreak", sBidirectionalBreak, SSHCFG_ALL },
 	{ NULL, sBadOption, 0 }
 };
 
@@ -2672,6 +2677,10 @@ process_server_config_line_depth(ServerO
 		charptr = &options->sshd_session_path;
 		goto parse_filename;
 
+	case sBidirectionalBreak:
+		intptr = &options->bidirectional_break;
+		goto parse_flag;
+
 	case sDeprecated:
 	case sIgnore:
 	case sUnsupported:
@@ -2887,6 +2896,7 @@ copy_set_server_options(ServerOptions *d
 	M_CP_INTOPT(log_level);
 	M_CP_INTOPT(required_rsa_size);
 	M_CP_INTOPT(unused_connection_timeout);
+	M_CP_INTOPT(bidirectional_break);
 
 	/*
 	 * The bind_mask is a mode_t that may be unsigned, so we can't use
@@ -3217,6 +3227,7 @@ dump_config(ServerOptions *o)
 	dump_cfg_fmtint(sStreamLocalBindUnlink, o->fwd_opts.streamlocal_bind_unlink);
 	dump_cfg_fmtint(sFingerprintHash, o->fingerprint_hash);
 	dump_cfg_fmtint(sExposeAuthInfo, o->expose_userauth_info);
+	dump_cfg_fmtint(sBidirectionalBreak, o->bidirectional_break);
 
 	/* string arguments */
 	dump_cfg_string(sPidFile, o->pid_file);
Index: openssh-9.8p1/servconf.h
===================================================================
--- openssh-9.8p1.orig/servconf.h
+++ openssh-9.8p1/servconf.h
@@ -248,6 +248,7 @@ typedef struct {
 	u_int	num_channel_timeouts;
 
 	int	unused_connection_timeout;
+	int	bidirectional_break;
 
 	char   *sshd_session_path;
 }       ServerOptions;
Index: openssh-9.8p1/session.c
===================================================================
--- openssh-9.8p1.orig/session.c
+++ openssh-9.8p1/session.c
@@ -94,6 +94,7 @@
 #include "monitor_wrap.h"
 #include "sftp.h"
 #include "atomicio.h"
+#include "break-filter.h"
 
 #if defined(KRB5) && defined(USE_AFS)
 #include <kafs.h>
@@ -153,6 +154,7 @@ extern void destroy_sensitive_data(void)
 extern struct sshbuf *loginmsg;
 extern struct sshauthopt *auth_opts;
 extern char *tun_fwd_ifnames; /* serverloop.c */
+extern char const break_sequence[];
 
 /* original command from peer. */
 const char *original_command = NULL;
@@ -2099,7 +2101,7 @@ session_exec_req(struct ssh *ssh, Sessio
 }
 
 static int
-session_break_req(struct ssh *ssh, Session *s)
+session_break_req(struct ssh *ssh, Session *s, Channel *c)
 {
 	int r;
 
@@ -2107,8 +2109,12 @@ session_break_req(struct ssh *ssh, Sessi
 	    (r = sshpkt_get_end(ssh)) != 0)
 		sshpkt_fatal(ssh, r, "%s: parse packet", __func__);
 
-	if (s->ptymaster == -1 || tcsendbreak(s->ptymaster, 0) == -1)
+	if (c->escaped) {
+		if ((r = sshbuf_put(c->output, break_sequence, BREAK_SEQ_LEN)) != 0)
+			fatal_fr(r, "channel %i: append data", c->self);
+	} else if (s->ptymaster == -1 || tcsendbreak(s->ptymaster, 0) == -1)
 		return 0;
+
 	return 1;
 }
 
@@ -2259,6 +2265,13 @@ session_input_channel_req(struct ssh *ss
 	if (c->type == SSH_CHANNEL_LARVAL) {
 		if (strcmp(rtype, "shell") == 0) {
 			success = session_shell_req(ssh, s);
+			if (success && options.bidirectional_break) {
+				channel_register_filter(ssh, c->self,
+					simple_break_filter, NULL,
+					break_filter_cleanup,
+				new_break_filter_ctx());
+				c->escaped = 1;
+			}
 		} else if (strcmp(rtype, "exec") == 0) {
 			success = session_exec_req(ssh, s);
 		} else if (strcmp(rtype, "pty-req") == 0) {
@@ -2276,7 +2289,7 @@ session_input_channel_req(struct ssh *ss
 	if (strcmp(rtype, "window-change") == 0) {
 		success = session_window_change_req(ssh, s);
 	} else if (strcmp(rtype, "break") == 0) {
-		success = session_break_req(ssh, s);
+		success = session_break_req(ssh, s, c);
 	} else if (strcmp(rtype, "signal") == 0) {
 		success = session_signal_req(ssh, s);
 	}
