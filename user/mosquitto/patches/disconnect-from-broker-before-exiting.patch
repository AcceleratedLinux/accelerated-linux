From: Tatiana Leon <Tatiana.Leon@digi.com>
Date: Mon, 13 Jun 2022 13:40:44 +0200
Subject: [PATCH] mosquito_rr: disconnect from broker before
 exiting

Signed-off-by: Tatiana Leon <Tatiana.Leon@digi.com>
---
 client/rr_client.c | 46 +++++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 45 insertions(+), 1 deletion(-)

diff --git a/client/rr_client.c b/client/rr_client.c
index 9dca6d74..3d7f8a5a 100644
--- a/client/rr_client.c
+++ b/client/rr_client.c
@@ -67,6 +67,18 @@ static void my_signal_handler(int signum)
 }
 #endif
 
+void my_disconnect_callback(struct mosquitto *mosq, void *obj, int rc, const mosquitto_property *properties)
+{
+	UNUSED(mosq);
+	UNUSED(obj);
+	UNUSED(rc);
+	UNUSED(properties);
+
+	if(rc == 0){
+		client_state = rr_s_disconnect;
+	}
+}
+
 
 int my_publish(struct mosquitto *mosq, int *mid, const char *topic, int payloadlen, void *payload, int qos, bool retain)
 {
@@ -84,20 +96,24 @@ static void my_message_callback(struct mosquitto *mosq, void *obj, const struct
 	UNUSED(obj);
 	UNUSED(properties);
 
+	if(process_messages == false) return;
+
 	if(message->retain && cfg.no_retain) return;
 
+	process_messages = false;
 	print_message(&cfg, message, properties);
 	switch(cfg.pub_mode){
 		case MSGMODE_CMD:
 		case MSGMODE_FILE:
 		case MSGMODE_STDIN_FILE:
 		case MSGMODE_NULL:
-			client_state = rr_s_disconnect;
+			mosquitto_disconnect_v5(mosq, 0, cfg.disconnect_props);
 			break;
 		case MSGMODE_STDIN_LINE:
 			client_state = rr_s_ready_to_publish;
 			break;
 	}
+
 	/* FIXME - check all below
 	if(process_messages == false) return;
 
@@ -366,6 +382,7 @@ int main(int argc, char *argv[])
 		mosquitto_log_callback_set(g_mosq, my_log_callback);
 	}
 	mosquitto_connect_v5_callback_set(g_mosq, my_connect_callback);
+	mosquitto_disconnect_v5_callback_set(g_mosq, my_disconnect_callback);
 	mosquitto_subscribe_callback_set(g_mosq, my_subscribe_callback);
 	mosquitto_message_v5_callback_set(g_mosq, my_message_callback);
 
@@ -409,6 +426,33 @@ int main(int argc, char *argv[])
 		}
 	}while(rc == MOSQ_ERR_SUCCESS && client_state != rr_s_disconnect);
 
+	if(rc != MOSQ_ERR_SUCCESS){
+		process_messages = false;
+		switch(rc){
+			case MOSQ_ERR_INVAL:
+				err_printf(&cfg, "Error: Invalid input. Does your topic contain '+' or '#'?\n");
+				break;
+			case MOSQ_ERR_NOMEM:
+				err_printf(&cfg, "Error: Out of memory when trying to publish message.\n");
+				break;
+			case MOSQ_ERR_NO_CONN:
+				err_printf(&cfg, "Error: Client not connected when trying to publish.\n");
+				break;
+			case MOSQ_ERR_PROTOCOL:
+				err_printf(&cfg, "Error: Protocol error when communicating with broker.\n");
+				break;
+			case MOSQ_ERR_PAYLOAD_SIZE:
+				err_printf(&cfg, "Error: Message payload is too large.\n");
+				break;
+			case MOSQ_ERR_QOS_NOT_SUPPORTED:
+				err_printf(&cfg, "Error: Message QoS not supported on broker, try a lower QoS.\n");
+				break;
+		}
+		if (client_state != rr_s_disconnect){
+			mosquitto_disconnect_v5(g_mosq, 0, cfg.disconnect_props);
+		}
+	}
+
 	mosquitto_destroy(g_mosq);
 	mosquitto_lib_cleanup();
 
