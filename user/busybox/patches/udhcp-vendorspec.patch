Author: David Leonard <david.leonard@opengear.com>
Date:   Wed Jan 21 15:00:02 2015 +1000

    OG-762 add vendorspec option (43) handling to udhcpc
    
    Decode option 43 (vendorspec) and pass suboptions (strings) to the
    script as envvars ${vendorspec_1} etc.

Author: David Leonard <david.leonard@opengear.com>
Date:   Mon Jul 25 15:36:45 2016 +1000

    OG-1141 udhcpc: fix off-by-one
    
    fixes bug where $vendorspec_2 was sometimes empty
Index: busybox-1.31.0/networking/udhcp/common.c
===================================================================
--- busybox-1.31.0.orig/networking/udhcp/common.c
+++ busybox-1.31.0/networking/udhcp/common.c
@@ -45,6 +45,7 @@ const struct dhcp_optflag dhcp_optflags[
 	{ OPTION_STRING_HOST                      , 0x28 }, /* DHCP_NIS_DOMAIN    */
 	{ OPTION_IP | OPTION_LIST                 , 0x29 }, /* DHCP_NIS_SERVER    */
 	{ OPTION_IP | OPTION_LIST     | OPTION_REQ, 0x2a }, /* DHCP_NTP_SERVER    */
+	{ OPTION_TLV| OPTION_LIST                 , 0x2b }, /* DHCP_VENDOR_SPEC   */
 	{ OPTION_IP | OPTION_LIST                 , 0x2c }, /* DHCP_WINS_SERVER   */
 	{ OPTION_U32                              , 0x33 }, /* DHCP_LEASE_TIME    */
 	{ OPTION_IP                               , 0x36 }, /* DHCP_SERVER_ID     */
@@ -116,6 +117,7 @@ const char dhcp_option_strings[] ALIGN1
 	"nisdomain" "\0"        /* DHCP_NIS_DOMAIN      */
 	"nissrv" "\0"           /* DHCP_NIS_SERVER      */
 	"ntpsrv" "\0"           /* DHCP_NTP_SERVER      */
+	"vendorspec" "\0"       /* DHCP_VENDOR_SPEC     */
 	"wins" "\0"             /* DHCP_WINS_SERVER     */
 	"lease" "\0"            /* DHCP_LEASE_TIME      */
 	"serverid" "\0"         /* DHCP_SERVER_ID       */
@@ -503,6 +505,7 @@ int FAST_FUNC udhcp_str2optset(const cha
 	struct option_set **opt_list = arg;
 	char *opt;
 	char *str;
+	char *endptr;
 	const struct dhcp_optflag *optflag;
 	struct dhcp_optflag userdef_optflag;
 	unsigned optcode;
@@ -561,6 +564,17 @@ int FAST_FUNC udhcp_str2optset(const cha
 			if (retval)
 				retval = udhcp_str2nip(val, buffer + 4);
 			break;
+		case OPTION_TLV:
+			buffer[0] = bb_strtou(val, &endptr, 0);
+			retval = (endptr[0] == ':'); /* <tag>:<value> */
+			if (retval) {
+				length = strlen(endptr + 1);
+				if (length > 253) length = 253;
+				buffer[1] = length;
+				memcpy(buffer + 2, endptr + 1, length);
+				length += 2;
+			}
+			break;
  case_OPTION_STRING:
 		case OPTION_STRING:
 		case OPTION_STRING_HOST:
Index: busybox-1.31.0/networking/udhcp/common.h
===================================================================
--- busybox-1.31.0.orig/networking/udhcp/common.h
+++ busybox-1.31.0/networking/udhcp/common.h
@@ -80,6 +80,7 @@ struct BUG_bad_sizeof_struct_ip_udp_dhcp
 enum {
 	OPTION_IP = 1,
 	OPTION_IP_PAIR,
+	OPTION_TLV,	/* tag-length-value sub options */
 	OPTION_STRING,
 	/* Opts of STRING_HOST type will be sanitized before they are passed
 	 * to udhcpc script's environment: */
@@ -134,6 +135,7 @@ enum {
 //#define DHCP_NIS_DOMAIN       0x28
 //#define DHCP_NIS_SERVER       0x29
 //#define DHCP_NTP_SERVER       0x2a
+#define DHCP_VENDOR_SPEC        0x2b
 //#define DHCP_WINS_SERVER      0x2c
 #define DHCP_REQUESTED_IP       0x32 /* 50: sent by client if specific IP is wanted */
 #define DHCP_LEASE_TIME         0x33 /* 51: */
Index: busybox-1.31.0/networking/udhcp/dhcpc.c
===================================================================
--- busybox-1.31.0.orig/networking/udhcp/dhcpc.c
+++ busybox-1.31.0/networking/udhcp/dhcpc.c
@@ -122,6 +122,7 @@ static const uint8_t len_of_option_as_st
 	[OPTION_IP_PAIR         ] = sizeof("255.255.255.255 ") * 2,
 	[OPTION_STATIC_ROUTES   ] = sizeof("255.255.255.255/32 255.255.255.255 "),
 	[OPTION_6RD             ] = sizeof("132 128 ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff 255.255.255.255 "),
+	[OPTION_TLV             ] = 1,
 	[OPTION_STRING          ] = 1,
 	[OPTION_STRING_HOST     ] = 1,
 #if ENABLE_FEATURE_UDHCP_RFC3397
@@ -431,6 +432,65 @@ static NOINLINE char *xmalloc_optname_op
 	return ret;
 }
 
+/* Count the number of TLV entries in the option */
+static int
+tlv_count(uint8_t *option)
+{
+	int count;
+	uint8_t *p;
+	uint8_t *optend;
+
+	optend = option + option[OPT_LEN - 2];
+	count = 0;
+	for (p = option; p < optend; ) {
+		/* tag 0 is padding */
+		if (p[OPT_CODE] == 0) {
+			p++;
+			continue;
+		}
+		/* tag 255 truncates */
+		if (p[OPT_CODE] == 255) {
+			break;
+		}
+		/* check for overlong value */
+		if (&p[OPT_DATA] + p[OPT_LEN] > optend) {
+			break;
+		}
+		p += OPT_DATA + p[OPT_LEN];
+		count++;
+	}
+	return count;
+
+}
+
+/* Allocate and fill multiple envvars with the sub-values of an options */
+static char **
+tlv_putenv(uint8_t *option, const char *opt_name, char **curr)
+{
+	static const struct dhcp_optflag str_option = { .flags = OPTION_STRING };
+	uint8_t *optend = option + option[OPT_LEN - 2];
+	uint8_t *p;
+	char name[32];
+
+	for (p = option; p < optend; ) {
+		if (p[OPT_CODE] == 0) {
+			p++;
+			continue;
+		}
+		if (p[OPT_CODE] == 255) {
+			break;
+		}
+		if (&p[OPT_DATA] + p[OPT_LEN] > optend) {
+			break;
+		}
+		snprintf(name, sizeof name, "%s_%d", opt_name, p[OPT_CODE]);
+		*curr = xmalloc_optname_optval(p + OPT_DATA, &str_option, name);
+		putenv(*curr++);
+		p += OPT_DATA + p[OPT_LEN];
+	}
+	return curr;
+}
+
 /* put all the parameters into the environment */
 static char **fill_envp(struct dhcp_packet *packet)
 {
@@ -469,6 +529,8 @@ static char **fill_envp(struct dhcp_pack
 					overload |= *temp;
 				else if (i == DHCP_SUBNET)
 					envc++; /* for $mask */
+				else if ((dhcp_optflags[i].flags & OPTION_TYPE_MASK) == OPTION_TLV)
+					envc += tlv_count(temp);
 				envc++;
 				/*if (i != DHCP_MESSAGE_TYPE)*/
 				FOUND_OPTS(i) |= BMASK(i);
@@ -529,6 +591,10 @@ static char **fill_envp(struct dhcp_pack
 			goto next;
 		*found_ptr &= ~found_mask; /* leave only unknown options */
 		temp = udhcp_get_option(packet, code);
+		if ((dhcp_optflags[i].flags & OPTION_TYPE_MASK) == OPTION_TLV) {
+			curr = tlv_putenv(temp, opt_name, curr);
+			goto next;
+		}
 		*curr = xmalloc_optname_optval(temp, &dhcp_optflags[i], opt_name);
 		putenv(*curr++);
 		if (code == DHCP_SUBNET && temp[-OPT_DATA + OPT_LEN] == 4) {
