--- busybox-1.31.0.org/networking/httpd.c	2019-06-10 19:09:31.000000000 +1000
+++ busybox-1.31.0/networking/httpd.c	2019-07-10 14:17:28.353953044 +1000
@@ -221,8 +221,10 @@
 
 //usage:#define httpd_trivial_usage
 //usage:       "[-ifv[v]]"
+//usage:       " [-n max-instances]"
 //usage:       " [-c CONFFILE]"
 //usage:       " [-p [IP:]PORT]"
+//usage:	IF_FEATURE_HTTPD_PROXY(" [-F unchanged|remove|append|replace]")
 //usage:	IF_FEATURE_HTTPD_SETUID(" [-u USER[:GRP]]")
 //usage:	IF_FEATURE_HTTPD_BASIC_AUTH(" [-r REALM]")
 //usage:       " [-h HOME]\n"
@@ -232,6 +234,7 @@
 //usage:     "\n	-i		Inetd mode"
 //usage:     "\n	-f		Don't daemonize"
 //usage:     "\n	-v[v]		Verbose"
+//usage:     "\n	-n NUM		Max instances (Default of 0 is unlimited)"
 //usage:     "\n	-p [IP:]PORT	Bind to IP:PORT (default *:80)"
 //usage:	IF_FEATURE_HTTPD_SETUID(
 //usage:     "\n	-u USER[:GRP]	Set uid/gid after binding to port")
@@ -242,7 +245,11 @@
 //usage:	IF_FEATURE_HTTPD_AUTH_MD5(
 //usage:     "\n	-m STRING	MD5 crypt STRING")
 //usage:     "\n	-e STRING	HTML encode STRING"
+//usage:     "\n	-D STRING	HTML decode STRING"
 //usage:     "\n	-d STRING	URL decode STRING"
+//usage:	IF_FEATURE_HTTPD_PROXY(
+//usage:     "\n	-F ACTION	RFC7239 Forwarded header, action can be one of:"
+//usage:     "\n	         	'unchanged','remove','append','replace'")
 
 /* TODO: use TCP_CORK, parse_config() */
 
@@ -259,18 +266,29 @@
 #if ENABLE_FEATURE_USE_SENDFILE
 # include <sys/sendfile.h>
 #endif
+/* amount of buffering in a pipe */
+#ifndef PIPE_BUF
+# define PIPE_BUF 4096
+#endif
 
+#if 1
 #define DEBUG 0
+#else
+#define DEBUG (verbose > 3)
+#endif
 
 #define IOBUF_SIZE 8192
-#define MAX_HTTP_HEADERS_SIZE (32*1024)
+#if PIPE_BUF >= IOBUF_SIZE
+# error "PIPE_BUF >= IOBUF_SIZE"
+#endif
 
 #define HEADER_READ_TIMEOUT 60
 
 static const char DEFAULT_PATH_HTTPD_CONF[] ALIGN1 = "/etc";
 static const char HTTPD_CONF[] ALIGN1 = "httpd.conf";
-static const char HTTP_200[] ALIGN1 = "HTTP/1.0 200 OK\r\n";
+static const char HTTP_200[] ALIGN1 = "HTTP/1.1 200 OK\r\n";
 static const char index_html[] ALIGN1 = "index.html";
+static const char RFC1123FMT[] ALIGN1 = "%a, %d %b %Y %H:%M:%S GMT";
 
 typedef struct has_next_ptr {
 	struct has_next_ptr *next;
@@ -299,25 +317,19 @@
 	char *url_to;
 } Htaccess_Proxy;
 
-typedef enum CGI_type {
-	CGI_NONE = 0,
-	CGI_NORMAL,
-	CGI_INDEX,
-	CGI_INTERPRETER,
-} CGI_type;
-
 enum {
 	HTTP_OK = 200,
 	HTTP_PARTIAL_CONTENT = 206,
 	HTTP_MOVED_TEMPORARILY = 302,
+	HTTP_NOT_MODIFIED = 304,
 	HTTP_BAD_REQUEST = 400,       /* malformed syntax */
 	HTTP_UNAUTHORIZED = 401, /* authentication needed, respond with auth hdr */
 	HTTP_NOT_FOUND = 404,
 	HTTP_FORBIDDEN = 403,
 	HTTP_REQUEST_TIMEOUT = 408,
+	HTTP_ENTITY_TOO_LARGE = 413,
 	HTTP_NOT_IMPLEMENTED = 501,   /* used for unrecognized requests */
 	HTTP_INTERNAL_SERVER_ERROR = 500,
-	HTTP_ENTITY_TOO_LARGE = 413,
 	HTTP_CONTINUE = 100,
 #if 0   /* future use */
 	HTTP_SWITCHING_PROTOCOLS = 101,
@@ -327,7 +339,6 @@
 	HTTP_NO_CONTENT = 204,
 	HTTP_MULTIPLE_CHOICES = 300,
 	HTTP_MOVED_PERMANENTLY = 301,
-	HTTP_NOT_MODIFIED = 304,
 	HTTP_PAYMENT_REQUIRED = 402,
 	HTTP_BAD_GATEWAY = 502,
 	HTTP_SERVICE_UNAVAILABLE = 503, /* overload, maintenance */
@@ -340,6 +351,7 @@
 	HTTP_PARTIAL_CONTENT,
 #endif
 	HTTP_MOVED_TEMPORARILY,
+	HTTP_NOT_MODIFIED,
 	HTTP_REQUEST_TIMEOUT,
 	HTTP_NOT_IMPLEMENTED,
 #if ENABLE_FEATURE_HTTPD_BASIC_AUTH
@@ -356,7 +368,6 @@
 	HTTP_NO_CONTENT,
 	HTTP_MULTIPLE_CHOICES,
 	HTTP_MOVED_PERMANENTLY,
-	HTTP_NOT_MODIFIED,
 	HTTP_BAD_GATEWAY,
 	HTTP_SERVICE_UNAVAILABLE,
 #endif
@@ -371,6 +382,7 @@
 	{ "Partial Content", NULL },
 #endif
 	{ "Found", NULL },
+	{ "Not Modified", NULL },
 	{ "Request Timeout", "No request appeared within 60 seconds" },
 	{ "Not Implemented", "The requested method is not recognized" },
 #if ENABLE_FEATURE_HTTPD_BASIC_AUTH
@@ -387,19 +399,26 @@
 	{ "No Content" },
 	{ "Multiple Choices" },
 	{ "Moved Permanently" },
-	{ "Not Modified" },
 	{ "Bad Gateway", "" },
 	{ "Service Unavailable", "" },
 #endif
 };
 
+#if ENABLE_FEATURE_HTTPD_PROXY
+/* How we handle the Forwarded: header */
+#define FORWARDED_REMOVE 0x1
+#define FORWARDED_APPEND 0x2
+#endif
+
 struct globals {
 	int verbose;            /* must be int (used by getopt32) */
+	int max_instances;      /* Maximum number of outstanding forks */
 	smallint flg_deny_all;
 #if ENABLE_FEATURE_HTTPD_GZIP
 	/* client can handle gzip / we are going to send gzip */
 	smallint content_gzip;
 #endif
+	unsigned rmt_ip;        /* used for IP-based allow/deny rules */
 	time_t last_mod;
 	char *rmt_ip_str;       /* for $REMOTE_ADDR and $REMOTE_PORT */
 	const char *bind_addr_or_port;
@@ -415,6 +434,12 @@
 
 	IF_FEATURE_HTTPD_BASIC_AUTH(const char *g_realm;)
 	IF_FEATURE_HTTPD_BASIC_AUTH(char *remoteuser;)
+	IF_FEATURE_HTTPD_CGI(char *referer;)
+	IF_FEATURE_HTTPD_CGI(char *user_agent;)
+	IF_FEATURE_HTTPD_CGI(char *host;)
+	IF_FEATURE_HTTPD_CGI(char *http_accept;)
+	IF_FEATURE_HTTPD_CGI(char *http_accept_language;)
+	char *if_modified_since;
 
 	off_t file_size;        /* -1 - unknown */
 #if ENABLE_FEATURE_HTTPD_RANGES
@@ -440,16 +465,24 @@
 #endif
 #if ENABLE_FEATURE_HTTPD_PROXY
 	Htaccess_Proxy *proxy;
+	int forwarded_flags;
 #endif
+
+	smallint keep_alive;
+	smallint websocket;
+	unsigned char http_major_version;
+	unsigned char http_minor_version;
 };
 #define G (*ptr_to_globals)
 #define verbose           (G.verbose          )
+#define max_instances     (G.max_instances    )
 #define flg_deny_all      (G.flg_deny_all     )
 #if ENABLE_FEATURE_HTTPD_GZIP
 # define content_gzip     (G.content_gzip     )
 #else
 # define content_gzip     0
 #endif
+#define rmt_ip            (G.rmt_ip           )
 #define bind_addr_or_port (G.bind_addr_or_port)
 #define g_query           (G.g_query          )
 #define opt_c_configFile  (G.opt_c_configFile )
@@ -461,6 +494,12 @@
 #define ip_a_d            (G.ip_a_d           )
 #define g_realm           (G.g_realm          )
 #define remoteuser        (G.remoteuser       )
+#define referer           (G.referer          )
+#define user_agent        (G.user_agent       )
+#define host              (G.host             )
+#define http_accept       (G.http_accept      )
+#define http_accept_language (G.http_accept_language)
+#define if_modified_since (G.if_modified_since)
 #define file_size         (G.file_size        )
 #if ENABLE_FEATURE_HTTPD_RANGES
 #define range_start       (G.range_start      )
@@ -482,6 +521,16 @@
 #define hdr_cnt           (G.hdr_cnt          )
 #define http_error_page   (G.http_error_page  )
 #define proxy             (G.proxy            )
+#define keep_alive        (G.keep_alive       )
+#define websocket         (G.websocket       )
+
+#define http_major_version (G.http_major_version)
+#define http_minor_version (G.http_minor_version)
+
+#if ENABLE_FEATURE_HTTPD_PROXY
+#define forwarded_flags (G.forwarded_flags)
+#endif
+
 #define INIT_G() do { \
 	setup_common_bufsiz(); \
 	SET_PTR_TO_GLOBALS(xzalloc(sizeof(G))); \
@@ -945,6 +994,38 @@
 	*p = '\0';
 	return out;
 }
+
+/*
+ * Given an html-encoded string, decode it into a (malloced) string.
+ */
+static char *decodeString(const char *string)
+{
+	char *out = malloc(strlen(string) + 1);
+	char *i, *o;
+	int d;
+
+	for (i = (char *) string, o = out; *i; i++) {
+		*o = *i;
+		o++;
+		if (i[0] != '&' || i[1] != '#')
+			continue;
+
+		/* &#d; or &#dd; or &#ddd; */
+		for (d = 1; d <= 3; d++) {
+			if (!isdigit(i[d + 1]))
+				break;
+			if (i[d + 2] == ';') {
+				char s[] = "xxx";
+				strncpy(s, i + 2, d);
+				*(o - 1) = (char)strtol(s, NULL, 10);
+				i += d + 2;
+				break;
+			}
+		}
+	}
+	*o = '\0';
+	return out;
+}
 #endif
 
 #if ENABLE_FEATURE_HTTPD_BASIC_AUTH
@@ -1038,19 +1119,16 @@
  */
 static void send_headers(unsigned responseNum)
 {
-	static const char RFC1123FMT[] ALIGN1 = "%a, %d %b %Y %H:%M:%S GMT";
-	/* Fixed size 29-byte string. Example: Sun, 06 Nov 1994 08:49:37 GMT */
-	char date_str[40]; /* using a bit larger buffer to paranoia reasons */
-
-	struct tm tm;
 	const char *responseString = "";
 	const char *infoString = NULL;
+	const char *mime_type;
 #if ENABLE_FEATURE_HTTPD_ERROR_PAGES
 	const char *error_page = NULL;
 #endif
-	unsigned len;
 	unsigned i;
 	time_t timer = time(NULL);
+	char tmp_str[80];
+	int len;
 
 	for (i = 0; i < ARRAY_SIZE(http_response_type); i++) {
 		if (http_response_type[i] == responseNum) {
@@ -1062,33 +1140,30 @@
 			break;
 		}
 	}
+	/* error message is HTML */
+	mime_type = responseNum == HTTP_OK ?
+				found_mime_type : "text/html";
 
 	if (verbose)
 		bb_error_msg("response:%u", responseNum);
 
-	/* We use sprintf, not snprintf (it's less code).
-	 * iobuf[] is several kbytes long and all headers we generate
-	 * always fit into those kbytes.
-	 */
-
-	strftime(date_str, sizeof(date_str), RFC1123FMT, gmtime_r(&timer, &tm));
-	/* ^^^ using gmtime_r() instead of gmtime() to not use static data */
+	/* emit the current date */
+	strftime(tmp_str, sizeof(tmp_str), RFC1123FMT, gmtime(&timer));
 	len = sprintf(iobuf,
-			"HTTP/1.0 %u %s\r\n"
-			"Date: %s\r\n"
-			"Connection: close\r\n",
-			responseNum, responseString,
-			date_str
-	);
+			"HTTP/%d.%d %d %s\r\nContent-type: %s\r\n"
+			"Date: %s\r\n",
+			http_major_version, http_minor_version,
+			responseNum, responseString, mime_type, tmp_str);
 
-	if (responseNum != HTTP_OK || found_mime_type) {
-		len += sprintf(iobuf + len,
-				"Content-type: %s\r\n",
-				/* if it's error message, then it's HTML */
-				(responseNum != HTTP_OK ? "text/html" : found_mime_type)
-		);
-	}
+	if (!keep_alive)
+	    len += sprintf(iobuf + len, "Connection: close\r\n");
+	else
+	    len += sprintf(iobuf + len, "Connection: keep-alive\r\n");
 
+/* Do not send this header. We no longer want the browser to prompt for
+ * Basic Auth *ever*, because the browser will cache the credentials and
+ * they interfere with non-Basic Auth. */
+#if 0
 #if ENABLE_FEATURE_HTTPD_BASIC_AUTH
 	if (responseNum == HTTP_UNAUTHORIZED) {
 		len += sprintf(iobuf + len,
@@ -1097,22 +1172,12 @@
 		);
 	}
 #endif
+#endif
 	if (responseNum == HTTP_MOVED_TEMPORARILY) {
-		/* Responding to "GET /dir" with
-		 * "HTTP/1.0 302 Found" "Location: /dir/"
-		 * - IOW, asking them to repeat with a slash.
-		 * Here, overflow IS possible, can't use sprintf:
-		 * mkdir test
-		 * python -c 'print("get /test?" + ("x" * 8192))' | busybox httpd -i -h .
-		 */
-		len += snprintf(iobuf + len, IOBUF_SIZE-3 - len,
-				"Location: %s/%s%s\r\n",
+		len += sprintf(iobuf + len, "Location: %s/%s%s\r\n",
 				found_moved_temporarily,
 				(g_query ? "?" : ""),
-				(g_query ? g_query : "")
-		);
-		if (len > IOBUF_SIZE-3)
-			len = IOBUF_SIZE-3;
+				(g_query ? g_query : ""));
 	}
 
 #if ENABLE_FEATURE_HTTPD_ERROR_PAGES
@@ -1121,7 +1186,7 @@
 		iobuf[len++] = '\n';
 		if (DEBUG) {
 			iobuf[len] = '\0';
-			fprintf(stderr, "headers: '%s'\n", iobuf);
+			fprintf(stderr, "headers1: '%s'\n", iobuf);
 		}
 		full_write(STDOUT_FILENO, iobuf, len);
 		if (DEBUG)
@@ -1131,7 +1196,7 @@
 #endif
 
 	if (file_size != -1) {    /* file */
-		strftime(date_str, sizeof(date_str), RFC1123FMT, gmtime_r(&last_mod, &tm));
+		strftime(tmp_str, sizeof(tmp_str), RFC1123FMT, gmtime(&last_mod));
 #if ENABLE_FEATURE_HTTPD_RANGES
 		if (responseNum == HTTP_PARTIAL_CONTENT) {
 			len += sprintf(iobuf + len,
@@ -1143,61 +1208,17 @@
 			file_size = range_end - range_start + 1;
 		}
 #endif
-
-//RFC 2616 4.4 Message Length
-// The transfer-length of a message is the length of the message-body as
-// it appears in the message; that is, after any transfer-codings have
-// been applied. When a message-body is included with a message, the
-// transfer-length of that body is determined by one of the following
-// (in order of precedence):
-// 1.Any response message which "MUST NOT" include a message-body (such
-//   as the 1xx, 204, and 304 responses and any response to a HEAD
-//   request) is always terminated by the first empty line after the
-//   header fields, regardless of the entity-header fields present in
-//   the message.
-// 2.If a Transfer-Encoding header field (section 14.41) is present and
-//   has any value other than "identity", then the transfer-length is
-//   defined by use of the "chunked" transfer-coding (section 3.6),
-//   unless the message is terminated by closing the connection.
-// 3.If a Content-Length header field (section 14.13) is present, its
-//   decimal value in OCTETs represents both the entity-length and the
-//   transfer-length. The Content-Length header field MUST NOT be sent
-//   if these two lengths are different (i.e., if a Transfer-Encoding
-//   header field is present). If a message is received with both a
-//   Transfer-Encoding header field and a Content-Length header field,
-//   the latter MUST be ignored.
-// 4.If the message uses the media type "multipart/byteranges" ...
-// 5.By the server closing the connection.
-//
-// (NB: standards do not define "Transfer-Length:" _header_,
-// transfer-length above is just a concept).
-
 		len += sprintf(iobuf + len,
 #if ENABLE_FEATURE_HTTPD_RANGES
 			"Accept-Ranges: bytes\r\n"
 #endif
-			"Last-Modified: %s\r\n"
-	/* Because of 4.4 (5), we can forgo sending of "Content-Length"
-	 * since we close connection afterwards, but it helps clients
-	 * to e.g. estimate download times, show progress bars etc.
-	 * Theoretically we should not send it if page is compressed,
-	 * but de-facto standard is to send it (see comment below).
-	 */
-			"Content-Length: %"OFF_FMT"u\r\n",
-				date_str,
+			"Last-Modified: %s\r\n%s %"OFF_FMT"u\r\n",
+				tmp_str,
+				content_gzip ? "Transfer-length:" : "Content-length:",
 				file_size
 		);
 	}
 
-	/* This should be "Transfer-Encoding", not "Content-Encoding":
-	 * "data is compressed for transfer", not "data is an archive".
-	 * But many clients were not handling "Transfer-Encoding" correctly
-	 * (they were not uncompressing gzipped pages, tried to show
-	 * raw compressed data), and servers worked around it by using
-	 * "Content-Encoding" instead... and this become de-facto standard.
-	 * https://bugzilla.mozilla.org/show_bug.cgi?id=68517
-	 * https://bugs.chromium.org/p/chromium/issues/detail?id=94730
-	 */
 	if (content_gzip)
 		len += sprintf(iobuf + len, "Content-Encoding: gzip\r\n");
 
@@ -1205,18 +1226,14 @@
 	iobuf[len++] = '\n';
 	if (infoString) {
 		len += sprintf(iobuf + len,
-				"<HTML><HEAD><TITLE>%u %s</TITLE></HEAD>\n"
-				"<BODY><H1>%u %s</H1>\n"
-				"%s\n"
-				"</BODY></HTML>\n",
-				responseNum, responseString,
+				"<HTML><HEAD><TITLE>%d %s</TITLE></HEAD>\n"
+				"<BODY><H1>%d %s</H1>\n%s\n</BODY></HTML>\n",
 				responseNum, responseString,
-				infoString
-		);
+				responseNum, responseString, infoString);
 	}
 	if (DEBUG) {
 		iobuf[len] = '\0';
-		fprintf(stderr, "headers: '%s'\n", iobuf);
+		fprintf(stderr, "headers2: '%s'\n", iobuf);
 	}
 	if (full_write(STDOUT_FILENO, iobuf, len) != len) {
 		if (verbose > 1)
@@ -1245,12 +1262,21 @@
 {
 	unsigned count;
 	char c;
+	struct pollfd pfd[1];
+
+	alarm(HEADER_READ_TIMEOUT);
 
 	count = 0;
 	while (1) {
 		if (hdr_cnt <= 0) {
-			alarm(HEADER_READ_TIMEOUT);
+			memset(pfd, 0, sizeof(pfd));
+			pfd[0].fd = STDIN_FILENO;
+			pfd[0].events = POLLIN;
+			(void)safe_poll(pfd, 1, -1);
+
 			hdr_cnt = safe_read(STDIN_FILENO, hdr_buf, sizeof_hdr_buf);
+			if (DEBUG)
+				fprintf(stderr, "get_line: read %d (%*s)\n", hdr_cnt, hdr_cnt, hdr_buf);
 			if (hdr_cnt <= 0)
 				goto ret;
 			hdr_ptr = hdr_buf;
@@ -1265,16 +1291,20 @@
 		if (count < (IOBUF_SIZE - 1))      /* check overflow */
 			count++;
 	}
+
  ret:
 	iobuf[count] = '\0';
+	if (DEBUG && count <= 0)
+		fprintf(stderr, "NO DATA\n");
+	if (DEBUG)
+		fprintf(stderr, "iobuf: %s\n", iobuf);
 	return count;
 }
 
 #if ENABLE_FEATURE_HTTPD_CGI || ENABLE_FEATURE_HTTPD_PROXY
 
 /* gcc 4.2.1 fares better with NOINLINE */
-static NOINLINE void cgi_io_loop_and_exit(int fromCgi_rd, int toCgi_wr, int post_len) NORETURN;
-static NOINLINE void cgi_io_loop_and_exit(int fromCgi_rd, int toCgi_wr, int post_len)
+static int cgi_io_loop(int fromCgi_rd, int toCgi_wr, long long post_len)
 {
 	enum { FROM_CGI = 1, TO_CGI = 2 }; /* indexes in pfd[] */
 	struct pollfd pfd[3];
@@ -1301,31 +1331,18 @@
 
 	/* NB: breaking out of this loop jumps to log_and_exit() */
 	out_cnt = 0;
-	pfd[FROM_CGI].fd = fromCgi_rd;
-	pfd[FROM_CGI].events = POLLIN;
-	pfd[TO_CGI].fd = toCgi_wr;
 	while (1) {
-		/* Note: even pfd[0].events == 0 won't prevent
-		 * revents == POLLHUP|POLLERR reports from closed stdin.
-		 * Setting fd to -1 works: */
-		pfd[0].fd = -1;
-		pfd[0].events = POLLIN;
-		pfd[0].revents = 0; /* probably not needed, paranoia */
-
-		/* We always poll this fd, thus kernel always sets revents: */
-		/*pfd[FROM_CGI].events = POLLIN; - moved out of loop */
-		/*pfd[FROM_CGI].revents = 0; - not needed */
-
-		/* gcc-4.8.0 still doesnt fill two shorts with one insn :( */
-		/* http://gcc.gnu.org/bugzilla/show_bug.cgi?id=47059 */
-		/* hopefully one day it will... */
-		pfd[TO_CGI].events = POLLOUT;
-		pfd[TO_CGI].revents = 0; /* needed! */
-
-		if (toCgi_wr && hdr_cnt <= 0) {
-			if (post_len > 0) {
-				/* Expect more POST data from network */
-				pfd[0].fd = 0;
+		memset(pfd, 0, sizeof(pfd));
+
+		pfd[FROM_CGI].fd = fromCgi_rd;
+		pfd[FROM_CGI].events = POLLIN;
+
+		if (toCgi_wr) {
+			pfd[TO_CGI].fd = toCgi_wr;
+			if (hdr_cnt > 0) {
+				pfd[TO_CGI].events = POLLOUT;
+			} else if (post_len > 0 || keep_alive) {
+				pfd[0].events = POLLIN;
 			} else {
 				/* post_len <= 0 && hdr_cnt <= 0:
 				 * no more POST data to CGI,
@@ -1337,7 +1354,7 @@
 		}
 
 		/* Now wait on the set of sockets */
-		count = safe_poll(pfd, hdr_cnt > 0 ? TO_CGI+1 : FROM_CGI+1, -1);
+		count = safe_poll(pfd, toCgi_wr ? TO_CGI+1 : FROM_CGI+1, -1);
 		if (count <= 0) {
 #if 0
 			if (safe_waitpid(pid, &status, WNOHANG) <= 0) {
@@ -1346,15 +1363,15 @@
 				continue;
 			}
 			if (DEBUG && WIFEXITED(status))
-				bb_error_msg("CGI exited, status=%u", WEXITSTATUS(status));
+				bb_error_msg("CGI exited, status=%d", WEXITSTATUS(status));
 			if (DEBUG && WIFSIGNALED(status))
-				bb_error_msg("CGI killed, signal=%u", WTERMSIG(status));
+				bb_error_msg("CGI killed, signal=%d", WTERMSIG(status));
 #endif
 			break;
 		}
 
 		if (pfd[TO_CGI].revents) {
-			/* hdr_cnt > 0 here due to the way poll() called */
+			/* hdr_cnt > 0 here due to the way pfd[TO_CGI].events set */
 			/* Have data from peer and can write to CGI */
 			count = safe_write(toCgi_wr, hdr_ptr, hdr_cnt);
 			/* Doesn't happen, we dont use nonblocking IO here
@@ -1366,25 +1383,32 @@
 				hdr_cnt -= count;
 			} else {
 				/* EOF/broken pipe to CGI, stop piping POST data */
-				hdr_cnt = post_len = 0;
+				hdr_cnt = 0;
+				post_len = -1;
 			}
 		}
 
 		if (pfd[0].revents) {
+			/* we received some more data (after post request) while
+			 * doing keep alive,  must be the next request,  trigger that */
+			if (post_len == 0 && keep_alive && !websocket)
+				return 1;
 			/* post_len > 0 && hdr_cnt == 0 here */
 			/* We expect data, prev data portion is eaten by CGI
 			 * and there *is* data to read from the peer
 			 * (POSTDATA) */
-			//count = post_len > (int)sizeof_hdr_buf ? (int)sizeof_hdr_buf : post_len;
+			//count = post_len > (int)sizeof(hdr_buf) ? (int)sizeof(hdr_buf) : post_len;
 			//count = safe_read(STDIN_FILENO, hdr_buf, count);
-			count = safe_read(STDIN_FILENO, hdr_buf, sizeof_hdr_buf);
+			count = safe_read(STDIN_FILENO, hdr_buf, COMMON_BUFSIZE);
 			if (count > 0) {
 				hdr_cnt = count;
 				hdr_ptr = hdr_buf;
-				post_len -= count;
+				/* post_len of 0 means we are just joining fd's now */
+				if (post_len > 0)
+					post_len -= count;
 			} else {
 				/* no more POST data can be read */
-				post_len = 0;
+				post_len = (count == 0 && keep_alive) ? 0 : -1;
 			}
 		}
 
@@ -1406,10 +1430,10 @@
 				 * CGI may output a few first bytes and then wait
 				 * for POSTDATA without closing stdout.
 				 * With full_read we may wait here forever. */
-				count = safe_read(fromCgi_rd, rbuf + out_cnt, IOBUF_SIZE - 8);
+				count = safe_read(fromCgi_rd, rbuf + out_cnt, PIPE_BUF - 8);
 				if (count <= 0) {
 					/* eof (or error) and there was no "HTTP",
-					 * send "HTTP/1.0 200 OK\r\n", then send received data */
+					 * so write it, then write received data */
 					if (out_cnt) {
 						full_write(STDOUT_FILENO, HTTP_200, sizeof(HTTP_200)-1);
 						full_write(STDOUT_FILENO, rbuf, out_cnt);
@@ -1420,11 +1444,10 @@
 				count = 0;
 				/* "Status" header format is: "Status: 302 Redirected\r\n" */
 				if (out_cnt >= 8 && memcmp(rbuf, "Status: ", 8) == 0) {
-					/* send "HTTP/1.0 " */
+					/* send "HTTP/1.1 " */
 					if (full_write(STDOUT_FILENO, HTTP_200, 9) != 9)
 						break;
-					/* skip "Status: " (including space, sending "HTTP/1.0  NNN" is wrong) */
-					rbuf += 8;
+					rbuf += 8; /* skip "Status: " */
 					count = out_cnt - 8;
 					out_cnt = -1; /* buffering off */
 				} else if (out_cnt >= 4) {
@@ -1447,7 +1470,7 @@
 					out_cnt = -1; /* buffering off */
 				}
 			} else {
-				count = safe_read(fromCgi_rd, rbuf, IOBUF_SIZE);
+				count = safe_read(fromCgi_rd, rbuf, PIPE_BUF);
 				if (count <= 0)
 					break;  /* eof (or error) */
 			}
@@ -1457,7 +1480,7 @@
 				fprintf(stderr, "cgi read %d bytes: '%.*s'\n", count, count, rbuf);
 		} /* if (pfd[FROM_CGI].revents) */
 	} /* while (1) */
-	log_and_exit();
+	return 0;
 }
 #endif
 
@@ -1478,18 +1501,24 @@
  * Parameters:
  * const char *url              The requested URL (with leading /).
  * const char *orig_uri         The original URI before rewriting (if any)
- * int post_len                 Length of the POST body.
+ * long long post_len                 Length of the POST body.
+ * const char *cookie           For set HTTP_COOKIE.
+ * const char *content_type     For set CONTENT_TYPE.
  */
 static void send_cgi_and_exit(
 		const char *url,
 		const char *orig_uri,
 		const char *request,
-		int post_len) NORETURN;
+		long long post_len,
+		const char *cookie,
+		const char *content_type) NORETURN;
 static void send_cgi_and_exit(
 		const char *url,
 		const char *orig_uri,
 		const char *request,
-		int post_len)
+		long long post_len,
+		const char *cookie,
+		const char *content_type)
 {
 	struct fd_pair fromCgi;  /* CGI -> httpd pipe */
 	struct fd_pair toCgi;    /* httpd -> CGI pipe */
@@ -1546,7 +1575,7 @@
 	/* (Older versions of bbox seem to do some decoding) */
 	setenv1("QUERY_STRING", g_query);
 	putenv((char*)"SERVER_SOFTWARE=busybox httpd/"BB_VER);
-	putenv((char*)"SERVER_PROTOCOL=HTTP/1.0");
+	putenv((char*)"SERVER_PROTOCOL=HTTP/1.1");
 	putenv((char*)"GATEWAY_INTERFACE=CGI/1.1");
 	/* Having _separate_ variables for IP and port defeats
 	 * the purpose of having socket abstraction. Which "port"
@@ -1567,14 +1596,26 @@
 #endif
 		}
 	}
+	setenv1("HTTP_USER_AGENT", user_agent);
+	if (http_accept)
+		setenv1("HTTP_ACCEPT", http_accept);
+	if (http_accept_language)
+		setenv1("HTTP_ACCEPT_LANGUAGE", http_accept_language);
 	if (post_len)
-		putenv(xasprintf("CONTENT_LENGTH=%u", post_len));
+		putenv(xasprintf("CONTENT_LENGTH=%lld", post_len));
+	if (cookie)
+		setenv1("HTTP_COOKIE", cookie);
+	if (content_type)
+		setenv1("CONTENT_TYPE", content_type);
 #if ENABLE_FEATURE_HTTPD_BASIC_AUTH
 	if (remoteuser) {
 		setenv1("REMOTE_USER", remoteuser);
 		putenv((char*)"AUTH_TYPE=Basic");
 	}
 #endif
+	if (referer)
+		setenv1("HTTP_REFERER", referer);
+	setenv1("HTTP_HOST", host); /* set to "" if NULL */
 	/* setenv1("SERVER_NAME", safe_gethostname()); - don't do this,
 	 * just run "env SERVER_NAME=xyz httpd ..." instead */
 
@@ -1660,10 +1701,14 @@
 	/* Restore variables possibly changed by child */
 	xfunc_error_retval = 0;
 
+	/* Force keep-alive off for CGI scripts */
+	keep_alive = 0;
+
 	/* Pump data */
 	close(fromCgi.wr);
 	close(toCgi.rd);
-	cgi_io_loop_and_exit(fromCgi.rd, toCgi.wr, post_len);
+	cgi_io_loop(fromCgi.rd, toCgi.wr, post_len);
+	log_and_exit();
 }
 
 #endif          /* FEATURE_HTTPD_CGI */
@@ -1712,8 +1757,8 @@
 	 * (happens if you abort downloads from local httpd): */
 	signal(SIGPIPE, SIG_IGN);
 
-	/* If not found, default is to not send "Content-type:" */
-	/*found_mime_type = NULL; - already is */
+	/* If not found, default is "application/octet-stream" */
+	found_mime_type = "application/octet-stream";
 	suffix = strrchr(url, '.');
 	if (suffix) {
 		static const char suffixTable[] ALIGN1 =
@@ -1843,34 +1888,29 @@
 	log_and_exit();
 }
 
-static void if_ip_denied_send_HTTP_FORBIDDEN_and_exit(unsigned remote_ip)
+static int checkPermIP(void)
 {
 	Htaccess_IP *cur;
 
 	for (cur = ip_a_d; cur; cur = cur->next) {
-#if DEBUG
-		fprintf(stderr,
-			"checkPermIP: '%s' ? '%u.%u.%u.%u/%u.%u.%u.%u'\n",
-			rmt_ip_str,
-			(unsigned char)(cur->ip >> 24),
-			(unsigned char)(cur->ip >> 16),
-			(unsigned char)(cur->ip >> 8),
-			(unsigned char)(cur->ip),
-			(unsigned char)(cur->mask >> 24),
-			(unsigned char)(cur->mask >> 16),
-			(unsigned char)(cur->mask >> 8),
-			(unsigned char)(cur->mask)
+		if (DEBUG)
+			fprintf(stderr,
+				"checkPermIP: '%s' ? '%u.%u.%u.%u/%u.%u.%u.%u'\n",
+				rmt_ip_str,
+				(unsigned char)(cur->ip >> 24),
+				(unsigned char)(cur->ip >> 16),
+				(unsigned char)(cur->ip >> 8),
+				(unsigned char)(cur->ip),
+				(unsigned char)(cur->mask >> 24),
+				(unsigned char)(cur->mask >> 16),
+				(unsigned char)(cur->mask >> 8),
+				(unsigned char)(cur->mask)
 		);
-#endif
-		if ((remote_ip & cur->mask) == cur->ip) {
-			if (cur->allow_deny == 'A')
-				return;
-			send_headers_and_exit(HTTP_FORBIDDEN);
-		}
+		if ((rmt_ip & cur->mask) == cur->ip)
+			return (cur->allow_deny == 'A'); /* A -> 1 */
 	}
 
-	if (flg_deny_all) /* depends on whether we saw "D:*" */
-		send_headers_and_exit(HTTP_FORBIDDEN);
+	return !flg_deny_all; /* depends on whether we saw "D:*" */
 }
 
 #if ENABLE_FEATURE_HTTPD_BASIC_AUTH
@@ -1942,6 +1982,7 @@
 		const char *dir_prefix;
 		size_t len;
 		int r;
+		int optional = 0;
 
 		dir_prefix = cur->before_colon;
 
@@ -1966,13 +2007,23 @@
 		/* Path match found */
 		prev = dir_prefix;
 
-		if (ENABLE_FEATURE_HTTPD_AUTH_MD5) {
+		if (ENABLE_PAM || ENABLE_FEATURE_HTTPD_AUTH_MD5) {
 			char *colon_after_user;
 			const char *passwd;
 # if ENABLE_FEATURE_SHADOWPASSWDS && !ENABLE_PAM
 			char sp_buf[256];
 # endif
 
+			// Allow if user in conf is empty. Lets subpaths be overriden with no auth
+			if (cur->after_colon[0] == ':') {
+				return 1;
+			}
+
+			// Allow if auth is optional and no user/password given
+			if (*user_and_passwd == '\0' && strcmp(cur->after_colon, "*:+") == 0) {
+				return 1;
+			}
+
 			colon_after_user = strchr(user_and_passwd, ':');
 			if (!colon_after_user)
 				goto bad_input;
@@ -1990,13 +2041,23 @@
 			if (!passwd)
 				goto bad_input;
 			passwd++;
-			if (passwd[0] == '*') {
+			if (passwd[0] == '*' || passwd[0] == '+') {
 # if ENABLE_PAM
 				struct pam_userinfo userinfo;
 				struct pam_conv conv_info = { &pam_talker, (void *) &userinfo };
 				pam_handle_t *pamh;
+				char **pamenv;
+				static char *pam_authed = NULL;
 
+				optional = passwd[0] == '+';
 				*colon_after_user = '\0';
+
+				if (pam_authed && strcmp(pam_authed, user_and_passwd) != 0) {
+					r = 0;
+					*colon_after_user = ':';
+					goto end_check_passwd;
+				}
+
 				userinfo.name = user_and_passwd;
 				userinfo.pw = colon_after_user + 1;
 				r = pam_start("httpd", user_and_passwd, &conv_info, &pamh) != PAM_SUCCESS;
@@ -2004,9 +2065,16 @@
 					r = pam_authenticate(pamh, PAM_DISALLOW_NULL_AUTHTOK) != PAM_SUCCESS
 					 || pam_acct_mgmt(pamh, PAM_DISALLOW_NULL_AUTHTOK)    != PAM_SUCCESS
 					;
+					for (pamenv = pam_getenvlist(pamh); pamenv && *pamenv; pamenv++)
+						putenv(*pamenv);
 					pam_end(pamh, PAM_SUCCESS);
 				}
 				*colon_after_user = ':';
+				if (r == 0) {
+					if (pam_authed)
+						free(pam_authed);
+					pam_authed = strdup(user_and_passwd);
+				}
 				goto end_check_passwd;
 # else
 #  if ENABLE_FEATURE_SHADOWPASSWDS
@@ -2039,7 +2107,7 @@
 			}
 			/* Else: passwd is from httpd.conf, it is either plaintext or encrypted */
 
-			if (passwd[0] == '$' && isdigit(passwd[1])) {
+			if (ENABLE_FEATURE_HTTPD_AUTH_MD5 && passwd[0] == '$' && isdigit(passwd[1])) {
 				char *encrypted;
 # if !ENABLE_PAM
  check_encrypted:
@@ -2066,7 +2134,11 @@
 			remoteuser = xstrndup(user_and_passwd,
 				strchrnul(user_and_passwd, ':') - user_and_passwd
 			);
-			return 1; /* Ok */
+			return 2; /* Ok */
+		}
+		// Let through on auth fail if password is optional
+		if (optional) {
+			return 1;
 		}
 	} /* for */
 
@@ -2080,11 +2152,43 @@
 {
 	Htaccess_Proxy *p;
 	for (p = proxy; p; p = p->next) {
-		if (is_prefixed_with(url, p->url_from))
+		if (strncmp(url, p->url_from, strlen(p->url_from)) == 0)
 			return p;
 	}
 	return NULL;
 }
+
+static void remove_header(char *header, int *header_length, const char *id)
+{
+	//assert(header);
+	//assert(header_length);
+	//assert(*header_length >= 0);
+	//assert(id);
+	//assert(strchr(id, ':'));
+	int id_length = strlen(id);
+
+	if (id_length <= 0)
+		return;
+
+	for (char *ptr = header; header + *header_length - ptr >= id_length; ) {
+		char *end = ptr;
+		do {
+			end = memchr(end, '\n', header + *header_length - end);
+			if (end == NULL) {
+				end = header + *header_length;
+			} else {
+				++end;
+			}
+		} while (end < header + *header_length && *end == ' ');
+		if (!strncasecmp(ptr, id, id_length)) {
+			memmove(ptr, end, header + *header_length - end);
+			*header_length -= end - ptr;
+		} else {
+			ptr = end;
+		}
+	}
+}
+
 #endif
 
 /*
@@ -2107,38 +2211,50 @@
 	char *urlcopy;
 	char *urlp;
 	char *tptr;
-	unsigned remote_ip;
-#if ENABLE_FEATURE_HTTPD_CGI
-	unsigned total_headers_len;
-#endif
 #if ENABLE_FEATURE_HTTPD_CGI
 	static const char request_HEAD[] ALIGN1 = "HEAD";
+	static const char request_DELETE[] ALIGN1 = "DELETE";
+	const char *request_list[] = {
+				request_GET,
+				request_HEAD,
+				request_DELETE,
+				"POST",
+				"PUT",
+				NULL
+			};
+	int i;
 	const char *prequest;
-	unsigned long length = 0;
-	enum CGI_type cgi_type = CGI_NONE;
+	char *cookie = NULL;
+	char *content_type = NULL;
+	unsigned long long length = 0;
 #elif ENABLE_FEATURE_HTTPD_PROXY
 #define prequest request_GET
-	unsigned long length = 0;
+	unsigned long long length = 0;
 #endif
 #if ENABLE_FEATURE_HTTPD_BASIC_AUTH
 	smallint authorized = -1;
 #endif
-	char *HTTP_slash;
+	smallint ip_allowed;
+#if ENABLE_FEATURE_HTTPD_PROXY
+	char *header_buf = header_buf; /* for gcc */
+	char *header_ptr = header_ptr;
+	Htaccess_Proxy *proxy_entry;
+#endif
 
 	/* Allocation of iobuf is postponed until now
 	 * (IOW, server process doesn't need to waste 8k) */
 	iobuf = xmalloc(IOBUF_SIZE);
 
-	remote_ip = 0;
+	rmt_ip = 0;
 	if (fromAddr->u.sa.sa_family == AF_INET) {
-		remote_ip = ntohl(fromAddr->u.sin.sin_addr.s_addr);
+		rmt_ip = ntohl(fromAddr->u.sin.sin_addr.s_addr);
 	}
 #if ENABLE_FEATURE_IPV6
 	if (fromAddr->u.sa.sa_family == AF_INET6
 	 && fromAddr->u.sin6.sin6_addr.s6_addr32[0] == 0
 	 && fromAddr->u.sin6.sin6_addr.s6_addr32[1] == 0
 	 && ntohl(fromAddr->u.sin6.sin6_addr.s6_addr32[2]) == 0xffff)
-		remote_ip = ntohl(fromAddr->u.sin6.sin6_addr.s6_addr32[3]);
+		rmt_ip = ntohl(fromAddr->u.sin6.sin6_addr.s6_addr32[3]);
 #endif
 	if (ENABLE_FEATURE_HTTPD_CGI || DEBUG || verbose) {
 		/* NB: can be NULL (user runs httpd -i by hand?) */
@@ -2151,7 +2267,13 @@
 		if (verbose > 2)
 			bb_error_msg("connected");
 	}
-	if_ip_denied_send_HTTP_FORBIDDEN_and_exit(remote_ip);
+
+next_request:
+
+	authorized = -1;
+	length = 0;
+
+	*iobuf = '\0';
 
 	/* Install timeout handler. get_line() needs it. */
 	signal(SIGALRM, send_REQUEST_TIMEOUT_and_exit);
@@ -2167,77 +2289,52 @@
 		send_headers_and_exit(HTTP_BAD_REQUEST);
 	*urlp++ = '\0';
 #if ENABLE_FEATURE_HTTPD_CGI
-	prequest = request_GET;
-	if (strcasecmp(iobuf, prequest) != 0) {
-		prequest = request_HEAD;
-		if (strcasecmp(iobuf, prequest) != 0) {
-			prequest = "POST";
-			if (strcasecmp(iobuf, prequest) != 0)
-				send_headers_and_exit(HTTP_NOT_IMPLEMENTED);
-		}
+	for (i = 0; request_list[i]; i++) {
+		prequest = request_list[i];
+		if (strcasecmp(iobuf, prequest) == 0)
+			break;
 	}
+	if (request_list[i] == NULL)
+		send_headers_and_exit(HTTP_NOT_IMPLEMENTED);
 #else
 	if (strcasecmp(iobuf, request_GET) != 0)
 		send_headers_and_exit(HTTP_NOT_IMPLEMENTED);
 #endif
 	// rfc2616: method and URI is separated by exactly one space
-	//urlp = skip_whitespace(urlp); - should not be necessary
+	//urlp = skip_whitespace(urlp);
 	if (urlp[0] != '/')
 		send_headers_and_exit(HTTP_BAD_REQUEST);
 
-	/* Find end of URL */
-	HTTP_slash = strchr(urlp, ' ');
+	/* Find end of URL and parse HTTP version, if any */
+	http_major_version = 0;
+	http_minor_version = 0;
+	tptr = strchrnul(urlp, ' ');
 	/* Is it " HTTP/"? */
-	if (!HTTP_slash || strncmp(HTTP_slash + 1, HTTP_200, 5) != 0)
-		send_headers_and_exit(HTTP_BAD_REQUEST);
-	*HTTP_slash++ = '\0';
+	if (tptr[0] && strncmp(tptr + 1, HTTP_200, 5) == 0) {
+		if (tptr[6] >= '0' && tptr[6] <= '9')
+			http_major_version = tptr[6] - '0';
+		if (tptr[8] >= '0' && tptr[8] <= '9')
+			http_minor_version = tptr[8] - '0';
+	}
+	*tptr = '\0';
+
+	if (http_major_version > 0 && http_minor_version > 0)
+		keep_alive = 1;
 
-	/* Copy URL from after "GET "/"POST " to stack-allocated char[] */
-	urlcopy = alloca((HTTP_slash - urlp) + 2 + strlen(index_page));
+	/* Copy URL from after "GET "/"POST " */
+	urlcopy = xmalloc((tptr - urlp) + 2 + strlen(index_page));
 	/*if (urlcopy == NULL)
 	 *	send_headers_and_exit(HTTP_INTERNAL_SERVER_ERROR);*/
 	strcpy(urlcopy, urlp);
 	/* NB: urlcopy ptr is never changed after this */
 
-#if ENABLE_FEATURE_HTTPD_PROXY
-	{
-		int proxy_fd;
-		len_and_sockaddr *lsa;
-		Htaccess_Proxy *proxy_entry = find_proxy_entry(urlcopy);
-
-		if (proxy_entry) {
-			if (verbose > 1)
-				bb_error_msg("proxy:%s", urlcopy);
-			lsa = host2sockaddr(proxy_entry->host_port, 80);
-			if (!lsa)
-				send_headers_and_exit(HTTP_INTERNAL_SERVER_ERROR);
-			proxy_fd = socket(lsa->u.sa.sa_family, SOCK_STREAM, 0);
-			if (proxy_fd < 0)
-				send_headers_and_exit(HTTP_INTERNAL_SERVER_ERROR);
-			if (connect(proxy_fd, &lsa->u.sa, lsa->len) < 0)
-				send_headers_and_exit(HTTP_INTERNAL_SERVER_ERROR);
-			/* Disable peer header reading timeout */
-			alarm(0);
-			/* Config directive was of the form:
-			 *   P:/url:[http://]hostname[:port]/new/path
-			 * When /urlSFX is requested, reverse proxy it
-			 * to http://hostname[:port]/new/pathSFX
-			 */
-			fdprintf(proxy_fd, "%s %s%s %s\r\n",
-					prequest, /* "GET" or "POST" */
-					proxy_entry->url_to, /* "/new/path" */
-					urlcopy + strlen(proxy_entry->url_from), /* "SFX" */
-					HTTP_slash /* "HTTP/xyz" */
-			);
-			cgi_io_loop_and_exit(proxy_fd, proxy_fd, /*max POST length:*/ INT_MAX);
-		}
-	}
-#endif
-
 	/* Extract url args if present */
-	g_query = strchr(urlcopy, '?');
-	if (g_query)
-		*g_query++ = '\0';
+	/* g_query = NULL; - already is */
+	tptr = strchr(urlcopy, '?');
+	if (tptr) {
+		*tptr++ = '\0';
+		g_query = tptr;
+	}
 
 	/* Decode URL escape sequences */
 	tptr = percent_decode_in_place(urlcopy, /*strict:*/ 1);
@@ -2277,7 +2374,7 @@
 			}
 		}
 		*++urlp = *tptr;
-		if (*tptr == '\0')
+		if (*urlp == '\0')
 			break;
  next_char:
 		tptr++;
@@ -2295,197 +2392,190 @@
 		bb_error_msg("url:%s", urlcopy);
 
 	tptr = urlcopy;
-	while ((tptr = strchr(tptr + 1, '/')) != NULL) {
+	ip_allowed = checkPermIP();
+	while (ip_allowed && (tptr = strchr(tptr + 1, '/')) != NULL) {
 		/* have path1/path2 */
 		*tptr = '\0';
 		if (is_directory(urlcopy + 1, /*followlinks:*/ 1)) {
 			/* may have subdir config */
 			parse_conf(urlcopy + 1, SUBDIR_PARSE);
-			if_ip_denied_send_HTTP_FORBIDDEN_and_exit(remote_ip);
+			ip_allowed = checkPermIP();
 		}
 		*tptr = '/';
 	}
 
-	tptr = urlcopy + 1;      /* skip first '/' */
-
-#if ENABLE_FEATURE_HTTPD_CGI
-	if (is_prefixed_with(tptr, "cgi-bin/")) {
-		if (tptr[8] == '\0') {
-			/* protect listing "cgi-bin/" */
-			send_headers_and_exit(HTTP_FORBIDDEN);
-		}
-		cgi_type = CGI_NORMAL;
-	}
+#if ENABLE_FEATURE_HTTPD_PROXY
+	proxy_entry = find_proxy_entry(urlcopy);
+	if (proxy_entry)
+		header_buf = header_ptr = xmalloc(IOBUF_SIZE);
 #endif
 
-	if (urlp[-1] == '/') {
-		/* When index_page string is appended to <dir>/ URL, it overwrites
-		 * the query string. If we fall back to call /cgi-bin/index.cgi,
-		 * query string would be lost and not available to the CGI.
-		 * Work around it by making a deep copy.
-		 */
-		if (ENABLE_FEATURE_HTTPD_CGI)
-			g_query = xstrdup(g_query); /* ok for NULL too */
-		strcpy(urlp, index_page);
-	}
-	if (stat(tptr, &sb) == 0) {
-#if ENABLE_FEATURE_HTTPD_CONFIG_WITH_SCRIPT_INTERPR
-		char *suffix = strrchr(tptr, '.');
-		if (suffix) {
-			Htaccess *cur;
-			for (cur = script_i; cur; cur = cur->next) {
-				if (strcmp(cur->before_colon + 1, suffix) == 0) {
-					cgi_type = CGI_INTERPRETER;
-					break;
-				}
-			}
-		}
-#endif
-		if (!found_moved_temporarily) {
-			file_size = sb.st_size;
-			last_mod = sb.st_mtime;
-		}
-	}
-#if ENABLE_FEATURE_HTTPD_CGI
-	else if (urlp[-1] == '/') {
-		/* It's a dir URL and there is no index.html
-		 * Try cgi-bin/index.cgi */
-		if (access("/cgi-bin/index.cgi"+1, X_OK) == 0) {
-			cgi_type = CGI_INDEX;
-		}
-	}
-#endif
-	urlp[0] = '\0';
+	if (http_major_version >= 0) {
+		/* Request was with "... HTTP/nXXX", and n >= 0 */
 
-#if ENABLE_FEATURE_HTTPD_CGI
-	total_headers_len = 0;
-#endif
+		/* Read until blank line */
+		while (1) {
+			if (!get_line())
+				break; /* EOF or error or empty line */
+			if (DEBUG)
+				bb_error_msg("header: '%s'", iobuf);
 
-	/* Read until blank line */
-	while (1) {
-		unsigned iobuf_len = get_line();
-		if (!iobuf_len)
-			break; /* EOF or error or empty line */
-#if ENABLE_FEATURE_HTTPD_CGI
-		/* Prevent unlimited growth of HTTP_xyz envvars */
-		total_headers_len += iobuf_len;
-		if (total_headers_len >= MAX_HTTP_HEADERS_SIZE)
-			send_headers_and_exit(HTTP_ENTITY_TOO_LARGE);
+#if ENABLE_FEATURE_HTTPD_PROXY
+			/* We need 2 more bytes for yet another "\r\n" -
+			 * see near fdprintf(proxy_fd...) further below */
+			if (proxy_entry && (header_ptr - header_buf) < IOBUF_SIZE - 2) {
+				int len = strlen(iobuf);
+				if (len > IOBUF_SIZE - (header_ptr - header_buf) - 4)
+					len = IOBUF_SIZE - (header_ptr - header_buf) - 4;
+				memcpy(header_ptr, iobuf, len);
+				header_ptr += len;
+				header_ptr[0] = '\r';
+				header_ptr[1] = '\n';
+				header_ptr += 2;
+			}
 #endif
-		if (DEBUG)
-			bb_error_msg("header: '%s'", iobuf);
+
 #if ENABLE_FEATURE_HTTPD_CGI || ENABLE_FEATURE_HTTPD_PROXY
-		/* Try and do our best to parse more lines */
-		if (STRNCASECMP(iobuf, "Content-Length:") == 0) {
-			/* extra read only for POST */
-			if (prequest != request_GET
+			/* Try and do our best to parse more lines */
+			if ((STRNCASECMP(iobuf, "Content-length:") == 0)) {
+				/* extra read only for POST */
+				if (prequest != request_GET
 # if ENABLE_FEATURE_HTTPD_CGI
-			 && prequest != request_HEAD
+				 && prequest != request_HEAD
+				 && prequest != request_DELETE
 # endif
-			) {
-				tptr = skip_whitespace(iobuf + sizeof("Content-Length:") - 1);
-				if (!tptr[0])
-					send_headers_and_exit(HTTP_BAD_REQUEST);
-				/* not using strtoul: it ignores leading minus! */
-				length = bb_strtou(tptr, NULL, 10);
-				/* length is "ulong", but we need to pass it to int later */
-				if (errno || length > INT_MAX)
-					send_headers_and_exit(HTTP_BAD_REQUEST);
+				) {
+					tptr = skip_whitespace(iobuf + sizeof("Content-length:") - 1);
+					if (!tptr[0])
+						send_headers_and_exit(HTTP_BAD_REQUEST);
+					/* not using strtoul: it ignores leading minus! */
+					length = bb_strtoull(tptr, NULL, 10);
+					/* length is "unsigned long long", but we need to pass it to long long later */
+					if (errno || length > LLONG_MAX)
+						send_headers_and_exit(HTTP_BAD_REQUEST);
+				}
+			}
+#endif
+#if ENABLE_FEATURE_HTTPD_CGI
+			else if (STRNCASECMP(iobuf, "Cookie:") == 0) {
+				cookie = xstrdup(skip_whitespace(iobuf + sizeof("Cookie:")-1));
+			} else if (STRNCASECMP(iobuf, "Content-Type:") == 0) {
+				content_type = xstrdup(skip_whitespace(iobuf + sizeof("Content-Type:")-1));
+			} else if (STRNCASECMP(iobuf, "Referer:") == 0) {
+				referer = xstrdup(skip_whitespace(iobuf + sizeof("Referer:")-1));
+			} else if (STRNCASECMP(iobuf, "User-Agent:") == 0) {
+				user_agent = xstrdup(skip_whitespace(iobuf + sizeof("User-Agent:")-1));
+			} else if (STRNCASECMP(iobuf, "Host:") == 0) {
+				host = xstrdup(skip_whitespace(iobuf + sizeof("Host:")-1));
+			} else if (STRNCASECMP(iobuf, "Accept:") == 0) {
+				http_accept = xstrdup(skip_whitespace(iobuf + sizeof("Accept:")-1));
+			} else if (STRNCASECMP(iobuf, "Accept-Language:") == 0) {
+				http_accept_language = xstrdup(skip_whitespace(iobuf + sizeof("Accept-Language:")-1));
 			}
-			continue;
-		}
 #endif
 #if ENABLE_FEATURE_HTTPD_BASIC_AUTH
-		if (STRNCASECMP(iobuf, "Authorization:") == 0) {
-			/* We only allow Basic credentials.
-			 * It shows up as "Authorization: Basic <user>:<passwd>" where
-			 * "<user>:<passwd>" is base64 encoded.
-			 */
-			tptr = skip_whitespace(iobuf + sizeof("Authorization:")-1);
-			if (STRNCASECMP(tptr, "Basic") == 0) {
+			if (STRNCASECMP(iobuf, "Authorization:") == 0) {
+				/* We only allow Basic credentials.
+				 * It shows up as "Authorization: Basic <user>:<passwd>" where
+				 * "<user>:<passwd>" is base64 encoded.
+				 */
+				tptr = skip_whitespace(iobuf + sizeof("Authorization:")-1);
+				if (STRNCASECMP(tptr, "Basic") != 0)
+					continue;
 				tptr += sizeof("Basic")-1;
 				/* decodeBase64() skips whitespace itself */
 				decodeBase64(tptr);
 				authorized = check_user_passwd(urlcopy, tptr);
-				continue;
 			}
-		}
 #endif
 #if ENABLE_FEATURE_HTTPD_RANGES
-		if (STRNCASECMP(iobuf, "Range:") == 0) {
-			/* We know only bytes=NNN-[MMM] */
-			char *s = skip_whitespace(iobuf + sizeof("Range:")-1);
-			if (is_prefixed_with(s, "bytes=")) {
-				s += sizeof("bytes=")-1;
-				range_start = BB_STRTOOFF(s, &s, 10);
-				if (s[0] != '-' || range_start < 0) {
-					range_start = -1;
-				} else if (s[1]) {
-					range_end = BB_STRTOOFF(s+1, NULL, 10);
-					if (errno || range_end < range_start)
+			if (STRNCASECMP(iobuf, "Range:") == 0) {
+				/* We know only bytes=NNN-[MMM] */
+				char *s = skip_whitespace(iobuf + sizeof("Range:")-1);
+				if (strncmp(s, "bytes=", 6) == 0) {
+					s += sizeof("bytes=")-1;
+					range_start = BB_STRTOOFF(s, &s, 10);
+					if (s[0] != '-' || range_start < 0) {
 						range_start = -1;
+					} else if (s[1]) {
+						range_end = BB_STRTOOFF(s+1, NULL, 10);
+						if (errno || range_end < range_start)
+							range_start = -1;
+					}
 				}
 			}
-			continue;
-		}
 #endif
 #if ENABLE_FEATURE_HTTPD_GZIP
-		if (STRNCASECMP(iobuf, "Accept-Encoding:") == 0) {
-			/* Note: we do not support "gzip;q=0"
-			 * method of _disabling_ gzip
-			 * delivery. No one uses that, though */
-			const char *s = strstr(iobuf, "gzip");
-			if (s) {
-				// want more thorough checks?
-				//if (s[-1] == ' '
-				// || s[-1] == ','
-				// || s[-1] == ':'
-				//) {
-					content_gzip = 1;
-				//}
-			}
-			continue;
-		}
-#endif
-#if ENABLE_FEATURE_HTTPD_CGI
-		if (cgi_type != CGI_NONE) {
-			bool ct = (STRNCASECMP(iobuf, "Content-Type:") == 0);
-			char *cp;
-			char *colon = strchr(iobuf, ':');
-
-			if (!colon)
-				continue;
-			cp = iobuf;
-			while (cp < colon) {
-				/* a-z => A-Z, not-alnum => _ */
-				char c = (*cp & ~0x20); /* toupper for A-Za-z, undef for others */
-				if ((unsigned)(c - 'A') <= ('Z' - 'A')) {
-					*cp++ = c;
-					continue;
+			if (STRNCASECMP(iobuf, "Accept-Encoding:") == 0) {
+				/* Note: we do not support "gzip;q=0"
+				 * method of _disabling_ gzip
+				 * delivery. No one uses that, though */
+				const char *s = strstr(iobuf, "gzip");
+				if (s) {
+					// want more thorough checks?
+					//if (s[-1] == ' '
+					// || s[-1] == ','
+					// || s[-1] == ':'
+					//) {
+						content_gzip = 1;
+					//}
 				}
-				if (!isdigit(*cp))
-					*cp = '_';
-				cp++;
-			}
-			/* "Content-Type:" gets no HTTP_ prefix, all others do */
-			cp = xasprintf(ct ? "HTTP_%.*s=%s" + 5 : "HTTP_%.*s=%s",
-				(int)(colon - iobuf), iobuf,
-				skip_whitespace(colon + 1)
-			);
-			putenv(cp);
-		}
+			}
 #endif
-	} /* while extra header reading */
+			if (STRNCASECMP(iobuf, "Connection: keep-alive") == 0) {
+				keep_alive = 1;
+			}
+			// Keep WebSockets alive
+			if (STRNCASECMP(iobuf, "Connection: keep-alive, Upgrade") == 0) {
+				keep_alive = 1;
+			}
+			if (STRNCASECMP(iobuf, "Upgrade: websocket") == 0) {
+				websocket = 1;
+			}
+			if (STRNCASECMP(iobuf, "If-Modified-Since:") == 0) {
+				if_modified_since = xstrdup(skip_whitespace(iobuf + sizeof("If-Modified-Since:")-1));
+			}
+		} /* while extra header reading */
+	}
 
 	/* We are done reading headers, disable peer timeout */
 	alarm(0);
 
-	if (strcmp(bb_basename(urlcopy), HTTPD_CONF) == 0) {
+	if (strcmp(bb_basename(urlcopy), HTTPD_CONF) == 0 || !ip_allowed) {
 		/* protect listing [/path]/httpd.conf or IP deny */
 		send_headers_and_exit(HTTP_FORBIDDEN);
 	}
 
 #if ENABLE_FEATURE_HTTPD_BASIC_AUTH
+//#if ENABLE_FEATURE_HTTPD_COOKIE_AUTH
+	/* Check for an auth token in the cookie -- may succeed over a failed Basic auth */
+	if (authorized <= 1) {
+		char *token, *s, *c = NULL;
+		const char *delim;
+		/* Only allow cookies from HTTP get requests. Other HTTP methods must explicitly
+		 * include the cookie in the query string. This mitigates malicious POSTs using
+		 * CSRF. */
+		if (prequest == request_GET && cookie) {
+			c = xstrdup(cookie);
+			delim = "; ";
+		} else if (prequest != request_GET && g_query) {
+			c = xstrdup(g_query);
+			delim = "&";
+		}
+
+		if (c) {
+			token = strstr(c, "auth=");
+			if (token) {
+				token += strlen("auth=");
+				s = strpbrk(token, delim);
+				if (s) *s = '\0';
+				authorized = check_user_passwd(urlcopy, token);
+			}
+			free(c);
+		}
+	}
+#endif
+#if ENABLE_FEATURE_HTTPD_BASIC_AUTH
 	/* Case: no "Authorization:" was seen, but page might require passwd.
 	 * Check that with dummy user:pass */
 	if (authorized < 0)
@@ -2498,27 +2588,165 @@
 		send_headers_and_exit(HTTP_MOVED_TEMPORARILY);
 	}
 
+#if ENABLE_FEATURE_HTTPD_PROXY
+	if (proxy_entry != NULL) {
+		int proxy_fd, hlen;
+		len_and_sockaddr *lsa;
+
+		proxy_fd = socket(AF_INET, SOCK_STREAM, 0);
+		if (proxy_fd < 0)
+			send_headers_and_exit(HTTP_INTERNAL_SERVER_ERROR);
+		lsa = host2sockaddr(proxy_entry->host_port, 80);
+		if (lsa == NULL)
+			send_headers_and_exit(HTTP_INTERNAL_SERVER_ERROR);
+		if (connect(proxy_fd, &lsa->u.sa, lsa->len) < 0)
+			send_headers_and_exit(HTTP_INTERNAL_SERVER_ERROR);
+		free(lsa);
+		fdprintf(proxy_fd, "%s %s%s%s%s HTTP/%d.%d\r\n",
+				prequest, /* GET or POST */
+				proxy_entry->url_to, /* url part 1 */
+				urlcopy + strlen(proxy_entry->url_from), /* url part 2 */
+				(g_query ? "?" : ""), /* "?" (maybe) */
+				(g_query ? g_query : ""), /* query string (maybe) */
+				http_major_version, http_minor_version);
+		/* RFC7239 support */
+		if (forwarded_flags & FORWARDED_REMOVE) {
+			/* delete any Forwarded: headers */
+			hlen = header_ptr - header_buf;
+			remove_header(header_buf, &hlen, "forwarded:");
+			header_ptr = header_buf + hlen;
+		}
+		if (forwarded_flags & FORWARDED_APPEND) {
+			/* Append Forwarded: header */
+			char *tmp = NULL, faddr[128] = {0};
+			hlen = asprintf(&tmp, "Forwarded: for=%s%s%s\r\n",
+					fromAddr->u.sa.sa_family == AF_INET6 ? "\"" : "",
+					inet_ntop(fromAddr->u.sa.sa_family,
+#if ENABLE_FEATURE_IPV6
+						fromAddr->u.sa.sa_family == AF_INET6 ?
+							(void *)&fromAddr->u.sin6.sin6_addr
+							:
+#endif
+							(void *)&fromAddr->u.sin.sin_addr,
+						faddr, 128),
+					fromAddr->u.sa.sa_family == AF_INET6 ? "\"" : "");
+			/* don't overflow IOBUF_SIZE - 2 (\r\n space) */
+			if (header_ptr - header_buf + hlen < (IOBUF_SIZE - 2)) {
+				memcpy(header_ptr, tmp, hlen);
+				header_ptr += hlen;
+			}
+			free(tmp);
+		}
+		header_ptr[0] = '\r';
+		header_ptr[1] = '\n';
+		header_ptr += 2;
+		write(proxy_fd, header_buf, header_ptr - header_buf);
+		free(header_buf); /* on the order of 8k, free it */
+		/*
+		 * if we are keeping the connection alive then process the next
+		 * request
+		 */
+		if (cgi_io_loop(proxy_fd, proxy_fd, length)) {
+			close(proxy_fd);
+
+			// Loop variables
+			free(urlcopy);
+			urlcopy = NULL;
+			free(cookie);
+			cookie = NULL;
+			free(content_type);
+			content_type = NULL;
+
+			// Global variables
+			free(referer);
+			referer = NULL;
+			free(user_agent);
+			user_agent = NULL;
+			free(host);
+			host = NULL;
+			free(http_accept);
+			http_accept = NULL;
+			free(http_accept_language);
+			http_accept_language = NULL;
+			free(if_modified_since);
+			if_modified_since = NULL;
+			free(remoteuser);
+			remoteuser = NULL;
+			g_query = NULL;
+
+			goto next_request;
+		}
+		log_and_exit();
+	}
+#endif
+
 	tptr = urlcopy + 1;      /* skip first '/' */
 
 #if ENABLE_FEATURE_HTTPD_CGI
-	if (cgi_type != CGI_NONE) {
-		send_cgi_and_exit(
-			(cgi_type == CGI_INDEX) ? "/cgi-bin/index.cgi"
-			/*CGI_NORMAL or CGI_INTERPRETER*/ : urlcopy,
-			urlcopy, prequest, length
-		);
+	if (strncmp(tptr, "cgi-bin/", 8) == 0) {
+		if (tptr[8] == '\0') {
+			/* protect listing "cgi-bin/" */
+			send_headers_and_exit(HTTP_FORBIDDEN);
+		}
+		send_cgi_and_exit(urlcopy, urlcopy, prequest, length, cookie, content_type);
 	}
 #endif
 
 	if (urlp[-1] == '/') {
+		/* When index_page string is appended to <dir>/ URL, it overwrites
+		 * the query string. If we fall back to call /cgi-bin/index.cgi,
+		 * query string would be lost and not available to the CGI.
+		 * Work around it by making a deep copy.
+		 */
+		if (ENABLE_FEATURE_HTTPD_CGI)
+			g_query = xstrdup(g_query); /* ok for NULL too */
 		strcpy(urlp, index_page);
 	}
-
+	if (stat(tptr, &sb) == 0) {
+#if ENABLE_FEATURE_HTTPD_CONFIG_WITH_SCRIPT_INTERPR
+		char *suffix = strrchr(tptr, '.');
+		if (suffix) {
+			Htaccess *cur;
+			for (cur = script_i; cur; cur = cur->next) {
+				if (strcmp(cur->before_colon + 1, suffix) == 0) {
+					send_cgi_and_exit(urlcopy, urlcopy, prequest, length, cookie, content_type);
+				}
+			}
+		}
+#endif
+		file_size = sb.st_size;
+		last_mod = sb.st_mtime;
+		if (if_modified_since) {
+			char tmp_str[80];
+			strftime(tmp_str, sizeof(tmp_str), RFC1123FMT, gmtime(&last_mod));
+			if (strcmp(tmp_str, if_modified_since) == 0) {
+				send_headers_and_exit(HTTP_NOT_MODIFIED);
+			}
+		}
+	}
 #if ENABLE_FEATURE_HTTPD_CGI
-	if (prequest != request_GET && prequest != request_HEAD) {
+	else if (urlp[-1] == '/') {
+		/* It's a dir URL and there is no index.html
+		 * Try cgi-bin/index.cgi */
+		if (access("/cgi-bin/index.cgi"+1, X_OK) == 0) {
+			urlp[0] = '\0'; /* remove index_page */
+			send_cgi_and_exit("/cgi-bin/index.cgi", urlcopy, prequest, length, cookie, content_type);
+		}
+	}
+	/* else fall through to send_file, it errors out if open fails: */
+
+	if (prequest != request_GET && prequest != request_HEAD &&
+			prequest != request_DELETE) {
 		/* POST for files does not make sense */
 		send_headers_and_exit(HTTP_NOT_IMPLEMENTED);
 	}
+	if (strncmp(tptr, "ccgi-bin/", 9) == 0) {
+		if (tptr[9] == '\0') {
+			/* protect listing "cgi-bin/" */
+			send_headers_and_exit(HTTP_FORBIDDEN);
+		}
+		send_cgi_and_exit(urlcopy, urlcopy, prequest, length, cookie, content_type);
+	}
 	send_file_and_exit(tptr,
 		(prequest != request_HEAD ? SEND_HEADERS_AND_BODY : SEND_HEADERS)
 	);
@@ -2527,6 +2755,8 @@
 #endif
 }
 
+static const int const_int_1 = 1;
+
 /*
  * The main http server function.
  * Given a socket, listen for new connections and farm out
@@ -2537,15 +2767,30 @@
 static void mini_httpd(int server_socket) NORETURN;
 static void mini_httpd(int server_socket)
 {
+	int children = 0;
 	/* NB: it's best to not use xfuncs in this loop before fork().
 	 * Otherwise server may die on transient errors (temporary
 	 * out-of-memory condition, etc), which is Bad(tm).
 	 * Try to do any dangerous calls after fork.
 	 */
 	while (1) {
-		int n;
+		int n, status;
+		pid_t pid;
 		len_and_sockaddr fromAddr;
 
+		if (max_instances != 0 && children >= max_instances) {
+			pid = waitpid(-1, &status, 0);
+			if (pid != 0 && pid != -1) {
+				children--;
+			}
+			continue;
+		} else if (children > 0) {
+			pid = waitpid(-1, &status, WNOHANG);
+			if (pid != 0 && pid != -1) {
+				children--;
+			}
+		}
+
 		/* Wait for connections... */
 		fromAddr.len = LSA_SIZEOF_SA;
 		n = accept(server_socket, &fromAddr.u.sa, &fromAddr.len);
@@ -2553,9 +2798,10 @@
 			continue;
 
 		/* set the KEEPALIVE option to cull dead connections */
-		setsockopt_keepalive(n);
+		setsockopt(n, SOL_SOCKET, SO_KEEPALIVE, &const_int_1, sizeof(const_int_1));
 
-		if (fork() == 0) {
+		pid = fork();
+		if (pid == 0) {
 			/* child */
 			/* Do not reload config on HUP */
 			signal(SIGHUP, SIG_IGN);
@@ -2564,7 +2810,8 @@
 			xdup2(0, 1);
 
 			handle_incoming_and_exit(&fromAddr);
-		}
+		} else if (pid > 0)
+			children++;
 		/* parent, or fork failed */
 		close(n);
 	} /* while (1) */
@@ -2575,6 +2822,7 @@
 static void mini_httpd_nommu(int server_socket, int argc, char **argv)
 {
 	char *argv_copy[argc + 2];
+	int children = 0;
 
 	argv_copy[0] = argv[0];
 	argv_copy[1] = (char*)"-i";
@@ -2586,17 +2834,34 @@
 	 * Try to do any dangerous calls after fork.
 	 */
 	while (1) {
-		int n;
+		int n, status;
+		pid_t pid;
+		len_and_sockaddr fromAddr;
+
+		if (max_instances != 0 && children >= max_instances) {
+			pid = waitpid(-1, &status, 0);
+			if (pid != 0 && pid != -1) {
+				children--;
+			}
+			continue;
+		} else if (children > 0) {
+			pid = waitpid(-1, &status, WNOHANG);
+			if (pid != 0 && pid != -1) {
+				children--;
+			}
+		}
 
 		/* Wait for connections... */
-		n = accept(server_socket, NULL, NULL);
+		fromAddr.len = LSA_SIZEOF_SA;
+		n = accept(server_socket, &fromAddr.u.sa, &fromAddr.len);
 		if (n < 0)
 			continue;
 
 		/* set the KEEPALIVE option to cull dead connections */
-		setsockopt_keepalive(n);
+		setsockopt(n, SOL_SOCKET, SO_KEEPALIVE, &const_int_1, sizeof(const_int_1));
 
-		if (vfork() == 0) {
+		pid = vfork();
+		if (pid == 0) {
 			/* child */
 			/* Do not reload config on HUP */
 			signal(SIGHUP, SIG_IGN);
@@ -2606,7 +2871,8 @@
 
 			/* Run a copy of ourself in inetd mode */
 			re_exec(argv_copy);
-		}
+		} else if (pid > 0)
+			children++;
 		argv_copy[0][0] &= 0x7f;
 		/* parent, or vfork failed */
 		close(n);
@@ -2642,10 +2908,13 @@
 	c_opt_config_file = 0,
 	d_opt_decode_url,
 	h_opt_home_httpd,
+	n_opt_max_instances,
 	IF_FEATURE_HTTPD_ENCODE_URL_STR(e_opt_encode_url,)
+	IF_FEATURE_HTTPD_ENCODE_URL_STR(e_opt_decode_html,)
 	IF_FEATURE_HTTPD_BASIC_AUTH(    r_opt_realm     ,)
 	IF_FEATURE_HTTPD_AUTH_MD5(      m_opt_md5       ,)
 	IF_FEATURE_HTTPD_SETUID(        u_opt_setuid    ,)
+	IF_FEATURE_HTTPD_PROXY(         u_opt_forwarded ,)
 	p_opt_port      ,
 	p_opt_inetd     ,
 	p_opt_foreground,
@@ -2653,10 +2922,13 @@
 	OPT_CONFIG_FILE = 1 << c_opt_config_file,
 	OPT_DECODE_URL  = 1 << d_opt_decode_url,
 	OPT_HOME_HTTPD  = 1 << h_opt_home_httpd,
+	OPT_MAX_INSTANCES = 1 << n_opt_max_instances,
 	OPT_ENCODE_URL  = IF_FEATURE_HTTPD_ENCODE_URL_STR((1 << e_opt_encode_url)) + 0,
+	OPT_DECODE_HTML = IF_FEATURE_HTTPD_ENCODE_URL_STR((1 << e_opt_decode_html)) + 0,
 	OPT_REALM       = IF_FEATURE_HTTPD_BASIC_AUTH(    (1 << r_opt_realm     )) + 0,
 	OPT_MD5         = IF_FEATURE_HTTPD_AUTH_MD5(      (1 << m_opt_md5       )) + 0,
 	OPT_SETUID      = IF_FEATURE_HTTPD_SETUID(        (1 << u_opt_setuid    )) + 0,
+	OPT_FORWARDED   = IF_FEATURE_HTTPD_PROXY(         (1 << u_opt_forwarded )) + 0,
 	OPT_PORT        = 1 << p_opt_port,
 	OPT_INETD       = 1 << p_opt_inetd,
 	OPT_FOREGROUND  = 1 << p_opt_foreground,
@@ -2670,8 +2942,10 @@
 	int server_socket = server_socket; /* for gcc */
 	unsigned opt;
 	char *url_for_decode;
+	char *n_max_instances;
 	IF_FEATURE_HTTPD_ENCODE_URL_STR(const char *url_for_encode;)
 	IF_FEATURE_HTTPD_SETUID(const char *s_ugid = NULL;)
+	IF_FEATURE_HTTPD_PROXY(const char *forwarded = NULL;)
 	IF_FEATURE_HTTPD_SETUID(struct bb_uidgid_t ugid;)
 	IF_FEATURE_HTTPD_AUTH_MD5(const char *pass;)
 
@@ -2686,21 +2960,22 @@
 	/* We do not "absolutize" path given by -h (home) opt.
 	 * If user gives relative path in -h,
 	 * $SCRIPT_FILENAME will not be set. */
-	opt = getopt32(argv, "^"
-			"c:d:h:"
+	opt = getopt32(argv, "c:d:h:n:"
 			IF_FEATURE_HTTPD_ENCODE_URL_STR("e:")
+			IF_FEATURE_HTTPD_ENCODE_URL_STR("D:")
 			IF_FEATURE_HTTPD_BASIC_AUTH("r:")
 			IF_FEATURE_HTTPD_AUTH_MD5("m:")
 			IF_FEATURE_HTTPD_SETUID("u:")
-			"p:ifv"
-			"\0"
-			/* -v counts, -i implies -f */
-			"vv:if",
+			IF_FEATURE_HTTPD_PROXY("F:")
+			"p:ifv" "\0" "vv:if" /* -v counts, -i implies -f */,
 			&opt_c_configFile, &url_for_decode, &home_httpd
+			, &n_max_instances
+			IF_FEATURE_HTTPD_ENCODE_URL_STR(, &url_for_encode)
 			IF_FEATURE_HTTPD_ENCODE_URL_STR(, &url_for_encode)
 			IF_FEATURE_HTTPD_BASIC_AUTH(, &g_realm)
 			IF_FEATURE_HTTPD_AUTH_MD5(, &pass)
 			IF_FEATURE_HTTPD_SETUID(, &s_ugid)
+			IF_FEATURE_HTTPD_PROXY(, &forwarded)
 			, &bind_addr_or_port
 			, &verbose
 		);
@@ -2708,11 +2983,18 @@
 		fputs(percent_decode_in_place(url_for_decode, /*strict:*/ 0), stdout);
 		return 0;
 	}
+	if (opt & OPT_MAX_INSTANCES)
+		max_instances = atoi(n_max_instances);
 #if ENABLE_FEATURE_HTTPD_ENCODE_URL_STR
 	if (opt & OPT_ENCODE_URL) {
 		fputs(encodeString(url_for_encode), stdout);
 		return 0;
 	}
+	if (opt & OPT_DECODE_HTML) {
+		fputs(decodeString(url_for_encode), stdout);
+		return 0;
+	}
+
 #endif
 #if ENABLE_FEATURE_HTTPD_AUTH_MD5
 	if (opt & OPT_MD5) {
@@ -2730,6 +3012,21 @@
 		xget_uidgid(&ugid, s_ugid);
 	}
 #endif
+#if ENABLE_FEATURE_HTTPD_PROXY
+	forwarded_flags = 0;
+	if (opt & OPT_FORWARDED) {
+		if (strcasecmp(forwarded, "unchanged") == 0)
+			forwarded_flags = 0;
+		else if (strcasecmp(forwarded, "remove") == 0)
+			forwarded_flags = FORWARDED_REMOVE;
+		else if (strcasecmp(forwarded, "append") == 0)
+			forwarded_flags = FORWARDED_APPEND;
+		else if (strcasecmp(forwarded, "replace") == 0)
+			forwarded_flags = FORWARDED_APPEND|FORWARDED_REMOVE;
+		else
+			bb_error_msg_and_die("invalid Forwarded action");
+	}
+#endif
 
 #if !BB_MMU
 	if (!(opt & OPT_FOREGROUND)) {
@@ -2739,7 +3036,7 @@
 
 	xchdir(home_httpd);
 	if (!(opt & OPT_INETD)) {
-		signal(SIGCHLD, SIG_IGN);
+		signal(SIGCHLD, SIG_DFL);
 		server_socket = openServer();
 #if ENABLE_FEATURE_HTTPD_SETUID
 		/* drop privileges */
