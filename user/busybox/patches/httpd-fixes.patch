diff -Naur busybox-1.36.1.org/networking/httpd.c busybox-1.36.1/networking/httpd.c
--- busybox-1.36.1.org/networking/httpd.c	2021-06-16 20:02:16.000000000 +1000
+++ busybox-1.36.1/networking/httpd.c	2021-12-23 15:29:28.956822393 +1000
@@ -265,8 +265,10 @@
 
 //usage:#define httpd_trivial_usage
 //usage:       "[-ifv[v]]"
+//usage:       " [-n max-instances]"
 //usage:       " [-c CONFFILE]"
 //usage:       " [-p [IP:]PORT]"
+//usage:	IF_FEATURE_HTTPD_PROXY(" [-F unchanged|remove|append|replace]")
 //usage:	IF_FEATURE_HTTPD_SETUID(" [-u USER[:GRP]]")
 //usage:	IF_FEATURE_HTTPD_BASIC_AUTH(" [-r REALM]")
 //usage:       " [-h HOME]\n"
@@ -276,6 +278,7 @@
 //usage:     "\n	-i		Inetd mode"
 //usage:     "\n	-f		Run in foreground"
 //usage:     "\n	-v[v]		Verbose"
+//usage:     "\n	-n NUM		Max instances (Default of 0 is unlimited)"
 //usage:     "\n	-p [IP:]PORT	Bind to IP:PORT (default *:"STR(CONFIG_FEATURE_HTTPD_PORT_DEFAULT)")"
 //usage:	IF_FEATURE_HTTPD_SETUID(
 //usage:     "\n	-u USER[:GRP]	Set uid/gid after binding to port")
@@ -286,7 +289,11 @@
 //usage:	IF_FEATURE_HTTPD_AUTH_MD5(
 //usage:     "\n	-m STRING	MD5 crypt STRING")
 //usage:     "\n	-e STRING	HTML encode STRING"
+//usage:     "\n	-D STRING	HTML decode STRING"
 //usage:     "\n	-d STRING	URL decode STRING"
+//usage:	IF_FEATURE_HTTPD_PROXY(
+//usage:     "\n	-F ACTION	RFC7239 Forwarded header, action can be one of:"
+//usage:     "\n	         	'unchanged','remove','append','replace'")
 
 /* TODO: use TCP_CORK, parse_config() */
 
@@ -303,6 +310,10 @@
 #if ENABLE_FEATURE_USE_SENDFILE
 # include <sys/sendfile.h>
 #endif
+/* amount of buffering in a pipe */
+#ifndef PIPE_BUF
+# define PIPE_BUF 4096
+#endif
 
 /* see sys/netinet6/in6.h */
 #if defined(__FreeBSD__)
@@ -318,7 +329,9 @@
 #endif
 
 #define IOBUF_SIZE 8192
-#define MAX_HTTP_HEADERS_SIZE (32*1024)
+#if PIPE_BUF >= IOBUF_SIZE
+# error "PIPE_BUF >= IOBUF_SIZE"
+#endif
 
 #define HEADER_READ_TIMEOUT 60

@@ -328,6 +341,7 @@
 static const char DEFAULT_PATH_HTTPD_CONF[] ALIGN1 = "/etc";
 static const char HTTPD_CONF[] ALIGN1 = "httpd.conf";
 static const char HTTP_200[] ALIGN1 = "HTTP/1.1 200 OK\r\n";
+static const char RFC1123FMT[] ALIGN1 = "%a, %d %b %Y %H:%M:%S GMT";
 static const char index_html[] ALIGN1 = "index.html";
 
 typedef struct has_next_ptr {
@@ -369,9 +383,9 @@
 	HTTP_NOT_FOUND = 404,
 	HTTP_FORBIDDEN = 403,
 	HTTP_REQUEST_TIMEOUT = 408,
+	HTTP_ENTITY_TOO_LARGE = 413,
 	HTTP_NOT_IMPLEMENTED = 501,   /* used for unrecognized requests */
 	HTTP_INTERNAL_SERVER_ERROR = 500,
-	HTTP_ENTITY_TOO_LARGE = 413,
 	HTTP_CONTINUE = 100,
 #if 0   /* future use */
 	HTTP_SWITCHING_PROTOCOLS = 101,
@@ -450,13 +464,21 @@
 #endif
 };
 
+#if ENABLE_FEATURE_HTTPD_PROXY
+/* How we handle the Forwarded: header */
+#define FORWARDED_REMOVE 0x1
+#define FORWARDED_APPEND 0x2
+#endif
+
 struct globals {
 	int verbose;            /* must be int (used by getopt32) */
+	int max_instances;      /* Maximum number of outstanding forks */
 	smallint flg_deny_all;
 #if ENABLE_FEATURE_HTTPD_GZIP
 	/* client can handle gzip / we are going to send gzip */
 	smallint content_gzip;
 #endif
+	unsigned rmt_ip;        /* used for IP-based allow/deny rules */
 	time_t last_mod;
 #if ENABLE_FEATURE_HTTPD_ETAG
 	char *if_none_match;
@@ -477,6 +499,12 @@
 
 	IF_FEATURE_HTTPD_BASIC_AUTH(const char *g_realm;)
 	IF_FEATURE_HTTPD_BASIC_AUTH(char *remoteuser;)
+	IF_FEATURE_HTTPD_CGI(char *referer;)
+	IF_FEATURE_HTTPD_CGI(char *user_agent;)
+	IF_FEATURE_HTTPD_CGI(char *host;)
+	IF_FEATURE_HTTPD_CGI(char *http_accept;)
+	IF_FEATURE_HTTPD_CGI(char *http_accept_language;)
+	char *if_modified_since;
 
 	off_t file_size;        /* -1 - unknown */
 #if ENABLE_FEATURE_HTTPD_RANGES
@@ -505,16 +533,24 @@
 #endif
 #if ENABLE_FEATURE_HTTPD_PROXY
 	Htaccess_Proxy *proxy;
+	int forwarded_flags;
 #endif
+
+	smallint keep_alive;
+	smallint websocket;
+	unsigned char http_major_version;
+	unsigned char http_minor_version;
 };
 #define G (*ptr_to_globals)
 #define verbose           (G.verbose          )
+#define max_instances     (G.max_instances    )
 #define flg_deny_all      (G.flg_deny_all     )
 #if ENABLE_FEATURE_HTTPD_GZIP
 # define content_gzip     (G.content_gzip     )
 #else
 # define content_gzip     0
 #endif
+#define rmt_ip            (G.rmt_ip           )
 #define bind_addr_or_port (G.bind_addr_or_port)
 #define g_query           (G.g_query          )
 #define opt_c_configFile  (G.opt_c_configFile )
@@ -525,6 +561,12 @@
 #define last_mod          (G.last_mod         )
 #define g_realm           (G.g_realm          )
 #define remoteuser        (G.remoteuser       )
+#define referer           (G.referer          )
+#define user_agent        (G.user_agent       )
+#define host              (G.host             )
+#define http_accept       (G.http_accept      )
+#define http_accept_language (G.http_accept_language)
+#define if_modified_since (G.if_modified_since)
 #define file_size         (G.file_size        )
 #if ENABLE_FEATURE_HTTPD_RANGES
 #define range_start       (G.range_start      )
@@ -546,6 +588,16 @@
 #define hdr_cnt           (G.hdr_cnt          )
 #define http_error_page   (G.http_error_page  )
 #define proxy             (G.proxy            )
+#define keep_alive        (G.keep_alive       )
+#define websocket         (G.websocket       )
+
+#define http_major_version (G.http_major_version)
+#define http_minor_version (G.http_minor_version)
+
+#if ENABLE_FEATURE_HTTPD_PROXY
+#define forwarded_flags (G.forwarded_flags)
+#endif
+
 #define INIT_G() do { \
 	setup_common_bufsiz(); \
 	SET_PTR_TO_GLOBALS(xzalloc(sizeof(G))); \
@@ -1017,6 +1069,38 @@
 	*p = '\0';
 	return out;
 }
+
+/*
+ * Given an html-encoded string, decode it into a (malloced) string.
+ */
+static char *decodeString(const char *string)
+{
+	char *out = malloc(strlen(string) + 1);
+	char *i, *o;
+	int d;
+
+	for (i = (char *) string, o = out; *i; i++) {
+		*o = *i;
+		o++;
+		if (i[0] != '&' || i[1] != '#')
+			continue;
+
+		/* &#d; or &#dd; or &#ddd; */
+		for (d = 1; d <= 3; d++) {
+			if (!isdigit(i[d + 1]))
+				break;
+			if (i[d + 2] == ';') {
+				char s[] = "xxx";
+				strncpy(s, i + 2, d);
+				*(o - 1) = (char)strtol(s, NULL, 10);
+				i += d + 2;
+				break;
+			}
+		}
+	}
+	*o = '\0';
+	return out;
+}
 #endif
 
 #if ENABLE_FEATURE_HTTPD_BASIC_AUTH
@@ -1079,7 +1163,6 @@
 static void send_headers(unsigned responseNum)
 {
 #if ENABLE_FEATURE_HTTPD_DATE || ENABLE_FEATURE_HTTPD_LAST_MODIFIED
-	static const char RFC1123FMT[] ALIGN1 = "%a, %d %b %Y %H:%M:%S GMT";
 	/* Fixed size 29-byte string. Example: Sun, 06 Nov 1994 08:49:37 GMT */
 	char date_str[40]; /* using a bit larger buffer to paranoia reasons */
 	struct tm tm;
@@ -1089,6 +1172,7 @@
 #if ENABLE_FEATURE_HTTPD_ERROR_PAGES
 	const char *error_page = NULL;
 #endif
+	const char *mime_type;
 	unsigned len;
 	unsigned i;
 
@@ -1102,6 +1186,9 @@
 			break;
 		}
 	}
+	/* error message is HTML */
+	mime_type = responseNum == HTTP_OK ?
+				found_mime_type : "text/html";
 
 	if (verbose)
 		bb_error_msg("response:%u", responseNum);
@@ -1118,26 +1205,28 @@
 		/* ^^^ using gmtime_r() instead of gmtime() to not use static data */
 #endif
 		len = sprintf(iobuf,
-			"HTTP/1.1 %u %s\r\n"
+			"HTTP/%d.%d %d %s\r\n"
+			"Content-type: %s\r\n"
 #if ENABLE_FEATURE_HTTPD_DATE
 			"Date: %s\r\n"
 #endif
-			"Connection: close\r\n",
-			responseNum, responseString
+			,http_major_version, http_minor_version,
+			responseNum, responseString, mime_type
 #if ENABLE_FEATURE_HTTPD_DATE
 			, date_str
 #endif
 		);
 	}
 
-	if (responseNum != HTTP_OK || found_mime_type) {
-		len += sprintf(iobuf + len,
-				"Content-type: %s\r\n",
-				/* if it's error message, then it's HTML */
-				(responseNum != HTTP_OK ? "text/html" : found_mime_type)
-		);
-	}
+	if (!keep_alive)
+		len += sprintf(iobuf + len, "Connection: close\r\n");
+	else
+		len += sprintf(iobuf + len, "Connection: keep-alive\r\n");
 
+/* Do not send this header. We no longer want the browser to prompt for
+ * Basic Auth *ever*, because the browser will cache the credentials and
+ * they interfere with non-Basic Auth. */
+#if 0
 #if ENABLE_FEATURE_HTTPD_BASIC_AUTH
 	if (responseNum == HTTP_UNAUTHORIZED) {
 		len += sprintf(iobuf + len,
@@ -1146,6 +1235,7 @@
 		);
 	}
 #endif
+#endif
 	if (responseNum == HTTP_MOVED_TEMPORARILY) {
 		/* Responding to "GET /dir" with
 		 * "HTTP/1.1 302 Found" "Location: /dir/"
@@ -1170,7 +1260,7 @@
 		iobuf[len++] = '\n';
 		if (DEBUG) {
 			iobuf[len] = '\0';
-			fprintf(stderr, "headers: '%s'\n", iobuf);
+			fprintf(stderr, "headers1: '%s'\n", iobuf);
 		}
 		full_write(STDOUT_FILENO, iobuf, len);
 		dbg("writing error page: '%s'\n", error_page);
@@ -1239,13 +1329,14 @@
 	 * Theoretically we should not send it if page is compressed,
 	 * but de-facto standard is to send it (see comment below).
 	 */
-			"Content-Length: %"OFF_FMT"u\r\n",
+			"%s %"OFF_FMT"u\r\n",
 #if ENABLE_FEATURE_HTTPD_LAST_MODIFIED
 				date_str,
 #endif
 #if ENABLE_FEATURE_HTTPD_ETAG
 				G.etag,
 #endif
+				content_gzip ? "Transfer-length:" : "Content-length:",
 				file_size
 		);
 	}
@@ -1266,18 +1357,14 @@
 	iobuf[len++] = '\n';
 	if (infoString) {
 		len += sprintf(iobuf + len,
-				"<HTML><HEAD><TITLE>%u %s</TITLE></HEAD>\n"
-				"<BODY><H1>%u %s</H1>\n"
-				"%s\n"
-				"</BODY></HTML>\n",
-				responseNum, responseString,
+				"<HTML><HEAD><TITLE>%d %s</TITLE></HEAD>\n"
+				"<BODY><H1>%d %s</H1>\n%s\n</BODY></HTML>\n",
 				responseNum, responseString,
-				infoString
-		);
+				responseNum, responseString, infoString);
 	}
 	if (DEBUG) {
 		iobuf[len] = '\0';
-		fprintf(stderr, "headers: '%s'\n", iobuf);
+		fprintf(stderr, "headers2: '%s'\n", iobuf);
 	}
 	if (full_write(STDOUT_FILENO, iobuf, len) != len) {
 		if (verbose > 1)
@@ -1307,12 +1394,21 @@
 {
 	unsigned count;
 	char c;
+	struct pollfd pfd[1];
+
+	alarm(HEADER_READ_TIMEOUT);
 
 	count = 0;
 	while (1) {
 		if (hdr_cnt <= 0) {
-			alarm(HEADER_READ_TIMEOUT);
+			memset(pfd, 0, sizeof(pfd));
+			pfd[0].fd = STDIN_FILENO;
+			pfd[0].events = POLLIN;
+			(void)safe_poll(pfd, 1, -1);
+
 			hdr_cnt = safe_read(STDIN_FILENO, hdr_buf, sizeof_hdr_buf);
+			if (DEBUG)
+				fprintf(stderr, "get_line: read %d (%*s)\n", hdr_cnt, hdr_cnt, hdr_buf);
 			if (hdr_cnt <= 0)
 				goto ret;
 			hdr_ptr = hdr_buf;
@@ -1327,16 +1423,20 @@
 		if (count < (IOBUF_SIZE - 1))      /* check overflow */
 			count++;
 	}
+
  ret:
 	iobuf[count] = '\0';
+	if (DEBUG && count <= 0)
+		fprintf(stderr, "NO DATA\n");
+	if (DEBUG)
+		fprintf(stderr, "iobuf: %s\n", iobuf);
 	return count;
 }
 
 #if ENABLE_FEATURE_HTTPD_CGI || ENABLE_FEATURE_HTTPD_PROXY
 
 /* gcc 4.2.1 fares better with NOINLINE */
-static NOINLINE void cgi_io_loop_and_exit(int fromCgi_rd, int toCgi_wr, int post_len) NORETURN;
-static NOINLINE void cgi_io_loop_and_exit(int fromCgi_rd, int toCgi_wr, int post_len)
+static int cgi_io_loop(int fromCgi_rd, int toCgi_wr, long long post_len)
 {
 	enum { FROM_CGI = 1, TO_CGI = 2 }; /* indexes in pfd[] */
 	struct pollfd pfd[3];
@@ -1363,31 +1463,18 @@
 
 	/* NB: breaking out of this loop jumps to log_and_exit() */
 	out_cnt = 0;
-	pfd[FROM_CGI].fd = fromCgi_rd;
-	pfd[FROM_CGI].events = POLLIN;
-	pfd[TO_CGI].fd = toCgi_wr;
 	while (1) {
-		/* Note: even pfd[0].events == 0 won't prevent
-		 * revents == POLLHUP|POLLERR reports from closed stdin.
-		 * Setting fd to -1 works: */
-		pfd[0].fd = -1;
-		pfd[0].events = POLLIN;
-		pfd[0].revents = 0; /* probably not needed, paranoia */
-
-		/* We always poll this fd, thus kernel always sets revents: */
-		/*pfd[FROM_CGI].events = POLLIN; - moved out of loop */
-		/*pfd[FROM_CGI].revents = 0; - not needed */
-
-		/* gcc-4.8.0 still doesnt fill two shorts with one insn :( */
-		/* http://gcc.gnu.org/bugzilla/show_bug.cgi?id=47059 */
-		/* hopefully one day it will... */
-		pfd[TO_CGI].events = POLLOUT;
-		pfd[TO_CGI].revents = 0; /* needed! */
-
-		if (toCgi_wr && hdr_cnt <= 0) {
-			if (post_len > 0) {
-				/* Expect more POST data from network */
-				pfd[0].fd = 0;
+		memset(pfd, 0, sizeof(pfd));
+
+		pfd[FROM_CGI].fd = fromCgi_rd;
+		pfd[FROM_CGI].events = POLLIN;
+
+		if (toCgi_wr) {
+			pfd[TO_CGI].fd = toCgi_wr;
+			if (hdr_cnt > 0) {
+				pfd[TO_CGI].events = POLLOUT;
+			} else if (post_len > 0 || keep_alive) {
+				pfd[0].events = POLLIN;
 			} else {
 				/* post_len <= 0 && hdr_cnt <= 0:
 				 * no more POST data to CGI,
@@ -1399,7 +1486,7 @@
 		}
 
 		/* Now wait on the set of sockets */
-		count = safe_poll(pfd, hdr_cnt > 0 ? TO_CGI+1 : FROM_CGI+1, -1);
+		count = safe_poll(pfd, toCgi_wr ? TO_CGI+1 : FROM_CGI+1, -1);
 		if (count <= 0) {
 #if 0
 			if (safe_waitpid(pid, &status, WNOHANG) <= 0) {
@@ -1408,15 +1495,15 @@
 				continue;
 			}
 			if (DEBUG && WIFEXITED(status))
-				bb_error_msg("CGI exited, status=%u", WEXITSTATUS(status));
+				bb_error_msg("CGI exited, status=%d", WEXITSTATUS(status));
 			if (DEBUG && WIFSIGNALED(status))
-				bb_error_msg("CGI killed, signal=%u", WTERMSIG(status));
+				bb_error_msg("CGI killed, signal=%d", WTERMSIG(status));
 #endif
 			break;
 		}
 
 		if (pfd[TO_CGI].revents) {
-			/* hdr_cnt > 0 here due to the way poll() called */
+			/* hdr_cnt > 0 here due to the way pfd[TO_CGI].events set */
 			/* Have data from peer and can write to CGI */
 			count = safe_write(toCgi_wr, hdr_ptr, hdr_cnt);
 			/* Doesn't happen, we dont use nonblocking IO here
@@ -1428,25 +1515,32 @@
 				hdr_cnt -= count;
 			} else {
 				/* EOF/broken pipe to CGI, stop piping POST data */
-				hdr_cnt = post_len = 0;
+				hdr_cnt = 0;
+				post_len = -1;
 			}
 		}
 
 		if (pfd[0].revents) {
+			/* we received some more data (after post request) while
+			 * doing keep alive,  must be the next request,  trigger that */
+			if (post_len == 0 && keep_alive && !websocket)
+				return 1;
 			/* post_len > 0 && hdr_cnt == 0 here */
 			/* We expect data, prev data portion is eaten by CGI
 			 * and there *is* data to read from the peer
 			 * (POSTDATA) */
-			//count = post_len > (int)sizeof_hdr_buf ? (int)sizeof_hdr_buf : post_len;
+			//count = post_len > (int)sizeof(hdr_buf) ? (int)sizeof(hdr_buf) : post_len;
 			//count = safe_read(STDIN_FILENO, hdr_buf, count);
-			count = safe_read(STDIN_FILENO, hdr_buf, sizeof_hdr_buf);
+			count = safe_read(STDIN_FILENO, hdr_buf, COMMON_BUFSIZE);
 			if (count > 0) {
 				hdr_cnt = count;
 				hdr_ptr = hdr_buf;
-				post_len -= count;
+				/* post_len of 0 means we are just joining fd's now */
+				if (post_len > 0)
+					post_len -= count;
 			} else {
 				/* no more POST data can be read */
-				post_len = 0;
+				post_len = (count == 0 && keep_alive) ? 0 : -1;
 			}
 		}
 
@@ -1468,10 +1562,10 @@
 				 * CGI may output a few first bytes and then wait
 				 * for POSTDATA without closing stdout.
 				 * With full_read we may wait here forever. */
-				count = safe_read(fromCgi_rd, rbuf + out_cnt, IOBUF_SIZE - 8);
+				count = safe_read(fromCgi_rd, rbuf + out_cnt, PIPE_BUF - 8);
 				if (count <= 0) {
 					/* eof (or error) and there was no "HTTP",
-					 * send "HTTP/1.1 200 OK\r\n", then send received data */
+					 * so write it, then write received data */
 					if (out_cnt) {
 						full_write(STDOUT_FILENO, HTTP_200, sizeof(HTTP_200)-1);
 						full_write(STDOUT_FILENO, rbuf, out_cnt);
@@ -1509,7 +1603,7 @@
 					out_cnt = -1; /* buffering off */
 				}
 			} else {
-				count = safe_read(fromCgi_rd, rbuf, IOBUF_SIZE);
+				count = safe_read(fromCgi_rd, rbuf, PIPE_BUF);
 				if (count <= 0)
 					break;  /* eof (or error) */
 			}
@@ -1518,7 +1612,7 @@
 			dbg("cgi read %d bytes: '%.*s'\n", count, count, rbuf);
 		} /* if (pfd[FROM_CGI].revents) */
 	} /* while (1) */
-	log_and_exit();
+	return 0;
 }
 #endif
 
@@ -1539,18 +1633,24 @@
  * Parameters:
  * const char *url              The requested URL (with leading /).
  * const char *orig_uri         The original URI before rewriting (if any)
- * int post_len                 Length of the POST body.
+ * long long post_len                 Length of the POST body.
+ * const char *cookie           For set HTTP_COOKIE.
+ * const char *content_type     For set CONTENT_TYPE.
  */
 static void send_cgi_and_exit(
 		const char *url,
 		const char *orig_uri,
 		const char *request,
-		int post_len) NORETURN;
+		long long post_len,
+		const char *cookie,
+		const char *content_type) NORETURN;
 static void send_cgi_and_exit(
 		const char *url,
 		const char *orig_uri,
 		const char *request,
-		int post_len)
+		long long post_len,
+		const char *cookie,
+		const char *content_type)
 {
 	struct fd_pair fromCgi;  /* CGI -> httpd pipe */
 	struct fd_pair toCgi;    /* httpd -> CGI pipe */
@@ -1628,14 +1728,26 @@
 #endif
 		}
 	}
+	setenv1("HTTP_USER_AGENT", user_agent);
+	if (http_accept)
+		setenv1("HTTP_ACCEPT", http_accept);
+	if (http_accept_language)
+		setenv1("HTTP_ACCEPT_LANGUAGE", http_accept_language);
 	if (post_len)
-		putenv(xasprintf("CONTENT_LENGTH=%u", post_len));
+		putenv(xasprintf("CONTENT_LENGTH=%lld", post_len));
+	if (cookie)
+		setenv1("HTTP_COOKIE", cookie);
+	if (content_type)
+		setenv1("CONTENT_TYPE", content_type);
 #if ENABLE_FEATURE_HTTPD_BASIC_AUTH
 	if (remoteuser) {
 		setenv1("REMOTE_USER", remoteuser);
 		putenv((char*)"AUTH_TYPE=Basic");
 	}
 #endif
+	if (referer)
+		setenv1("HTTP_REFERER", referer);
+	setenv1("HTTP_HOST", host); /* set to "" if NULL */
 	/* setenv1("SERVER_NAME", safe_gethostname()); - don't do this,
 	 * just run "env SERVER_NAME=xyz httpd ..." instead */
 
@@ -1720,10 +1832,14 @@
 	/* Restore variables possibly changed by child */
 	xfunc_error_retval = 0;
 
+	/* Force keep-alive off for CGI scripts */
+	keep_alive = 0;
+
 	/* Pump data */
 	close(fromCgi.wr);
 	close(toCgi.rd);
-	cgi_io_loop_and_exit(fromCgi.rd, toCgi.wr, post_len);
+	cgi_io_loop(fromCgi.rd, toCgi.wr, post_len);
+	log_and_exit();
 }
 
 #endif          /* FEATURE_HTTPD_CGI */
@@ -1784,8 +1900,8 @@
 	 * (happens if you abort downloads from local httpd): */
 	signal(SIGPIPE, SIG_IGN);
 
-	/* If not found, default is to not send "Content-type:" */
-	/*found_mime_type = NULL; - already is */
+	/* If not found, default is "application/octet-stream" */
+	found_mime_type = "application/octet-stream";
 	suffix = strrchr(url, '.');
 	if (suffix) {
 		static const char suffixTable[] ALIGN1 =
@@ -1921,7 +2037,7 @@
 }
 
 #if ENABLE_FEATURE_HTTPD_ACL_IP
-static void if_ip_denied_send_HTTP_FORBIDDEN_and_exit(unsigned remote_ip)
+static int checkPermIP(void)
 {
 	Htaccess_IP *cur;
 
@@ -1937,18 +2053,14 @@
 			(unsigned char)(cur->mask >> 8),
 			(unsigned char)(cur->mask)
 		);
-		if ((remote_ip & cur->mask) == cur->ip) {
-			if (cur->allow_deny == 'A')
-				return;
-			send_headers_and_exit(HTTP_FORBIDDEN);
-		}
+		if ((rmt_ip & cur->mask) == cur->ip)
+			return (cur->allow_deny == 'A'); /* A -> 1 */
 	}
 
-	if (flg_deny_all) /* depends on whether we saw "D:*" */
-		send_headers_and_exit(HTTP_FORBIDDEN);
+	return !flg_deny_all; /* depends on whether we saw "D:*" */
 }
 #else
-# define if_ip_denied_send_HTTP_FORBIDDEN_and_exit(arg) ((void)0)
+# define checkPermIP() 1
 #endif
 
 #if ENABLE_FEATURE_HTTPD_BASIC_AUTH
@@ -2020,6 +2132,7 @@
 		const char *dir_prefix;
 		size_t len;
 		int r;
+		int optional = 0;
 
 		dir_prefix = cur->before_colon;
 
@@ -2043,13 +2156,23 @@
 		/* Path match found */
 		prev = dir_prefix;
 
-		if (ENABLE_FEATURE_HTTPD_AUTH_MD5) {
+		if (ENABLE_PAM || ENABLE_FEATURE_HTTPD_AUTH_MD5) {
 			char *colon_after_user;
 			const char *passwd;
 # if ENABLE_FEATURE_SHADOWPASSWDS && !ENABLE_PAM
 			char sp_buf[256];
 # endif
 
+			// Allow if user in conf is empty. Lets subpaths be overriden with no auth
+			if (cur->after_colon[0] == ':') {
+				return 1;
+			}
+
+			// Allow if auth is optional and no user/password given
+			if (*user_and_passwd == '\0' && strcmp(cur->after_colon, "*:+") == 0) {
+				return 1;
+			}
+
 			colon_after_user = strchr(user_and_passwd, ':');
 			if (!colon_after_user)
 				goto bad_input;
@@ -2067,13 +2182,23 @@
 			if (!passwd)
 				goto bad_input;
 			passwd++;
-			if (passwd[0] == '*') {
+			if (passwd[0] == '*' || passwd[0] == '+') {
 # if ENABLE_PAM
 				struct pam_userinfo userinfo;
 				struct pam_conv conv_info = { &pam_talker, (void *) &userinfo };
 				pam_handle_t *pamh;
+				char **pamenv;
+				static char *pam_authed = NULL;
 
+				optional = passwd[0] == '+';
 				*colon_after_user = '\0';
+
+				if (pam_authed && strcmp(pam_authed, user_and_passwd) != 0) {
+					r = 0;
+					*colon_after_user = ':';
+					goto end_check_passwd;
+				}
+
 				userinfo.name = user_and_passwd;
 				userinfo.pw = colon_after_user + 1;
 				r = pam_start("httpd", user_and_passwd, &conv_info, &pamh) != PAM_SUCCESS;
@@ -2081,9 +2214,16 @@
 					r = pam_authenticate(pamh, PAM_DISALLOW_NULL_AUTHTOK) != PAM_SUCCESS
 					 || pam_acct_mgmt(pamh, PAM_DISALLOW_NULL_AUTHTOK)    != PAM_SUCCESS
 					;
+					for (pamenv = pam_getenvlist(pamh); pamenv && *pamenv; pamenv++)
+						putenv(*pamenv);
 					pam_end(pamh, PAM_SUCCESS);
 				}
 				*colon_after_user = ':';
+				if (r == 0) {
+					if (pam_authed)
+						free(pam_authed);
+					pam_authed = strdup(user_and_passwd);
+				}
 				goto end_check_passwd;
 # else
 #  if ENABLE_FEATURE_SHADOWPASSWDS
@@ -2116,7 +2256,7 @@
 			}
 			/* Else: passwd is from httpd.conf, it is either plaintext or encrypted */
 
-			if (passwd[0] == '$' && isdigit(passwd[1])) {
+			if (ENABLE_FEATURE_HTTPD_AUTH_MD5 && passwd[0] == '$' && isdigit(passwd[1])) {
 				char *encrypted;
 # if !ENABLE_PAM
  check_encrypted:
@@ -2143,7 +2283,11 @@
 			remoteuser = xstrndup(user_and_passwd,
 				strchrnul(user_and_passwd, ':') - user_and_passwd
 			);
-			return 1; /* Ok */
+			return 2; /* Ok */
+		}
+		// Let through on auth fail if password is optional
+		if (optional) {
+			return 1;
 		}
 	} /* for */
 
@@ -2157,11 +2301,43 @@
 {
 	Htaccess_Proxy *p;
 	for (p = proxy; p; p = p->next) {
-		if (is_prefixed_with(url, p->url_from))
+		if (strncmp(url, p->url_from, strlen(p->url_from)) == 0)
 			return p;
 	}
 	return NULL;
 }
+
+static void remove_header(char *header, int *header_length, const char *id)
+{
+	//assert(header);
+	//assert(header_length);
+	//assert(*header_length >= 0);
+	//assert(id);
+	//assert(strchr(id, ':'));
+	int id_length = strlen(id);
+
+	if (id_length <= 0)
+		return;
+
+	for (char *ptr = header; header + *header_length - ptr >= id_length; ) {
+		char *end = ptr;
+		do {
+			end = memchr(end, '\n', header + *header_length - end);
+			if (end == NULL) {
+				end = header + *header_length;
+			} else {
+				++end;
+			}
+		} while (end < header + *header_length && *end == ' ');
+		if (!strncasecmp(ptr, id, id_length)) {
+			memmove(ptr, end, header + *header_length - end);
+			*header_length -= end - ptr;
+		} else {
+			ptr = end;
+		}
+	}
+}
+
 #endif
 
 /*
@@ -2183,32 +2359,37 @@
 	char *urlcopy;
 	char *urlp;
 	char *tptr;
-#if ENABLE_FEATURE_HTTPD_ACL_IP
-	unsigned remote_ip;
-#endif
+	static const char request_GET[] ALIGN1 = "GET";
 #if ENABLE_FEATURE_HTTPD_CGI
-	unsigned total_headers_len;
-#endif
-	const char *prequest;
-	static const char request_GET[]  ALIGN1 = "GET";
 	static const char request_HEAD[] ALIGN1 = "HEAD";
-#if ENABLE_FEATURE_HTTPD_CGI
+	static const char request_DELETE[] ALIGN1 = "DELETE";
 	static const char request_POST[] ALIGN1 = "POST";
-	unsigned long POST_length;
-	enum CGI_type {
-		CGI_NONE = 0,
-		CGI_NORMAL,
-		CGI_INDEX,
-		CGI_INTERPRETER,
-	} cgi_type = CGI_NONE;
-#endif
-#if ENABLE_FEATURE_HTTPD_PROXY
-	Htaccess_Proxy *proxy_entry;
+	const char *request_list[] = {
+				request_GET,
+				request_HEAD,
+				request_DELETE,
+				request_POST,
+				"PUT",
+				NULL
+			};
+	int i;
+	const char *prequest;
+	char *cookie = NULL;
+	char *content_type = NULL;
+	unsigned long long length = 0;
+#elif ENABLE_FEATURE_HTTPD_PROXY
+#define prequest request_GET
+	unsigned long long length = 0;
 #endif
 #if ENABLE_FEATURE_HTTPD_BASIC_AUTH
 	smallint authorized = -1;
 #endif
-	char *HTTP_slash;
+	smallint ip_allowed;
+#if ENABLE_FEATURE_HTTPD_PROXY
+	char *header_buf = header_buf; /* for gcc */
+	char *header_ptr = header_ptr;
+	Htaccess_Proxy *proxy_entry;
+#endif
 
 	/* Allocation of iobuf is postponed until now
 	 * (IOW, server process doesn't need to waste 8k) */
@@ -2226,117 +2407,86 @@
 			bb_simple_error_msg("connected");
 	}
 #if ENABLE_FEATURE_HTTPD_ACL_IP
-	remote_ip = 0;
+	rmt_ip = 0;
 	if (fromAddr->u.sa.sa_family == AF_INET) {
-		remote_ip = ntohl(fromAddr->u.sin.sin_addr.s_addr);
+		rmt_ip = ntohl(fromAddr->u.sin.sin_addr.s_addr);
 	}
 # if ENABLE_FEATURE_IPV6
 	if (fromAddr->u.sa.sa_family == AF_INET6
 	 && fromAddr->u.sin6.sin6_addr.s6_addr32[0] == 0
 	 && fromAddr->u.sin6.sin6_addr.s6_addr32[1] == 0
 	 && ntohl(fromAddr->u.sin6.sin6_addr.s6_addr32[2]) == 0xffff)
-		remote_ip = ntohl(fromAddr->u.sin6.sin6_addr.s6_addr32[3]);
+		rmt_ip = ntohl(fromAddr->u.sin6.sin6_addr.s6_addr32[3]);
 # endif
-	if_ip_denied_send_HTTP_FORBIDDEN_and_exit(remote_ip);
 #endif
 
+next_request:
+
+	authorized = -1;
+	length = 0;
+
+	*iobuf = '\0';
+
 	/* Install timeout handler. get_line() needs it. */
 	signal(SIGALRM, send_REQUEST_TIMEOUT_and_exit);
 
-	if (!get_line()) { /* EOF or error or empty line */
-		/* Observed Firefox to "speculatively" open
-		 * extra connections to a new site on first access,
-		 * they are closed in ~5 seconds with nothing
-		 * being sent at all.
-		 * (Presumably it's a method to decrease latency?)
-		 */
-		if (verbose > 2)
-			bb_simple_error_msg("eof on read, closing");
-		/* Don't bother generating error page in this case,
-		 * just close the socket.
-		 */
-		//send_headers_and_exit(HTTP_BAD_REQUEST);
-		_exit(xfunc_error_retval);
-	}
-	dbg("Request:'%s'\n", iobuf);
+	if (!get_line()) /* EOF or error or empty line */
+		send_headers_and_exit(HTTP_BAD_REQUEST);
 
-	/* Find URL */
+	/* Determine type of request (GET/POST) */
 	// rfc2616: method and URI is separated by exactly one space
 	//urlp = strpbrk(iobuf, " \t"); - no, tab isn't allowed
 	urlp = strchr(iobuf, ' ');
 	if (urlp == NULL)
 		send_headers_and_exit(HTTP_BAD_REQUEST);
 	*urlp++ = '\0';
-	//urlp = skip_whitespace(urlp); - should not be necessary
-	if (urlp[0] != '/')
-		send_headers_and_exit(HTTP_BAD_REQUEST);
-	/* Find end of URL */
-	HTTP_slash = strchr(urlp, ' ');
-	/* Is it " HTTP/"? */
-	if (!HTTP_slash || strncmp(HTTP_slash + 1, HTTP_200, 5) != 0)
-		send_headers_and_exit(HTTP_BAD_REQUEST);
-	*HTTP_slash++ = '\0';
-
-#if ENABLE_FEATURE_HTTPD_PROXY
-	proxy_entry = find_proxy_entry(urlp);
-	if (proxy_entry) {
-		int proxy_fd;
-		len_and_sockaddr *lsa;
-
-		if (verbose > 1)
-			bb_error_msg("proxy:%s", urlp);
-		lsa = host2sockaddr(proxy_entry->host_port, 80);
-		if (!lsa)
-			send_headers_and_exit(HTTP_INTERNAL_SERVER_ERROR);
-		proxy_fd = socket(lsa->u.sa.sa_family, SOCK_STREAM, 0);
-		if (proxy_fd < 0)
-			send_headers_and_exit(HTTP_INTERNAL_SERVER_ERROR);
-		if (connect(proxy_fd, &lsa->u.sa, lsa->len) < 0)
-			send_headers_and_exit(HTTP_INTERNAL_SERVER_ERROR);
-		/* Disable peer header reading timeout */
-		alarm(0);
-		/* Config directive was of the form:
-		 *   P:/url:[http://]hostname[:port]/new/path
-		 * When /urlSFX is requested, reverse proxy it
-		 * to http://hostname[:port]/new/pathSFX
-		 */
-		fdprintf(proxy_fd, "%s %s%s %s\r\n",
-				iobuf, /* "GET" / "POST" / etc */
-				proxy_entry->url_to, /* "/new/path" */
-				urlp + strlen(proxy_entry->url_from), /* "SFX" */
-				HTTP_slash /* "HTTP/xyz" */
-		);
-		cgi_io_loop_and_exit(proxy_fd, proxy_fd, /*max POST length:*/ INT_MAX);
+#if ENABLE_FEATURE_HTTPD_CGI
+	for (i = 0; request_list[i]; i++) {
+		prequest = request_list[i];
+		if (strcasecmp(iobuf, prequest) == 0)
+			break;
 	}
+	if (request_list[i] == NULL)
+		send_headers_and_exit(HTTP_NOT_IMPLEMENTED);
+#else
+	if (strcasecmp(iobuf, request_GET) != 0)
+		send_headers_and_exit(HTTP_NOT_IMPLEMENTED);
 #endif
+	// rfc2616: method and URI is separated by exactly one space
+	//urlp = skip_whitespace(urlp);
+	if (urlp[0] != '/')
+		send_headers_and_exit(HTTP_BAD_REQUEST);
 
-	/* Determine type of request (GET/POST/...) */
-	prequest = request_GET;
-	if (strcasecmp(iobuf, prequest) == 0)
-		goto found;
-	prequest = request_HEAD;
-	if (strcasecmp(iobuf, prequest) == 0)
-		goto found;
-#if !ENABLE_FEATURE_HTTPD_CGI
-	send_headers_and_exit(HTTP_NOT_IMPLEMENTED);
-#else
-	prequest = request_POST;
-	if (strcasecmp(iobuf, prequest) == 0)
-		goto found;
-	/* For CGI, allow DELETE, PUT, OPTIONS, etc too */
-	prequest = alloca(16);
-	safe_strncpy((char*)prequest, iobuf, 16);
-#endif
- found:
-	/* Copy URL to stack-allocated char[] */
-	urlcopy = alloca((HTTP_slash - urlp) + 2 + strlen(index_page));
+	/* Find end of URL and parse HTTP version, if any */
+	http_major_version = 0;
+	http_minor_version = 0;
+	tptr = strchrnul(urlp, ' ');
+	/* Is it " HTTP/"? */
+	if (tptr[0] && strncmp(tptr + 1, HTTP_200, 5) == 0) {
+		if (tptr[6] >= '0' && tptr[6] <= '9')
+			http_major_version = tptr[6] - '0';
+		if (tptr[8] >= '0' && tptr[8] <= '9')
+			http_minor_version = tptr[8] - '0';
+	}
+	*tptr = '\0';
+
+	if (http_major_version > 0 && http_minor_version > 0)
+		keep_alive = 1;
+
+	/* Copy URL from after "GET "/"POST " */
+	urlcopy = xmalloc((tptr - urlp) + 2 + strlen(index_page));
+	/*if (urlcopy == NULL)
+	 *	send_headers_and_exit(HTTP_INTERNAL_SERVER_ERROR);*/
 	strcpy(urlcopy, urlp);
 	/* NB: urlcopy ptr is never changed after this */
 
 	/* Extract url args if present */
-	g_query = strchr(urlcopy, '?');
-	if (g_query)
-		*g_query++ = '\0';
+	/* g_query = NULL; - already is */
+	tptr = strchr(urlcopy, '?');
+	if (tptr) {
+		*tptr++ = '\0';
+		g_query = tptr;
+	}
 
 	/* Decode URL escape sequences */
 	tptr = percent_decode_in_place(urlcopy, /*strict:*/ 1);
@@ -2351,7 +2501,7 @@
 	/* Algorithm stolen from libbb bb_simplify_path(),
 	 * but don't strdup, retain trailing slash, protect root */
 	urlp = tptr = urlcopy;
-	while (1) {
+	for (;;) {
 		if (*urlp == '/') {
 			/* skip duplicate (or initial) slash */
 			if (*tptr == '/') {
@@ -2376,214 +2526,214 @@
 			}
 		}
 		*++urlp = *tptr;
-		if (*tptr == '\0')
+		if (*urlp == '\0')
 			break;
  next_char:
 		tptr++;
 	}
 
+	/* If URL is a directory, add '/' */
+	if (urlp[-1] != '/') {
+		if (is_directory(urlcopy + 1, /*followlinks:*/ 1)) {
+			found_moved_temporarily = urlcopy;
+		}
+	}
+
 	/* Log it */
 	if (verbose > 1)
 		bb_error_msg("url:%s", urlcopy);
 
 	tptr = urlcopy;
-	while ((tptr = strchr(tptr + 1, '/')) != NULL) {
+	ip_allowed = checkPermIP();
+	while (ip_allowed && (tptr = strchr(tptr + 1, '/')) != NULL) {
 		/* have path1/path2 */
 		*tptr = '\0';
-		/* may have subdir config */
-		if (parse_conf(urlcopy + 1, SUBDIR_PARSE) == 0)
-			if_ip_denied_send_HTTP_FORBIDDEN_and_exit(remote_ip);
+		if (is_directory(urlcopy + 1, /*followlinks:*/ 1)) {
+			/* may have subdir config */
+			parse_conf(urlcopy + 1, SUBDIR_PARSE);
+			ip_allowed = checkPermIP();
+		}
 		*tptr = '/';
 	}
 
-	tptr = urlcopy + 1;      /* skip first '/' */
-
-#if ENABLE_FEATURE_HTTPD_CGI
-	if (is_prefixed_with(tptr, "cgi-bin/")) {
-		if (tptr[8] == '\0') {
-			/* protect listing "cgi-bin/" */
-			send_headers_and_exit(HTTP_FORBIDDEN);
-		}
-		cgi_type = CGI_NORMAL;
-	}
+#if ENABLE_FEATURE_HTTPD_PROXY
+	proxy_entry = find_proxy_entry(urlcopy);
+	if (proxy_entry)
+		header_buf = header_ptr = xmalloc(IOBUF_SIZE);
 #endif
 
-	if (urlp[-1] == '/') {
-		/* When index_page string is appended to <dir>/ URL, it overwrites
-		 * the query string. If we fall back to call /cgi-bin/index.cgi,
-		 * query string would be lost and not available to the CGI.
-		 * Work around it by making a deep copy.
-		 */
-		if (ENABLE_FEATURE_HTTPD_CGI)
-			g_query = xstrdup(g_query); /* ok for NULL too */
-		strcpy(urlp, index_page);
-	}
-	if (stat(tptr, &sb) == 0) {
-		/* If URL is a directory with no slash, set up
-		 * "HTTP/1.1 302 Found" "Location: /dir/" reply */
-		if (urlp[-1] != '/' && S_ISDIR(sb.st_mode)) {
-			found_moved_temporarily = urlcopy;
-		} else {
-#if ENABLE_FEATURE_HTTPD_CONFIG_WITH_SCRIPT_INTERPR
-			char *suffix = strrchr(tptr, '.');
-			if (suffix) {
-				Htaccess *cur;
-				for (cur = script_i; cur; cur = cur->next) {
-					if (strcmp(cur->before_colon + 1, suffix) == 0) {
-						cgi_type = CGI_INTERPRETER;
-						break;
-					}
-				}
-			}
-#endif
-			file_size = sb.st_size;
-			last_mod = sb.st_mtime;
-		}
-	}
-#if ENABLE_FEATURE_HTTPD_CGI
-	else if (urlp[-1] == '/') {
-		/* It's a dir URL and there is no index.html */
-		/* Is there cgi-bin/index.cgi? */
-		if (access("/cgi-bin/index.cgi"+1, X_OK) != 0)
-			send_headers_and_exit(HTTP_NOT_FOUND); /* no */
-		cgi_type = CGI_INDEX;
-	}
-#endif
+	if (http_major_version >= 0) {
+		/* Request was with "... HTTP/nXXX", and n >= 0 */
 
-#if ENABLE_FEATURE_HTTPD_BASIC_AUTH || ENABLE_FEATURE_HTTPD_CGI
-	/* check_user_passwd() would be confused by added .../index.html, truncate it */
-	urlp[0] = '\0';
-#endif
+		/* Read until blank line */
+		while (1) {
+			if (!get_line())
+				break; /* EOF or error or empty line */
+			if (DEBUG)
+				bb_error_msg("header: '%s'", iobuf);
 
-#if ENABLE_FEATURE_HTTPD_CGI
-	total_headers_len = 0;
-	POST_length = 0;
+#if ENABLE_FEATURE_HTTPD_PROXY
+			/* We need 2 more bytes for yet another "\r\n" -
+			 * see near fdprintf(proxy_fd...) further below */
+			if (proxy_entry && (header_ptr - header_buf) < IOBUF_SIZE - 2) {
+				int len = strlen(iobuf);
+				if (len > IOBUF_SIZE - (header_ptr - header_buf) - 4)
+					len = IOBUF_SIZE - (header_ptr - header_buf) - 4;
+				memcpy(header_ptr, iobuf, len);
+				header_ptr += len;
+				header_ptr[0] = '\r';
+				header_ptr[1] = '\n';
+				header_ptr += 2;
+			}
 #endif
 
-	/* Read until blank line */
-	while (1) {
-		unsigned iobuf_len = get_line();
-		if (!iobuf_len)
-			break; /* EOF or error or empty line */
-#if ENABLE_FEATURE_HTTPD_CGI
-		/* Prevent unlimited growth of HTTP_xyz envvars */
-		total_headers_len += iobuf_len;
-		if (total_headers_len >= MAX_HTTP_HEADERS_SIZE)
-			send_headers_and_exit(HTTP_ENTITY_TOO_LARGE);
+#if ENABLE_FEATURE_HTTPD_CGI || ENABLE_FEATURE_HTTPD_PROXY
+			/* Try and do our best to parse more lines */
+			if ((STRNCASECMP(iobuf, "Content-length:") == 0)) {
+				/* extra read only for POST */
+				if (prequest != request_GET
+# if ENABLE_FEATURE_HTTPD_CGI
+				&& prequest != request_HEAD
+				&& prequest != request_DELETE
+# endif
+				) {
+					tptr = skip_whitespace(iobuf + sizeof("Content-length:") - 1);
+					if (!tptr[0])
+						send_headers_and_exit(HTTP_BAD_REQUEST);
+					/* not using strtoul: it ignores leading minus! */
+					length = bb_strtoull(tptr, NULL, 10);
+					/* length is "unsigned long long", but we need to pass it to long long later */
+					if (errno || length > LLONG_MAX)
+						send_headers_and_exit(HTTP_BAD_REQUEST);
+				}
+			}
 #endif
-		dbg("header:'%s'\n", iobuf);
 #if ENABLE_FEATURE_HTTPD_CGI
-		/* Only POST needs to know POST_length */
-		if (prequest == request_POST && STRNCASECMP(iobuf, "Content-Length:") == 0) {
-			tptr = skip_whitespace(iobuf + sizeof("Content-Length:") - 1);
-			if (!tptr[0])
-				send_headers_and_exit(HTTP_BAD_REQUEST);
-			/* not using strtoul: it ignores leading minus! */
-			POST_length = bb_strtou(tptr, NULL, 10);
-			/* length is "ulong", but we need to pass it to int later */
-			if (errno || POST_length > INT_MAX)
-				send_headers_and_exit(HTTP_BAD_REQUEST);
-			continue;
-		}
+			else if (STRNCASECMP(iobuf, "Cookie:") == 0) {
+				cookie = xstrdup(skip_whitespace(iobuf + sizeof("Cookie:")-1));
+			} else if (STRNCASECMP(iobuf, "Content-Type:") == 0) {
+				content_type = xstrdup(skip_whitespace(iobuf + sizeof("Content-Type:")-1));
+			} else if (STRNCASECMP(iobuf, "Referer:") == 0) {
+				referer = xstrdup(skip_whitespace(iobuf + sizeof("Referer:")-1));
+			} else if (STRNCASECMP(iobuf, "User-Agent:") == 0) {
+				user_agent = xstrdup(skip_whitespace(iobuf + sizeof("User-Agent:")-1));
+			} else if (STRNCASECMP(iobuf, "Host:") == 0) {
+				host = xstrdup(skip_whitespace(iobuf + sizeof("Host:")-1));
+			} else if (STRNCASECMP(iobuf, "Accept:") == 0) {
+				http_accept = xstrdup(skip_whitespace(iobuf + sizeof("Accept:")-1));
+			} else if (STRNCASECMP(iobuf, "Accept-Language:") == 0) {
+				http_accept_language = xstrdup(skip_whitespace(iobuf + sizeof("Accept-Language:")-1));
+			}
 #endif
 #if ENABLE_FEATURE_HTTPD_BASIC_AUTH
-		if (STRNCASECMP(iobuf, "Authorization:") == 0) {
-			/* We only allow Basic credentials.
-			 * It shows up as "Authorization: Basic <user>:<passwd>" where
-			 * "<user>:<passwd>" is base64 encoded.
-			 */
-			tptr = skip_whitespace(iobuf + sizeof("Authorization:")-1);
-			if (STRNCASECMP(tptr, "Basic") == 0) {
+			if (STRNCASECMP(iobuf, "Authorization:") == 0) {
+				/* We only allow Basic credentials.
+				 * It shows up as "Authorization: Basic <user>:<passwd>" where
+				 * "<user>:<passwd>" is base64 encoded.
+				 */
+				tptr = skip_whitespace(iobuf + sizeof("Authorization:")-1);
+				if (STRNCASECMP(tptr, "Basic") != 0)
+					continue;
 				tptr += sizeof("Basic")-1;
 				/* decodeBase64() skips whitespace itself */
 				decodeBase64(tptr);
 				authorized = check_user_passwd(urlcopy, tptr);
-				continue;
 			}
-		}
 #endif
 #if ENABLE_FEATURE_HTTPD_RANGES
-		if (STRNCASECMP(iobuf, "Range:") == 0) {
-			/* We know only bytes=NNN-[MMM] */
-			char *s = skip_whitespace(iobuf + sizeof("Range:")-1);
-			s = is_prefixed_with(s, "bytes=");
-			if (s) {
-				range_start = BB_STRTOOFF(s, &s, 10);
-				if (s[0] != '-' || range_start < 0) {
-					range_start = -1;
-				} else if (s[1]) {
-					range_end = BB_STRTOOFF(s+1, NULL, 10);
-					if (errno || range_end < range_start)
+			if (STRNCASECMP(iobuf, "Range:") == 0) {
+				/* We know only bytes=NNN-[MMM] */
+				char *s = skip_whitespace(iobuf + sizeof("Range:")-1);
+				if (strncmp(s, "bytes=", 6) == 0) {
+					s += sizeof("bytes=")-1;
+					range_start = BB_STRTOOFF(s, &s, 10);
+					if (s[0] != '-' || range_start < 0) {
+						range_start = -1;
+					} else if (s[1]) {
+						range_end = BB_STRTOOFF(s+1, NULL, 10);
+						if (errno || range_end < range_start)
 						range_start = -1;
+					}
 				}
 			}
-			continue;
-		}
 #endif
 #if ENABLE_FEATURE_HTTPD_GZIP
-		if (STRNCASECMP(iobuf, "Accept-Encoding:") == 0) {
-			/* Note: we do not support "gzip;q=0"
-			 * method of _disabling_ gzip
-			 * delivery. No one uses that, though */
-			const char *s = strstr(iobuf, "gzip");
-			if (s) {
-				// want more thorough checks?
-				//if (s[-1] == ' '
-				// || s[-1] == ','
-				// || s[-1] == ':'
-				//) {
-					content_gzip = 1;
-				//}
-			}
-			continue;
-		}
-#endif
 #if ENABLE_FEATURE_HTTPD_ETAG
-		if (STRNCASECMP(iobuf, "If-None-Match:") == 0) {
-			free(G.if_none_match);
-			G.if_none_match = xstrdup(skip_whitespace(iobuf + sizeof("If-None-Match:") - 1));
-			continue;
-		}
-#endif
-#if ENABLE_FEATURE_HTTPD_CGI
-		if (cgi_type != CGI_NONE) {
-			bool ct = (STRNCASECMP(iobuf, "Content-Type:") == 0);
-			char *cp;
-			char *colon = strchr(iobuf, ':');
-
-			if (!colon)
+			if (STRNCASECMP(iobuf, "If-None-Match:") == 0) {
+				free(G.if_none_match);
+				G.if_none_match = xstrdup(skip_whitespace(iobuf + sizeof("If-None-Match:") - 1));
 				continue;
-			cp = iobuf;
-			while (cp < colon) {
-				/* a-z => A-Z, not-alnum => _ */
-				char c = (*cp & ~0x20); /* toupper for A-Za-z, undef for others */
-				if ((unsigned)(c - 'A') <= ('Z' - 'A')) {
-					*cp++ = c;
-					continue;
+			}
+#endif
+			if (STRNCASECMP(iobuf, "Accept-Encoding:") == 0) {
+				/* Note: we do not support "gzip;q=0"
+				 * method of _disabling_ gzip
+				 * delivery. No one uses that, though */
+				const char *s = strstr(iobuf, "gzip");
+				if (s) {
+					// want more thorough checks?
+					//if (s[-1] == ' '
+					// || s[-1] == ','
+					// || s[-1] == ':'
+					//) {
+						content_gzip = 1;
+					//}
 				}
-				if (!isdigit(*cp))
-					*cp = '_';
-				cp++;
-			}
-			/* "Content-Type:" gets no HTTP_ prefix, all others do */
-			cp = xasprintf(ct ? "HTTP_%.*s=%s" + 5 : "HTTP_%.*s=%s",
-				(int)(colon - iobuf), iobuf,
-				skip_whitespace(colon + 1)
-			);
-			putenv(cp);
-		}
+			}
 #endif
-	} /* while extra header reading */
+			if (STRNCASECMP(iobuf, "Connection: keep-alive") == 0) {
+				keep_alive = 1;
+			}
+			// Keep WebSockets alive
+			if (STRNCASECMP(iobuf, "Connection: keep-alive, Upgrade") == 0) {
+				keep_alive = 1;
+			}
+			if (STRNCASECMP(iobuf, "Upgrade: websocket") == 0) {
+				websocket = 1;
+			}
+			if (STRNCASECMP(iobuf, "If-Modified-Since:") == 0) {
+				if_modified_since = xstrdup(skip_whitespace(iobuf + sizeof("If-Modified-Since:")-1));
+			}
+		} /* while extra header reading */
+	}
 
 	/* We are done reading headers, disable peer timeout */
 	alarm(0);
 
-	if (strcmp(bb_basename(urlcopy), HTTPD_CONF) == 0) {
+	if (strcmp(bb_basename(urlcopy), HTTPD_CONF) == 0 || !ip_allowed) {
 		/* protect listing [/path]/httpd.conf or IP deny */
 		send_headers_and_exit(HTTP_FORBIDDEN);
 	}
 
 #if ENABLE_FEATURE_HTTPD_BASIC_AUTH
+	/* Check for an auth token in the cookie -- may succeed over a failed Basic auth */
+	if (authorized <= 1) {
+		char *token, *s, *c = NULL;
+		const char *delim;
+		/* Only allow cookies from HTTP get requests. Other HTTP methods must explicitly
+		 * include the cookie in the query string. This mitigates malicious POSTs using
+		 * CSRF. */
+		if (prequest == request_GET && cookie) {
+			c = xstrdup(cookie);
+			delim = "; ";
+		} else if (prequest != request_GET && g_query) {
+			c = xstrdup(g_query);
+			delim = "&";
+		}
+
+		if (c) {
+			token = strstr(c, "auth=");
+			if (token) {
+				token += strlen("auth=");
+				s = strpbrk(token, delim);
+				if (s) *s = '\0';
+				authorized = check_user_passwd(urlcopy, token);
+			}
+			free(c);
+		}
+	}
+#endif
+#if ENABLE_FEATURE_HTTPD_BASIC_AUTH
 	/* Case: no "Authorization:" was seen, but page might require passwd.
 	 * Check that with dummy user:pass */
 	if (authorized < 0)
@@ -2592,38 +2742,179 @@
 		send_headers_and_exit(HTTP_UNAUTHORIZED);
 #endif
 
-	if (found_moved_temporarily)
+	if (found_moved_temporarily) {
 		send_headers_and_exit(HTTP_MOVED_TEMPORARILY);
+	}
 
-#if ENABLE_FEATURE_HTTPD_CGI
-	if (cgi_type != CGI_NONE) {
-		send_cgi_and_exit(
-			(cgi_type == CGI_INDEX) ? "/cgi-bin/index.cgi"
-			/*CGI_NORMAL or CGI_INTERPRETER*/ : urlcopy,
-			urlcopy, prequest, POST_length
-		);
+#if ENABLE_FEATURE_HTTPD_PROXY
+	if (proxy_entry != NULL) {
+		int proxy_fd, hlen;
+		len_and_sockaddr *lsa;
+
+		proxy_fd = socket(AF_INET, SOCK_STREAM, 0);
+		if (proxy_fd < 0)
+			send_headers_and_exit(HTTP_INTERNAL_SERVER_ERROR);
+		lsa = host2sockaddr(proxy_entry->host_port, 80);
+		if (lsa == NULL)
+			send_headers_and_exit(HTTP_INTERNAL_SERVER_ERROR);
+		if (connect(proxy_fd, &lsa->u.sa, lsa->len) < 0)
+			send_headers_and_exit(HTTP_INTERNAL_SERVER_ERROR);
+		free(lsa);
+		fdprintf(proxy_fd, "%s %s%s%s%s HTTP/%d.%d\r\n",
+				prequest, /* GET or POST */
+				proxy_entry->url_to, /* url part 1 */
+				urlcopy + strlen(proxy_entry->url_from), /* url part 2 */
+				(g_query ? "?" : ""), /* "?" (maybe) */
+				(g_query ? g_query : ""), /* query string (maybe) */
+				http_major_version, http_minor_version);
+		/* RFC7239 support */
+		if (forwarded_flags & FORWARDED_REMOVE) {
+			/* delete any Forwarded: headers */
+			hlen = header_ptr - header_buf;
+			remove_header(header_buf, &hlen, "forwarded:");
+			header_ptr = header_buf + hlen;
+		}
+		if (forwarded_flags & FORWARDED_APPEND) {
+			/* Append Forwarded: header */
+			char *tmp = NULL, faddr[128] = {0};
+			hlen = asprintf(&tmp, "Forwarded: for=%s%s%s\r\n",
+					fromAddr->u.sa.sa_family == AF_INET6 ? "\"" : "",
+					inet_ntop(fromAddr->u.sa.sa_family,
+#if ENABLE_FEATURE_IPV6
+						fromAddr->u.sa.sa_family == AF_INET6 ?
+							(void *)&fromAddr->u.sin6.sin6_addr
+							:
+#endif
+							(void *)&fromAddr->u.sin.sin_addr,
+						faddr, 128),
+					fromAddr->u.sa.sa_family == AF_INET6 ? "\"" : "");
+			/* don't overflow IOBUF_SIZE - 2 (\r\n space) */
+			if (header_ptr - header_buf + hlen < (IOBUF_SIZE - 2)) {
+				memcpy(header_ptr, tmp, hlen);
+				header_ptr += hlen;
+			}
+			free(tmp);
+		}
+		header_ptr[0] = '\r';
+		header_ptr[1] = '\n';
+		header_ptr += 2;
+		write(proxy_fd, header_buf, header_ptr - header_buf);
+		free(header_buf); /* on the order of 8k, free it */
+		/*
+		 * if we are keeping the connection alive then process the next
+		 * request
+		 */
+		if (cgi_io_loop(proxy_fd, proxy_fd, length)) {
+			close(proxy_fd);
+
+			// Loop variables
+			free(urlcopy);
+			urlcopy = NULL;
+			free(cookie);
+			cookie = NULL;
+			free(content_type);
+			content_type = NULL;
+
+			// Global variables
+			free(referer);
+			referer = NULL;
+			free(user_agent);
+			user_agent = NULL;
+			free(host);
+			host = NULL;
+			free(http_accept);
+			http_accept = NULL;
+			free(http_accept_language);
+			http_accept_language = NULL;
+			free(if_modified_since);
+			if_modified_since = NULL;
+			free(remoteuser);
+			remoteuser = NULL;
+			g_query = NULL;
+
+			goto next_request;
+		}
+		log_and_exit();
 	}
 #endif
 
+	tptr = urlcopy + 1;      /* skip first '/' */
+
 #if ENABLE_FEATURE_HTTPD_CGI
-	if (prequest != request_GET && prequest != request_HEAD) {
-		/* POST / DELETE / PUT / OPTIONS for files do not make sense */
-		send_headers_and_exit(HTTP_NOT_IMPLEMENTED);
+	if (strncmp(tptr, "cgi-bin/", 8) == 0) {
+		if (tptr[8] == '\0') {
+			/* protect listing "cgi-bin/" */
+			send_headers_and_exit(HTTP_FORBIDDEN);
+		}
+		send_cgi_and_exit(urlcopy, urlcopy, prequest, length, cookie, content_type);
 	}
-#else
-	/* !CGI: it can be only GET or HEAD */
 #endif
 
-#if ENABLE_FEATURE_HTTPD_BASIC_AUTH
-	/* Restore truncated .../index.html */
-	if (urlp[-1] == '/')
-		urlp[0] = index_page[0];
+	if (urlp[-1] == '/') {
+		/* When index_page string is appended to <dir>/ URL, it overwrites
+		 * the query string. If we fall back to call /cgi-bin/index.cgi,
+		 * query string would be lost and not available to the CGI.
+		 * Work around it by making a deep copy.
+		 */
+		if (ENABLE_FEATURE_HTTPD_CGI)
+			g_query = xstrdup(g_query); /* ok for NULL too */
+		strcpy(urlp, index_page);
+	}
+	if (stat(tptr, &sb) == 0) {
+#if ENABLE_FEATURE_HTTPD_CONFIG_WITH_SCRIPT_INTERPR
+		char *suffix = strrchr(tptr, '.');
+		if (suffix) {
+			Htaccess *cur;
+			for (cur = script_i; cur; cur = cur->next) {
+				if (strcmp(cur->before_colon + 1, suffix) == 0) {
+					send_cgi_and_exit(urlcopy, urlcopy, prequest, length, cookie, content_type);
+				}
+			}
+		}
 #endif
-	send_file_and_exit(urlcopy + 1,
+		file_size = sb.st_size;
+		last_mod = sb.st_mtime;
+		if (if_modified_since) {
+			char tmp_str[80];
+			strftime(tmp_str, sizeof(tmp_str), RFC1123FMT, gmtime(&last_mod));
+			if (strcmp(tmp_str, if_modified_since) == 0) {
+				send_headers_and_exit(HTTP_NOT_MODIFIED);
+			}
+		}
+	}
+#if ENABLE_FEATURE_HTTPD_CGI
+	else if (urlp[-1] == '/') {
+		/* It's a dir URL and there is no index.html
+		 * Try cgi-bin/index.cgi */
+		if (access("/cgi-bin/index.cgi"+1, X_OK) == 0) {
+			urlp[0] = '\0'; /* remove index_page */
+			send_cgi_and_exit("/cgi-bin/index.cgi", urlcopy, prequest, length, cookie, content_type);
+		}
+	}
+	/* else fall through to send_file, it errors out if open fails: */
+
+	if (prequest != request_GET && prequest != request_HEAD &&
+			prequest != request_DELETE) {
+		/* POST for files does not make sense */
+		send_headers_and_exit(HTTP_NOT_IMPLEMENTED);
+	}
+	if (strncmp(tptr, "ccgi-bin/", 9) == 0) {
+		if (tptr[9] == '\0') {
+			/* protect listing "cgi-bin/" */
+			send_headers_and_exit(HTTP_FORBIDDEN);
+		}
+		send_cgi_and_exit(urlcopy, urlcopy, prequest, length, cookie, content_type);
+	}
+	send_file_and_exit(tptr,
 		(prequest != request_HEAD ? (SEND_HEADERS + SEND_BODY) : SEND_HEADERS)
 	);
+#else
+	send_file_and_exit(tptr, (SEND_HEADERS + SEND_BODY));
+#endif
 }
 
+static const int const_int_1 = 1;
+
 /*
  * The main http server function.
  * Given a socket, listen for new connections and farm out
@@ -2634,15 +2925,30 @@
 static void mini_httpd(int server_socket) NORETURN;
 static void mini_httpd(int server_socket)
 {
+	int children = 0;
 	/* NB: it's best to not use xfuncs in this loop before fork().
 	 * Otherwise server may die on transient errors (temporary
 	 * out-of-memory condition, etc), which is Bad(tm).
 	 * Try to do any dangerous calls after fork.
 	 */
 	while (1) {
-		int n;
+		int n, status;
+		pid_t pid;
 		len_and_sockaddr fromAddr;
 
+		if (max_instances != 0 && children >= max_instances) {
+			pid = waitpid(-1, &status, 0);
+			if (pid != 0 && pid != -1) {
+				children--;
+			}
+			continue;
+		} else if (children > 0) {
+			pid = waitpid(-1, &status, WNOHANG);
+			if (pid != 0 && pid != -1) {
+				children--;
+			}
+		}
+
 		/* Wait for connections... */
 		fromAddr.len = LSA_SIZEOF_SA;
 		n = accept(server_socket, &fromAddr.u.sa, &fromAddr.len);
@@ -2657,9 +2963,10 @@
 //to ratelimit connects in iptables)
 
 		/* set the KEEPALIVE option to cull dead connections */
-		setsockopt_keepalive(n);
+		setsockopt(n, SOL_SOCKET, SO_KEEPALIVE, &const_int_1, sizeof(const_int_1));
 
-		if (fork() == 0) {
+		pid = fork();
+		if (pid == 0) {
 			/* child */
 			/* Do not reload config on HUP */
 			signal(SIGHUP, SIG_IGN);
@@ -2668,7 +2975,8 @@
 			xdup2(0, 1);
 
 			handle_incoming_and_exit(&fromAddr);
-		}
+		} else if (pid > 0)
+			children++;
 		/* parent, or fork failed */
 		close(n);
 	} /* while (1) */
@@ -2679,6 +2987,7 @@
 static void mini_httpd_nommu(int server_socket, int argc, char **argv)
 {
 	char *argv_copy[argc + 2];
+	int children = 0;
 
 	argv_copy[0] = argv[0];
 	argv_copy[1] = (char*)"-i";
@@ -2690,17 +2999,34 @@
 	 * Try to do any dangerous calls after fork.
 	 */
 	while (1) {
-		int n;
+		int n, status;
+		pid_t pid;
+		len_and_sockaddr fromAddr;
+
+		if (max_instances != 0 && children >= max_instances) {
+			pid = waitpid(-1, &status, 0);
+			if (pid != 0 && pid != -1) {
+				children--;
+			}
+			continue;
+		} else if (children > 0) {
+			pid = waitpid(-1, &status, WNOHANG);
+			if (pid != 0 && pid != -1) {
+				children--;
+			}
+		}
 
 		/* Wait for connections... */
-		n = accept(server_socket, NULL, NULL);
+		fromAddr.len = LSA_SIZEOF_SA;
+		n = accept(server_socket, &fromAddr.u.sa, &fromAddr.len);
 		if (n < 0)
 			continue;
 
 		/* set the KEEPALIVE option to cull dead connections */
-		setsockopt_keepalive(n);
+		setsockopt(n, SOL_SOCKET, SO_KEEPALIVE, &const_int_1, sizeof(const_int_1));
 
-		if (vfork() == 0) {
+		pid = vfork();
+		if (pid == 0) {
 			/* child */
 			/* Do not reload config on HUP */
 			signal(SIGHUP, SIG_IGN);
@@ -2710,7 +3036,8 @@
 
 			/* Run a copy of ourself in inetd mode */
 			re_exec(argv_copy);
-		}
+		} else if (pid > 0)
+			children++;
 		argv_copy[0][0] &= 0x7f;
 		/* parent, or vfork failed */
 		close(n);
@@ -2746,10 +3073,13 @@
 	c_opt_config_file = 0,
 	d_opt_decode_url,
 	h_opt_home_httpd,
+	n_opt_max_instances,
 	IF_FEATURE_HTTPD_ENCODE_URL_STR(e_opt_encode_url,)
+	IF_FEATURE_HTTPD_ENCODE_URL_STR(e_opt_decode_html,)
 	IF_FEATURE_HTTPD_BASIC_AUTH(    r_opt_realm     ,)
 	IF_FEATURE_HTTPD_AUTH_MD5(      m_opt_md5       ,)
 	IF_FEATURE_HTTPD_SETUID(        u_opt_setuid    ,)
+	IF_FEATURE_HTTPD_PROXY(         u_opt_forwarded ,)
 	p_opt_port      ,
 	p_opt_inetd     ,
 	p_opt_foreground,
@@ -2757,10 +3087,13 @@
 	OPT_CONFIG_FILE = 1 << c_opt_config_file,
 	OPT_DECODE_URL  = 1 << d_opt_decode_url,
 	OPT_HOME_HTTPD  = 1 << h_opt_home_httpd,
+	OPT_MAX_INSTANCES = 1 << n_opt_max_instances,
 	OPT_ENCODE_URL  = IF_FEATURE_HTTPD_ENCODE_URL_STR((1 << e_opt_encode_url)) + 0,
+	OPT_DECODE_HTML = IF_FEATURE_HTTPD_ENCODE_URL_STR((1 << e_opt_decode_html)) + 0,
 	OPT_REALM       = IF_FEATURE_HTTPD_BASIC_AUTH(    (1 << r_opt_realm     )) + 0,
 	OPT_MD5         = IF_FEATURE_HTTPD_AUTH_MD5(      (1 << m_opt_md5       )) + 0,
 	OPT_SETUID      = IF_FEATURE_HTTPD_SETUID(        (1 << u_opt_setuid    )) + 0,
+	OPT_FORWARDED   = IF_FEATURE_HTTPD_PROXY(         (1 << u_opt_forwarded )) + 0,
 	OPT_PORT        = 1 << p_opt_port,
 	OPT_INETD       = 1 << p_opt_inetd,
 	OPT_FOREGROUND  = 1 << p_opt_foreground,
@@ -2774,8 +3107,10 @@
 	int server_socket = server_socket; /* for gcc */
 	unsigned opt;
 	char *url_for_decode;
+	char *n_max_instances;
 	IF_FEATURE_HTTPD_ENCODE_URL_STR(const char *url_for_encode;)
 	IF_FEATURE_HTTPD_SETUID(const char *s_ugid = NULL;)
+	IF_FEATURE_HTTPD_PROXY(const char *forwarded = NULL;)
 	IF_FEATURE_HTTPD_SETUID(struct bb_uidgid_t ugid;)
 	IF_FEATURE_HTTPD_AUTH_MD5(const char *pass;)
 
@@ -2790,21 +3125,22 @@
 	/* We do not "absolutize" path given by -h (home) opt.
 	 * If user gives relative path in -h,
 	 * $SCRIPT_FILENAME will not be set. */
-	opt = getopt32(argv, "^"
-			"c:d:h:"
+	opt = getopt32(argv, "c:d:h:n:"
 			IF_FEATURE_HTTPD_ENCODE_URL_STR("e:")
+			IF_FEATURE_HTTPD_ENCODE_URL_STR("D:")
 			IF_FEATURE_HTTPD_BASIC_AUTH("r:")
 			IF_FEATURE_HTTPD_AUTH_MD5("m:")
 			IF_FEATURE_HTTPD_SETUID("u:")
-			"p:ifv"
-			"\0"
-			/* -v counts, -i implies -f */
-			"vv:if",
+			IF_FEATURE_HTTPD_PROXY("F:")
+			"p:ifv" "\0" "vv:if" /* -v counts, -i implies -f */,
 			&opt_c_configFile, &url_for_decode, &home_httpd
+			, &n_max_instances
+			IF_FEATURE_HTTPD_ENCODE_URL_STR(, &url_for_encode)
 			IF_FEATURE_HTTPD_ENCODE_URL_STR(, &url_for_encode)
 			IF_FEATURE_HTTPD_BASIC_AUTH(, &g_realm)
 			IF_FEATURE_HTTPD_AUTH_MD5(, &pass)
 			IF_FEATURE_HTTPD_SETUID(, &s_ugid)
+			IF_FEATURE_HTTPD_PROXY(, &forwarded)
 			, &bind_addr_or_port
 			, &verbose
 		);
@@ -2812,11 +3148,17 @@
 		fputs_stdout(percent_decode_in_place(url_for_decode, /*strict:*/ 0));
 		return 0;
 	}
+	if (opt & OPT_MAX_INSTANCES)
+		max_instances = atoi(n_max_instances);
 #if ENABLE_FEATURE_HTTPD_ENCODE_URL_STR
 	if (opt & OPT_ENCODE_URL) {
 		fputs_stdout(encodeString(url_for_encode));
 		return 0;
 	}
+	if (opt & OPT_DECODE_HTML) {
+		fputs_stdout(decodeString(url_for_encode));
+		return 0;
+	}
 #endif
 #if ENABLE_FEATURE_HTTPD_AUTH_MD5
 	if (opt & OPT_MD5) {
@@ -2834,6 +3176,21 @@
 		xget_uidgid(&ugid, s_ugid);
 	}
 #endif
+#if ENABLE_FEATURE_HTTPD_PROXY
+	forwarded_flags = 0;
+	if (opt & OPT_FORWARDED) {
+		if (strcasecmp(forwarded, "unchanged") == 0)
+			forwarded_flags = 0;
+		else if (strcasecmp(forwarded, "remove") == 0)
+			forwarded_flags = FORWARDED_REMOVE;
+		else if (strcasecmp(forwarded, "append") == 0)
+			forwarded_flags = FORWARDED_APPEND;
+		else if (strcasecmp(forwarded, "replace") == 0)
+			forwarded_flags = FORWARDED_APPEND|FORWARDED_REMOVE;
+		else
+			bb_error_msg_and_die("invalid Forwarded action");
+	}
+#endif
 
 #if !BB_MMU
 	if (!(opt & OPT_FOREGROUND)) {
@@ -2848,7 +3205,7 @@
 		xchdir(home_httpd);
 
 	if (!(opt & OPT_INETD)) {
-		signal(SIGCHLD, SIG_IGN);
+		signal(SIGCHLD, SIG_DFL);
 		server_socket = openServer();
 #if ENABLE_FEATURE_HTTPD_SETUID
 		/* drop privileges */
