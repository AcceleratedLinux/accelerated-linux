.\"     Title: IPSEC_KEYBLOBTOID
.\"    Author: 
.\" Generator: DocBook XSL Stylesheets v1.73.2 <http://docbook.sf.net/>
.\"      Date: 11/14/2008
.\"    Manual: 25 March 2002
.\"    Source: 25 March 2002
.\"
.TH "IPSEC_KEYBLOBTOID" "3" "11/14/2008" "25 March 2002" "25 March 2002"
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.SH "NAME"
ipsec_keyblobtoid, ipsec_splitkeytoid - generate key IDs from RSA keys
.SH "SYNOPSIS"
.sp
.ft B
.nf
#include <freeswan\.h>

.fi
.ft
.HP 19
.BI "size_t keyblobtoid(const\ unsigned\ char\ *\ " "blob" ", size_t\ " "bloblen" ", char\ *\ " "dst" ", size_t\ " "dstlen" ");"
.sp
.ft B
.nf

.fi
.ft
.HP 20
.BI "size_t splitkeytoid(const\ unsigned\ char\ *\ " "e" ", size_t\ " "elen" ", const\ unsigned\ char\ *\ " "m" ", size_t\ " "mlen" ", char\ *\ " "dst" ", size_t\ " "dstlen" ");"
.SH "DESCRIPTION"
.PP
\fIKeyblobtoid\fR
and
\fBsplitkeytoid\fR
generate key IDs from RSA keys, for use in messages and reporting, writing the result to
\fIdst\fR\. A
\fIkey ID\fR
is a short ASCII string identifying a key; currently it is just the first nine characters of the base64 encoding of the RFC 2537/3110 \(lqbyte blob\(rq representation of the key\. (Beware that no finite key ID can be collision\-proof: there is always some small chance of two random keys having the same ID\.)
.PP
\fIKeyblobtoid\fR
generates a key ID from a key which is already in the form of an RFC 2537/3110 binary key
\fIblob\fR
(encoded exponent length, exponent, modulus)\.
.PP
\fISplitkeytoid\fR
generates a key ID from a key given in the form of a separate (binary) exponent
\fIe\fR
and modulus
\fIm\fR\.
.PP
The
\fIdstlen\fR
parameter of either specifies the size of the
\fIdst\fR
parameter; under no circumstances are more than
\fIdstlen\fR
bytes written to
\fIdst\fR\. A result which will not fit is truncated\.
\fIDstlen\fR
can be zero, in which case
\fIdst\fR
need not be valid and no result is written, but the return value is unaffected; in all other cases, the (possibly truncated) result is NUL\-terminated\. The
\fIfreeswan\.h\fR
header file defines a constant
\fBKEYID_BUF\fR
which is the size of a buffer large enough for worst\-case results\.
.PP
Both functions return
0
for a failure, and otherwise always return the size of buffer which would be needed to accommodate the full conversion result, including terminating NUL; it is the caller\'s responsibility to check this against the size of the provided buffer to determine whether truncation has occurred\.
.PP
With keys generated by
\fBipsec_rsasigkey\fR(3), the first two base64 digits are always the same, and the third carries only about one bit of information\. It\'s worse with keys using longer fixed exponents, e\.g\. the 24\-bit exponent that\'s common in X\.509 certificates\. However, being able to relate key IDs to the full base64 text form of keys by eye is sufficiently useful that this waste of space seems justifiable\. The choice of nine digits is a compromise between bulk and probability of collision\.
.SH "SEE ALSO"
.PP
RFC 3110,
\fIRSA/SHA\-1 SIGs and RSA KEYs in the Domain Name System (DNS)\fR, Eastlake, 2001 (superseding the older but better\-known RFC 2537)\.
.SH "DIAGNOSTICS"
.PP
Fatal errors are: key too short to supply enough bits to construct a complete key ID (almost certainly indicating a garbage key); exponent too long for its length to be representable\.
.SH "HISTORY"
.PP
Written for the FreeS/WAN project by Henry Spencer\.
