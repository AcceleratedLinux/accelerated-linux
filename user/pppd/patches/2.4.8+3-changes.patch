diff -ru ppp-ppp-2.4.7/chat/chat.c ppp-ppp-2.4.8/chat/chat.c
--- ppp-ppp-2.4.7/chat/chat.c	2020-03-09 12:16:34.490057835 +1000
+++ ppp-ppp-2.4.8/chat/chat.c	2020-03-09 12:16:15.666513309 +1000
@@ -577,6 +577,7 @@
 	syslog(LOG_INFO, "%s", line);
     if (to_stderr)
 	fprintf(stderr, "%s\n", line);
+    va_end(args);
 }
 
 /*
@@ -602,6 +603,7 @@
 	syslog(LOG_ERR, "%s", line);
     if (to_stderr)
 	fprintf(stderr, "%s\n", line);
+    va_end(args);
     terminate(code);
 }
 
diff -ru ppp-ppp-2.4.7/pppd/auth.c ppp-ppp-2.4.8/pppd/auth.c
--- ppp-ppp-2.4.7/pppd/auth.c	2020-03-09 12:16:34.494057737 +1000
+++ ppp-ppp-2.4.8/pppd/auth.c	2020-03-09 12:16:15.670513212 +1000
@@ -100,6 +100,10 @@
 #endif
 #include <time.h>
 
+#ifdef SYSTEMD
+#include <systemd/sd-daemon.h>
+#endif
+
 #include "pppd.h"
 #include "fsm.h"
 #include "lcp.h"
@@ -115,7 +119,6 @@
 #include "pathnames.h"
 #include "session.h"
 
-static const char rcsid[] = RCSID;
 
 /* Bits in scan_authfile return value */
 #define NONWILD_SERVER	1
@@ -445,6 +448,7 @@
     euid = geteuid();
     if (seteuid(getuid()) == -1) {
 	option_error("unable to reset uid before opening %s: %m", fname);
+        free(fname);
 	return 0;
     }
     ufile = fopen(fname, "r");
@@ -452,6 +456,7 @@
 	fatal("unable to regain privileges: %m");
     if (ufile == NULL) {
 	option_error("unable to open user login data file %s", fname);
+        free(fname);
 	return 0;
     }
     check_access(ufile, fname);
@@ -462,6 +467,7 @@
 	|| fgets(p, MAXSECRETLEN - 1, ufile) == NULL) {
 	fclose(ufile);
 	option_error("unable to read user login data file %s", fname);
+        free(fname);
 	return 0;
     }
     fclose(ufile);
@@ -483,6 +489,7 @@
 	explicit_passwd = 1;
     }
 
+    free(fname);
     return (1);
 }
 
@@ -1128,8 +1135,15 @@
 	/*
 	 * Detach now, if the updetach option was given.
 	 */
-	if (updetach && !nodetach)
+	if (updetach && !nodetach) {
+	    dbglog("updetach is set. Now detaching.");
 	    detach();
+#ifdef SYSTEMD
+	} else if (nodetach && up_sdnotify) {
+	    dbglog("up_sdnotify is set. Now notifying systemd: READY=1");
+	    sd_notify(0, "READY=1");
+#endif
+	}
     }
     ++num_np_up;
 }
diff -ru ppp-ppp-2.4.7/pppd/cbcp.c ppp-ppp-2.4.8/pppd/cbcp.c
--- ppp-ppp-2.4.7/pppd/cbcp.c	2014-08-09 22:31:39.000000000 +1000
+++ ppp-ppp-2.4.8/pppd/cbcp.c	2020-03-09 12:16:15.670513212 +1000
@@ -45,7 +45,6 @@
 #include "fsm.h"
 #include "lcp.h"
 
-static const char rcsid[] = RCSID;
 
 /*
  * Options.
diff -ru ppp-ppp-2.4.7/pppd/ccp.c ppp-ppp-2.4.8/pppd/ccp.c
--- ppp-ppp-2.4.7/pppd/ccp.c	2014-08-09 22:31:39.000000000 +1000
+++ ppp-ppp-2.4.8/pppd/ccp.c	2020-03-09 12:16:15.670513212 +1000
@@ -43,7 +43,6 @@
 #include "lcp.h"	/* lcp_close(), lcp_fsm */
 #endif
 
-static const char rcsid[] = RCSID;
 
 /*
  * Unfortunately there is a bug in zlib which means that using a
@@ -676,7 +675,8 @@
     ccp_options *go = &ccp_gotoptions[f->unit];
 
     return (go->bsd_compress? CILEN_BSD_COMPRESS: 0)
-	+ (go->deflate? CILEN_DEFLATE: 0)
+	+ (go->deflate && go->deflate_correct? CILEN_DEFLATE: 0)
+	+ (go->deflate && go->deflate_draft? CILEN_DEFLATE: 0)
 	+ (go->predictor_1? CILEN_PREDICTOR_1: 0)
 	+ (go->predictor_2? CILEN_PREDICTOR_2: 0)
 	+ (go->mppe? CILEN_MPPE: 0);
diff -ru ppp-ppp-2.4.7/pppd/ccp.h ppp-ppp-2.4.8/pppd/ccp.h
--- ppp-ppp-2.4.7/pppd/ccp.h	2014-08-09 22:31:39.000000000 +1000
+++ ppp-ppp-2.4.8/pppd/ccp.h	2020-03-09 12:16:15.670513212 +1000
@@ -37,7 +37,7 @@
     bool predictor_2;		/* do Predictor-2? */
     bool deflate_correct;	/* use correct code for deflate? */
     bool deflate_draft;		/* use draft RFC code for deflate? */
-    bool mppe;			/* do MPPE? */
+    u_char mppe;		/* MPPE bitfield */
     u_short bsd_bits;		/* # bits/code for BSD Compress */
     u_short deflate_size;	/* lg(window size) for Deflate */
     short method;		/* code for chosen compression method */
diff -ru ppp-ppp-2.4.7/pppd/chap_ms.c ppp-ppp-2.4.8/pppd/chap_ms.c
--- ppp-ppp-2.4.7/pppd/chap_ms.c	2014-08-09 22:31:39.000000000 +1000
+++ ppp-ppp-2.4.8/pppd/chap_ms.c	2020-03-09 12:16:15.670513212 +1000
@@ -94,7 +94,6 @@
 #include "pppcrypt.h"
 #include "magic.h"
 
-static const char rcsid[] = RCSID;
 
 
 static void	ascii2unicode __P((char[], int, u_char[]));
diff -ru ppp-ppp-2.4.7/pppd/demand.c ppp-ppp-2.4.8/pppd/demand.c
--- ppp-ppp-2.4.7/pppd/demand.c	2014-08-09 22:31:39.000000000 +1000
+++ ppp-ppp-2.4.8/pppd/demand.c	2020-03-09 12:16:15.670513212 +1000
@@ -52,7 +52,6 @@
 #include "ipcp.h"
 #include "lcp.h"
 
-static const char rcsid[] = RCSID;
 
 char *frame;
 int framelen;
diff -ru ppp-ppp-2.4.7/pppd/eap.c ppp-ppp-2.4.8/pppd/eap.c
--- ppp-ppp-2.4.7/pppd/eap.c	2014-08-09 22:31:39.000000000 +1000
+++ ppp-ppp-2.4.8/pppd/eap.c	2020-03-09 12:16:15.670513212 +1000
@@ -76,7 +76,6 @@
 #define	SHA_DIGESTSIZE 20
 #endif
 
-static const char rcsid[] = RCSID;
 
 eap_state eap_states[NUM_PPP];		/* EAP state; one for each unit */
 #ifdef USE_SRP
@@ -1330,6 +1329,12 @@
 #endif /* USE_SRP */
 
 	/*
+	 * Ignore requests if we're not open
+	 */
+	if (esp->es_client.ea_state <= eapClosed)
+		return;
+
+	/*
 	 * Note: we update es_client.ea_id *only if* a Response
 	 * message is being generated.  Otherwise, we leave it the
 	 * same for duplicate detection purposes.
@@ -1421,7 +1426,7 @@
 		}
 
 		/* Not so likely to happen. */
-		if (vallen >= len + sizeof (rhostname)) {
+		if (len - vallen >= sizeof (rhostname)) {
 			dbglog("EAP: trimming really long peer name down");
 			BCOPY(inp + vallen, rhostname, sizeof (rhostname) - 1);
 			rhostname[sizeof (rhostname) - 1] = '\0';
@@ -1737,6 +1742,12 @@
 	u_char dig[SHA_DIGESTSIZE];
 #endif /* USE_SRP */
 
+	/*
+	 * Ignore responses if we're not open
+	 */
+	if (esp->es_server.ea_state <= eapClosed)
+		return;
+
 	if (esp->es_server.ea_id != id) {
 		dbglog("EAP: discarding Response %d; expected ID %d", id,
 		    esp->es_server.ea_id);
@@ -1847,7 +1858,7 @@
 		}
 
 		/* Not so likely to happen. */
-		if (vallen >= len + sizeof (rhostname)) {
+		if (len - vallen >= sizeof (rhostname)) {
 			dbglog("EAP: trimming really long peer name down");
 			BCOPY(inp + vallen, rhostname, sizeof (rhostname) - 1);
 			rhostname[sizeof (rhostname) - 1] = '\0';
@@ -2048,6 +2059,12 @@
 int id;
 int len;
 {
+	/*
+	 * Ignore failure messages if we're not open
+	 */
+	if (esp->es_client.ea_state <= eapClosed)
+		return;
+
 	if (!eap_client_active(esp)) {
 		dbglog("EAP unexpected failure message in state %s (%d)",
 		    eap_state_name(esp->es_client.ea_state),
diff -ru ppp-ppp-2.4.7/pppd/ecp.c ppp-ppp-2.4.8/pppd/ecp.c
--- ppp-ppp-2.4.7/pppd/ecp.c	2014-08-09 22:31:39.000000000 +1000
+++ ppp-ppp-2.4.8/pppd/ecp.c	2020-03-09 12:16:15.670513212 +1000
@@ -59,7 +59,6 @@
 
 #define RCSID	"$Id: ecp.c,v 1.4 2004/11/04 10:02:26 paulus Exp $"
 
-static const char rcsid[] = RCSID;
 
 #include <string.h>
 
diff -ru ppp-ppp-2.4.7/pppd/eui64.c ppp-ppp-2.4.8/pppd/eui64.c
--- ppp-ppp-2.4.7/pppd/eui64.c	2014-08-09 22:31:39.000000000 +1000
+++ ppp-ppp-2.4.8/pppd/eui64.c	2020-03-09 12:16:15.678513019 +1000
@@ -39,7 +39,6 @@
 
 #include "pppd.h"
 
-static const char rcsid[] = RCSID;
 
 /*
  * eui64_ntoa - Make an ascii representation of an interface identifier
diff -ru ppp-ppp-2.4.7/pppd/fsm.c ppp-ppp-2.4.8/pppd/fsm.c
--- ppp-ppp-2.4.7/pppd/fsm.c	2014-08-09 22:31:39.000000000 +1000
+++ ppp-ppp-2.4.8/pppd/fsm.c	2020-03-09 12:16:15.678513019 +1000
@@ -55,7 +55,6 @@
 #include "pppd.h"
 #include "fsm.h"
 
-static const char rcsid[] = RCSID;
 
 static void fsm_timeout __P((void *));
 static void fsm_rconfreq __P((fsm *, int, u_char *, int));
@@ -468,7 +467,7 @@
 	f->nakloops = 0;
 
     } else {
-	/* we sent CONFACK or CONFREJ */
+	/* we sent CONFNAK or CONFREJ */
 	if (f->state != ACKRCVD)
 	    f->state = REQSENT;
 	if( code == CONFNAK )
diff -ru ppp-ppp-2.4.7/pppd/ipcp.c ppp-ppp-2.4.8/pppd/ipcp.c
--- ppp-ppp-2.4.7/pppd/ipcp.c	2020-03-09 12:16:34.494057737 +1000
+++ ppp-ppp-2.4.8/pppd/ipcp.c	2020-03-09 12:16:15.678513019 +1000
@@ -63,7 +63,6 @@
 #include "ipcp.h"
 #include "pathnames.h"
 
-static const char rcsid[] = RCSID;
 
 /* global vars */
 ipcp_options ipcp_wantoptions[NUM_PPP];	/* Options that we want to request */
@@ -182,10 +181,10 @@
     { "noipdefault", o_bool, &disable_defaultip,
       "Don't use name for default IP adrs", 1 },
 
-    { "ms-dns", 1, (void *)setdnsaddr,
-      "DNS address for the peer's use" },
-    { "ms-wins", 1, (void *)setwinsaddr,
-      "Nameserver for SMB over TCP/IP for peer" },
+    { "ms-dns", o_special, (void *)setdnsaddr,
+      "DNS address for the peer's use", OPT_A2LIST },
+    { "ms-wins", o_special, (void *)setwinsaddr,
+      "Nameserver for SMB over TCP/IP for peer", OPT_A2LIST },
 
     { "ipcp-restart", o_int, &ipcp_fsm[0].timeouttime,
       "Set timeout for IPCP", OPT_PRIO },
diff -ru ppp-ppp-2.4.7/pppd/ipv6cp.c ppp-ppp-2.4.8/pppd/ipv6cp.c
--- ppp-ppp-2.4.7/pppd/ipv6cp.c	2014-08-09 22:31:39.000000000 +1000
+++ ppp-ppp-2.4.8/pppd/ipv6cp.c	2020-03-09 12:16:15.678513019 +1000
@@ -168,7 +168,6 @@
 #include "magic.h"
 #include "pathnames.h"
 
-static const char rcsid[] = RCSID;
 
 /* global vars */
 ipv6cp_options ipv6cp_wantoptions[NUM_PPP];     /* Options that we want to request */
@@ -178,6 +177,7 @@
 int no_ifaceid_neg = 0;
 
 /* local vars */
+static int default_route_set[NUM_PPP];		/* Have set up a default route */
 static int ipv6cp_is_up;
 
 /* Hook for a plugin to know when IPv6 protocol has come up */
@@ -246,6 +246,15 @@
     { "ipv6cp-accept-local", o_bool, &ipv6cp_allowoptions[0].accept_local,
       "Accept peer's interface identifier for us", 1 },
 
+    { "defaultroute6", o_bool, &ipv6cp_wantoptions[0].default_route,
+      "Add default IPv6 route", OPT_ENABLE|1, &ipv6cp_allowoptions[0].default_route },
+    { "nodefaultroute6", o_bool, &ipv6cp_allowoptions[0].default_route,
+      "disable defaultroute6 option", OPT_A2CLR,
+      &ipv6cp_wantoptions[0].default_route },
+    { "-defaultroute6", o_bool, &ipv6cp_allowoptions[0].default_route,
+      "disable defaultroute6 option", OPT_ALIAS | OPT_A2CLR,
+      &ipv6cp_wantoptions[0].default_route },
+
     { "ipv6cp-use-ipaddr", o_bool, &ipv6cp_allowoptions[0].use_ip,
       "Use (default) IPv4 address as interface identifier", 1 },
 
@@ -444,6 +453,10 @@
     wo->vj_protocol = IPV6CP_COMP;
 #endif
 
+    /*
+     * XXX This controls whether the user may use the defaultroute option.
+     */
+    ao->default_route = 1;
 }
 
 
@@ -1152,6 +1165,9 @@
 #endif
     if (!sifnpmode(u, PPP_IPV6, NPMODE_QUEUE))
 	return 0;
+    if (wo->default_route)
+	if (sif6defaultroute(u, wo->ourid, wo->hisid))
+	    default_route_set[u] = 1;
 
     notice("ipv6_demand_conf");
     notice("local  LL address %s", llv6_ntoa(wo->ourid));
@@ -1231,6 +1247,10 @@
 		return;
 	    }
 
+	    /* assign a default route through the interface if required */
+	    if (ipv6cp_wantoptions[f->unit].default_route)
+		if (sif6defaultroute(f->unit, go->ourid, ho->hisid))
+		    default_route_set[f->unit] = 1;
 	}
 	demand_rexmit(PPP_IPV6);
 	sifnpmode(f->unit, PPP_IPV6, NPMODE_PASS);
@@ -1252,6 +1272,11 @@
 	}
 	sifnpmode(f->unit, PPP_IPV6, NPMODE_PASS);
 
+	/* assign a default route through the interface if required */
+	if (ipv6cp_wantoptions[f->unit].default_route)
+	    if (sif6defaultroute(f->unit, go->ourid, ho->hisid))
+		default_route_set[f->unit] = 1;
+
 	notice("local  LL address %s", llv6_ntoa(go->ourid));
 	notice("remote LL address %s", llv6_ntoa(ho->hisid));
     }
diff -ru ppp-ppp-2.4.7/pppd/ipv6cp.h ppp-ppp-2.4.8/pppd/ipv6cp.h
--- ppp-ppp-2.4.7/pppd/ipv6cp.h	2014-08-09 22:31:39.000000000 +1000
+++ ppp-ppp-2.4.8/pppd/ipv6cp.h	2020-03-09 12:16:15.678513019 +1000
@@ -150,6 +150,7 @@
 typedef struct ipv6cp_options {
     int neg_ifaceid;		/* Negotiate interface identifier? */
     int req_ifaceid;		/* Ask peer to send interface identifier? */
+    int default_route;		/* Assign default route through interface? */
     int accept_local;		/* accept peer's value for iface id? */
     int opt_local;		/* ourtoken set by option */
     int opt_remote;		/* histoken set by option */
diff -ru ppp-ppp-2.4.7/pppd/ipxcp.c ppp-ppp-2.4.8/pppd/ipxcp.c
--- ppp-ppp-2.4.7/pppd/ipxcp.c	2014-08-09 22:31:39.000000000 +1000
+++ ppp-ppp-2.4.8/pppd/ipxcp.c	2020-03-09 12:16:15.678513019 +1000
@@ -62,7 +62,6 @@
 #include "pathnames.h"
 #include "magic.h"
 
-static const char rcsid[] = RCSID;
 
 /* global vars */
 ipxcp_options ipxcp_wantoptions[NUM_PPP];	/* Options that we want to request */
@@ -1194,7 +1193,7 @@
 	case IPX_ROUTER_NAME:
 	    if (cilen >= CILEN_NAME) {
 		int name_size = cilen - CILEN_NAME;
-		if (name_size > sizeof (ho->name))
+		if (name_size >= sizeof (ho->name))
 		    name_size = sizeof (ho->name) - 1;
 		memset (ho->name, 0, sizeof (ho->name));
 		memcpy (ho->name, p, name_size);
diff -ru ppp-ppp-2.4.7/pppd/lcp.c ppp-ppp-2.4.8/pppd/lcp.c
--- ppp-ppp-2.4.7/pppd/lcp.c	2020-03-09 12:16:34.494057737 +1000
+++ ppp-ppp-2.4.8/pppd/lcp.c	2020-03-09 12:16:15.678513019 +1000
@@ -56,7 +56,6 @@
 #include "chap-new.h"
 #include "magic.h"
 
-static const char rcsid[] = RCSID;
 
 /*
  * When the link comes up we want to be able to wait for a short while,
diff -ru ppp-ppp-2.4.7/pppd/magic.c ppp-ppp-2.4.8/pppd/magic.c
--- ppp-ppp-2.4.7/pppd/magic.c	2014-08-09 22:31:39.000000000 +1000
+++ ppp-ppp-2.4.8/pppd/magic.c	2020-03-09 12:16:15.678513019 +1000
@@ -51,10 +51,9 @@
 #include "pppd.h"
 #include "magic.h"
 
-static const char rcsid[] = RCSID;
 
-extern long mrand48 __P((void));
-extern void srand48 __P((long));
+extern long mrand48 (void);
+extern void srand48 (long);
 
 /*
  * magic_init - Initialize the magic number generator.
@@ -64,7 +63,7 @@
  * and current time, currently.
  */
 void
-magic_init()
+magic_init(void)
 {
     long seed;
     struct timeval t;
@@ -78,7 +77,7 @@
  * magic - Returns the next magic number.
  */
 u_int32_t
-magic()
+magic(void)
 {
     return (u_int32_t) mrand48();
 }
@@ -102,20 +101,19 @@
  */
 
 double
-drand48()
+drand48(void)
 {
     return (double)random() / (double)0x7fffffffL; /* 2**31-1 */
 }
 
 long
-mrand48()
+mrand48(void)
 {
     return random();
 }
 
 void
-srand48(seedval)
-long seedval;
+srand48(long seedval)
 {
     srandom((int)seedval);
 }
diff -ru ppp-ppp-2.4.7/pppd/magic.h ppp-ppp-2.4.8/pppd/magic.h
--- ppp-ppp-2.4.7/pppd/magic.h	2020-03-09 12:16:34.494057737 +1000
+++ ppp-ppp-2.4.8/pppd/magic.h	2020-03-09 12:16:15.678513019 +1000
@@ -46,8 +46,8 @@
 #define __P(args)       args
 #endif
 
-void magic_init __P((void));	/* Initialize the magic number generator */
-u_int32_t magic __P((void));	/* Returns the next magic number */
+void magic_init (void);	/* Initialize the magic number generator */
+u_int32_t magic (void);	/* Returns the next magic number */
 
 /* Fill buffer with random bytes */
-void random_bytes __P((unsigned char *buf, int len));
+void random_bytes (unsigned char *buf, int len);
diff -ru ppp-ppp-2.4.7/pppd/main.c ppp-ppp-2.4.8/pppd/main.c
--- ppp-ppp-2.4.7/pppd/main.c	2020-03-09 12:16:34.494057737 +1000
+++ ppp-ppp-2.4.8/pppd/main.c	2020-03-09 12:16:15.678513019 +1000
@@ -80,7 +80,6 @@
 #include <netdb.h>
 #include <utmp.h>
 #include <pwd.h>
-#include <setjmp.h>
 #include <sys/param.h>
 #include <sys/types.h>
 #include <sys/wait.h>
@@ -121,10 +120,9 @@
 #include "atcp.h"
 #endif
 
-static const char rcsid[] = RCSID;
 
 /* interface vars */
-char ifname[32];		/* Interface name */
+char ifname[MAXIFNAMELEN];	/* Interface name */
 int ifunit;			/* Interface unit number */
 
 struct channel *the_channel;
@@ -181,7 +179,7 @@
 
 static sigset_t signals_handled;
 static int waiting;
-static sigjmp_buf sigjmp;
+static int sigpipe[2];
 
 char **script_env;		/* Env. variable values for scripts */
 int s_env_nalloc;		/* # words avail at script_env */
@@ -262,7 +260,6 @@
 static void handle_events __P((void));
 void print_link_stats __P((void));
 
-extern	char	*ttyname __P((int));
 extern	char	*getlogin __P((void));
 int main __P((int, char *[]));
 
@@ -303,13 +300,6 @@
     NULL
 };
 
-/*
- * If PPP_DRV_NAME is not defined, use the default "ppp" as the device name.
- */
-#if !defined(PPP_DRV_NAME)
-#define PPP_DRV_NAME	"ppp"
-#endif /* !defined(PPP_DRV_NAME) */
-
 int
 main(argc, argv)
     int argc;
@@ -612,19 +602,21 @@
 handle_events()
 {
     struct timeval timo;
+    unsigned char buf[16];
 
     kill_link = open_ccp_flag = 0;
-    if (sigsetjmp(sigjmp, 1) == 0) {
-	sigprocmask(SIG_BLOCK, &signals_handled, NULL);
-	if (got_sighup || got_sigterm || got_sigusr2 || got_sigchld) {
-	    sigprocmask(SIG_UNBLOCK, &signals_handled, NULL);
-	} else {
-	    waiting = 1;
-	    sigprocmask(SIG_UNBLOCK, &signals_handled, NULL);
-	    wait_input(timeleft(&timo));
-	}
-    }
+
+    /* alert via signal pipe */
+    waiting = 1;
+    /* flush signal pipe */
+    for (; read(sigpipe[0], buf, sizeof(buf)) > 0; );
+    add_fd(sigpipe[0]);
+    /* wait if necessary */
+    if (!(got_sighup || got_sigterm || got_sigusr2 || got_sigchld))
+	wait_input(timeleft(&timo));
     waiting = 0;
+    remove_fd(sigpipe[0]);
+
     calltimeout();
     if (got_sighup) {
 	info("Hangup (SIGHUP)");
@@ -659,6 +651,14 @@
 {
     struct sigaction sa;
 
+    /* create pipe to wake up event handler from signal handler */
+    if (pipe(sigpipe) < 0)
+	fatal("Couldn't create signal pipe: %m");
+    fcntl(sigpipe[0], F_SETFD, fcntl(sigpipe[0], F_GETFD) | FD_CLOEXEC);
+    fcntl(sigpipe[1], F_SETFD, fcntl(sigpipe[1], F_GETFD) | FD_CLOEXEC);
+    fcntl(sigpipe[0], F_SETFL, fcntl(sigpipe[0], F_GETFL) | O_NONBLOCK);
+    fcntl(sigpipe[1], F_SETFL, fcntl(sigpipe[1], F_GETFL) | O_NONBLOCK);
+
     /*
      * Compute mask of all interesting signals and install signal handlers
      * for each.  Only one signal handler may be active at a time.  Therefore,
@@ -742,9 +742,16 @@
 set_ifunit(iskey)
     int iskey;
 {
-    info("Using interface %s%d", PPP_DRV_NAME, ifunit);
-    slprintf(ifname, sizeof(ifname), "%s%d", PPP_DRV_NAME, ifunit);
+    char ifkey[32];
+
+    if (req_ifname[0] != '\0')
+	slprintf(ifname, sizeof(ifname), "%s", req_ifname);
+    else
+	slprintf(ifname, sizeof(ifname), "%s%d", PPP_DRV_NAME, ifunit);
+    info("Using interface %s", ifname);
     script_setenv("IFNAME", ifname, iskey);
+    slprintf(ifkey, sizeof(ifkey), "%d", ifunit);
+    script_setenv("UNIT", ifkey, iskey);
     if (iskey) {
 	create_pidfile(getpid());	/* write pid to file */
 	create_linkpidfile(getpid());
@@ -1452,7 +1459,7 @@
 	kill_my_pg(sig);
     notify(sigreceived, sig);
     if (waiting)
-	siglongjmp(sigjmp, 1);
+	write(sigpipe[1], &sig, sizeof(sig));
 }
 
 
@@ -1473,7 +1480,7 @@
 	kill_my_pg(sig);
     notify(sigreceived, sig);
     if (waiting)
-	siglongjmp(sigjmp, 1);
+	write(sigpipe[1], &sig, sizeof(sig));
 }
 
 
@@ -1487,7 +1494,7 @@
 {
     got_sigchld = 1;
     if (waiting)
-	siglongjmp(sigjmp, 1);
+	write(sigpipe[1], &sig, sizeof(sig));
 }
 
 
@@ -1522,7 +1529,7 @@
 {
     got_sigusr2 = 1;
     if (waiting)
-	siglongjmp(sigjmp, 1);
+	write(sigpipe[1], &sig, sizeof(sig));
 }
 
 
@@ -1859,7 +1866,8 @@
 	/* Executing in the child */
 	sys_close();
 #ifdef USE_TDB
-	tdb_close(pppdb);
+	if (pppdb != NULL)
+		tdb_close(pppdb);
 #endif
 
 	/* make sure infd, outfd and errfd won't get tromped on below */
@@ -2014,7 +2022,7 @@
 		script_env[i] = newstring;
 	    else
 		add_script_env(i, newstring);
-	} else {
+	} else if (p != NULL) {
 	    remove_script_env(i);
 	}
     }
diff -ru ppp-ppp-2.4.7/pppd/Makefile.linux ppp-ppp-2.4.8/pppd/Makefile.linux
--- ppp-ppp-2.4.7/pppd/Makefile.linux	2020-03-09 12:16:34.506057448 +1000
+++ ppp-ppp-2.4.8/pppd/Makefile.linux	2020-03-09 12:16:15.670513212 +1000
@@ -142,7 +142,7 @@
 #LIBS     += -lshadow $(LIBS)
 endif
 
-ifneq ($(wildcard /usr/include/crypt.h),)
+ifneq ($(wildcard $(shell $(CC) --print-sysroot)/usr/include/crypt.h),)
 CFLAGS  += -DHAVE_CRYPT_H=1
 LIBS	+= -lcrypt
 endif
diff -ru ppp-ppp-2.4.7/pppd/multilink.c ppp-ppp-2.4.8/pppd/multilink.c
--- ppp-ppp-2.4.7/pppd/multilink.c	2014-08-09 22:31:39.000000000 +1000
+++ ppp-ppp-2.4.8/pppd/multilink.c	2020-03-09 12:16:15.678513019 +1000
@@ -204,7 +204,7 @@
 			/* make sure the string is null-terminated */
 			rec.dptr[rec.dsize-1] = 0;
 			/* parse the interface number */
-			parse_num(rec.dptr, "IFNAME=ppp", &unit);
+			parse_num(rec.dptr, "UNIT=", &unit);
 			/* check the pid value */
 			if (!parse_num(rec.dptr, "PPPD_PID=", &pppd_pid)
 			    || !process_exists(pppd_pid)
@@ -420,7 +420,7 @@
 	TDB_DATA kd, vd;
 	int ret = 0;
 
-	slprintf(ifkey, sizeof(ifkey), "IFNAME=ppp%d", unit);
+	slprintf(ifkey, sizeof(ifkey), "UNIT=%d", unit);
 	kd.dptr = ifkey;
 	kd.dsize = strlen(ifkey);
 	vd = tdb_fetch(pppdb, kd);
@@ -589,4 +589,3 @@
 	ep->length = l;
 	return 1;
 }
-
diff -ru ppp-ppp-2.4.7/pppd/options.c ppp-ppp-2.4.8/pppd/options.c
--- ppp-ppp-2.4.7/pppd/options.c	2020-03-09 12:16:34.494057737 +1000
+++ ppp-ppp-2.4.8/pppd/options.c	2020-03-09 12:16:15.678513019 +1000
@@ -79,7 +79,6 @@
 char *strdup __P((char *));
 #endif
 
-static const char rcsid[] = RCSID;
 
 struct option_value {
     struct option_value *next;
@@ -97,6 +96,9 @@
 bool	nodetach = 0;		/* Don't detach from controlling tty */
 bool	updetach = 0;		/* Detach once link is up */
 bool	master_detach;		/* Detach when we're (only) multilink master */
+#ifdef SYSTEMD
+bool	up_sdnotify = 0;	/* Notify systemd once link is up */
+#endif
 int	maxconnect = 0;		/* Maximum connect time */
 char	user[MAXNAMELEN];	/* Username for PAP */
 char	passwd[MAXSECRETLEN];	/* Password for PAP */
@@ -116,6 +118,7 @@
 bool	tune_kernel;		/* may alter kernel settings */
 int	connect_delay = 1000;	/* wait this many ms after connect script */
 int	req_unit = -1;		/* requested interface unit */
+char	req_ifname[MAXIFNAMELEN];	/* requested interface name */
 bool	multilink = 0;		/* Enable multilink operation */
 char	*bundle_name = NULL;	/* bundle name for multilink */
 bool	dump_options;		/* print out option values */
@@ -123,6 +126,7 @@
 char	*domain;		/* domain name set by domain option */
 int	child_wait = 5;		/* # seconds to wait for children at exit */
 struct userenv *userenv_list;	/* user environment variables */
+int	dfl_route_metric = -1;	/* metric of the default route to set over the PPP link */
 
 u_int32_t	metric = 0;	/* the metric to set the host route to */
 u_int32_t	drmetric = 0;	/* the default route metric to set */
@@ -221,6 +225,11 @@
       "Don't detach from controlling tty", OPT_PRIO | 1 },
     { "-detach", o_bool, &nodetach,
       "Don't detach from controlling tty", OPT_ALIAS | OPT_PRIOSUB | 1 },
+#ifdef SYSTEMD
+    { "up_sdnotify", o_bool, &up_sdnotify,
+      "Notify systemd once link is up (implies nodetach)",
+      OPT_PRIOSUB | OPT_A2COPY | 1, &nodetach },
+#endif
     { "updetach", o_bool, &updetach,
       "Detach from controlling tty once link is up",
       OPT_PRIOSUB | OPT_A2CLR | 1, &nodetach },
@@ -297,6 +306,10 @@
       "PPP interface unit number to use if possible",
       OPT_PRIO | OPT_LLIMIT, 0, 0 },
 
+    { "ifname", o_string, req_ifname,
+      "Set PPP interface name",
+      OPT_PRIO | OPT_PRIV | OPT_STATIC, NULL, MAXIFNAMELEN },
+
     { "dump", o_bool, &dump_options,
       "Print out option values after parsing all options", 1 },
     { "dryrun", o_bool, &dryrun,
@@ -313,6 +326,10 @@
       "Unset user environment variable",
       OPT_A2PRINTER | OPT_NOPRINT, (void *)user_unsetprint },
 
+    { "defaultroute-metric", o_int, &dfl_route_metric,
+      "Metric to use for the default route (Linux only; -1 for default behavior)",
+      OPT_PRIV|OPT_LLIMIT|OPT_INITONLY, NULL, 0, -1 },
+
 #ifdef HAVE_MULTILINK
     { "multilink", o_bool, &multilink,
       "Enable multilink operation", OPT_PRIO | 1 },
@@ -988,7 +1005,7 @@
 			p = (char *) opt->addr2;
 			if ((opt->flags & OPT_STATIC) == 0)
 				p = *(char **)p;
-			printer("%q", p);
+			printer(arg, "%q", p);
 		} else if (opt->flags & OPT_A2LIST) {
 			struct option_value *ovp;
 
@@ -1354,6 +1371,7 @@
 
 	c = getc(f);
     }
+    word[MAXWORDLEN-1] = 0;	/* make sure word is null-terminated */
 
     /*
      * End of the word: check for errors.
@@ -1857,7 +1875,7 @@
 	option_error("unexpected = in name: %s", arg);
 	return 0;
     }
-    if (arg == '\0') {
+    if (*arg == '\0') {
 	option_error("missing variable name for unset");
 	return 0;
     }
diff -ru ppp-ppp-2.4.7/pppd/patchlevel.h ppp-ppp-2.4.8/pppd/patchlevel.h
--- ppp-ppp-2.4.7/pppd/patchlevel.h	2014-08-09 22:31:39.000000000 +1000
+++ ppp-ppp-2.4.8/pppd/patchlevel.h	2020-03-09 12:16:15.678513019 +1000
@@ -1,2 +1,2 @@
-#define VERSION		"2.4.7"
-#define DATE		"9 August 2014"
+#define VERSION		"2.4.8"
+#define DATE		"31 December 2019"
diff -ru ppp-ppp-2.4.7/pppd/plugins/pppol2tp/Makefile.linux ppp-ppp-2.4.8/pppd/plugins/pppol2tp/Makefile.linux
--- ppp-ppp-2.4.7/pppd/plugins/pppol2tp/Makefile.linux	2020-03-09 12:16:34.494057737 +1000
+++ ppp-ppp-2.4.8/pppd/plugins/pppol2tp/Makefile.linux	2020-03-09 12:16:15.674513117 +1000
@@ -23,7 +23,7 @@
 all: $(PLUGINS)
 
 %.so: %.o
-	$(CC) $(CFLAGS) -o $@ -shared $^ $(LIBS)
+	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(LDFLAGS_SHARED) $^ $(LIBS)
 
 libpppol2tp.o: pppol2tp.o openl2tp.o
 	$(CC) $(CFLAGS) -c -o $@ $^
diff -ru ppp-ppp-2.4.7/pppd/plugins/pppol2tp/openl2tp.c ppp-ppp-2.4.8/pppd/plugins/pppol2tp/openl2tp.c
--- ppp-ppp-2.4.7/pppd/plugins/pppol2tp/openl2tp.c	2020-03-09 12:16:34.494057737 +1000
+++ ppp-ppp-2.4.8/pppd/plugins/pppol2tp/openl2tp.c	2020-03-09 12:16:15.674513117 +1000
@@ -249,6 +249,9 @@
 		(*old_pppol2tp_ip_updown_hook)(tunnel_id, session_id, up);
 	}
 
+	if (user_name != NULL)
+		free(user_name);
+
 	return;
 }
 
diff -ru ppp-ppp-2.4.7/pppd/plugins/pppol2tp/pppol2tp.c ppp-ppp-2.4.8/pppd/plugins/pppol2tp/pppol2tp.c
--- ppp-ppp-2.4.7/pppd/plugins/pppol2tp/pppol2tp.c	2020-03-09 12:16:34.494057737 +1000
+++ ppp-ppp-2.4.8/pppd/plugins/pppol2tp/pppol2tp.c	2020-03-09 12:16:15.674513117 +1000
@@ -151,6 +151,10 @@
 		fatal("PPPoL2TP kernel driver not installed");
 	}
 
+	pppol2tp_fd_str = strdup(*argv);
+	if (pppol2tp_fd_str == NULL)
+		novm("PPPoL2TP FD");
+
 	/* Setup option defaults. Compression options are disabled! */
 
 	modem = 0;
diff -ru ppp-ppp-2.4.7/pppd/plugins/radius/avpair.c ppp-ppp-2.4.8/pppd/plugins/radius/avpair.c
--- ppp-ppp-2.4.7/pppd/plugins/radius/avpair.c	2020-03-09 12:16:34.494057737 +1000
+++ ppp-ppp-2.4.8/pppd/plugins/radius/avpair.c	2020-03-09 12:16:15.674513117 +1000
@@ -121,7 +121,7 @@
 		if ((vp = (VALUE_PAIR *) malloc (sizeof (VALUE_PAIR)))
 							!= (VALUE_PAIR *) NULL)
 		{
-			strncpy (vp->name, pda->name, sizeof (vp->name));
+			strlcpy (vp->name, pda->name, NAME_LENGTH);
 			vp->attribute = attrid;
 			vp->vendorcode = vendorcode;
 			vp->next = (VALUE_PAIR *) NULL;
@@ -755,7 +755,7 @@
 		}
 		else
 		{
-			sprintf (buffer, "%ld", pair->lvalue);
+			sprintf (buffer, "%d", pair->lvalue);
 			strncpy(value, buffer, (size_t) lv);
 		}
 		break;
diff -ru ppp-ppp-2.4.7/pppd/plugins/radius/clientid.c ppp-ppp-2.4.8/pppd/plugins/radius/clientid.c
--- ppp-ppp-2.4.7/pppd/plugins/radius/clientid.c	2014-08-09 22:31:39.000000000 +1000
+++ ppp-ppp-2.4.8/pppd/plugins/radius/clientid.c	2020-03-09 12:16:15.674513117 +1000
@@ -110,7 +110,7 @@
 	if (*name != '/')
 		strcpy(ttyname, "/dev/");
 
-	strncat(ttyname, name, sizeof(ttyname));
+	strncat(ttyname, name, sizeof(ttyname) - strlen(ttyname) -1);
 
 	for(p = map2id_list; p; p = p->next)
 		if (!strcmp(ttyname, p->name)) return p->id;
diff -ru ppp-ppp-2.4.7/pppd/plugins/radius/config.c ppp-ppp-2.4.8/pppd/plugins/radius/config.c
--- ppp-ppp-2.4.7/pppd/plugins/radius/config.c	2020-03-09 12:16:34.498057642 +1000
+++ ppp-ppp-2.4.8/pppd/plugins/radius/config.c	2020-03-09 12:16:15.674513117 +1000
@@ -153,6 +153,7 @@
 			*iptr = AUTH_RADIUS_FST;
 	else {
 		error("%s: auth_order: unknown keyword: %s", filename, p);
+		free(iptr);
 		return (-1);
 	}
 
@@ -165,6 +166,7 @@
 			*iptr = (*iptr) | AUTH_RADIUS_SND;
 		else {
 			error("%s: auth_order: unknown or unexpected keyword: %s", filename, p);
+			free(iptr);
 			return (-1);
 		}
 	}
@@ -272,7 +274,7 @@
 
 	if (option == NULL)
 		fatal("rc_conf_str: unkown config option requested: %s", optname);
-		return (char *)option->val;
+	return (char *)option->val;
 }
 
 int rc_conf_int(char *optname)
@@ -482,26 +484,14 @@
 		if ((h = strtok (buffer, " \t\n")) == NULL) /* first hostname */
 			continue;
 
-		memset (hostnm, '\0', AUTH_ID_LEN);
-		len = strlen (h);
-		if (len > AUTH_ID_LEN)
-		{
-			len = AUTH_ID_LEN;
-		}
-		strncpy (hostnm, h, (size_t) len);
-		hostnm[AUTH_ID_LEN] = '\0';
+		memset (hostnm, '\0', AUTH_ID_LEN + 1);
+		strlcpy (hostnm, h, AUTH_ID_LEN + 1);
 
 		if ((s = strtok (NULL, " \t\n")) == NULL) /* and secret field */
 			continue;
 
-		memset (secret, '\0', MAX_SECRET_LENGTH);
-		len = strlen (s);
-		if (len > MAX_SECRET_LENGTH)
-		{
-			len = MAX_SECRET_LENGTH;
-		}
-		strncpy (secret, s, (size_t) len);
-		secret[MAX_SECRET_LENGTH] = '\0';
+		memset (secret, '\0', MAX_SECRET_LENGTH + 1);
+		strlcpy (secret, s, MAX_SECRET_LENGTH + 1);
 
 		if (!strchr (hostnm, '/')) /* If single name form */
 		{
diff -ru ppp-ppp-2.4.7/pppd/plugins/radius/Makefile.linux ppp-ppp-2.4.8/pppd/plugins/radius/Makefile.linux
--- ppp-ppp-2.4.7/pppd/plugins/radius/Makefile.linux	2020-03-09 12:16:34.506057448 +1000
+++ ppp-ppp-2.4.8/pppd/plugins/radius/Makefile.linux	2020-03-09 12:16:15.674513117 +1000
@@ -52,13 +52,13 @@
 	$(INSTALL) -c -m 444 pppd-radattr.8 $(MANDIR)
 
 radius.so: radius.o libradiusclient.a
-	$(CC) -o radius.so -shared radius.o libradiusclient.a
+	$(CC) $(LDFLAGS) -o radius.so -shared radius.o libradiusclient.a
 
 radattr.so: radattr.o
-	$(CC) -o radattr.so -shared radattr.o
+	$(CC) $(LDFLAGS) -o radattr.so -shared radattr.o
 
 radrealms.so: radrealms.o
-	$(CC) -o radrealms.so -shared radrealms.o
+	$(CC) $(LDFLAGS) -o radrealms.so -shared radrealms.o
 
 CLIENTOBJS = avpair.o buildreq.o config.o dict.o ip_util.o \
 	clientid.o sendserver.o lock.o util.o md5.o
diff -ru ppp-ppp-2.4.7/pppd/plugins/radius/radius.c ppp-ppp-2.4.8/pppd/plugins/radius/radius.c
--- ppp-ppp-2.4.7/pppd/plugins/radius/radius.c	2020-03-09 12:16:34.498057642 +1000
+++ ppp-ppp-2.4.8/pppd/plugins/radius/radius.c	2020-03-09 12:16:15.674513117 +1000
@@ -929,7 +929,7 @@
 
     rstate.start_time = time(NULL);
 
-    strncpy(rstate.session_id, rc_mksid(), sizeof(rstate.session_id));
+    strlcpy(rstate.session_id, rc_mksid(), MAXSESSIONID);
 
     rc_avpair_add(&send, PW_ACCT_SESSION_ID,
 		   rstate.session_id, 0, VENDOR_NONE);
@@ -1027,6 +1027,10 @@
 
     rc_avpair_add(&send, PW_USER_NAME, rstate.user, 0, VENDOR_NONE);
 
+    if (rstate.class_len > 0)
+	rc_avpair_add(&send, PW_CLASS,
+		      rstate.class, rstate.class_len, VENDOR_NONE);
+
     av_type = PW_STATUS_STOP;
     rc_avpair_add(&send, PW_ACCT_STATUS_TYPE, &av_type, 0, VENDOR_NONE);
 
@@ -1171,6 +1175,10 @@
 
     rc_avpair_add(&send, PW_USER_NAME, rstate.user, 0, VENDOR_NONE);
 
+    if (rstate.class_len > 0)
+	rc_avpair_add(&send, PW_CLASS,
+		      rstate.class, rstate.class_len, VENDOR_NONE);
+
     av_type = PW_STATUS_ALIVE;
     rc_avpair_add(&send, PW_ACCT_STATUS_TYPE, &av_type, 0, VENDOR_NONE);
 
diff -ru ppp-ppp-2.4.7/pppd/plugins/radius/radiusclient.h ppp-ppp-2.4.8/pppd/plugins/radius/radiusclient.h
--- ppp-ppp-2.4.7/pppd/plugins/radius/radiusclient.h	2020-03-09 12:16:34.506057448 +1000
+++ ppp-ppp-2.4.8/pppd/plugins/radius/radiusclient.h	2020-03-09 12:16:15.674513117 +1000
@@ -444,6 +444,7 @@
 int rc_good_ipaddr __P((char *));
 const char *rc_ip_hostname __P((UINT4));
 UINT4 rc_own_ipaddress __P((void));
+UINT4 rc_own_bind_ipaddress __P((void));
 
 
 /*	sendserver.c		*/
diff -ru ppp-ppp-2.4.7/pppd/plugins/radius/radrealms.c ppp-ppp-2.4.8/pppd/plugins/radius/radrealms.c
--- ppp-ppp-2.4.7/pppd/plugins/radius/radrealms.c	2020-03-09 12:16:34.498057642 +1000
+++ ppp-ppp-2.4.8/pppd/plugins/radius/radrealms.c	2020-03-09 12:16:15.674513117 +1000
@@ -71,10 +71,12 @@
     
     if ((fd = fopen(radrealms_config, "r")) == NULL) {
 	option_error("cannot open %s", radrealms_config);
+	free(auths);
+	free(accts);
 	return;
-    } 
+    }
     info("Reading %s", radrealms_config);
-    
+
     while ((fgets(buffer, sizeof(buffer), fd) != NULL)) {
 	line++;
 
@@ -90,6 +92,8 @@
 	    fclose(fd);
 	    option_error("%s: invalid line %d: %s", radrealms_config,
 			 line, buffer);
+	    free(auths);
+	    free(accts);
 	    return;
 	}
 	info("Parsing '%s' entry:", p);
@@ -104,6 +108,8 @@
 	    fclose(fd);
 	    option_error("%s: realm name missing on line %d: %s",
 			 radrealms_config, line, buffer);
+	    free(auths);
+	    free(accts);
 	    return;
 	}
 
@@ -114,6 +120,8 @@
 		fclose(fd);
 		option_error("%s: server address missing on line %d: %s",
 			     radrealms_config, line, buffer);
+	        free(auths);
+	        free(accts);
 		return;
 	    }
 	    s->name[s->max] = strdup(p);
@@ -122,6 +130,8 @@
 		fclose(fd);
 		option_error("%s: server port missing on line %d:  %s",
 			     radrealms_config, line, buffer);
+		free(auths);
+		free(accts);
 		return;
 	    }
 	    s->port[s->max] = atoi(p);
diff -ru ppp-ppp-2.4.7/pppd/plugins/radius/util.c ppp-ppp-2.4.8/pppd/plugins/radius/util.c
--- ppp-ppp-2.4.7/pppd/plugins/radius/util.c	2014-08-09 22:31:39.000000000 +1000
+++ ppp-ppp-2.4.8/pppd/plugins/radius/util.c	2020-03-09 12:16:15.674513117 +1000
@@ -73,9 +73,9 @@
 char *
 rc_mksid (void)
 {
-  static char buf[15];
+  static char buf[32];
   static unsigned short int cnt = 0;
-  sprintf (buf, "%08lX%04X%02hX",
+  slprintf(buf, sizeof(buf), "%08lX%04X%02hX",
 	   (unsigned long int) time (NULL),
 	   (unsigned int) getpid (),
 	   cnt & 0xFF);
diff -ru ppp-ppp-2.4.7/pppd/plugins/rp-pppoe/common.c ppp-ppp-2.4.8/pppd/plugins/rp-pppoe/common.c
--- ppp-ppp-2.4.7/pppd/plugins/rp-pppoe/common.c	2014-08-09 22:31:39.000000000 +1000
+++ ppp-ppp-2.4.8/pppd/plugins/rp-pppoe/common.c	2020-03-09 12:16:15.678513019 +1000
@@ -65,7 +65,7 @@
 
     /* Step through the tags */
     curTag = packet->payload;
-    while(curTag - packet->payload < len) {
+    while (curTag - packet->payload + TAG_HDR_SIZE <= len) {
 	/* Alignment is not guaranteed, so do this by hand... */
 	tagType = (curTag[0] << 8) + curTag[1];
 	tagLen = (curTag[2] << 8) + curTag[3];
@@ -119,15 +119,11 @@
     conn->session = 0;
 
     /* If we're using Host-Uniq, copy it over */
-    if (conn->useHostUniq) {
-	PPPoETag hostUniq;
-	pid_t pid = getpid();
-	hostUniq.type = htons(TAG_HOST_UNIQ);
-	hostUniq.length = htons(sizeof(pid));
-	memcpy(hostUniq.payload, &pid, sizeof(pid));
-	memcpy(cursor, &hostUniq, sizeof(pid) + TAG_HDR_SIZE);
-	cursor += sizeof(pid) + TAG_HDR_SIZE;
-	plen += sizeof(pid) + TAG_HDR_SIZE;
+    if (conn->hostUniq.length) {
+	int len = ntohs(conn->hostUniq.length);
+	memcpy(cursor, &conn->hostUniq, len + TAG_HDR_SIZE);
+	cursor += len + TAG_HDR_SIZE;
+	plen += len + TAG_HDR_SIZE;
     }
 
     /* Copy error message */
diff -ru ppp-ppp-2.4.7/pppd/plugins/rp-pppoe/config.h ppp-ppp-2.4.8/pppd/plugins/rp-pppoe/config.h
--- ppp-ppp-2.4.7/pppd/plugins/rp-pppoe/config.h	2020-03-09 12:16:34.498057642 +1000
+++ ppp-ppp-2.4.8/pppd/plugins/rp-pppoe/config.h	2020-03-09 12:16:15.678513019 +1000
@@ -101,9 +101,6 @@
 /* Define if you have the <netpacket/packet.h> header file.  */
 #define HAVE_NETPACKET_PACKET_H 1
 
-/* Define if you have the <sys/cdefs.h> header file.  */
-/* #undef HAVE_SYS_CDEFS_H */
-
 /* Define if you have the <sys/dlpi.h> header file.  */
 /* #undef HAVE_SYS_DLPI_H */
 
diff -ru ppp-ppp-2.4.7/pppd/plugins/rp-pppoe/discovery.c ppp-ppp-2.4.8/pppd/plugins/rp-pppoe/discovery.c
--- ppp-ppp-2.4.7/pppd/plugins/rp-pppoe/discovery.c	2014-08-09 22:31:39.000000000 +1000
+++ ppp-ppp-2.4.8/pppd/plugins/rp-pppoe/discovery.c	2020-03-09 12:16:15.678513019 +1000
@@ -80,14 +80,10 @@
 parseForHostUniq(UINT16_t type, UINT16_t len, unsigned char *data,
 		 void *extra)
 {
-    int *val = (int *) extra;
-    if (type == TAG_HOST_UNIQ && len == sizeof(pid_t)) {
-	pid_t tmp;
-	memcpy(&tmp, data, len);
-	if (tmp == getpid()) {
-	    *val = 1;
-	}
-    }
+    PPPoETag *tag = extra;
+
+    if (type == TAG_HOST_UNIQ && len == ntohs(tag->length))
+	tag->length = memcmp(data, tag->payload, len);
 }
 
 /**********************************************************************
@@ -104,16 +100,16 @@
 static int
 packetIsForMe(PPPoEConnection *conn, PPPoEPacket *packet)
 {
-    int forMe = 0;
+    PPPoETag hostUniq = conn->hostUniq;
 
     /* If packet is not directed to our MAC address, forget it */
     if (memcmp(packet->ethHdr.h_dest, conn->myEth, ETH_ALEN)) return 0;
 
     /* If we're not using the Host-Unique tag, then accept the packet */
-    if (!conn->useHostUniq) return 1;
+    if (!conn->hostUniq.length) return 1;
 
-    parsePacket(packet, parseForHostUniq, &forMe);
-    return forMe;
+    parsePacket(packet, parseForHostUniq, &hostUniq);
+    return !hostUniq.length;
 }
 
 /**********************************************************************
@@ -301,16 +297,12 @@
     }
 
     /* If we're using Host-Uniq, copy it over */
-    if (conn->useHostUniq) {
-	PPPoETag hostUniq;
-	pid_t pid = getpid();
-	hostUniq.type = htons(TAG_HOST_UNIQ);
-	hostUniq.length = htons(sizeof(pid));
-	memcpy(hostUniq.payload, &pid, sizeof(pid));
-	CHECK_ROOM(cursor, packet.payload, sizeof(pid) + TAG_HDR_SIZE);
-	memcpy(cursor, &hostUniq, sizeof(pid) + TAG_HDR_SIZE);
-	cursor += sizeof(pid) + TAG_HDR_SIZE;
-	plen += sizeof(pid) + TAG_HDR_SIZE;
+    if (conn->hostUniq.length) {
+	int len = ntohs(conn->hostUniq.length);
+	CHECK_ROOM(cursor, packet.payload, len + TAG_HDR_SIZE);
+	memcpy(cursor, &conn->hostUniq, len + TAG_HDR_SIZE);
+	cursor += len + TAG_HDR_SIZE;
+	plen += len + TAG_HDR_SIZE;
     }
 
     /* Add our maximum MTU/MRU */
@@ -478,16 +470,12 @@
     cursor += namelen + TAG_HDR_SIZE;
 
     /* If we're using Host-Uniq, copy it over */
-    if (conn->useHostUniq) {
-	PPPoETag hostUniq;
-	pid_t pid = getpid();
-	hostUniq.type = htons(TAG_HOST_UNIQ);
-	hostUniq.length = htons(sizeof(pid));
-	memcpy(hostUniq.payload, &pid, sizeof(pid));
-	CHECK_ROOM(cursor, packet.payload, sizeof(pid)+TAG_HDR_SIZE);
-	memcpy(cursor, &hostUniq, sizeof(pid) + TAG_HDR_SIZE);
-	cursor += sizeof(pid) + TAG_HDR_SIZE;
-	plen += sizeof(pid) + TAG_HDR_SIZE;
+    if (conn->hostUniq.length) {
+	int len = ntohs(conn->hostUniq.length);
+	CHECK_ROOM(cursor, packet.payload, len+TAG_HDR_SIZE);
+	memcpy(cursor, &conn->hostUniq, len + TAG_HDR_SIZE);
+	cursor += len + TAG_HDR_SIZE;
+	plen += len + TAG_HDR_SIZE;
     }
 
     /* Add our maximum MTU/MRU */
@@ -634,7 +622,7 @@
 
     do {
 	padiAttempts++;
-	if (padiAttempts > MAX_PADI_ATTEMPTS) {
+	if (padiAttempts > conn->discoveryAttempts) {
 	    warn("Timeout waiting for PADO packets");
 	    close(conn->discoverySocket);
 	    conn->discoverySocket = -1;
@@ -650,7 +638,7 @@
     timeout = conn->discoveryTimeout;
     do {
 	padrAttempts++;
-	if (padrAttempts > MAX_PADI_ATTEMPTS) {
+	if (padrAttempts > conn->discoveryAttempts) {
 	    warn("Timeout waiting for PADS packets");
 	    close(conn->discoverySocket);
 	    conn->discoverySocket = -1;
diff -ru ppp-ppp-2.4.7/pppd/plugins/rp-pppoe/if.c ppp-ppp-2.4.8/pppd/plugins/rp-pppoe/if.c
--- ppp-ppp-2.4.7/pppd/plugins/rp-pppoe/if.c	2014-08-09 22:31:39.000000000 +1000
+++ ppp-ppp-2.4.8/pppd/plugins/rp-pppoe/if.c	2020-03-09 12:16:15.678513019 +1000
@@ -133,7 +133,7 @@
 
     /* Fill in hardware address */
     if (hwaddr) {
-	strncpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name));
+	strlcpy(ifr.ifr_name, ifname, IFNAMSIZ);
 	if (ioctl(fd, SIOCGIFHWADDR, &ifr) < 0) {
 	    error("Can't get hardware address for %s: %m", ifname);
 	    close(fd);
@@ -152,7 +152,7 @@
     }
 
     /* Sanity check on MTU */
-    strncpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name));
+    strlcpy(ifr.ifr_name, ifname, IFNAMSIZ);
     if (ioctl(fd, SIOCGIFMTU, &ifr) < 0) {
 	error("Can't get MTU for %s: %m", ifname);
     } else if (ifr.ifr_mtu < ETH_DATA_LEN) {
@@ -166,7 +166,7 @@
     sa.sll_family = AF_PACKET;
     sa.sll_protocol = htons(type);
 
-    strncpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name));
+    strlcpy(ifr.ifr_name, ifname, IFNAMSIZ);
     if (ioctl(fd, SIOCGIFINDEX, &ifr) < 0) {
 	error("Could not get interface index for %s: %m", ifname);
 	close(fd);
diff -ru ppp-ppp-2.4.7/pppd/plugins/rp-pppoe/Makefile.linux ppp-ppp-2.4.8/pppd/plugins/rp-pppoe/Makefile.linux
--- ppp-ppp-2.4.7/pppd/plugins/rp-pppoe/Makefile.linux	2020-03-09 12:16:34.506057448 +1000
+++ ppp-ppp-2.4.8/pppd/plugins/rp-pppoe/Makefile.linux	2020-03-09 12:16:15.678513019 +1000
@@ -39,16 +39,16 @@
 all: $(TARGET)
 
 pppoe-discovery: pppoe-discovery.o debug.o
-	$(CC) -o pppoe-discovery pppoe-discovery.o debug.o
+	$(CC) $(LDFLAGS) -o pppoe-discovery pppoe-discovery.o debug.o
 
 pppoe-discovery.o: pppoe-discovery.c
-	$(CC) $(CFLAGS) -c -o pppoe-discovery.o pppoe-discovery.c
+	$(CC) $(CFLAGS) -I../../.. -c -o pppoe-discovery.o pppoe-discovery.c
 
 debug.o: debug.c
-	$(CC) $(CFLAGS) -c -o debug.o debug.c
+	$(CC) $(CFLAGS) -I../../.. -c -o debug.o debug.c
 
 rp-pppoe.so: plugin.o discovery.o if.o common.o
-	$(CC) -o rp-pppoe.so -shared plugin.o discovery.o if.o common.o
+	$(CC) $(LDFLAGS) -o rp-pppoe.so -shared plugin.o discovery.o if.o common.o
 
 install: all
 	$(INSTALL) -d -m 755 $(LIBDIR)
diff -ru ppp-ppp-2.4.7/pppd/plugins/rp-pppoe/plugin.c ppp-ppp-2.4.8/pppd/plugins/rp-pppoe/plugin.c
--- ppp-ppp-2.4.7/pppd/plugins/rp-pppoe/plugin.c	2020-03-09 12:16:34.506057448 +1000
+++ ppp-ppp-2.4.8/pppd/plugins/rp-pppoe/plugin.c	2020-03-09 12:16:15.678513019 +1000
@@ -76,6 +76,9 @@
 static int printACNames = 0;
 static char *pppoe_reqd_mac = NULL;
 unsigned char pppoe_reqd_mac_addr[6];
+static char *host_uniq;
+static int pppoe_padi_timeout = PADI_TIMEOUT;
+static int pppoe_padi_attempts = MAX_PADI_ATTEMPTS;
 
 static int PPPoEDevnameHook(char *cmd, char **argv, int doit);
 static option_t Options[] = {
@@ -93,6 +96,12 @@
       "Be verbose about discovered access concentrators"},
     { "pppoe-mac", o_string, &pppoe_reqd_mac,
       "Only connect to specified MAC address" },
+    { "host-uniq", o_string, &host_uniq,
+      "Set the Host-Uniq to the supplied hex string" },
+    { "pppoe-padi-timeout", o_int, &pppoe_padi_timeout,
+      "Initial timeout for discovery packets in seconds" },
+    { "pppoe-padi-attempts", o_int, &pppoe_padi_attempts,
+      "Number of discovery attempts" },
     { NULL }
 };
 int (*OldDevnameHook)(char *cmd, char **argv, int doit) = NULL;
@@ -118,9 +127,9 @@
     conn->ifName = devnam;
     conn->discoverySocket = -1;
     conn->sessionSocket = -1;
-    conn->useHostUniq = 1;
     conn->printACNames = printACNames;
-    conn->discoveryTimeout = PADI_TIMEOUT;
+    conn->discoveryTimeout = pppoe_padi_timeout;
+    conn->discoveryAttempts = pppoe_padi_attempts;
     return 1;
 }
 
@@ -161,7 +170,7 @@
 	error("Can't get MTU for %s: %m", conn->ifName);
 	goto errout;
     }
-    strncpy(ifr.ifr_name, conn->ifName, sizeof(ifr.ifr_name));
+    strlcpy(ifr.ifr_name, conn->ifName, sizeof(ifr.ifr_name));
     if (ioctl(s, SIOCGIFMTU, &ifr) < 0) {
 	error("Can't get MTU for %s: %m", conn->ifName);
 	close(s);
@@ -174,6 +183,17 @@
     if (lcp_wantoptions[0].mru > ifr.ifr_mtu - TOTAL_OVERHEAD)
 	lcp_wantoptions[0].mru = ifr.ifr_mtu - TOTAL_OVERHEAD;
 
+    if (host_uniq) {
+	if (!parseHostUniq(host_uniq, &conn->hostUniq))
+	    fatal("Illegal value for host-uniq option");
+    } else {
+	/* if a custom host-uniq is not supplied, use our PID */
+	pid_t pid = getpid();
+	conn->hostUniq.type = htons(TAG_HOST_UNIQ);
+	conn->hostUniq.length = htons(sizeof(pid));
+	memcpy(conn->hostUniq.payload, &pid, sizeof(pid));
+    }
+
     conn->acName = acName;
     conn->serviceName = pppd_pppoe_service;
     strlcpy(ppp_devnam, devnam, sizeof(ppp_devnam));
@@ -278,19 +298,22 @@
     memcpy(sp.sa_addr.pppoe.dev, conn->ifName, IFNAMSIZ);
     memcpy(sp.sa_addr.pppoe.remote, conn->peerEth, ETH_ALEN);
     if (connect(conn->sessionSocket, (struct sockaddr *) &sp,
-		sizeof(struct sockaddr_pppox)) < 0)
+		sizeof(struct sockaddr_pppox)) < 0 && errno != EALREADY)
 	error("Failed to disconnect PPPoE socket: %d %m", errno);
     close(conn->sessionSocket);
-    /* don't send PADT?? */
-    if (conn->discoverySocket >= 0)
+    if (conn->discoverySocket >= 0) {
+        sendPADT(conn, NULL);
 	close(conn->discoverySocket);
+    }
 }
 
 static void
 PPPOEDeviceOptions(void)
 {
-    char buf[256];
-    snprintf(buf, 256, _PATH_ETHOPT "%s", devnam);
+    char buf[MAXPATHLEN];
+
+    strlcpy(buf, _PATH_ETHOPT, MAXPATHLEN);
+    strlcat(buf, devnam, MAXPATHLEN);
     if (!options_from_file(buf, 0, 0, 1))
 	exit(EXIT_OPTION_ERROR);
 
@@ -334,7 +357,7 @@
 
     /* Try getting interface index */
     if (r) {
-	strncpy(ifr.ifr_name, cmd, sizeof(ifr.ifr_name));
+	strlcpy(ifr.ifr_name, cmd, sizeof(ifr.ifr_name));
 	if (ioctl(fd, SIOCGIFINDEX, &ifr) < 0) {
 	    r = 0;
 	} else {
@@ -353,7 +376,7 @@
     /* Close socket */
     close(fd);
     if (r && doit) {
-	strncpy(devnam, cmd, sizeof(devnam));
+	strlcpy(devnam, cmd, sizeof(devnam));
 	if (the_channel != &pppoe_channel) {
 
 	    the_channel = &pppoe_channel;
diff -ru ppp-ppp-2.4.7/pppd/plugins/rp-pppoe/pppoe-discovery.c ppp-ppp-2.4.8/pppd/plugins/rp-pppoe/pppoe-discovery.c
--- ppp-ppp-2.4.7/pppd/plugins/rp-pppoe/pppoe-discovery.c	2020-03-09 12:16:34.498057642 +1000
+++ ppp-ppp-2.4.8/pppd/plugins/rp-pppoe/pppoe-discovery.c	2020-03-09 12:16:15.678513019 +1000
@@ -9,11 +9,13 @@
  *
  */
 
+#include <stdarg.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
 #include <errno.h>
 #include <string.h>
+#include <time.h>
 
 #include "pppoe.h"
 
@@ -59,6 +61,14 @@
 	exit(status);
 }
 
+void error(char *fmt, ...)
+{
+    va_list pvar;
+    va_start(pvar, fmt);
+    vfprintf(stderr, fmt, pvar);
+    va_end(pvar);
+}
+
 /* Initialize frame types to RFC 2516 values.  Some broken peers apparently
    use different frame types... sigh... */
 
@@ -176,7 +186,8 @@
     sa.sll_family = AF_PACKET;
     sa.sll_protocol = htons(type);
 
-    strncpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name));
+    strncpy(ifr.ifr_name, ifname, IFNAMSIZ);
+    ifr.ifr_name[IFNAMSIZ - 1] = 0;
     if (ioctl(fd, SIOCGIFINDEX, &ifr) < 0) {
 	fatalSys("ioctl(SIOCFIGINDEX): Could not get interface index");
     }
@@ -351,7 +362,7 @@
     if (memcmp(packet->ethHdr.h_dest, conn->myEth, ETH_ALEN)) return 0;
 
     /* If we're not using the Host-Unique tag, then accept the packet */
-    if (!conn->useHostUniq) return 1;
+    if (!conn->hostUniq.length) return 1;
 
     parsePacket(packet, parseForHostUniq, &forMe);
     return forMe;
@@ -382,7 +393,9 @@
     switch(type) {
     case TAG_AC_NAME:
 	pc->seenACName = 1;
-	printf("Access-Concentrator: %.*s\n", (int) len, data);
+	if (conn->printACNames) {
+	    printf("Access-Concentrator: %.*s\n", (int) len, data);
+	}
 	if (conn->acName && len == strlen(conn->acName) &&
 	    !strncmp((char *) data, conn->acName, len)) {
 	    pc->acNameOK = 1;
@@ -390,7 +403,7 @@
 	break;
     case TAG_SERVICE_NAME:
 	pc->seenServiceName = 1;
-	if (len > 0) {
+	if (conn->printACNames && len > 0) {
 	    printf("       Service-Name: %.*s\n", (int) len, data);
 	}
 	if (conn->serviceName && len == strlen(conn->serviceName) &&
@@ -399,37 +412,47 @@
 	}
 	break;
     case TAG_AC_COOKIE:
-	printf("Got a cookie:");
-	/* Print first 20 bytes of cookie */
-	for (i=0; i<len && i < 20; i++) {
-	    printf(" %02x", (unsigned) data[i]);
+	if (conn->printACNames) {
+	    printf("Got a cookie:");
+	    /* Print first 20 bytes of cookie */
+	    for (i=0; i<len && i < 20; i++) {
+		printf(" %02x", (unsigned) data[i]);
+	    }
+	    if (i < len) printf("...");
+	    printf("\n");
 	}
-	if (i < len) printf("...");
-	printf("\n");
 	conn->cookie.type = htons(type);
 	conn->cookie.length = htons(len);
 	memcpy(conn->cookie.payload, data, len);
 	break;
     case TAG_RELAY_SESSION_ID:
-	printf("Got a Relay-ID:");
-	/* Print first 20 bytes of relay ID */
-	for (i=0; i<len && i < 20; i++) {
-	    printf(" %02x", (unsigned) data[i]);
+	if (conn->printACNames) {
+	    printf("Got a Relay-ID:");
+	    /* Print first 20 bytes of relay ID */
+	    for (i=0; i<len && i < 20; i++) {
+		printf(" %02x", (unsigned) data[i]);
+	    }
+	    if (i < len) printf("...");
+	    printf("\n");
 	}
-	if (i < len) printf("...");
-	printf("\n");
 	conn->relayId.type = htons(type);
 	conn->relayId.length = htons(len);
 	memcpy(conn->relayId.payload, data, len);
 	break;
     case TAG_SERVICE_NAME_ERROR:
-	printf("Got a Service-Name-Error tag: %.*s\n", (int) len, data);
+	if (conn->printACNames) {
+	    printf("Got a Service-Name-Error tag: %.*s\n", (int) len, data);
+	}
 	break;
     case TAG_AC_SYSTEM_ERROR:
-	printf("Got a System-Error tag: %.*s\n", (int) len, data);
+	if (conn->printACNames) {
+	    printf("Got a System-Error tag: %.*s\n", (int) len, data);
+	}
 	break;
     case TAG_GENERIC_ERROR:
-	printf("Got a Generic-Error tag: %.*s\n", (int) len, data);
+	if (conn->printACNames) {
+	    printf("Got a Generic-Error tag: %.*s\n", (int) len, data);
+	}
 	break;
     }
 }
@@ -477,16 +500,12 @@
     cursor += namelen + TAG_HDR_SIZE;
 
     /* If we're using Host-Uniq, copy it over */
-    if (conn->useHostUniq) {
-	PPPoETag hostUniq;
-	pid_t pid = getpid();
-	hostUniq.type = htons(TAG_HOST_UNIQ);
-	hostUniq.length = htons(sizeof(pid));
-	memcpy(hostUniq.payload, &pid, sizeof(pid));
-	CHECK_ROOM(cursor, packet.payload, sizeof(pid) + TAG_HDR_SIZE);
-	memcpy(cursor, &hostUniq, sizeof(pid) + TAG_HDR_SIZE);
-	cursor += sizeof(pid) + TAG_HDR_SIZE;
-	plen += sizeof(pid) + TAG_HDR_SIZE;
+    if (conn->hostUniq.length) {
+	int len = ntohs(conn->hostUniq.length);
+	CHECK_ROOM(cursor, packet.payload, len + TAG_HDR_SIZE);
+	memcpy(cursor, &conn->hostUniq, len + TAG_HDR_SIZE);
+	cursor += len + TAG_HDR_SIZE;
+	plen += len + TAG_HDR_SIZE;
     }
 
     packet.length = htons(plen);
@@ -585,7 +604,6 @@
 		continue;
 	    }
 	    conn->numPADOs++;
-	    printf("--------------------------------------------------\n");
 	    if (pc.acNameOK && pc.serviceNameOK) {
 		memcpy(conn->peerEth, packet.ethHdr.h_source, ETH_ALEN);
 		if (conn->printACNames) {
@@ -596,6 +614,7 @@
 			   (unsigned) conn->peerEth[3],
 			   (unsigned) conn->peerEth[4],
 			   (unsigned) conn->peerEth[5]);
+		    printf("--------------------------------------------------\n");
 		    continue;
 		}
 		conn->discoveryState = STATE_RECEIVED_PADO;
@@ -618,14 +637,14 @@
 discovery(PPPoEConnection *conn)
 {
     int padiAttempts = 0;
-    int timeout = PADI_TIMEOUT;
+    int timeout = conn->discoveryTimeout;
 
     conn->discoverySocket =
 	openInterface(conn->ifName, Eth_PPPOE_Discovery, conn->myEth);
 
     do {
 	padiAttempts++;
-	if (padiAttempts > MAX_PADI_ATTEMPTS) {
+	if (padiAttempts > conn->discoveryAttempts) {
 	    fprintf(stderr, "Timeout waiting for PADO packets\n");
 	    close(conn->discoverySocket);
 	    conn->discoverySocket = -1;
@@ -648,7 +667,11 @@
 
     memset(conn, 0, sizeof(PPPoEConnection));
 
-    while ((opt = getopt(argc, argv, "I:D:VUAS:C:h")) > 0) {
+    conn->printACNames = 1;
+    conn->discoveryTimeout = PADI_TIMEOUT;
+    conn->discoveryAttempts = MAX_PADI_ATTEMPTS;
+
+    while ((opt = getopt(argc, argv, "I:D:VUQS:C:W:t:a:h")) > 0) {
 	switch(opt) {
 	case 'S':
 	    conn->serviceName = xstrdup(optarg);
@@ -656,8 +679,44 @@
 	case 'C':
 	    conn->acName = xstrdup(optarg);
 	    break;
+	case 't':
+	    if (sscanf(optarg, "%d", &conn->discoveryTimeout) != 1) {
+		fprintf(stderr, "Illegal argument to -t: Should be -t timeout\n");
+		exit(EXIT_FAILURE);
+	    }
+	    if (conn->discoveryTimeout < 1) {
+		conn->discoveryTimeout = 1;
+	    }
+	    break;
+	case 'a':
+	    if (sscanf(optarg, "%d", &conn->discoveryAttempts) != 1) {
+		fprintf(stderr, "Illegal argument to -a: Should be -a attempts\n");
+		exit(EXIT_FAILURE);
+	    }
+	    if (conn->discoveryAttempts < 1) {
+		conn->discoveryAttempts = 1;
+	    }
+	    break;
 	case 'U':
-	    conn->useHostUniq = 1;
+	    if(conn->hostUniq.length) {
+		fprintf(stderr, "-U and -W are mutually exclusive\n");
+		exit(EXIT_FAILURE);
+	    } else {
+		pid_t pid = getpid();
+		conn->hostUniq.type = htons(TAG_HOST_UNIQ);
+		conn->hostUniq.length = htons(sizeof(pid));
+		memcpy(conn->hostUniq.payload, &pid, sizeof(pid));
+	    }
+	    break;
+	case 'W':
+	    if(conn->hostUniq.length) {
+		fprintf(stderr, "-U and -W are mutually exclusive\n");
+		exit(EXIT_FAILURE);
+	    }
+	    if (!parseHostUniq(optarg, &conn->hostUniq)) {
+		fprintf(stderr, "Invalid host-uniq argument: %s\n", optarg);
+		exit(EXIT_FAILURE);
+            }
 	    break;
 	case 'D':
 	    conn->debugFile = fopen(optarg, "w");
@@ -671,8 +730,8 @@
 	case 'I':
 	    conn->ifName = xstrdup(optarg);
 	    break;
-	case 'A':
-	    /* this is the default */
+	case 'Q':
+	    conn->printACNames = 0;
 	    break;
 	case 'V':
 	case 'h':
@@ -690,10 +749,13 @@
 
     conn->discoverySocket = -1;
     conn->sessionSocket = -1;
-    conn->printACNames = 1;
 
     discovery(conn);
-    exit(0);
+
+    if (!conn->numPADOs)
+	exit(1);
+    else
+	exit(0);
 }
 
 void rp_fatal(char const *str)
@@ -724,5 +786,18 @@
 void usage(void)
 {
     fprintf(stderr, "Usage: pppoe-discovery [options]\n");
+    fprintf(stderr, "Options:\n");
+    fprintf(stderr, "   -I if_name     -- Specify interface (default eth0)\n");
+    fprintf(stderr, "   -D filename    -- Log debugging information in filename.\n");
+    fprintf(stderr,
+	    "   -t timeout     -- Initial timeout for discovery packets in seconds\n"
+	    "   -a attempts    -- Number of discovery attempts\n"
+	    "   -V             -- Print version and exit.\n"
+	    "   -Q             -- Quit Mode: Do not print access concentrator names\n"
+	    "   -S name        -- Set desired service name.\n"
+	    "   -C name        -- Set desired access concentrator name.\n"
+	    "   -U             -- Use Host-Unique to allow multiple PPPoE sessions.\n"
+	    "   -W hexvalue    -- Set the Host-Unique to the supplied hex string.\n"
+	    "   -h             -- Print usage information.\n");
     fprintf(stderr, "\nVersion " RP_VERSION "\n");
 }
diff -ru ppp-ppp-2.4.7/pppd/plugins/rp-pppoe/pppoe.h ppp-ppp-2.4.8/pppd/plugins/rp-pppoe/pppoe.h
--- ppp-ppp-2.4.7/pppd/plugins/rp-pppoe/pppoe.h	2020-03-09 12:16:34.498057642 +1000
+++ ppp-ppp-2.4.8/pppd/plugins/rp-pppoe/pppoe.h	2020-03-09 12:16:15.678513019 +1000
@@ -15,12 +15,12 @@
 
 #include "config.h"
 
-#if defined(HAVE_NETPACKET_PACKET_H) || defined(HAVE_LINUX_IF_PACKET_H)
-#define _POSIX_SOURCE 1 /* For sigaction defines */
-#endif
-
 #include <stdio.h>		/* For FILE */
 #include <sys/types.h>		/* For pid_t */
+#include <ctype.h>
+#include <string.h>
+
+#include "pppd/pppd.h"		/* For error */
 
 /* How do we access raw Ethernet devices? */
 #undef USE_LINUX_PACKET
@@ -39,14 +39,12 @@
 #error Unknown method for accessing raw Ethernet frames
 #endif
 
-#ifdef HAVE_SYS_CDEFS_H
-#include <sys/cdefs.h>
-#endif
-
 #ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
 
+/* This has to be included before Linux 4.8's linux/in.h
+ * gets dragged in. */
 #include <netinet/in.h>
 
 /* Ugly header files on some Linux boxes... */
@@ -97,7 +95,6 @@
 #include <linux/if_ether.h>
 #endif
 
-
 /* Ethernet frame types according to RFC 2516 */
 #define ETH_PPPOE_DISCOVERY 0x8863
 #define ETH_PPPOE_SESSION   0x8864
@@ -234,7 +231,7 @@
     char *serviceName;		/* Desired service name, if any */
     char *acName;		/* Desired AC name, if any */
     int synchronous;		/* Use synchronous PPP */
-    int useHostUniq;		/* Use Host-Uniq tag */
+    PPPoETag hostUniq;		/* Use Host-Uniq tag */
     int printACNames;		/* Just print AC names */
     FILE *debugFile;		/* Debug file for dumping packets */
     int numPADOs;		/* Number of PADO packets received */
@@ -243,6 +240,7 @@
     int error;			/* Error packet received */
     int debug;			/* Set to log packets sent and received */
     int discoveryTimeout;       /* Timeout for discovery packets */
+    int discoveryAttempts;      /* Number of discovery attempts */
     int seenMaxPayload;
     int mtu;			/* Stored MTU */
     int mru;			/* Stored MRU */
@@ -290,6 +288,32 @@
 		    void (*printer)(void *, char *, ...), void *arg);
 void pppoe_log_packet(const char *prefix, PPPoEPacket *packet);
 
+static inline int parseHostUniq(const char *uniq, PPPoETag *tag)
+{
+    unsigned i, len = strlen(uniq);
+
+#define hex(x) \
+    (((x) <= '9') ? ((x) - '0') : \
+        (((x) <= 'F') ? ((x) - 'A' + 10) : \
+            ((x) - 'a' + 10)))
+
+    if (!len || len % 2 || len / 2 > sizeof(tag->payload))
+        return 0;
+
+    for (i = 0; i < len; i += 2) {
+        if (!isxdigit(uniq[i]) || !isxdigit(uniq[i+1]))
+            return 0;
+
+        tag->payload[i / 2] = (char)(hex(uniq[i]) << 4 | hex(uniq[i+1]));
+    }
+
+#undef hex
+
+    tag->type = htons(TAG_HOST_UNIQ);
+    tag->length = htons(len / 2);
+    return 1;
+}
+
 #define SET_STRING(var, val) do { if (var) free(var); var = strDup(val); } while(0);
 
 #define CHECK_ROOM(cursor, start, len) \
diff -ru ppp-ppp-2.4.7/pppd/plugins/winbind.c ppp-ppp-2.4.8/pppd/plugins/winbind.c
--- ppp-ppp-2.4.7/pppd/plugins/winbind.c	2020-03-09 12:16:34.502057545 +1000
+++ ppp-ppp-2.4.8/pppd/plugins/winbind.c	2020-03-09 12:16:15.674513117 +1000
@@ -435,6 +435,7 @@
 
         /* parent */
         if (close(child_out[0]) == -1) {
+                close(child_in[1]);
                 notice("error closing pipe?!? for child OUT[0]");
                 return NOT_AUTHENTICATED;
         }
diff -ru ppp-ppp-2.4.7/pppd/pppcrypt.c ppp-ppp-2.4.8/pppd/pppcrypt.c
--- ppp-ppp-2.4.7/pppd/pppcrypt.c	2020-03-09 12:16:34.546056480 +1000
+++ ppp-ppp-2.4.8/pppd/pppcrypt.c	2020-03-09 12:16:15.670513212 +1000
@@ -75,7 +75,7 @@
 	des_key[7] = Get7Bits(key, 49);
 
 #ifndef USE_CRYPT
-	des_set_odd_parity((des_cblock *)des_key);
+	DES_set_odd_parity((DES_cblock *)des_key);
 #endif
 }
 
@@ -169,15 +169,15 @@
 }
 
 #else /* USE_CRYPT */
-static des_key_schedule	key_schedule;
+static DES_key_schedule	key_schedule;
 
 bool
 DesSetkey(key)
 u_char *key;
 {
-	des_cblock des_key;
+	DES_cblock des_key;
 	MakeKey(key, des_key);
-	des_set_key(&des_key, key_schedule);
+	DES_set_key(&des_key, &key_schedule);
 	return (1);
 }
 
@@ -186,8 +186,8 @@
 u_char *clear;	/* IN  8 octets */
 u_char *cipher;	/* OUT 8 octets */
 {
-	des_ecb_encrypt((des_cblock *)clear, (des_cblock *)cipher,
-	    key_schedule, 1);
+	DES_ecb_encrypt((DES_cblock *)clear, (DES_cblock *)cipher,
+	    &key_schedule, 1);
 	return (1);
 }
 
@@ -196,8 +196,8 @@
 u_char *cipher;	/* IN  8 octets */
 u_char *clear;	/* OUT 8 octets */
 {
-	des_ecb_encrypt((des_cblock *)cipher, (des_cblock *)clear,
-	    key_schedule, 0);
+	DES_ecb_encrypt((DES_cblock *)cipher, (DES_cblock *)clear,
+	    &key_schedule, 0);
 	return (1);
 }
 
diff -ru ppp-ppp-2.4.7/pppd/pppd.8 ppp-ppp-2.4.8/pppd/pppd.8
--- ppp-ppp-2.4.7/pppd/pppd.8	2014-08-09 22:31:39.000000000 +1000
+++ ppp-ppp-2.4.8/pppd/pppd.8	2020-03-09 12:16:15.682512922 +1000
@@ -121,6 +121,18 @@
 This entry is removed when the PPP connection is broken.  This option
 is privileged if the \fInodefaultroute\fR option has been specified.
 .TP
+.B defaultroute-metric
+Define the metric of the \fIdefaultroute\fR and only add it if there
+is no other default route with the same metric.  With the default
+value of -1, the route is only added if there is no default route at
+all.
+.TP
+.B defaultroute6
+Add a default IPv6 route to the system routing tables, using the peer as
+the gateway, when IPv6CP negotiation is successfully completed.
+This entry is removed when the PPP connection is broken.  This option
+is privileged if the \fInodefaultroute6\fR option has been specified.
+.TP
 .B disconnect \fIscript
 Execute the command specified by \fIscript\fR, by passing it to a
 shell, after
@@ -737,6 +749,11 @@
 wishes to prevent users from creating default routes with pppd
 can do so by placing this option in the /etc/ppp/options file.
 .TP
+.B nodefaultroute6
+Disable the \fIdefaultroute6\fR option.  The system administrator who
+wishes to prevent users from adding a default route with pppd
+can do so by placing this option in the /etc/ppp/options file.
+.TP
 .B nodeflate
 Disables Deflate compression; pppd will not request or agree to
 compress packets using the Deflate scheme.
@@ -1073,7 +1090,13 @@
 .TP
 .B unit \fInum
 Sets the ppp unit number (for a ppp0 or ppp1 etc interface name) for outbound
-connections.
+connections.  If the unit is already in use a dynamically allocated number will
+be used.
+.TP
+.B ifname \fIstring
+Set the ppp interface name for outbound connections.  If the interface name is
+already in use, or if the name cannot be used for any other reason, pppd will
+terminate.
 .TP
 .B unset \fIname
 Remove a variable from the environment variable for scripts that are
@@ -1088,6 +1111,15 @@
 the first network control protocol, usually the IP control protocol,
 has come up).
 .TP
+.B up_sdnotify
+Use this option to run pppd in systemd service units of Type=notify
+(\fBup_sdnotify\fR implies \fBnodetach\fR).
+When \fBup_sdnotify\fR is enabled, pppd will notify systemd once
+it has successfully established the ppp connection (to the point where
+the first network control protocl, usually the IP control protocol,
+has come up). This option is only availble when pppd is compiled with
+systemd support.
+.TP
 .B usehostname
 Enforce the use of the hostname (with domain name appended, if given)
 as the name of the local system for authentication purposes (overrides
diff -ru ppp-ppp-2.4.7/pppd/pppd.h ppp-ppp-2.4.8/pppd/pppd.h
--- ppp-ppp-2.4.7/pppd/pppd.h	2020-03-09 12:16:34.502057545 +1000
+++ ppp-ppp-2.4.8/pppd/pppd.h	2020-03-09 12:16:15.670513212 +1000
@@ -50,6 +50,8 @@
 #define __PPPD_H__
 
 #include <stdio.h>		/* for FILE */
+#include <stdlib.h>		/* for encrypt */
+#include <unistd.h>		/* for setkey */
 #include <limits.h>		/* for NGROUPS_MAX */
 #include <sys/param.h>		/* for MAXPATHLEN and BSD4_4, if defined */
 #include <sys/types.h>		/* for u_int32_t, if defined */
@@ -80,6 +82,16 @@
 #define MAXARGS		1	/* max # args to a command */
 #define MAXNAMELEN	256	/* max length of hostname or name for auth */
 #define MAXSECRETLEN	256	/* max length of password or secret */
+#define MAXIFNAMELEN	32	/* max length of interface name; or use IFNAMSIZ, can we
+				   always include net/if.h? */
+
+/*
+ * If PPP_DRV_NAME is not defined, use the default "ppp" as the device name.
+ * Where should PPP_DRV_NAME come from? Do we include it here?
+ */
+#if !defined(PPP_DRV_NAME)
+#define PPP_DRV_NAME	"ppp"
+#endif /* !defined(PPP_DRV_NAME) */
 
 
 /*
@@ -288,6 +300,9 @@
 extern u_int32_t netmask;	/* IP netmask to set on interface */
 extern bool	lockflag;	/* Create lock file to lock the serial dev */
 extern bool	nodetach;	/* Don't detach from controlling tty */
+#ifdef SYSTEMD
+extern bool	up_sdnotify;	/* Notify systemd once link is up (implies nodetach) */
+#endif
 extern bool	updetach;	/* Detach from controlling tty when link up */
 extern bool	master_detach;	/* Detach when multilink master without link */
 extern char	*initializer;	/* Script to initialize physical link */
@@ -324,6 +339,7 @@
 extern int	connect_delay;	/* Time to delay after connect script */
 extern int	max_data_rate;	/* max bytes/sec through charshunt */
 extern int	req_unit;	/* interface unit number to use */
+extern char	req_ifname[MAXIFNAMELEN]; /* interface name to use */
 extern bool	multilink;	/* enable multilink operation */
 extern bool	noendpoint;	/* don't send or accept endpt. discrim. */
 extern char	*bundle_name;	/* bundle name for multilink */
@@ -687,6 +703,12 @@
 				/* Create default route through i/f */
 int  cifdefaultroute __P((int, u_int32_t, u_int32_t));
 				/* Delete default route through i/f */
+#ifdef INET6
+int  sif6defaultroute __P((int, eui64_t, eui64_t));
+				/* Create default IPv6 route through i/f */
+int  cif6defaultroute __P((int, eui64_t, eui64_t));
+				/* Delete default IPv6 route through i/f */
+#endif
 int  rtmetricfixup __P((int, u_int32_t, u_int32_t));
 int  sifproxyarp __P((int, u_int32_t));
 				/* Add proxy ARP entry for peer */
diff -ru ppp-ppp-2.4.7/pppd/session.c ppp-ppp-2.4.8/pppd/session.c
--- ppp-ppp-2.4.7/pppd/session.c	2014-08-09 22:31:39.000000000 +1000
+++ ppp-ppp-2.4.8/pppd/session.c	2020-03-09 12:16:15.682512922 +1000
@@ -384,8 +384,8 @@
                 memset((void *)&ll, 0, sizeof(ll));
 		(void)time(&tnow);
                 ll.ll_time = tnow;
-                (void)strncpy(ll.ll_line, ttyName, sizeof(ll.ll_line));
-                (void)strncpy(ll.ll_host, ifname, sizeof(ll.ll_host));
+                strlcpy(ll.ll_line, ttyName, sizeof(ll.ll_line));
+                strlcpy(ll.ll_host, ifname, sizeof(ll.ll_host));
                 (void)write(fd, (char *)&ll, sizeof(ll));
                 (void)close(fd);
             }
diff -ru ppp-ppp-2.4.7/pppd/sha1.c ppp-ppp-2.4.8/pppd/sha1.c
--- ppp-ppp-2.4.7/pppd/sha1.c	2020-03-09 12:16:34.502057545 +1000
+++ ppp-ppp-2.4.8/pppd/sha1.c	2020-03-09 12:16:15.682512922 +1000
@@ -18,6 +18,7 @@
 
 #include <time.h>
 #include <string.h>
+#include <time.h>
 #include <netinet/in.h>	/* htonl() */
 #include <net/ppp_defs.h>
 #include "sha1.h"
diff -ru ppp-ppp-2.4.7/pppd/sys-linux.c ppp-ppp-2.4.8/pppd/sys-linux.c
--- ppp-ppp-2.4.7/pppd/sys-linux.c	2020-03-09 12:16:34.502057545 +1000
+++ ppp-ppp-2.4.8/pppd/sys-linux.c	2020-03-09 12:16:15.670513212 +1000
@@ -73,12 +73,12 @@
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <sys/time.h>
-#include <sys/errno.h>
 #include <sys/file.h>
 #include <sys/stat.h>
 #include <sys/utsname.h>
 #include <sys/sysmacros.h>
 
+#include <errno.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <syslog.h>
@@ -102,7 +102,7 @@
 #define MAX_ADDR_LEN 7
 #endif
 
-#if __GLIBC__ >= 2
+#if !defined(__GLIBC__) || __GLIBC__ >= 2
 #include <asm/types.h>		/* glibc 2 conflicts with linux/types.h */
 #include <net/if.h>
 #include <net/if_arp.h>
@@ -158,6 +158,7 @@
 	eui64_copy(eui64, sin6.s6_addr32[2]);			\
 	} while (0)
 
+static const eui64_t nulleui64;
 #endif /* INET6 */
 
 /* We can get an EIO error on an ioctl if the modem has hung up */
@@ -202,6 +203,7 @@
 static int	if_is_up;	/* Interface has been marked up */
 static int	if6_is_up;	/* Interface has been marked up for IPv6, to help differentiate */
 static int	have_default_route;	/* Gateway for default route added */
+static int	have_default_route6;	/* Gateway for default IPv6 route added */
 static u_int32_t proxy_arp_addr;	/* Addr for proxy arp entry added */
 static char proxy_arp_dev[16];		/* Device for proxy arp entry */
 static u_int32_t our_old_addr;		/* for detecting address changes */
@@ -228,7 +230,8 @@
 static void close_route_table (void);
 static int open_route_table (void);
 static int read_route_table (struct rtentry *rt);
-static int defaultroute_exists (struct rtentry *rt);
+static int defaultroute_exists (struct rtentry *rt, int metric);
+static int defaultroute6_exists (struct in6_rtmsg *rt, int metric);
 static int get_ether_addr (u_int32_t ipaddr, struct sockaddr *hwaddr,
 			   char *name, int namelen);
 static void decode_version (char *buf, int *version, int *mod, int *patch);
@@ -239,6 +242,8 @@
 
 extern u_char	inpacket_buf[];	/* borrowed from main.c */
 
+extern int dfl_route_metric;
+
 /*
  * SET_SA_FAMILY - set the sa_family field of a struct sockaddr,
  * if it exists.
@@ -343,6 +348,10 @@
  */
     if (have_default_route)
 	cifdefaultroute(0, 0, 0);
+#ifdef INET6
+    if (have_default_route6)
+	cif6defaultroute(0, nulleui64, nulleui64);
+#endif
 
     if (has_proxy_arp)
 	cifproxyarp(0, proxy_arp_addr);
@@ -636,6 +645,21 @@
 	}
 	if (x < 0)
 		error("Couldn't create new ppp unit: %m");
+
+	if (x == 0 && req_ifname[0] != '\0') {
+		struct ifreq ifr;
+		char t[MAXIFNAMELEN];
+		memset(&ifr, 0, sizeof(struct ifreq));
+		slprintf(t, sizeof(t), "%s%d", PPP_DRV_NAME, ifunit);
+		strlcpy(ifr.ifr_name, t, IF_NAMESIZE);
+		strlcpy(ifr.ifr_newname, req_ifname, IF_NAMESIZE);
+		x = ioctl(sock_fd, SIOCSIFNAME, &ifr);
+		if (x < 0)
+		    error("Couldn't rename interface %s to %s: %m", t, req_ifname);
+		else
+		    info("Renamed interface %s to %s", t, req_ifname);
+	}
+
 	return x;
 }
 
@@ -1442,7 +1466,7 @@
 FILE *route_fd = (FILE *) 0;
 static char route_buffer[512];
 static int route_dev_col, route_dest_col, route_gw_col;
-static int route_flags_col, route_mask_col;
+static int route_flags_col, route_metric_col, route_mask_col;
 static int route_num_cols;
 
 static int open_route_table (void);
@@ -1485,6 +1509,7 @@
     route_dest_col = 1;
     route_gw_col = 2;
     route_flags_col = 3;
+    route_metric_col = 6;
     route_mask_col = 7;
     route_num_cols = 8;
 
@@ -1545,6 +1570,7 @@
     SIN_ADDR(rt->rt_genmask) = strtoul(cols[route_mask_col], NULL, 16);
 
     rt->rt_flags = (short) strtoul(cols[route_flags_col], NULL, 16);
+    rt->rt_metric = (short) strtoul(cols[route_metric_col], NULL, 10);
     rt->rt_dev   = cols[route_dev_col];
 
     return 1;
@@ -1553,9 +1579,10 @@
 /********************************************************************
  *
  * defaultroute_exists - determine if there is a default route
+ * with the given metric (or negative for any)
  */
 
-static int defaultroute_exists (struct rtentry *rt)
+static int defaultroute_exists (struct rtentry *rt, int metric)
 {
     int result = 0;
 
@@ -1568,7 +1595,8 @@
 
 	if (kernel_version > KVERSION(2,1,0) && SIN_ADDR(rt->rt_genmask) != 0)
 	    continue;
-	if (SIN_ADDR(rt->rt_dst) == 0L) {
+	if (SIN_ADDR(rt->rt_dst) == 0L && (metric < 0
+					   || rt->rt_metric == metric)) {
 	    result = 1;
 	    break;
 	}
@@ -1615,13 +1643,13 @@
 {
     struct rtentry rt;
 
-    if (!force && defaultroute_exists(&rt) && strcmp(rt.rt_dev, ifname) != 0) {
+    if (!force && defaultroute_exists(&rt, dfl_route_metric) && strcmp(rt.rt_dev, ifname) != 0) {
 	if (rt.rt_flags & RTF_GATEWAY)
-	    error("not replacing existing default route via %I",
-		  SIN_ADDR(rt.rt_gateway));
+	    error("not replacing existing default route via %I with metric %d",
+		  SIN_ADDR(rt.rt_gateway), dfl_route_metric);
 	else
-	    error("not replacing existing default route through %s",
-		  rt.rt_dev);
+	    error("not replacing existing default route through %s with metric %d",
+		  rt.rt_dev, dfl_route_metric);
 	return 0;
     }
 
@@ -1663,6 +1691,7 @@
     SET_SA_FAMILY (rt.rt_gateway, AF_INET);
 
     rt.rt_dev = ifname;
+    rt.rt_metric = dfl_route_metric + 1; /* +1 for binary compatibility */
 
     if (kernel_version > KVERSION(2,1,0)) {
 	SET_SA_FAMILY (rt.rt_genmask, AF_INET);
@@ -1706,6 +1735,198 @@
     return 1;
 }
 
+#ifdef INET6
+/*
+ * /proc/net/ipv6_route parsing stuff.
+ */
+static int route_dest_plen_col;
+static int open_route6_table (void);
+static int read_route6_table (struct in6_rtmsg *rt);
+
+/********************************************************************
+ *
+ * open_route6_table - open the interface to the route table
+ */
+static int open_route6_table (void)
+{
+    char *path;
+
+    close_route_table();
+
+    path = path_to_procfs("/net/ipv6_route");
+    route_fd = fopen (path, "r");
+    if (route_fd == NULL) {
+	error("can't open routing table %s: %m", path);
+	return 0;
+    }
+
+    /* default to usual columns */
+    route_dest_col = 0;
+    route_dest_plen_col = 1;
+    route_gw_col = 4;
+    route_metric_col = 5;
+    route_flags_col = 8;
+    route_dev_col = 9;
+    route_num_cols = 10;
+
+    return 1;
+}
+
+/********************************************************************
+ *
+ * read_route6_table - read the next entry from the route table
+ */
+
+static void hex_to_in6_addr(struct in6_addr *addr, const char *s)
+{
+    char hex8[9];
+    unsigned i;
+    uint32_t v;
+
+    hex8[8] = 0;
+    for (i = 0; i < 4; i++) {
+	memcpy(hex8, s + 8*i, 8);
+	v = strtoul(hex8, NULL, 16);
+	addr->s6_addr32[i] = v;
+    }
+}
+
+static int read_route6_table(struct in6_rtmsg *rt)
+{
+    char *cols[ROUTE_MAX_COLS], *p;
+    int col;
+
+    memset (rt, '\0', sizeof (struct in6_rtmsg));
+
+    if (fgets (route_buffer, sizeof (route_buffer), route_fd) == (char *) 0)
+	return 0;
+
+    p = route_buffer;
+    for (col = 0; col < route_num_cols; ++col) {
+	cols[col] = strtok(p, route_delims);
+	if (cols[col] == NULL)
+	    return 0;		/* didn't get enough columns */
+	p = NULL;
+    }
+
+    hex_to_in6_addr(&rt->rtmsg_dst, cols[route_dest_col]);
+    rt->rtmsg_dst_len = strtoul(cols[route_dest_plen_col], NULL, 16);
+    hex_to_in6_addr(&rt->rtmsg_gateway, cols[route_gw_col]);
+
+    rt->rtmsg_metric = strtoul(cols[route_metric_col], NULL, 16);
+    rt->rtmsg_flags = strtoul(cols[route_flags_col], NULL, 16);
+    rt->rtmsg_ifindex = if_nametoindex(cols[route_dev_col]);
+
+    return 1;
+}
+
+/********************************************************************
+ *
+ * defaultroute6_exists - determine if there is a default route
+ */
+
+static int defaultroute6_exists (struct in6_rtmsg *rt, int metric)
+{
+    int result = 0;
+
+    if (!open_route6_table())
+	return 0;
+
+    while (read_route6_table(rt) != 0) {
+	if ((rt->rtmsg_flags & RTF_UP) == 0)
+	    continue;
+
+	if (rt->rtmsg_dst_len != 0)
+	    continue;
+	if (rt->rtmsg_dst.s6_addr32[0] == 0L
+	 && rt->rtmsg_dst.s6_addr32[1] == 0L
+	 && rt->rtmsg_dst.s6_addr32[2] == 0L
+	 && rt->rtmsg_dst.s6_addr32[3] == 0L
+	 && (metric < 0 || rt->rtmsg_metric == metric)) {
+	    result = 1;
+	    break;
+	}
+    }
+
+    close_route_table();
+    return result;
+}
+
+/********************************************************************
+ *
+ * sif6defaultroute - assign a default route through the address given.
+ *
+ * If the global default_rt_repl_rest flag is set, then this function
+ * already replaced the original system defaultroute with some other
+ * route and it should just replace the current defaultroute with
+ * another one, without saving the current route. Use: demand mode,
+ * when pppd sets first a defaultroute it it's temporary ppp0 addresses
+ * and then changes the temporary addresses to the addresses for the real
+ * ppp connection when it has come up.
+ */
+
+int sif6defaultroute (int unit, eui64_t ouraddr, eui64_t gateway)
+{
+    struct in6_rtmsg rt;
+    char buf[IF_NAMESIZE];
+
+    if (defaultroute6_exists(&rt, dfl_route_metric) &&
+	    rt.rtmsg_ifindex != if_nametoindex(ifname)) {
+	if (rt.rtmsg_flags & RTF_GATEWAY)
+	    error("not replacing existing default route via gateway");
+	else
+	    error("not replacing existing default route through %s",
+		  if_indextoname(rt.rtmsg_ifindex, buf));
+	return 0;
+    }
+
+    memset (&rt, 0, sizeof (rt));
+
+    rt.rtmsg_ifindex = if_nametoindex(ifname);
+    rt.rtmsg_metric = dfl_route_metric + 1; /* +1 for binary compatibility */
+    rt.rtmsg_dst_len = 0;
+
+    rt.rtmsg_flags = RTF_UP;
+    if (ioctl(sock6_fd, SIOCADDRT, &rt) < 0) {
+	if ( ! ok_error ( errno ))
+	    error("default route ioctl(SIOCADDRT): %m");
+	return 0;
+    }
+
+    have_default_route6 = 1;
+    return 1;
+}
+
+/********************************************************************
+ *
+ * cif6defaultroute - delete a default route through the address given.
+ */
+
+int cif6defaultroute (int unit, eui64_t ouraddr, eui64_t gateway)
+{
+    struct in6_rtmsg rt;
+
+    have_default_route6 = 0;
+
+    memset (&rt, '\0', sizeof (rt));
+
+    rt.rtmsg_ifindex = if_nametoindex(ifname);
+    rt.rtmsg_metric = dfl_route_metric + 1; /* +1 for binary compatibility */
+    rt.rtmsg_dst_len = 0;
+
+    rt.rtmsg_flags = RTF_UP;
+    if (ioctl(sock6_fd, SIOCDELRT, &rt) < 0 && errno != ESRCH) {
+	if (still_ppp()) {
+	    if ( ! ok_error ( errno ))
+		error("default route ioctl(SIOCDELRT): %m");
+	    return 0;
+	}
+    }
+
+    return 1;
+}
+#endif /* INET6 */
+
 /********************************************************************
  *
  * sifproxyarp - Make a proxy ARP entry for the peer.
@@ -2163,7 +2384,6 @@
 		}
 	    }
 
-	    close (s);
 	    if (!ok) {
 		slprintf(route_buffer, sizeof(route_buffer),
 			 "Sorry - PPP driver version %d.%d.%d is out of date\n",
@@ -2173,6 +2393,7 @@
 	    }
 	}
     }
+    close(s);
     return ok;
 }
 
@@ -2649,7 +2870,10 @@
 		warn("Couldn't unlock pty slave %s: %m", pty_name);
 #endif
 	    if ((sfd = open(pty_name, O_RDWR | O_NOCTTY)) < 0)
+	    {
 		warn("Couldn't open pty slave %s: %m", pty_name);
+		close(mfd);
+	    }
 	}
     }
 #endif /* TIOCGPTN */
diff -ru ppp-ppp-2.4.7/pppd/sys-solaris.c ppp-ppp-2.4.8/pppd/sys-solaris.c
--- ppp-ppp-2.4.7/pppd/sys-solaris.c	2014-08-09 22:31:39.000000000 +1000
+++ ppp-ppp-2.4.8/pppd/sys-solaris.c	2020-03-09 12:16:15.682512922 +1000
@@ -166,7 +166,6 @@
 #define	UDP6_DEV_NAME	"/dev/udp6"
 #endif /* !defined(UDP6_DEV_NAME) && defined(SOL2) */
 
-static const char rcsid[] = RCSID;
 
 #if defined(SOL2)
 /*
@@ -189,6 +188,12 @@
 static int	ip6muxid = -1;	/* Multiplexer file descriptor */
 static int	if6_is_up = 0;	/* IPv6 interface has been marked up */
 
+#define IN6_SOCKADDR_FROM_EUI64(s, eui64) do { \
+	(s)->sin6_family = AF_INET6; \
+	(s)->sin6_addr.s6_addr32[0] = htonl(0xfe800000); \
+	eui64_copy(eui64, (s)->sin6_addr.s6_addr32[2]); \
+	} while(0)
+
 #define _IN6_LLX_FROM_EUI64(l, s, eui64, as) do {	\
 	s->sin6_addr.s6_addr32[0] = htonl(as); 	\
 	eui64_copy(eui64, s->sin6_addr.s6_addr32[2]);	\
@@ -198,12 +203,20 @@
 	l.lifr_addr = laddr;			\
 	} while (0)
 
+#define _IN6A_LLX_FROM_EUI64(s, eui64, as) do {	\
+	s->s6_addr32[0] = htonl(as); 	\
+	eui64_copy(eui64, s->s6_addr32[2]);	\
+	} while (0)
+
 #define IN6_LLADDR_FROM_EUI64(l, s, eui64)  \
     _IN6_LLX_FROM_EUI64(l, s, eui64, 0xfe800000)
 
 #define IN6_LLTOKEN_FROM_EUI64(l, s, eui64) \
     _IN6_LLX_FROM_EUI64(l, s, eui64, 0)
 
+#define IN6A_LLADDR_FROM_EUI64(s, eui64)  \
+    _IN6A_LLX_FROM_EUI64(s, eui64, 0xfe800000)
+
 #endif /* defined(INET6) && defined(SOL2) */
 
 #if defined(INET6) && defined(SOL2)
@@ -238,6 +251,7 @@
 static int	if_is_up;	/* Interface has been marked up */
 static u_int32_t remote_addr;		/* IP address of peer */
 static u_int32_t default_route_gateway;	/* Gateway for default route added */
+static eui64_t	default_route_gateway6;	/* Gateway for default IPv6 route added */
 static u_int32_t proxy_arp_addr;	/* Addr for proxy arp entry added */
 
 /* Prototypes for procedures local to this file. */
@@ -787,6 +801,8 @@
 	sifdown(0);
     if (default_route_gateway)
 	cifdefaultroute(0, default_route_gateway, default_route_gateway);
+    if (default_route_gateway6.e32[0] != 0 || default_route_gateway6.e32[1] != 0)
+	cif6defaultroute(0, default_route_gateway6, default_route_gateway6);
     if (proxy_arp_addr)
 	cifproxyarp(0, proxy_arp_addr);
 #if defined(SOL2)
@@ -1957,6 +1973,70 @@
     return 1;
 }
 
+/*
+ * sif6defaultroute - assign a default route through the address given.
+ */
+int
+sif6defaultroute(u, l, g)
+    int u;
+    eui64_t l, g;
+{
+    struct {
+	struct rt_msghdr rtm;
+	struct sockaddr_in6 dst;
+	struct sockaddr_in6 gw;
+    } rmsg;
+    static int seq;
+    int rtsock;
+
+#if defined(__USLC__)
+    g = l;			/* use the local address as gateway */
+#endif
+    memset(&rmsg, 0, sizeof(rmsg));
+
+    rmsg.rtm.rtm_msglen = sizeof (rmsg);
+    rmsg.rtm.rtm_version = RTM_VERSION;
+    rmsg.rtm.rtm_type = RTM_ADD;
+    rmsg.rtm.rtm_flags = RTF_GATEWAY;
+    rmsg.rtm.rtm_addrs = RTA_DST | RTA_GATEWAY;
+    rmsg.rtm.rtm_pid = getpid();
+    rmsg.rtm.rtm_seq = seq++;
+
+    rmsg.dst.sin6_family = AF_INET6;
+
+    rmsg.gw.sin6_family = AF_INET6;
+    IN6_SOCKADDR_FROM_EUI64(&rmsg.gw, g);
+
+    rtsock = socket(PF_ROUTE, SOCK_RAW, 0);
+
+    if (rtsock < 0) {
+	error("Can't add default route: %m");
+	return 0;
+    }
+
+    if (write(rtsock, &rmsg, sizeof(rmsg)) < 0)
+	error("Can't add default route: %m");
+
+    close(rtsock);
+
+    default_route_gateway6 = g;
+    return 1;
+}
+
+/*
+ * cif6defaultroute - delete a default route through the address given.
+ */
+int
+cif6defaultroute(u, l, g)
+    int u;
+    eui64_t l, g;
+{
+    /* No need to do this on Solaris; the kernel deletes the
+       route when the interface goes down. */
+    memset(&default_route_gateway6, 0, sizeof(default_route_gateway6));
+    return 1;
+}
+
 #endif /* defined(SOL2) && defined(INET6) */
 
 
diff -ru ppp-ppp-2.4.7/pppd/tty.c ppp-ppp-2.4.8/pppd/tty.c
--- ppp-ppp-2.4.7/pppd/tty.c	2020-03-09 12:16:34.502057545 +1000
+++ ppp-ppp-2.4.8/pppd/tty.c	2020-03-09 12:16:15.682512922 +1000
@@ -83,7 +83,6 @@
 #include <netdb.h>
 #include <utmp.h>
 #include <pwd.h>
-#include <setjmp.h>
 #include <sys/param.h>
 #include <sys/types.h>
 #include <sys/wait.h>
diff -ru ppp-ppp-2.4.7/pppd/upap.c ppp-ppp-2.4.8/pppd/upap.c
--- ppp-ppp-2.4.7/pppd/upap.c	2020-03-09 12:16:34.502057545 +1000
+++ ppp-ppp-2.4.8/pppd/upap.c	2020-03-09 12:16:15.682512922 +1000
@@ -52,7 +52,6 @@
 #include "pppd.h"
 #include "upap.h"
 
-static const char rcsid[] = RCSID;
 
 static bool hide_password = 1;
 
diff -ru ppp-ppp-2.4.7/pppd/utils.c ppp-ppp-2.4.8/pppd/utils.c
--- ppp-ppp-2.4.7/pppd/utils.c	2014-08-09 22:31:39.000000000 +1000
+++ ppp-ppp-2.4.8/pppd/utils.c	2020-03-09 12:16:15.682512922 +1000
@@ -59,7 +59,6 @@
 #include "fsm.h"
 #include "lcp.h"
 
-static const char rcsid[] = RCSID;
 
 #if defined(SUNOS4)
 extern char *strerror();
@@ -167,6 +166,7 @@
     u_int32_t ip;
     static char hexchars[] = "0123456789abcdef";
     struct buffer_info bufinfo;
+    int termch;
 
     buf0 = buf;
     --buflen;
@@ -300,13 +300,17 @@
 		    p = (unsigned char *)"<NULL>";
 	    if (fillch == '0' && prec >= 0) {
 		n = prec;
+		termch = -1;	/* matches no unsigned char value */
 	    } else {
-		n = strlen((char *)p);
-		if (prec >= 0 && n > prec)
+		n = buflen;
+		if (prec != -1 && n > prec)
 		    n = prec;
+		termch = 0;	/* stop on null byte */
 	    }
 	    while (n > 0 && buflen > 0) {
 		c = *p++;
+		if (c == termch)
+		    break;
 		--n;
 		if (!quoted && c >= 0x80) {
 		    OUTCHAR('M');
@@ -386,9 +390,9 @@
 	    }
 	    len = num + sizeof(num) - 1 - str;
 	} else {
-	    len = strlen(str);
-	    if (prec >= 0 && len > prec)
-		len = prec;
+	    for (len = 0; len < buflen && (prec == -1 || len < prec); ++len)
+		if (str[len] == 0)
+		    break;
 	}
 	if (width > 0) {
 	    if (width > buflen)
@@ -625,7 +629,7 @@
 		printer(arg, "\\t");
 		break;
 	    default:
-		printer(arg, "\\%.3o", c);
+		printer(arg, "\\%.3o", (unsigned char) c);
 	    }
 	}
     }
diff -ru ppp-ppp-2.4.7/pppdump/pppdump.c ppp-ppp-2.4.8/pppdump/pppdump.c
--- ppp-ppp-2.4.7/pppdump/pppdump.c	2014-08-09 22:31:39.000000000 +1000
+++ ppp-ppp-2.4.8/pppdump/pppdump.c	2020-03-09 12:16:15.682512922 +1000
@@ -320,7 +320,7 @@
 			    ++r;
 			++r;
 			if (endp - r > mru)
-			    printf("     ERROR: length (%d) > MRU (%d)\n",
+			    printf("     ERROR: length (%zd) > MRU (%d)\n",
 				   endp - r, mru);
 			if (decompress && fcs == PPP_GOODFCS) {
 			    /* See if this is a CCP or compressed packet */
diff -ru ppp-ppp-2.4.7/pppstats/pppstats.c ppp-ppp-2.4.8/pppstats/pppstats.c
--- ppp-ppp-2.4.7/pppstats/pppstats.c	2014-08-09 22:31:39.000000000 +1000
+++ ppp-ppp-2.4.8/pppstats/pppstats.c	2020-03-09 12:16:15.682512922 +1000
@@ -88,7 +88,6 @@
 int	dflag;			/* print data rates, not bytes */
 int	interval, count;
 int	infinite;
-int	unit;
 int	s;			/* socket or /dev/ppp file descriptor */
 int	signalled;		/* set if alarm goes off "early" */
 char	*progname;
@@ -150,7 +149,8 @@
 #define ifr_name ifr__name
 #endif
 
-    strncpy(req.ifr_name, interface, sizeof(req.ifr_name));
+    strncpy(req.ifr_name, interface, IFNAMSIZ);
+    req.ifr_name[IFNAMSIZ - 1] = 0;
     if (ioctl(s, SIOCGPPPSTATS, &req) < 0) {
 	fprintf(stderr, "%s: ", progname);
 	if (errno == ENOTTY)
@@ -176,7 +176,8 @@
 #define ifr_name ifr__name
 #endif
 
-    strncpy(creq.ifr_name, interface, sizeof(creq.ifr_name));
+    strncpy(creq.ifr_name, interface, IFNAMSIZ);
+    creq.ifr_name[IFNAMSIZ - 1] = 0;
     if (ioctl(s, SIOCGPPPCSTATS, &creq) < 0) {
 	fprintf(stderr, "%s: ", progname);
 	if (errno == ENOTTY) {
@@ -449,6 +450,7 @@
 {
     int c;
 #ifdef STREAMS
+    int unit;
     char *dev;
 #endif
 
@@ -506,11 +508,6 @@
     if (argc > 0)
 	interface = argv[0];
 
-    if (sscanf(interface, PPP_DRV_NAME "%d", &unit) != 1) {
-	fprintf(stderr, "%s: invalid interface '%s' specified\n",
-		progname, interface);
-    }
-
 #ifndef STREAMS
     {
 	struct ifreq ifr;
@@ -526,7 +523,8 @@
 #undef  ifr_name
 #define ifr_name ifr_ifrn.ifrn_name
 #endif
-	strncpy(ifr.ifr_name, interface, sizeof(ifr.ifr_name));
+	strncpy(ifr.ifr_name, interface, IFNAMSIZ);
+	ifr.ifr_name[IFNAMSIZ - 1] = 0;
 	if (ioctl(s, SIOCGIFFLAGS, (caddr_t)&ifr) < 0) {
 	    fprintf(stderr, "%s: nonexistent interface '%s' specified\n",
 		    progname, interface);
@@ -535,6 +533,11 @@
     }
 
 #else	/* STREAMS */
+    if (sscanf(interface, PPP_DRV_NAME "%d", &unit) != 1) {
+	fprintf(stderr, "%s: invalid interface '%s' specified\n",
+		progname, interface);
+    }
+
 #ifdef __osf__
     dev = "/dev/streams/ppp";
 #else
diff -ru ppp-ppp-2.4.7/README ppp-ppp-2.4.8/README
--- ppp-ppp-2.4.7/README	2014-08-09 22:31:39.000000000 +1000
+++ ppp-ppp-2.4.8/README	2020-03-09 12:16:15.666513309 +1000
@@ -61,9 +61,33 @@
 authenticating itself to you, of course.)
 
 
-What's new in ppp-2.4.7.
+What's new in ppp-2.4.8.
 ************************
 
+* New pppd options have been added:
+  - ifname, to set the name for the PPP interface device
+  - defaultroute-metric, to set the metric for the default route
+  - defaultroute6, to add an IPv6 default route (with nodefaultroute6
+    to prevent adding an IPv6 default route)
+  - up_sdnotify, to have pppd notify systemd when the link is up.
+
+* The rp-pppoe plugin has new options:
+  - host-uniq, to set the Host-Uniq value to send
+  - pppoe-padi-timeout, to set the timeout for discovery packets
+  - pppoe-padi-attempts, to set the number of discovery attempts.
+
+* Added the CLASS attribute in radius packets.
+
+* Sundry bug fixes.
+
+* Fixed warnings and issues found by static analysis.
+
+* Added Submitting-patches.md.
+
+
+What was new in ppp-2.4.7.
+**************************
+
 * Fixed a potential security issue in parsing option files (CVE-2014-3158).
 
 * There is a new "stop-bits" option, which takes an argument of 1 or 2,
diff -ru ppp-ppp-2.4.7/scripts/plog ppp-ppp-2.4.8/scripts/plog
--- ppp-ppp-2.4.7/scripts/plog	2014-08-09 22:31:39.000000000 +1000
+++ ppp-ppp-2.4.8/scripts/plog	2020-03-09 12:16:15.682512922 +1000
@@ -3,5 +3,5 @@
 if [ -s /var/log/ppp.log ]; then
   exec tail "$@" /var/log/ppp.log
 else
-  exec tail "$@" /var/log/syslog | grep ' \(pppd\|chat\)\['
+  exec grep ' \(pppd\|chat\)\[' /var/log/syslog | tail "$@"
 fi
diff -ru ppp-ppp-2.4.7/scripts/poff ppp-ppp-2.4.8/scripts/poff
--- ppp-ppp-2.4.7/scripts/poff	2014-08-09 22:31:39.000000000 +1000
+++ ppp-ppp-2.4.8/scripts/poff	2020-03-09 12:16:15.682512922 +1000
@@ -91,7 +91,7 @@
 fi
 
 # There is an argument, so kill the pppd started on that provider.
-PID=`ps axw | grep "[ /]pppd call $1" | awk '{print $1}'`
+PID=`ps axw | grep "[ /]pppd call $1" | grep -w "$1" | awk '{print $1}'`
 if test -n "$PID" ; then
     $KILL -$SIG $PID || {
         echo "$0: $KILL failed.  None ${DONE}."
--- ppp-ppp-2.4.7/pppd/plugins/rp-pppoe/pppoe-discovery.c	2020-03-09 13:15:54.488303400 +1000
+++ ppp-ppp-2.4.7/pppd/plugins/rp-pppoe/pppoe-discovery.c	2020-03-09 13:17:12.911164862 +1000
@@ -49,26 +49,9 @@
 #include <net/if_arp.h>
 #endif
 
-#if !defined(__GLIBC__)
-#define error(msg)	printf("pppoe-discovery: " msg)
-#endif
-
 char *xstrdup(const char *s);
 void usage(void);
 
-void die(int status)
-{
-	exit(status);
-}
-
-void error(char *fmt, ...)
-{
-    va_list pvar;
-    va_start(pvar, fmt);
-    vfprintf(stderr, fmt, pvar);
-    va_end(pvar);
-}
-
 /* Initialize frame types to RFC 2516 values.  Some broken peers apparently
    use different frame types... sigh... */
 
