From a94c8dfd2d64438abf5b7ff2066b1bcff93ed1a3 Mon Sep 17 00:00:00 2001
From: Greg Ungerer <gerg@kernel.org>
Date: Tue, 2 Apr 2019 13:29:06 +1000
Subject: [PATCH 1/3] pppd: original accelerated patch set to pppd-2.4.5

A large number of accumulated changes from the existing in tree pppd
source to this automake version.

Changes include:

. radius support
. tacaccs support
. non-MMU support (uClinux)
, dynamic or static plugins
. size reduction
---
 chat/Makefile.linux                  |   13 +-
 chat/chat.c                          |  224 ++-
 configure                            |    2 +-
 linux/Makefile.top                   |   11 +
 pppd/Makefile.linux                  |   99 +-
 pppd/auth.c                          |  332 +++-
 pppd/chap-new.c                      |   14 +
 pppd/ipcp.c                          |   83 +-
 pppd/ipcp.h                          |    1 +
 pppd/lcp.c                           |    3 +
 pppd/magic.h                         |    4 +
 pppd/main.c                          |  327 +++-
 pppd/options.c                       |  124 +-
 pppd/pathnames.h                     |   48 +-
 pppd/plugins/TACACS.txt              |   67 +
 pppd/plugins/minconn.c               |    5 +-
 pppd/plugins/passprompt.c            |    5 +-
 pppd/plugins/passwordfd.c            |    5 +-
 pppd/plugins/pppoatm/Makefile.linux  |   21 +-
 pppd/plugins/pppoatm/pppoatm.c       |    5 +-
 pppd/plugins/pppol2tp/Makefile.linux |   20 +-
 pppd/plugins/pppol2tp/openl2tp.c     |    7 +-
 pppd/plugins/pppol2tp/pppol2tp.c     |    7 +-
 pppd/plugins/pptp/Makefile.linux     |   42 +
 pppd/plugins/pptp/dirutil.c          |   68 +
 pppd/plugins/pptp/dirutil.h          |   14 +
 pppd/plugins/pptp/orckit_quirks.c    |   86 ++
 pppd/plugins/pptp/orckit_quirks.h    |   27 +
 pppd/plugins/pptp/pppd-pptp.8        |   68 +
 pppd/plugins/pptp/pptp.c             |  325 ++++
 pppd/plugins/pptp/pptp_callmgr.c     |  381 +++++
 pppd/plugins/pptp/pptp_callmgr.h     |   17 +
 pppd/plugins/pptp/pptp_ctrl.c        | 1077 +++++++++++++
 pppd/plugins/pptp/pptp_ctrl.h        |   57 +
 pppd/plugins/pptp/pptp_msg.h         |  303 ++++
 pppd/plugins/pptp/pptp_options.h     |   41 +
 pppd/plugins/pptp/pptp_quirks.c      |   54 +
 pppd/plugins/pptp/pptp_quirks.h      |   59 +
 pppd/plugins/pptp/util.c             |  109 ++
 pppd/plugins/pptp/util.h             |   31 +
 pppd/plugins/pptp/vector.c           |  209 +++
 pppd/plugins/pptp/vector.h           |   31 +
 pppd/plugins/radius/Makefile.linux   |   24 +-
 pppd/plugins/radius/avpair.c         |   18 +
 pppd/plugins/radius/buildreq.c       |   11 +-
 pppd/plugins/radius/config.c         |    4 +-
 pppd/plugins/radius/radattr.c        |    5 +-
 pppd/plugins/radius/radius.c         |   54 +-
 pppd/plugins/radius/radrealms.c      |    5 +-
 pppd/plugins/rp-pppoe/Makefile.linux |   27 +-
 pppd/plugins/rp-pppoe/config.h       |    2 +-
 pppd/plugins/rp-pppoe/pppoe.h        |    4 +-
 pppd/plugins/tacacs.c                |  375 +++++
 pppd/plugins/tacc/.gitignore         |    1 +
 pppd/plugins/tacc/ChangeLog.tacacs   |   77 +
 pppd/plugins/tacc/Makefile           |   43 +
 pppd/plugins/tacc/README             |   57 +
 pppd/plugins/tacc/extras/Makefile    |    8 +
 pppd/plugins/tacc/extras/getopt.c    |  755 ++++++++++
 pppd/plugins/tacc/extras/getopt.h    |  127 ++
 pppd/plugins/tacc/extras/tailor.h    |  328 ++++
 pppd/plugins/tacc/include/libtac.h   |   48 +
 pppd/plugins/tacc/include/tacplus.h  |  259 ++++
 pppd/plugins/tacc/lib/Makefile       |   48 +
 pppd/plugins/tacc/lib/acct_r.c       |   86 ++
 pppd/plugins/tacc/lib/acct_s.c       |  135 ++
 pppd/plugins/tacc/lib/attrib.c       |   72 +
 pppd/plugins/tacc/lib/authen_r.c     |   94 ++
 pppd/plugins/tacc/lib/authen_s.c     |  102 ++
 pppd/plugins/tacc/lib/author_r.c     |  185 +++
 pppd/plugins/tacc/lib/author_s.c     |  127 ++
 pppd/plugins/tacc/lib/connect.c      |   83 +
 pppd/plugins/tacc/lib/crypt.c        |  100 ++
 pppd/plugins/tacc/lib/hdr_check.c    |   46 +
 pppd/plugins/tacc/lib/header.c       |   53 +
 pppd/plugins/tacc/lib/magic.c        |  114 ++
 pppd/plugins/tacc/lib/magic.h        |   27 +
 pppd/plugins/tacc/lib/md5.c          |  309 ++++
 pppd/plugins/tacc/lib/md5.h          |   60 +
 pppd/plugins/tacc/lib/messages.c     |   14 +
 pppd/plugins/tacc/lib/messages.h     |    5 +
 pppd/plugins/tacc/lib/version.c      |   12 +
 pppd/plugins/tacc/lib/xalloc.c       |   31 +
 pppd/plugins/tacc/lib/xalloc.h       |    2 +
 pppd/plugins/tacc/pppd-2.2.0g.patch  | 2089 ++++++++++++++++++++++++++
 pppd/plugins/tacc/pppd-2.3.4.patch   |  819 ++++++++++
 pppd/plugins/tacc/tacc.1             |  138 ++
 pppd/plugins/tacc/tacc.c             |  610 ++++++++
 pppd/plugins/winbind.c               |   11 +-
 pppd/pppd.h                          |   23 +-
 pppd/sha1.c                          |    1 +
 pppd/sys-linux.c                     |   35 +-
 pppd/tty.c                           |   11 +
 pppd/upap.c                          |   13 +-
 pppdump/Makefile.linux               |    5 +-
 pppstats/Makefile.linux              |    9 +-
 scripts/radiusclient/dictionary      |  242 +++
 scripts/radiusclient/dictionary.ms   |   81 +
 scripts/radiusclient/dictionary.sg   |   11 +
 99 files changed, 12299 insertions(+), 162 deletions(-)
 create mode 100644 pppd/plugins/TACACS.txt
 create mode 100644 pppd/plugins/pptp/Makefile.linux
 create mode 100644 pppd/plugins/pptp/dirutil.c
 create mode 100644 pppd/plugins/pptp/dirutil.h
 create mode 100644 pppd/plugins/pptp/orckit_quirks.c
 create mode 100644 pppd/plugins/pptp/orckit_quirks.h
 create mode 100644 pppd/plugins/pptp/pppd-pptp.8
 create mode 100644 pppd/plugins/pptp/pptp.c
 create mode 100644 pppd/plugins/pptp/pptp_callmgr.c
 create mode 100644 pppd/plugins/pptp/pptp_callmgr.h
 create mode 100644 pppd/plugins/pptp/pptp_ctrl.c
 create mode 100644 pppd/plugins/pptp/pptp_ctrl.h
 create mode 100644 pppd/plugins/pptp/pptp_msg.h
 create mode 100644 pppd/plugins/pptp/pptp_options.h
 create mode 100644 pppd/plugins/pptp/pptp_quirks.c
 create mode 100644 pppd/plugins/pptp/pptp_quirks.h
 create mode 100644 pppd/plugins/pptp/util.c
 create mode 100644 pppd/plugins/pptp/util.h
 create mode 100644 pppd/plugins/pptp/vector.c
 create mode 100644 pppd/plugins/pptp/vector.h
 create mode 100644 pppd/plugins/tacacs.c
 create mode 100644 pppd/plugins/tacc/.gitignore
 create mode 100644 pppd/plugins/tacc/ChangeLog.tacacs
 create mode 100644 pppd/plugins/tacc/Makefile
 create mode 100644 pppd/plugins/tacc/README
 create mode 100644 pppd/plugins/tacc/extras/Makefile
 create mode 100644 pppd/plugins/tacc/extras/getopt.c
 create mode 100644 pppd/plugins/tacc/extras/getopt.h
 create mode 100644 pppd/plugins/tacc/extras/tailor.h
 create mode 100644 pppd/plugins/tacc/include/libtac.h
 create mode 100644 pppd/plugins/tacc/include/tacplus.h
 create mode 100644 pppd/plugins/tacc/lib/Makefile
 create mode 100644 pppd/plugins/tacc/lib/acct_r.c
 create mode 100644 pppd/plugins/tacc/lib/acct_s.c
 create mode 100644 pppd/plugins/tacc/lib/attrib.c
 create mode 100644 pppd/plugins/tacc/lib/authen_r.c
 create mode 100644 pppd/plugins/tacc/lib/authen_s.c
 create mode 100644 pppd/plugins/tacc/lib/author_r.c
 create mode 100644 pppd/plugins/tacc/lib/author_s.c
 create mode 100644 pppd/plugins/tacc/lib/connect.c
 create mode 100644 pppd/plugins/tacc/lib/crypt.c
 create mode 100644 pppd/plugins/tacc/lib/hdr_check.c
 create mode 100644 pppd/plugins/tacc/lib/header.c
 create mode 100644 pppd/plugins/tacc/lib/magic.c
 create mode 100644 pppd/plugins/tacc/lib/magic.h
 create mode 100644 pppd/plugins/tacc/lib/md5.c
 create mode 100644 pppd/plugins/tacc/lib/md5.h
 create mode 100644 pppd/plugins/tacc/lib/messages.c
 create mode 100644 pppd/plugins/tacc/lib/messages.h
 create mode 100644 pppd/plugins/tacc/lib/version.c
 create mode 100644 pppd/plugins/tacc/lib/xalloc.c
 create mode 100644 pppd/plugins/tacc/lib/xalloc.h
 create mode 100644 pppd/plugins/tacc/pppd-2.2.0g.patch
 create mode 100644 pppd/plugins/tacc/pppd-2.3.4.patch
 create mode 100644 pppd/plugins/tacc/tacc.1
 create mode 100644 pppd/plugins/tacc/tacc.c
 create mode 100644 scripts/radiusclient/dictionary
 create mode 100644 scripts/radiusclient/dictionary.ms
 create mode 100644 scripts/radiusclient/dictionary.sg

diff --git a/chat/Makefile.linux b/chat/Makefile.linux
index 1065ac5..01ed85e 100644
--- a/chat/Makefile.linux
+++ b/chat/Makefile.linux
@@ -10,15 +10,19 @@ CDEF3=	-UNO_SLEEP			# Use the usleep function
 CDEF4=	-DFNDELAY=O_NDELAY		# Old name value
 CDEFS=	$(CDEF1) $(CDEF2) $(CDEF3) $(CDEF4)
 
-COPTS=	-O2 -g -pipe
-CFLAGS=	$(COPTS) $(CDEFS)
+#COPTS=	-O2 -g -pipe
+CFLAGS+=$(COPTS) $(CDEFS)
+
+ifdef CONFIG_USER_CHAT_CHAT_NETWORK
+CFLAGS += -DENABLE_NETWORK_SUPPORT=1
+endif
 
 INSTALL= install
 
 all:	chat
 
 chat:	chat.o
-	$(CC) -o chat chat.o
+	$(CC) $(LDFLAGS) -o chat chat.o $(LDLIBS$(LDLIBS_$@))
 
 chat.o:	chat.c
 	$(CC) -c $(CFLAGS) -o chat.o chat.c
@@ -28,5 +32,8 @@ install: chat
 	$(INSTALL) -s -c chat $(BINDIR)
 	$(INSTALL) -c -m 644 chat.8 $(MANDIR)
 
+romfs:
+	$(ROMFSINST) chat /bin/chat
+
 clean:
 	rm -f chat.o chat *~
diff --git a/chat/chat.c b/chat/chat.c
index 710dba9..baa64a7 100644
--- a/chat/chat.c
+++ b/chat/chat.c
@@ -14,6 +14,9 @@
  *	This software is in the public domain.
  *
  * -----------------
+ *  21st March 2003  - added network/telnet code option <davidm@snapgear.com>
+ *                   - added -R (truncated/created report file option)
+ *
  *	22-May-99 added environment substitutuion, enabled with -E switch.
  *	Andreas Arens <andras@cityweb.de>.
  *
@@ -171,6 +174,8 @@ int to_log        = 1;
 int to_stderr     = 0;
 int Verbose       = 0;
 int quiet         = 0;
+int ignorecase    = 0;
+int machine_speed = 0;
 int report        = 0;
 int use_env       = 0;
 int exit_code     = 0;
@@ -180,6 +185,24 @@ char *chat_file   = (char *) 0;
 char *phone_num   = (char *) 0;
 char *phone_num2  = (char *) 0;
 int timeout       = DEFAULT_CHAT_TIMEOUT;
+char *device      = 0;
+
+#ifdef ENABLE_NETWORK_SUPPORT
+
+int network       = 0;
+char *net_host    = NULL;
+int net_port      = 23; /* telnet by default */
+
+#define IAC  0xff
+#define DONT 0xfe
+#define DO   0xfd
+#define WONT 0xfc
+#define WILL 0xfb
+
+extern int net_get_char(unsigned char *cp);
+extern void net_open();
+
+#endif /* ENABLE_NETWORK_SUPPORT */
 
 int have_tty_parameters = 0;
 
@@ -278,10 +301,11 @@ size_t len;
 
 /*
  * chat [ -v ] [ -E ] [ -T number ] [ -U number ] [ -t timeout ] [ -f chat-file ] \
- * [ -r report-file ] \
+ * [ -r report-file ] [-d device] \
  *		[...[[expect[-say[-expect...]] say expect[-say[-expect]] ...]]]
  *
  *	Perform a UUCP-dialer-like chat script on stdin and stdout.
+ *	(or the given device if specified)
  */
 int
 main(argc, argv)
@@ -308,10 +332,31 @@ main(argc, argv)
 	    ++verbose;
 	    break;
 
+#ifdef ENABLE_NETWORK_SUPPORT
+	case 'h':
+	    ++network;
+	    if ((arg = OPTARG(argc, argv)) != NULL)
+		net_host = copy_of(arg);
+	    else
+		usage();
+	    break;
+
+	case 'p':
+	    if ((arg = OPTARG(argc, argv)) != NULL)
+		net_port = atoi(arg);
+	    else
+		usage();
+	    break;
+#endif
+
 	case 'V':
 	    ++Verbose;
 	    break;
 
+	case 'm':
+	    machine_speed = 1;
+	    break;
+
 	case 's':
 	    ++to_stderr;
 	    break;
@@ -334,13 +379,21 @@ main(argc, argv)
 		usage();
 	    break;
 
+	case 'd':
+	    if ((arg = OPTARG(argc, argv)) != NULL)
+		device = arg;
+	    else
+		usage();
+	    break;
+
 	case 'r':
+	case 'R':
 	    arg = OPTARG (argc, argv);
 	    if (arg) {
 		if (report_fp != NULL)
 		    fclose (report_fp);
 		report_file = copy_of (arg);
-		report_fp   = fopen (report_file, "a");
+		report_fp   = fopen (report_file, option == 'r' ? "a" : "w");
 		if (report_fp != NULL) {
 		    if (verbose)
 			fprintf (report_fp, "Opening \"%s\"...\n",
@@ -369,6 +422,7 @@ main(argc, argv)
 	    break;
 	}
     }
+
 /*
  * Default the report file to the stderr location
  */
@@ -388,6 +442,14 @@ main(argc, argv)
 #endif
     }
 
+    if (device != 0) {
+	int fd = open(device, O_RDWR, S_IRUSR | S_IWUSR);
+	if (fd == -1)
+	    usage();
+	dup2(fd, 0);
+	dup2(fd, 1);
+    }
+
     init();
     
     if (chat_file != NULL) {
@@ -485,8 +547,11 @@ char *chat_file;
 void usage()
 {
     fprintf(stderr, "\
-Usage: %s [-e] [-E] [-v] [-V] [-t timeout] [-r report-file]\n\
-     [-T phone-number] [-U phone-number2] {-f chat-file | chat-script}\n", program_name);
+Usage: %s [-e] [-E] [-v] [-V] [-m] [-t timeout] [-r report-file] [-R report-file]\n"
+#ifdef ENABLE_NETWORK_SUPPORT
+"     [-h hostname] [-p tcp-port]\n"
+#endif /* ENABLE_NETWORK_SUPPORT */
+"     [-T phone-number] [-U phone-number2] {-f chat-file | chat-script}\n", program_name);
     exit(1);
 }
 
@@ -596,6 +661,11 @@ void init()
     signal(SIGTERM, sigterm);
     signal(SIGHUP, sighup);
 
+#ifdef ENABLE_NETWORK_SUPPORT
+    if (network)
+	net_open();
+    else
+#endif
     set_tty_parameters();
     signal(SIGALRM, sigalrm);
     alarm(0);
@@ -645,7 +715,8 @@ int status;
 /*
  * Allow the last of the report string to be gathered before we terminate.
  */
-    if (report_gathering) {
+    if (report_gathering &&
+    	report_file != (char *) 0 && report_fp != (FILE *) NULL) {
 	int c, rep_len;
 
 	rep_len = strlen(report_buffer);
@@ -798,6 +869,10 @@ int sending;  /* set to 1 when sending (putting) this string. */
 	    quiet = 1;
 	    break;
 
+	case 'i':
+	    ignorecase = 1;
+	    break;
+
 	case 'r':
 	    *p++ = '\r';
 	    break;
@@ -1122,8 +1197,8 @@ register char *s;
 	    fatal(2, "Too many REPORT strings");
 	
 	s1 = clean(s, 0);
-	if (strlen(s1) > strlen(s)
-	    || strlen(s1) + 1 > sizeof(fail_buffer))
+	
+	if (strlen(s1) > strlen(s) || strlen(s1) > sizeof(fail_buffer) - 1)
 	    fatal(1, "Illegal or too-long REPORT string ('%v')", s);
 	
 	report_string[n_reports++] = s1;
@@ -1143,8 +1218,7 @@ register char *s;
 	
 	s1 = clean(s, 0);
 	
-	if (strlen(s1) > strlen(s)
-	    || strlen(s1) + 1 > sizeof(fail_buffer))
+	if (strlen(s1) > strlen(s) || strlen(s1) > sizeof(fail_buffer) - 1)
 	    fatal(1, "Illegal or too-long REPORT string ('%v')", s);
 
 	old_max = n_reports;
@@ -1228,12 +1302,19 @@ register char *s;
 int get_char()
 {
     int status;
-    char c;
+    unsigned char c;
 
     status = read(0, &c, 1);
 
     switch (status) {
     case 1:
+#ifdef ENABLE_NETWORK_SUPPORT
+	if (network && c == IAC) {
+	    if (net_get_char(&c) != -1)
+		return ((int)c & 0x7F);
+	    /* drop through to error below */
+	} else
+#endif
 	return ((int)c & 0x7F);
 
     default:
@@ -1256,7 +1337,8 @@ int c;
     int status;
     char ch = c;
 
-    usleep(10000);		/* inter-character typing delay (?) */
+    if (!machine_speed)
+	usleep(10000);		/* inter-character typing delay (?) */
 
     status = write(1, &ch, 1);
 
@@ -1388,6 +1470,7 @@ register char *string;
     char *logged = temp;
 
     fail_reason = (char *)0;
+    ignorecase = 0;
     string = clean(string, 0);
     len = strlen(string);
     minlen = (len > sizeof(fail_buffer)? len: sizeof(fail_buffer)) - 1;
@@ -1468,6 +1551,8 @@ register char *string;
 
 	if (s - temp >= len &&
 	    c == string[len - 1] &&
+	    ignorecase ?
+	    strncasecmp(s - len, string, len) == 0 :
 	    strncmp(s - len, string, len) == 0) {
 	    if (verbose) {
 		if (s > logged)
@@ -1786,3 +1871,120 @@ vfmtmsg(buf, buflen, fmt, args)
     *buf = 0;
     return buf - buf0;
 }
+
+
+#ifdef ENABLE_NETWORK_SUPPORT
+/*
+ * Allow chat to chat to a network connection easily
+ */
+
+#include <netdb.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <sys/socket.h>
+
+void
+net_open()
+{
+	struct	sockaddr_in sock_in;
+	struct hostent *host;
+	int s;
+
+	bzero((char *)&sock_in, sizeof (sock_in));
+	sock_in.sin_family = AF_INET;
+	s = socket(AF_INET, SOCK_STREAM, 0);
+	if (s == -1) {
+		perror("socket");
+		exit(1);
+	}
+
+	if (bind(s, (struct sockaddr*)&sock_in, sizeof (sock_in)) == -1) {
+		perror("bind");
+		exit(2);
+	}
+
+	host = gethostbyname(net_host);
+	if (host) {
+		sock_in.sin_family = host->h_addrtype;
+		bcopy(host->h_addr, &sock_in.sin_addr, host->h_length);
+	} else {
+		sock_in.sin_family = AF_INET;
+		sock_in.sin_addr.s_addr = inet_addr(net_host);
+		if (sock_in.sin_addr.s_addr == -1) {
+			fprintf(stderr, "%s: %s unknown host\n", program_name, net_host);
+			exit(3);
+		}
+	}
+
+	sock_in.sin_port = htons(net_port);
+
+	if (connect(s, (struct sockaddr*)&sock_in, sizeof(sock_in)) == -1) {
+		perror("connect:");
+		exit(4);
+	}
+
+	/*
+	 * make the socket stdin/stdout
+	 */
+	if (s != 0) {
+		dup2(s, 0);
+		close(s);
+	}
+	dup2(0, 1);
+}
+
+
+/* we arrive here having already receive an IAC */
+int
+net_get_char(unsigned char *cp)
+{
+	int status;
+	unsigned char cmd, option;
+
+	do {
+		status = read(0, &cmd, 1);
+		if (status <= 0)
+			return(IAC);
+
+		if (cmd == IAC) /* escaped IAC */
+			return(IAC);
+
+		status = read(0, &option, 1);
+		if (status <= 0) {
+			put_char(IAC);
+			return(cmd);
+		}
+
+		switch (cmd) {
+		case WILL:
+			put_char(IAC);
+			put_char(DONT);
+			put_char(option);
+			break;
+		case WONT:
+			break;
+		case DO:
+			put_char(IAC);
+			put_char(WONT);
+			put_char(option);
+			break;
+		case DONT:
+			break;
+		default:
+			put_char(IAC);
+			put_char(cmd);
+			return(option);
+		}
+
+		/*
+		 * get next char
+		 */
+		status = read(0, cp, 1);
+		if (status <= 0)
+			return(-1);
+	} while (*cp == IAC);
+
+	return(*cp);
+}
+
+#endif /* ENABLE_NETWORK_SUPPORT */
diff --git a/configure b/configure
index 6a55e0f..2f09e67 100755
--- a/configure
+++ b/configure
@@ -195,7 +195,7 @@ if [ -d "$ksrc" ]; then
     mkmkf $ksrc/Makedefs$compiletype Makedefs.com
     for dir in pppd pppstats chat pppdump pppd/plugins pppd/plugins/rp-pppoe \
 	       pppd/plugins/radius pppd/plugins/pppoatm \
-	       pppd/plugins/pppol2tp; do
+	       pppd/plugins/pppol2tp pppd/plugins/pptp ; do
 	mkmkf $dir/Makefile.$makext $dir/Makefile
     done
     if [ -f $ksrc/Makefile.$makext$archvariant ]; then
diff --git a/linux/Makefile.top b/linux/Makefile.top
index f63d45e..ad08aab 100644
--- a/linux/Makefile.top
+++ b/linux/Makefile.top
@@ -6,6 +6,17 @@ INCDIR = $(DESTDIR)/include
 MANDIR = $(DESTDIR)/share/man
 ETCDIR = $(INSTROOT)@SYSCONF@/ppp
 
+FLTFLAGS += -s 8192
+
+ifeq ($(CONFIG_USER_FLATFSD_FLATFSD),y)
+ifeq ($(CONFIG_USER_FLATFSD_ETC_CONFIG),y)
+CFLAGS += -DPATH_CONFIG='"/etc/config"'
+endif
+CFLAGS += -DPATH_AUTH='"/bin"'
+CFLAGS += -DPATH_LOG='"/var/log"'
+CFLAGS += -DPATH_RESOLV='"/var/run"'
+endif
+
 # uid 0 = root
 INSTALL= install
 
diff --git a/pppd/Makefile.linux b/pppd/Makefile.linux
index a74c914..a962e1d 100644
--- a/pppd/Makefile.linux
+++ b/pppd/Makefile.linux
@@ -30,25 +30,24 @@ ifeq (.depend,$(wildcard .depend))
 include .depend
 endif
 
-# CC = gcc
-#
-COPTS = -O2 -pipe -Wall -g
-LIBS =
-
 # Uncomment the next 2 lines to include support for Microsoft's
 # MS-CHAP authentication protocol.  Also, edit plugins/radius/Makefile.linux.
 CHAPMS=y
 USE_CRYPT=y
+
 # Don't use MSLANMAN unless you really know what you're doing.
 #MSLANMAN=y
+
 # Uncomment the next line to include support for MPPE.  CHAPMS (above) must
 # also be enabled.  Also, edit plugins/radius/Makefile.linux.
+ifeq ($(CONFIG_USER_PPPD_WITH_MPPE),y)
 MPPE=y
+endif
 
 # Uncomment the next line to include support for PPP packet filtering.
 # This requires that the libpcap library and headers be installed
 # and that the kernel driver support PPP packet filtering.
-FILTER=y
+#FILTER=y
 
 # Uncomment the next line to enable multilink PPP (enabled by default)
 # Linux distributions: Please leave multilink ENABLED in your builds
@@ -60,13 +59,29 @@ HAVE_MULTILINK=y
 # Linux distributions: Please leave TDB ENABLED in your builds.
 USE_TDB=y
 
+ifneq ($(CONFIG_USER_SHADOW_UTILS)$(USER_BUSYBOX_USE_BB_SHADOW),)
 HAS_SHADOW=y
-#USE_PAM=y
+endif
+
+ifeq ($(CONFIG_USER_PPPD_WITH_PAM),y)
+USE_PAM=y
+endif
+
+ifeq ($(CONFIG_PROP_STATSD_STATSD),y)
+USE_EXTERNAL_STATS_PROG=y
+endif
+
+ifeq ($(CONFIG_USER_PPPD_WITH_IPV6),y)
 HAVE_INET6=y
+endif
 
 # Enable plugins
 PLUGIN=y
 
+ifeq ($(CONFIG_USER_PPPD_WITH_DYNAMIC_PLUGINS),y)
+DYNAMIC_PLUGIN=y
+endif
+
 # Enable Microsoft proprietary Callback Control Protocol
 #CBCP=y
 
@@ -74,15 +89,15 @@
 #USE_SRP=y
 
 # Use libutil
+ifneq ($(CONFIG_DEFAULTS_LIBC_MUSL),y)
 USE_LIBUTIL=y
+endif
 
 MAXOCTETS=y
 
 INCLUDE_DIRS= -I../include
-
 COMPILE_FLAGS= -DHAVE_PATHS_H -DIPX_CHANGE -DHAVE_MMAP
-
-CFLAGS= $(COPTS) $(COMPILE_FLAGS) $(INCLUDE_DIRS) '-DDESTDIR="@DESTDIR@"'
+CFLAGS+= $(COPTS) $(COMPILE_FLAGS) $(INCLUDE_DIRS) '-DDESTDIR="@DESTDIR@"'
 
 ifdef CHAPMS
 CFLAGS   += -DCHAPMS=1
@@ -97,10 +110,15 @@ CFLAGS   += -DMPPE=1
 endif
 endif
 
+ifeq ($(findstring glibc,$(LIBCDIR)),glibc)
+LIBS += -lresolv
+endif
+
 # EAP SRP-SHA1
 ifdef USE_SRP
 CFLAGS	+= -DUSE_SRP -DOPENSSL -I/usr/local/ssl/include
-LIBS	+= -lsrp -L/usr/local/ssl/lib -lcrypto
+#LIBS	+= -lsrp -L/usr/local/ssl/lib -lcrypto
+LIBS	+= -lsrp -lcrypto
 TARGETS	+= srp-entry
 EXTRAINSTALL = $(INSTALL) -s -c -m 555 srp-entry $(BINDIR)/srp-entry
 MANPAGES += srp-entry.8
@@ -143,7 +161,11 @@ endif
 # For "Pluggable Authentication Modules", see ftp.redhat.com:/pub/pam/.
 ifdef USE_PAM
 CFLAGS   += -DUSE_PAM
-LIBS     += -lpam -ldl
+LIBS     += -lpam
+endif
+
+ifdef USE_EXTERNAL_STATS_PROG
+CFLAGS   += -DUSE_EXTERNAL_STATS_PROG
 endif
 
 # Multi-linnk
@@ -172,8 +194,52 @@ endif
 
 ifdef PLUGIN
 CFLAGS	+= -DPLUGIN
+ifdef DYNAMIC_PLUGIN
+CFLAGS	+= -DPLUGIN_DYNAMIC
 LDFLAGS	+= -Wl,-E
 LIBS	+= -ldl
+else
+ifeq ($(CONFIG_USER_PPPD_WITH_TACACS),y)
+PLUGINOBJS += plugins/tacacs.o plugins/tacc/lib/libtac.a
+CFLAGS += -DPLUGIN_TACACS
+endif
+ifeq ($(CONFIG_USER_PPPD_WITH_RADIUS),y)
+PLUGINOBJS += plugins/radius/libradius.o
+CFLAGS += -DPLUGIN_RADIUS
+endif
+ifeq ($(CONFIG_USER_PPPD_WITH_PPPOA),y)
+PLUGINOBJS += plugins/pppoatm/libpppoatm.o
+CFLAGS += -DPLUGIN_PPPOA
+endif
+ifeq ($(CONFIG_USER_PPPD_WITH_PPPOE),y)
+PLUGINOBJS += plugins/rp-pppoe/libpppoe.o
+CFLAGS += -DPLUGIN_PPPOE
+endif
+ifeq ($(CONFIG_USER_PPPD_WITH_PPPPPOL2TP),y)
+PLUGINOBJS += plugins/pppol2tp/libpppol2tp.o
+CFLAGS += -DPLUGIN_PPPOL2TP
+endif
+ifeq ($(CONFIG_USER_PPPD_WITH_PPTP),y)
+PLUGINOBJS += plugins/pptp/libpptp.o
+CFLAGS += -DPLUGIN_PPTP
+endif
+ifeq ($(CONFIG_USER_PPPD_WITH_MINCONN),y)
+PLUGINOBJS += plugins/minconn.o
+CFLAGS += -DPLUGIN_MINCONN
+endif
+ifeq ($(CONFIG_USER_PPPD_WITH_PASSPROMPT),y)
+PLUGINOBJS += plugins/passprompt.o
+CFLAGS += -DPLUGIN_PASSPROMPT
+endif
+ifeq ($(CONFIG_USER_PPPD_WITH_PASSWORDFD),y)
+PLUGINOBJS += plugins/passwordfd.o
+CFLAGS += -DPLUGIN_PASSWORDFD
+endif
+ifeq ($(CONFIG_USER_PPPD_WITH_WINBIND),y)
+PLUGINOBJS += plugins/winbind.o
+CFLAGS += -DPLUGIN_WINBIND
+endif
+endif
 endif
 
 ifdef FILTER
@@ -200,6 +266,11 @@ endif
 ifdef MAXOCTETS
      CFLAGS += -DMAXOCTETS
 endif
+ifdef CONFIG_DEFAULTS_LIBC_UC_LIBC
+        CFLAGS += -DNO_DRAND48
+else
+        CFLAGS += -DUSE_LASTLOG
+endif
 
 INSTALL= install
 
@@ -214,10 +285,10 @@ install: pppd
 	$(INSTALL) -c -m 444 pppd.8 $(MANDIR)
 
 pppd: $(PPPDOBJS)
-	$(CC) $(CFLAGS) $(LDFLAGS) -o pppd $(PPPDOBJS) $(LIBS)
+	$(CC) $(CFLAGS) $(LDFLAGS) -o pppd $(PPPDOBJS) $(PLUGINOBJS) $(LIBS) $(LDLIBS$(LDLIBS_$@))
 
 srp-entry:	srp-entry.c
-	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ srp-entry.c $(LIBS)
+	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ srp-entry.c $(LIBS) $(LDLIBS$(LDLIBS_$@))
 
 install-devel:
 	mkdir -p $(INCDIR)/pppd
diff --git a/pppd/auth.c b/pppd/auth.c
index 4271af6..e8ab269 100644
--- a/pppd/auth.c
+++ b/pppd/auth.c
@@ -83,7 +83,7 @@
 #include <sys/socket.h>
 #include <utmp.h>
 #include <fcntl.h>
-#if defined(_PATH_LASTLOG) && defined(__linux__)
+#if defined(USE_LASTLOG) && defined(_PATH_LASTLOG) && defined(__linux__)
 #include <lastlog.h>
 #endif
 
@@ -132,6 +132,9 @@ static int auth_pending[NUM_PPP];
 /* Records which authentication operations have been completed. */
 int auth_done[NUM_PPP];
 
+/* Set if we have successfully called plogin() */
+static int logged_in;
+
 /* List of addresses which the peer may use. */
 static struct permitted_ip *addresses[NUM_PPP];
 
@@ -238,6 +241,15 @@ bool explicit_remote = 0;	/* User specified explicit remote name */
 bool explicit_user = 0;		/* Set if "user" option supplied */
 bool explicit_passwd = 0;	/* Set if "password" option supplied */
 char remote_name[MAXNAMELEN];	/* Peer's name for authentication */
+#if USE_PAM
+bool explicit_pamservice = 0;	/* User specified explicit PAM service */
+char pamservice[MAXNAMELEN];	/* Service for pam_start() */
+bool obey_restrictions = 0; 	/* Obey PAM account restrictions */
+#endif
+const char *auth_group = NULL;	/* If our authentication source can provide us
+				   				   with a group, put it here */
+bool external_auth = 0;		/* If we're using an external authenticator (radius, tacas, etc)
+				   set this flag */
 
 static char *uafname;		/* name of most recent +ua file */
 
@@ -401,6 +413,13 @@ option_t auth_options[] = {
       "Set telephone number(s) which are allowed to connect",
       OPT_PRIV | OPT_A2LIST },
 
+#ifdef USE_PAM
+    { "pamservice", o_string, pamservice,
+      "Set PAM service for authentication", OPT_PRIO | OPT_STATIC,
+      &explicit_pamservice, MAXNAMELEN },
+    { "obey_acct_restrict", o_bool, &obey_restrictions,
+      "Obey any PAM account restrictions for an authed user", 1},
+#endif
     { NULL }
 };
 
@@ -922,6 +941,11 @@ auth_peer_fail(unit, protocol)
      * Authentication failure: take the link down
      */
     status = EXIT_PEER_AUTH_FAILED;
+    if (auth_group) {
+		free(auth_group);
+		auth_group = NULL;
+    }
+
     lcp_close(unit, "Authentication failed");
 }
 
@@ -982,6 +1006,11 @@ auth_peer_success(unit, protocol, prot_flavor, name, namelen)
      */
     if ((auth_pending[unit] &= ~bit) == 0)
         network_phase(unit);
+
+    if (auth_group) {
+		free(auth_group);
+		auth_group = NULL;
+    }
 }
 
 /*
@@ -1341,6 +1370,7 @@ auth_reset(unit)
 			      our_name, 1, NULL)))
 	    go->neg_chap = 0;
     }
+
     if (go->neg_eap &&
 	(hadchap == 0 || (hadchap == -1 &&
 	    !have_chap_secret((explicit_remote? remote_name: NULL), our_name,
@@ -1484,6 +1514,235 @@ check_passwd(unit, auser, userlen, apasswd, passwdlen, msg)
     return ret;
 }
 
+/*
+ * This function is needed for PAM.
+ */
+
+#ifdef USE_PAM
+#include <security/pam_appl.h>
+
+/* Static variables used to communicate between the conversation function
+ * and the server_login function 
+ */
+static char *PAM_username;
+static char *PAM_password;
+static int PAM_error = 0;
+static pam_handle_t *pamh = NULL;
+
+/* PAM conversation function
+ * Here we assume (for now, at least) that echo on means login name, and
+ * echo off means password.
+ */
+
+static int PAM_conv (int num_msg,
+#ifndef SOL2
+    const
+#endif
+    struct pam_message **msg,
+    struct pam_response **resp, void *appdata_ptr)
+{
+    int replies = 0;
+    struct pam_response *reply = NULL;
+
+#define COPY_STRING(s) (s) ? strdup(s) : NULL
+
+    reply = malloc(sizeof(struct pam_response) * num_msg);
+    if (!reply) return PAM_CONV_ERR;
+
+    for (replies = 0; replies < num_msg; replies++) {
+        switch (msg[replies]->msg_style) {
+            case PAM_PROMPT_ECHO_ON:
+                reply[replies].resp_retcode = PAM_SUCCESS;
+                reply[replies].resp = COPY_STRING(PAM_username);
+                /* PAM frees resp */
+                break;
+            case PAM_PROMPT_ECHO_OFF:
+                reply[replies].resp_retcode = PAM_SUCCESS;
+                reply[replies].resp = COPY_STRING(PAM_password);
+                /* PAM frees resp */
+                break;
+            case PAM_TEXT_INFO:
+                /* fall through */
+            case PAM_ERROR_MSG:
+                /* ignore it, but pam still wants a NULL response... */
+                reply[replies].resp_retcode = PAM_SUCCESS;
+                reply[replies].resp = NULL;
+                break;
+            default:       
+                /* Must be an error of some sort... */
+                free (reply);
+                PAM_error = 1;
+                return PAM_CONV_ERR;
+        }
+    }
+    *resp = reply;     
+    return PAM_SUCCESS;
+}
+
+static struct pam_conv PAM_conversation = {
+    &PAM_conv,
+    NULL
+};
+#endif  /* USE_PAM */
+
+/*
+ * plogin - Check the user name and password against the system
+ * password database, and login the user if OK.
+ *
+ * returns:
+ *	UPAP_AUTHNAK: Login failed.
+ *	UPAP_AUTHACK: Login succeeded.
+ * In either case, msg points to an appropriate message.
+ */
+
+static int
+plogin(user, passwd, msg)
+    char *user;
+    char *passwd;
+    char **msg;
+{
+    char *tty;
+
+#ifdef USE_PAM
+    int pam_error;
+
+    pam_error = pam_start (explicit_pamservice ? pamservice : "ppp",
+			   user, &PAM_conversation, &pamh);
+    if (pam_error != PAM_SUCCESS) {
+        *msg = (char *) pam_strerror (pamh, pam_error);
+	reopen_log();
+	return UPAP_AUTHNAK;
+    }
+    /*
+     * Define the fields for the credential validation
+     */
+     
+    PAM_username = user;
+    PAM_password = passwd;
+    PAM_error = 0;
+    pam_set_item (pamh, PAM_TTY, devnam); /* this might be useful to some modules */
+
+    /*
+     * Validate the user
+     */
+    pam_error = pam_authenticate (pamh, PAM_SILENT);
+    if (pam_error == PAM_SUCCESS && !PAM_error) {    
+        pam_error = pam_acct_mgmt (pamh, PAM_SILENT);
+        if (pam_error == PAM_SUCCESS)
+	    pam_error = pam_open_session (pamh, PAM_SILENT);
+    }
+
+    *msg = (char *) pam_strerror (pamh, pam_error);
+
+    /*
+     * Clean up the mess
+     */
+    reopen_log();	/* apparently the PAM stuff does closelog() */
+    PAM_username = NULL;
+    PAM_password = NULL;
+    if (pam_error != PAM_SUCCESS)
+        return UPAP_AUTHNAK;
+#else /* #ifdef USE_PAM */
+
+/*
+ * Use the non-PAM methods directly
+ */
+
+#ifdef HAS_SHADOW
+    struct spwd *spwd;
+    struct spwd *getspnam();
+#endif
+    struct passwd *pw = getpwnam(user);
+
+    endpwent();
+    if (pw == NULL)
+	return (UPAP_AUTHNAK);
+
+#ifdef HAS_SHADOW
+    spwd = getspnam(user);
+    endspent();
+    if (spwd) {
+	/* check the age of the password entry */
+	long now = time(NULL) / 86400L;
+
+	if ((spwd->sp_expire > 0 && now >= spwd->sp_expire)
+	    || ((spwd->sp_max >= 0 && spwd->sp_max < 10000)
+		&& spwd->sp_lstchg >= 0
+		&& now >= spwd->sp_lstchg + spwd->sp_max)) {
+	    warn("Password for %s has expired", user);
+	    return (UPAP_AUTHNAK);
+	}
+	pw->pw_passwd = spwd->sp_pwdp;
+    }
+#endif
+
+    /*
+     * If no passwd, don't let them login.
+     */
+    if (pw->pw_passwd == NULL || strlen(pw->pw_passwd) < 2
+	|| strcmp(crypt(passwd, pw->pw_passwd), pw->pw_passwd) != 0)
+	return (UPAP_AUTHNAK);
+
+#endif /* #ifdef USE_PAM */
+
+    /*
+     * Write a wtmp entry for this user.
+     */
+
+    tty = devnam;
+    if (strncmp(tty, "/dev/", 5) == 0)
+	tty += 5;
+    logwtmp(tty, user, ifname);		/* Add wtmp login entry */
+
+#if defined(USE_LASTLOG) && defined(_PATH_LASTLOG) && !defined(USE_PAM)
+    if (pw != (struct passwd *)NULL) {
+	    struct lastlog ll;
+	    int fd;
+
+	    if ((fd = open(_PATH_LASTLOG, O_RDWR, 0)) >= 0) {
+		(void)lseek(fd, (off_t)(pw->pw_uid * sizeof(ll)), SEEK_SET);
+		memset((void *)&ll, 0, sizeof(ll));
+		(void)time(&ll.ll_time);
+		(void)strncpy(ll.ll_line, tty, sizeof(ll.ll_line));
+		(void)write(fd, (char *)&ll, sizeof(ll));
+		(void)close(fd);
+	    }
+    }
+#endif /* USE_LASTLOG and _PATH_LASTLOG and not USE_PAM */
+
+    info("user %s logged in", user);
+    logged_in = 1;
+
+    return (UPAP_AUTHACK);
+}
+
+/*
+ * plogout - Logout the user.
+ */
+static void
+plogout()
+{
+    char *tty;
+#ifdef USE_PAM
+    int pam_error;
+
+    if (pamh != NULL) {
+	pam_error = pam_close_session (pamh, PAM_SILENT);
+	pam_end (pamh, pam_error);
+	pamh = NULL;
+    }
+    /* Apparently the pam stuff does closelog(). */
+    reopen_log();
+#endif /* USE_PAM */
+
+    tty = devnam;
+    if (strncmp(tty, "/dev/", 5) == 0)
+	tty += 5;
+    logwtmp(tty, "", "");		/* Wipe out utmp logout entry */
+    logged_in = 0;
+}
+
+
 /*
  * null_login - Check if a username of "" and a password of "" are
  * acceptable, and iff so, set the list of acceptable IP addresses
@@ -2355,7 +2614,76 @@ auth_script(script)
     argv[3] = user_name;
     argv[4] = devnam;
     argv[5] = strspeed;
-    argv[6] = NULL;
+    argv[6] = ipparam;
+    argv[7] = NULL;
 
     auth_script_pid = run_program(script, argv, 0, auth_script_done, NULL, 0);
 }
+
+#ifdef USE_PAM
+/* check_pam_account_restrictions - check if the authenticated user account is valid.
+   This is useful when doing CHAPpy things, which don't support PAM as an authentication
+   mechanism. It means we still obey PAM's account restrictions
+ */
+int check_pam_account_restrictions(const char *user) {
+	int pam_error;
+	pam_handle_t *loc_handle;
+
+	if (obey_restrictions) {
+		const char *username;
+
+		/* We should remove the domain first */
+		if ((username = strrchr(user, '\\')) != NULL)
+			++username;
+		else
+            username = user;
+		
+		pam_error = pam_start(explicit_pamservice ? pamservice : "ppp", username, &PAM_conversation, &loc_handle);
+
+		if (pam_error != PAM_SUCCESS) {
+			return 1;
+		}
+		/* If we have an authentication group, send it */
+		if (auth_group != NULL) {
+			char buf[128];
+			snprintf(buf, 128, "SG-GROUP=%s", auth_group);
+			pam_putenv(loc_handle, buf);
+		}
+		/* Call the account management function */
+		pam_error = pam_acct_mgmt(loc_handle, 0);	
+		pam_end(loc_handle, 0);
+
+		if (pam_error != PAM_SUCCESS)
+			return 1;
+	}
+
+	return 0;
+}
+#endif /* USE_PAM */
+
+#ifdef USE_EXTERNAL_STATS_PROG
+void notify_login_failure(const char *user) {
+	char buf[500];
+        snprintf(buf, 500-1,
+        	"statsd -a incr pam_failed_%s %s \\;"
+                " push pam_last_failure_%s %s \"Permission Denied\" 0 \\;"
+                " incr pam_users %s \\; incr pam_services %s",
+                        user,
+                        explicit_pamservice ? pamservice : "ppp",
+                        user,
+			explicit_pamservice ? pamservice : "ppp",
+			user,
+			explicit_pamservice ? pamservice : "ppp");
+        if (system(buf) == -1) {
+            warn("%s - failed", buf);
+        }
+
+	if (!external_auth) {
+		/* Do the same for pcidssd */
+		snprintf(buf, 500-1, "pcidssd -f %s", user);
+		if (system(buf) == -1) {
+			warn("%s - failed", buf);
+		}
+	}          
+}
+#endif 
diff --git a/pppd/chap-new.c b/pppd/chap-new.c
index 2714bff..e7719fc 100644
--- a/pppd/chap-new.c
+++ b/pppd/chap-new.c
@@ -349,6 +349,20 @@ chap_handle_response(struct chap_server_state *ss, int id,
 			ss->flags |= AUTH_FAILED;
 			warn("Peer %q failed CHAP authentication", name);
 		}
+#ifdef USE_PAM
+		if (!(ss->flags & AUTH_FAILED)) {
+			if (check_pam_account_restrictions(name)) {
+				ss->flags |= AUTH_FAILED;
+				warn("Peer %q failed PAM Account provisions", name);
+			}
+		}
+#endif 
+
+#ifdef USE_EXTERNAL_STATS_PROG
+		if (ss->flags & AUTH_FAILED) {
+			notify_login_failure(name);
+		}
+#endif
 	} else if ((ss->flags & AUTH_DONE) == 0)
 		return;
 
diff --git a/pppd/ipcp.c b/pppd/ipcp.c
index e9738fe..2bf755b 100644
--- a/pppd/ipcp.c
+++ b/pppd/ipcp.c
@@ -50,11 +50,13 @@
 #include <string.h>
 #include <stdlib.h>
 #include <netdb.h>
+#include <syslog.h>
 #include <sys/param.h>
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <netinet/in.h>
 #include <arpa/inet.h>
+#include <sys/stat.h>
 
 #include "pppd.h"
 #include "fsm.h"
@@ -169,6 +171,11 @@ static option_t ipcp_option_list[] = {
     { "ipcp-accept-remote", o_bool, &ipcp_wantoptions[0].accept_remote,
       "Accept peer's address for it", 1 },
 
+    { "ip-up", o_string, &ip_up,
+      "Set ip-up script name", OPT_PRIV },
+    { "ip-down", o_string, &ip_down,
+      "Set ip-down script name", OPT_PRIV },
+
     { "ipparam", o_string, &ipparam,
       "Set ip script parameter", OPT_PRIO },
 
@@ -198,6 +205,12 @@ static option_t ipcp_option_list[] = {
       "disable defaultroute option", OPT_ALIAS | OPT_A2CLR,
       &ipcp_wantoptions[0].default_route },
 
+    { "forcedefaultroute", o_bool, &ipcp_wantoptions[0].force_default_route,
+      "Always add default route", OPT_ENABLE|1, &ipcp_allowoptions[0].force_default_route },
+    { "noforcedefaultroute", o_bool, &ipcp_allowoptions[0].force_default_route,
+      "disable forcedefaultroute option", OPT_A2CLR,
+      &ipcp_wantoptions[0].force_default_route },
+
     { "proxyarp", o_bool, &ipcp_wantoptions[0].proxy_arp,
       "Add proxy ARP entry", OPT_ENABLE|1, &ipcp_allowoptions[0].proxy_arp },
     { "noproxyarp", o_bool, &ipcp_allowoptions[0].proxy_arp,
@@ -272,6 +285,8 @@ struct protent ipcp_protent = {
 };
 
 static void ipcp_clear_addrs __P((int, u_int32_t, u_int32_t));
+static void ipcp_script_up __P((void));
+static void ipcp_script_down __P((void));
 static void ipcp_script __P((char *, int));	/* Run an up/down script */
 static void ipcp_script_done __P((void *));
 
@@ -608,6 +623,7 @@ ipcp_init(unit)
      */
     ao->proxy_arp = 1;
     ao->default_route = 1;
+    ao->force_default_route = 1;
 }
 
 
@@ -1758,10 +1774,13 @@ ip_demand_conf(u)
     ipcp_script(_PATH_IPPREUP, 1);
     if (!sifup(u))
 	return 0;
+
+    rtmetricfixup(u, wo->hisaddr, metric);
+
     if (!sifnpmode(u, PPP_IP, NPMODE_QUEUE))
 	return 0;
     if (wo->default_route)
-	if (sifdefaultroute(u, wo->ouraddr, wo->hisaddr))
+	if (sifdefaultroute(u, wo->ouraddr, wo->hisaddr, drmetric, wo->force_default_route))
 	    default_route_set[u] = 1;
     if (wo->proxy_arp)
 	if (sifproxyarp(u, wo->hisaddr))
@@ -1872,9 +1891,11 @@ ipcp_up(f)
 		return;
 	    }
 
+	    rtmetricfixup(f->unit, ho->hisaddr, metric);
+
 	    /* assign a default route through the interface if required */
 	    if (ipcp_wantoptions[f->unit].default_route) 
-		if (sifdefaultroute(f->unit, go->ouraddr, ho->hisaddr))
+		if (sifdefaultroute(f->unit, go->ouraddr, ho->hisaddr, drmetric, ipcp_wantoptions[f->unit].force_default_route))
 		    default_route_set[f->unit] = 1;
 
 	    /* Make a proxy ARP entry if requested. */
@@ -1920,11 +1941,12 @@ ipcp_up(f)
 	    return;
 	}
 #endif
+	rtmetricfixup(f->unit, ho->hisaddr, metric);
 	sifnpmode(f->unit, PPP_IP, NPMODE_PASS);
 
 	/* assign a default route through the interface if required */
 	if (ipcp_wantoptions[f->unit].default_route) 
-	    if (sifdefaultroute(f->unit, go->ouraddr, ho->hisaddr))
+	    if (sifdefaultroute(f->unit, go->ouraddr, ho->hisaddr, drmetric, ipcp_wantoptions[f->unit].force_default_route))
 		default_route_set[f->unit] = 1;
 
 	/* Make a proxy ARP entry if requested. */
@@ -1958,7 +1980,7 @@ ipcp_up(f)
      */
     if (ipcp_script_state == s_down && ipcp_script_pid == 0) {
 	ipcp_script_state = s_up;
-	ipcp_script(_PATH_IPUP, 0);
+	ipcp_script_up();
     }
 }
 
@@ -2008,7 +2030,7 @@ ipcp_down(f)
     /* Execute the ip-down script */
     if (ipcp_script_state == s_up && ipcp_script_pid == 0) {
 	ipcp_script_state = s_down;
-	ipcp_script(_PATH_IPDOWN, 0);
+	ipcp_script_down();
     }
 }
 
@@ -2049,6 +2071,44 @@ ipcp_finished(f)
 }
 
 
+static void
+ipcp_script_up()
+{
+#ifdef PATH_ETC_CONFIG
+    if (ip_up)
+	ipcp_script(ip_up, 0);
+    else {
+	struct stat st;
+	if (stat(_PATH_IPUP, &st) == 0 && (st.st_mode & S_IXUSR))
+	    ipcp_script(_PATH_IPUP, 0);
+	else
+	    ipcp_script(_PATH_DEFAULT_IPUP, 0);
+    }       
+#else
+    ipcp_script(ip_up ? ip_up : _PATH_IPUP, 0);
+#endif
+}
+
+
+static void
+ipcp_script_down()
+{
+#ifdef PATH_ETC_CONFIG
+    if (ip_down)
+	ipcp_script(ip_down, 0);
+    else {
+	struct stat st;
+	if (stat(_PATH_IPDOWN, &st) == 0 && (st.st_mode & S_IXUSR))
+	    ipcp_script(_PATH_IPDOWN, 0);
+	else
+	    ipcp_script(_PATH_DEFAULT_IPDOWN, 0);
+    }       
+#else
+    ipcp_script(ip_down ? ip_down : _PATH_IPDOWN, 0);
+#endif
+}
+
+
 /*
  * ipcp_script_done - called when the ip-up or ip-down script
  * has finished.
@@ -2114,21 +2174,26 @@ create_resolv(peerdns1, peerdns2)
     u_int32_t peerdns1, peerdns2;
 {
     FILE *f;
+    char pathname[MAXPATHLEN];
 
-    f = fopen(_PATH_RESOLV, "w");
+    slprintf(pathname, sizeof(pathname), _PATH_RESOLV, ifname);
+
+    f = fopen(pathname, "w");
     if (f == NULL) {
-	error("Failed to create %s: %m", _PATH_RESOLV);
+	error("Failed to create %s: %m", pathname);
 	return;
     }
 
-    if (peerdns1)
+    if (peerdns1) {
+	syslog(LOG_INFO, "Adding resolv.conf for %s",ip_ntoa(peerdns1));
 	fprintf(f, "nameserver %s\n", ip_ntoa(peerdns1));
+    }
 
     if (peerdns2)
 	fprintf(f, "nameserver %s\n", ip_ntoa(peerdns2));
 
     if (ferror(f))
-	error("Write failed to %s: %m", _PATH_RESOLV);
+	error("Write failed to %s: %m", pathname);
 
     fclose(f);
 }
diff --git a/pppd/ipcp.h b/pppd/ipcp.h
index 6cf14c9..840e0db 100644
--- a/pppd/ipcp.h
+++ b/pppd/ipcp.h
@@ -70,6 +70,7 @@ typedef struct ipcp_options {
     bool old_addrs;		/* Use old (IP-Addresses) option? */
     bool req_addr;		/* Ask peer to send IP address? */
     bool default_route;		/* Assign default route through interface? */
+    bool force_default_route;	/* Don't check for existing default route */
     bool proxy_arp;		/* Make proxy ARP entry for peer? */
     bool neg_vj;		/* Van Jacobson Compression? */
     bool old_vj;		/* use old (short) form of VJ option? */
diff --git a/pppd/lcp.c b/pppd/lcp.c
index 8ed2778..148d27c 100644
--- a/pppd/lcp.c
+++ b/pppd/lcp.c
@@ -1898,6 +1898,7 @@ lcp_up(f)
     lcp_options *ho = &lcp_hisoptions[f->unit];
     lcp_options *go = &lcp_gotoptions[f->unit];
     lcp_options *ao = &lcp_allowoptions[f->unit];
+    char mtu_str[8];
     int mtu, mru;
 
     if (!go->neg_magicnumber)
@@ -1920,6 +1921,8 @@ lcp_up(f)
     if (!(multilink && go->neg_mrru && ho->neg_mrru))
 #endif /* HAVE_MULTILINK */
 	netif_set_mtu(f->unit, MIN(MIN(mtu, mru), ao->mru));
+    snprintf(mtu_str, sizeof(mtu_str), "%d", MIN(MIN(mtu, mru), ao->mru));
+    script_setenv("MTU", mtu_str, 0);
     ppp_send_config(f->unit, mtu,
 		    (ho->neg_asyncmap? ho->asyncmap: 0xffffffff),
 		    ho->neg_pcompression, ho->neg_accompression);
diff --git a/pppd/magic.h b/pppd/magic.h
index c81213b..0e4c4f9 100644
--- a/pppd/magic.h
+++ b/pppd/magic.h
@@ -42,6 +42,10 @@
  * $Id: magic.h,v 1.5 2003/06/11 23:56:26 paulus Exp $
  */
 
+#ifndef __P
+#define __P(args)       args
+#endif
+
 void magic_init __P((void));	/* Initialize the magic number generator */
 u_int32_t magic __P((void));	/* Returns the next magic number */
 
diff --git a/pppd/main.c b/pppd/main.c
index 6d50d1b..65c307b 100644
--- a/pppd/main.c
+++ b/pppd/main.c
@@ -196,7 +196,12 @@ int privopen;			/* don't lock, open device as root */
 
 char *no_ppp_msg = "Sorry - this system lacks PPP kernel support\n";
 
-GIDSET_TYPE groups[NGROUPS_MAX];/* groups the user is in */
+#ifdef __uClinux__
+#define MAXGROUPS 16		/* Save a lot of bss RAM space */
+#else
+#define MAXGROUPS NGROUPS_MAX
+#endif
+GIDSET_TYPE groups[MAXGROUPS];	/* groups the user is in */
 int ngroups;			/* How many groups valid in groups */
 
 static struct timeval start_time;	/* Time when link was started. */
@@ -338,7 +343,7 @@ main(argc, argv)
     slprintf(numbuf, sizeof(numbuf), "%d", uid);
     script_setenv("ORIG_UID", numbuf, 0);
 
-    ngroups = getgroups(NGROUPS_MAX, groups);
+    ngroups = getgroups(MAXGROUPS, groups);
 
     /*
      * Initialize magic number generator now so that protocols may
@@ -760,6 +765,7 @@ detach()
 	return;
     if (pipe(pipefd) == -1)
 	pipefd[0] = pipefd[1] = -1;
+#ifndef __uClinux__
     if ((pid = fork()) < 0) {
 	error("Couldn't detach (fork failed: %m)");
 	die(1);			/* or just return? */
@@ -774,6 +780,7 @@ detach()
 	    create_linkpidfile(pid);
 	exit(0);		/* parent dies */
     }
+#endif /* __uClinux__ */
     setsid();
     chdir("/");
     dup2(fd_devnull, 0);
@@ -810,10 +817,18 @@ create_pidfile(pid)
 {
     FILE *pidfile;
 
-    slprintf(pidfilename, sizeof(pidfilename), "%s%s.pid",
-	     _PATH_VARRUN, ifname);
+    if (pid_file[0])
+	slprintf(pidfilename, sizeof(pidfilename), "%s%s",
+			pid_file[0] == '/' ? "" : _PATH_VARRUN,
+			pid_file);
+    else
+	slprintf(pidfilename, sizeof(pidfilename), "%s%s.pid",
+			_PATH_VARRUN, ifname);
+
     if ((pidfile = fopen(pidfilename, "w")) != NULL) {
 	fprintf(pidfile, "%d\n", pid);
+	if (ipparam)
+	    fprintf(pidfile, "%s\n", ipparam);
 	(void) fclose(pidfile);
     } else {
 	error("Failed to create pid file %s: %m", pidfilename);
@@ -1530,6 +1545,279 @@ bad_signal(sig)
     die(127);
 }
 
+static bool
+add_script_env(pos, newstring)
+    int pos;
+    char *newstring;
+{
+    if (pos + 1 >= s_env_nalloc) {
+	int new_n = pos + 17;
+	char **newenv = realloc(script_env, new_n * sizeof(char *));
+	if (newenv == NULL) {
+	    free(newstring - 1);
+	    return 0;
+	}
+	script_env = newenv;
+	s_env_nalloc = new_n;
+    }
+    script_env[pos] = newstring;
+    script_env[pos + 1] = NULL;
+    return 1;
+}
+
+static void
+remove_script_env(pos)
+    int pos;
+{
+    free(script_env[pos] - 1);
+    while ((script_env[pos] = script_env[pos + 1]) != NULL)
+	pos++;
+}
+
+#ifdef __uClinux__
+
+/*
+ * device_script - run a program to talk to the serial device
+ * (e.g. to run the connector or disconnector script).
+ */
+int
+device_script(program, in, out, dont_wait)
+    char *program;
+    int in, out;
+    int dont_wait;
+{
+    pid_t pid;
+    int status = -1;
+    int fd, errfd, pipefd[2];
+    char *argv[16], *sp;
+    int argc = 0, prevspace = 1;
+    char *prog_copy = strdup(program);
+
+    ++conn_running;
+    /* Close syslog BEFORE doing the fork since we can't do it after if we vfork() */
+    closelog();
+
+    /* make sure fds 0, 1, 2 are occupied (probably not necessary) */
+    while ((fd = dup(fd_devnull)) >= 0) {
+	if (fd > 2) {
+	    close(fd);
+	    break;
+	}
+    }
+
+    if (pipe(pipefd) == -1)
+	pipefd[0] = pipefd[1] = -1;
+
+    pid = vfork();
+
+    if (pid == 0) {
+	/* Executing in the child */
+	sys_close();
+
+	/* make sure in, out and errfd won't get tromped on below */
+	if (in == 1 || in == 2)
+		in = dup(in);
+	if (out == 0 || out == 2)
+		out = dup(out);
+	if (errfd == 0 || errfd == 1)
+		errfd = dup(errfd);
+
+	/* dup the in, out, err fds to 0, 1, 2 */
+	if (in != 0)
+		dup2(in, 0);
+	if (out != 1)
+		dup2(out, 1);
+
+	if (log_to_fd >= 0)
+	    errfd = log_to_fd;
+	else
+	    errfd = open(_PATH_CONNERRS, O_WRONLY | O_APPEND | O_CREAT, 0600);
+
+	if (errfd != 2)
+		dup2(errfd, 2);
+
+	if (log_to_fd > 2)
+		close(log_to_fd);
+	if (the_channel->close)
+		(*the_channel->close)();
+	else
+		close(devfd);	/* some plugins don't have a close function */
+	close(fd_ppp);
+	close(fd_devnull);
+	if (in != 0)
+		close(in);
+	if (out != 1)
+		close(out);
+	if (errfd != 2)
+		close(errfd);
+
+	close(pipefd[0]);
+	/* this close unblocks the read() call above in the parent */
+	close(pipefd[1]);
+
+	setuid(uid);
+	if (getuid() != uid) {
+	    error("setuid failed");
+	    exit(1);
+	}
+	setgid(getgid());
+
+	/*
+	 *	Save on memory/resources by not running a shell process
+	 *	and just running the program directly.
+	 *	We work on a copy of the program to run rather than
+	 *	change what was passed in.
+	 */
+	for (sp = prog_copy; (*sp != 0); ) {
+		if (prevspace && !isspace(*sp))
+			argv[argc++] = sp;
+		if ((prevspace = isspace(*sp)))
+			*sp = 0;
+		sp++;
+	}
+	argv[argc] = 0;
+
+	execv(argv[0], argv);
+
+	error("could not exec /bin/sh: %m");
+	exit(99);
+	/* NOTREACHED */
+    }
+
+    if (prog_copy)
+	free(prog_copy);
+    /* Reopen the log in the parent */
+    reopen_log();
+
+    if (pid < 0) {
+	--conn_running;
+	error("Failed to create child process: %m");
+	return -1;
+    }
+
+    /* parent */
+    close(pipefd[1]);
+    close(pipefd[0]);
+
+    if (dont_wait) {
+	status = 0;
+    } else {
+	while (waitpid(pid, &status, 0) < 0) {
+	    if (errno == EINTR)
+		continue;
+	    fatal("error waiting for (dis)connection process: %m");
+	}
+	--conn_running;
+    }
+
+    return (status == 0 ? 0 : -1);
+}
+
+
+/*
+ * run-program - execute a program with given arguments,
+ * but don't wait for it.
+ * If the program can't be executed, logs an error unless
+ * must_exist is 0 and the program file doesn't exist.
+ * Returns -1 if it couldn't fork, 0 if the file doesn't exist
+ * or isn't an executable plain file, or the process ID of the child.
+ * If done != NULL, (*done)(arg) will be called later (within
+ * reap_kids) iff the return value is > 0.
+ */
+pid_t
+run_program(prog, args, must_exist, done, arg, wait)
+    char *prog;
+    char **args;
+    int must_exist;
+    void (*done) __P((void *));
+    void *arg;
+    int wait;
+{
+    int pid;
+    struct stat sbuf;
+
+    /*
+     * First check if the file exists and is executable.
+     * We don't use access() because that would use the
+     * real user-id, which might not be root, and the script
+     * might be accessible only to root.
+     */
+    errno = EINVAL;
+    if (stat(prog, &sbuf) < 0 || !S_ISREG(sbuf.st_mode)
+	|| (sbuf.st_mode & (S_IXUSR|S_IXGRP|S_IXOTH)) == 0) {
+	if (must_exist || errno != ENOENT)
+	    warn("Can't execute %s: %m", prog);
+	return 0;
+    }
+
+    /* Close syslog BEFORE doing the fork since we can't do it after if we vfork() */
+    closelog();
+
+    pid = vfork();
+    if (pid == 0) {
+	int new_fd;
+
+	/* Leave the current location */
+	(void) setsid();	/* No controlling tty. */
+	(void) umask (S_IRWXG|S_IRWXO);
+	(void) chdir ("/");	/* no current directory. */
+	setuid(0);		/* set real UID = root */
+	setgid(getegid());
+
+	/* Ensure that nothing of our device environment is inherited. */
+	sys_close();
+	close (0);
+	close (1);
+	close (2);
+
+        /* Don't pass handles to the PPP device, even by accident. */
+	new_fd = open (_PATH_DEVNULL, O_RDWR);
+	if (new_fd >= 0) {
+	    if (new_fd != 0) {
+	        dup2  (new_fd, 0); /* stdin <- /dev/null */
+		close (new_fd);
+	    }
+	    dup2 (0, 1); /* stdout -> /dev/null */
+	    dup2 (0, 2); /* stderr -> /dev/null */
+	}
+
+#ifdef BSD
+	/* Force the priority back to zero if pppd is running higher. */
+	if (setpriority (PRIO_PROCESS, 0, 0) < 0)
+	    warn("can't reset priority to 0: %m"); 
+#endif
+
+	/* SysV recommends a second fork at this point. */
+
+	/* run the program */
+	execve(prog, args, script_env);
+	if (must_exist || errno != ENOENT) {
+	    /* have to reopen the log, there's nowhere else
+	       for the message to go. */
+	    reopen_log();
+	    syslog(LOG_ERR, "Can't execute %s: %m", prog);
+	    closelog();
+	}
+	_exit(-1);
+    }
+
+    /* Reopen the log in the parent */
+    reopen_log();
+
+    if (pid == -1) {
+	error("Failed to create child process for %s: %m", prog);
+	return -1;
+    }
+
+    if (debug)
+	dbglog("Script %s started (pid %d)", prog, pid);
+    record_child(pid, prog, done, arg, 0);
+
+    return pid;
+}
+
+#else
+
 /*
  * safe_fork - Create a child process.  The child closes all the
  * file descriptors that we don't want to leak to a script.
@@ -1615,35 +1903,6 @@ safe_fork(int infd, int outfd, int errfd)
 	return 0;
 }
 
-static bool
-add_script_env(pos, newstring)
-    int pos;
-    char *newstring;
-{
-    if (pos + 1 >= s_env_nalloc) {
-	int new_n = pos + 17;
-	char **newenv = realloc(script_env, new_n * sizeof(char *));
-	if (newenv == NULL) {
-	    free(newstring - 1);
-	    return 0;
-	}
-	script_env = newenv;
-	s_env_nalloc = new_n;
-    }
-    script_env[pos] = newstring;
-    script_env[pos + 1] = NULL;
-    return 1;
-}
-
-static void
-remove_script_env(pos)
-    int pos;
-{
-    free(script_env[pos] - 1);
-    while ((script_env[pos] = script_env[pos + 1]) != NULL)
-	pos++;
-}
-
 /*
  * update_system_environment - process the list of set/unset options
  * and update the system environment.
@@ -1723,7 +1982,6 @@ device_script(program, in, out, dont_wait)
     /* NOTREACHED */
 }
 
-
 /*
  * update_script_environment - process the list of set/unset options
  * and update the script environment.  Note that we intentionally do
@@ -1844,6 +2102,7 @@ run_program(prog, args, must_exist, done, arg, wait)
     _exit(99);
 }
 
+#endif /* __uClinux__ */
 
 /*
  * record_child - add a child process to the list for reap_kids
diff --git a/pppd/options.c b/pppd/options.c
index f66b765..4359863 100644
--- a/pppd/options.c
+++ b/pppd/options.c
@@ -51,7 +51,7 @@
 #include <syslog.h>
 #include <string.h>
 #include <pwd.h>
-#ifdef PLUGIN
+#ifdef PLUGIN_DYNAMIC
 #include <dlfcn.h>
 #endif
 
@@ -103,6 +103,8 @@ char	passwd[MAXSECRETLEN];	/* Password for PAP */
 bool	persist = 0;		/* Reopen link after it goes down */
 char	our_name[MAXNAMELEN];	/* Our name for authentication purposes */
 bool	demand = 0;		/* do dial-on-demand */
+char	*ip_up = NULL;		/* user defined ip-up script */
+char	*ip_down = NULL;	/* user defined ip-down script */
 char	*ipparam = NULL;	/* Extra parameter for ip up/down scripts */
 int	idle_time_limit = 0;	/* Disconnect if idle for this many seconds */
 int	holdoff = 30;		/* # seconds to pause before reconnecting */
@@ -122,6 +124,10 @@ char	*domain;		/* domain name set by domain option */
 int	child_wait = 5;		/* # seconds to wait for children at exit */
 struct userenv *userenv_list;	/* user environment variables */
 
+u_int32_t	metric = 0;	/* the metric to set the host route to */
+u_int32_t	drmetric = 0;	/* the default route metric to set */
+char	pid_file[MAXNAMELEN];	/* name of our pid file */
+
 #ifdef MAXOCTETS
 unsigned int  maxoctets = 0;    /* default - no limit */
 int maxoctets_dir = 0;       /* default - sum of traffic */
@@ -194,6 +200,14 @@ static struct option_list *extra_options = NULL;
  * Valid arguments.
  */
 option_t general_options[] = {
+    { "metric", o_uint32, &metric,
+      "Set host route metric.", 1 },
+    { "drmetric", o_uint32, &drmetric,
+      "Set default route metric.", 1 },
+    { "pidfile", o_string, pid_file,
+      "File to write PPPD pid into.",
+      OPT_PRIV | OPT_STATIC, NULL, MAXNAMELEN },
+
     { "debug", o_int, &debug,
       "Increase debugging level", OPT_INC | OPT_NOARG | 1 },
     { "-d", o_int, &debug,
@@ -1590,10 +1604,41 @@ setmodir(argv)
 #endif
 
 #ifdef PLUGIN
+
+#ifdef PLUGIN_TACACS
+extern void tacacs_plugin_init __P((void));
+#endif
+#ifdef PLUGIN_RADIUS
+extern void radius_plugin_init __P((void));
+#endif
+#ifdef PLUGIN_PPPOE
+extern void pppoe_plugin_init __P((void));
+#endif
+#ifdef PLUGIN_PPPOA
+extern void pppoa_plugin_init __P((void));
+#endif
+#ifdef PLUGIN_PPPOL2TP
+extern void pppol2tp_plugin_init __P((void));
+extern void openl2tp_plugin_init __P((void));
+#endif
+#ifdef PLUGIN_PPTP
+extern void pptp_plugin_init __P((void));
+#endif
+#ifdef PLUGIN_MINCONN
+extern void minconn_plugin_init __P((void));
+#endif
+#ifdef PLUGIN_PASSPROMPT
+extern void passprompt_plugin_init __P((void));
+#endif
+#ifdef PLUGIN_PASSWORDFD
+extern void passwordfd_plugin_init __P((void));
+#endif
+ 
 static int
 loadplugin(argv)
     char **argv;
 {
+#ifdef PLUGIN_DYNAMIC
     char *arg = *argv;
     void *handle;
     const char *err;
@@ -1642,6 +1687,83 @@ loadplugin(argv)
     if (path != arg)
 	free(path);
     return 0;
+#else
+    char *arg = *argv;
+    void (*init) __P((void));
+    char *name;
+
+    /* Just get the basename of the library since we don't care
+     * about the path when statically linked. */
+    name = strrchr(arg, '/');
+    if (name != 0) {
+        arg = name+1;
+    }
+    if (strlen(arg) > 3 && strcmp(arg+strlen(arg)-3, ".so")==0) {
+        arg[strlen(arg)-3] = '\0';
+    }
+
+#ifdef PLUGIN_TACACS
+    if (strcmp(arg, "tacacs") == 0) {
+        init = tacacs_plugin_init;
+    } else
+#endif
+#ifdef PLUGIN_RADIUS
+    if (strcmp(arg, "radius") == 0) {
+        init = radius_plugin_init;
+    } else
+#endif
+#ifdef PLUGIN_PPPOE
+    if(strcmp(arg, "rp-pppoe") == 0 || strcmp(arg, "pppoe") == 0) {
+        init = pppoe_plugin_init;
+    } else
+#endif
+#ifdef PLUGIN_PPPOA
+    if(strcmp(arg, "pppoa") == 0) {
+        init = pppoa_plugin_init;
+    } else
+#endif
+#ifdef PLUGIN_PPPOL2TP
+    if(strcmp(arg, "pppol2tp") == 0) {
+        init = pppol2tp_plugin_init;
+    } else
+    if(strcmp(arg, "openl2tp") == 0) {
+        init = openl2tp_plugin_init;
+    } else
+#endif
+#ifdef PLUGIN_PPTP
+    if(strcmp(arg, "pptp") == 0) {
+        init = pptp_plugin_init;
+    } else
+#endif
+#ifdef PLUGIN_MINCONN
+    if(strcmp(arg, "minconn") == 0) {
+        init = minconn_plugin_init;
+    } else
+#endif
+#ifdef PLUGIN_PASSPROMPT
+    if(strcmp(arg, "passprompt") == 0) {
+        init = passprompt_plugin_init;
+    } else
+#endif
+#ifdef PLUGIN_PASSWORDFD
+    if(strcmp(arg, "passwordfd") == 0) {
+        init = passwordfd_plugin_init;
+    } else
+#endif
+#ifdef PLUGIN_WINBIND
+    if(strcmp(arg, "winbind") == 0) {
+        init = winbind_plugin_init;
+    } else
+#endif
+    {
+        option_error("Couldn't load plugin %s", arg);
+        return 0;
+    }
+
+    info("Plugin %s loaded.", arg);
+    (*init)();
+    return 1;
+#endif /* PLUGIN_DYNAMIC */
 }
 #endif /* PLUGIN */
 
diff --git a/pppd/pathnames.h b/pppd/pathnames.h
index a33f046..da2a73a 100644
--- a/pppd/pathnames.h
+++ b/pppd/pathnames.h
@@ -18,26 +18,44 @@
 #define _ROOT_PATH
 #endif
 
-#define _PATH_UPAPFILE 	 _ROOT_PATH "/etc/ppp/pap-secrets"
-#define _PATH_CHAPFILE 	 _ROOT_PATH "/etc/ppp/chap-secrets"
-#define _PATH_SRPFILE 	 _ROOT_PATH "/etc/ppp/srp-secrets"
-#define _PATH_SYSOPTIONS _ROOT_PATH "/etc/ppp/options"
-#define _PATH_IPUP	 _ROOT_PATH "/etc/ppp/ip-up"
-#define _PATH_IPDOWN	 _ROOT_PATH "/etc/ppp/ip-down"
-#define _PATH_IPPREUP	 _ROOT_PATH "/etc/ppp/ip-pre-up"
-#define _PATH_AUTHUP	 _ROOT_PATH "/etc/ppp/auth-up"
-#define _PATH_AUTHDOWN	 _ROOT_PATH "/etc/ppp/auth-down"
-#define _PATH_TTYOPT	 _ROOT_PATH "/etc/ppp/options."
-#define _PATH_CONNERRS	 _ROOT_PATH "/etc/ppp/connect-errors"
-#define _PATH_PEERFILES	 _ROOT_PATH "/etc/ppp/peers/"
-#define _PATH_RESOLV	 _ROOT_PATH "/etc/ppp/resolv.conf"
+#ifndef PATH_CONFIG
+#define	PATH_CONFIG	"/etc/ppp"
+#endif
+#ifndef PATH_AUTH
+#define	PATH_AUTH	"/etc/ppp"
+#endif
+#ifndef PATH_LOG
+#define	PATH_LOG	"/etc/ppp"
+#endif
+#ifndef PATH_RESOLV
+#define	PATH_RESOLV	"/etc/ppp"
+#endif
+
+#define _PATH_UPAPFILE 	 _ROOT_PATH PATH_CONFIG "/pap-secrets"
+#define _PATH_CHAPFILE 	 _ROOT_PATH PATH_CONFIG "/chap-secrets"
+#define _PATH_SRPFILE 	 _ROOT_PATH PATH_CONFIG "/srp-secrets"
+#define _PATH_SYSOPTIONS _ROOT_PATH PATH_CONFIG "/options"
+#define _PATH_IPUP	 _ROOT_PATH PATH_CONFIG "/ip-up"
+#define _PATH_IPDOWN	 _ROOT_PATH PATH_CONFIG "/ip-down"
+#define _PATH_IPPREUP	 _ROOT_PATH PATH_CONFIG "/ip-pre-up"
+#define _PATH_AUTHUP	 _ROOT_PATH PATH_AUTH   "/auth-up"
+#define _PATH_AUTHDOWN	 _ROOT_PATH PATH_AUTH   "/auth-down"
+#define _PATH_TTYOPT	 _ROOT_PATH PATH_CONFIG "/options."
+#define _PATH_CONNERRS	 _ROOT_PATH PATH_LOG    "/connect-errors"
+#define _PATH_PEERFILES	 _ROOT_PATH PATH_CONFIG "/peers/"
+#define _PATH_RESOLV	 _ROOT_PATH PATH_RESOLV "/%s.resolv"
+
+#ifdef PATH_ETC_CONFIG
+#define _PATH_DEFAULT_IPUP	"/etc/default/ip-up"
+#define _PATH_DEFAULT_IPDOWN	"/etc/default/ip-down"
+#endif
 
 #define _PATH_USEROPT	 ".ppprc"
 #define	_PATH_PSEUDONYM	 ".ppp_pseudonym"
 
 #ifdef INET6
-#define _PATH_IPV6UP     _ROOT_PATH "/etc/ppp/ipv6-up"
-#define _PATH_IPV6DOWN   _ROOT_PATH "/etc/ppp/ipv6-down"
+#define _PATH_IPV6UP     _ROOT_PATH PATH_CONFIG "/ipv6-up"
+#define _PATH_IPV6DOWN   _ROOT_PATH PATH_CONFIG "/ipv6-down"
 #endif
 
 #ifdef IPX_CHANGE
diff --git a/pppd/plugins/TACACS.txt b/pppd/plugins/TACACS.txt
new file mode 100644
index 0000000..62da5f3
--- /dev/null
+++ b/pppd/plugins/TACACS.txt
@@ -0,0 +1,67 @@
+TACACS+ plugin for pppdTACACS+ plugin for pppd
+This plugin add to pppd authentication, authorization and accounting provided by 
+a TACACS+ server. 
+
+Generated file
+==============
+Sample of accounting file : 
+Fri Mar 24 09:48:56 2000  194.149.85.30  nbodeux  ttyS1  194.149.85.8  start  start_time=953887736  task_id=27249  phone_#=43435592  service=ppp  protocol=ip
+Fri Mar 24 09:49:20 2000  194.149.85.30  nbodeux  ttyS1  194.149.85.8  stop   stop_time=953887759  task_id=27249  bytes_out=5122  bytes_in=3982  elapsed_time=27
+
+Config files
+============
+
+Part of /usr/local/etc/tac_plus.conf 
+# /usr/local/etc/tac_plus.conf
+
+default authentication = file /etc/passwd
+
+user = DEFAULT
+        {
+        member   = pppuser
+        service  = ppp
+        protocol = ip
+                {
+                addr=194.149.85.8/29
+                }
+        }
+
+Caution : currently only the first address argument is used. 
+
+Sample of /etc/mgetty+sendfax/login.config mgetty file : 
+# /usr/local/etc/mgetty+fax/login.conf
+#
+/AutoPPP/       -       autoppp /usr/sbin/pppd file /etc/ppp/incoming.tacacs
+
+Sample of /etc/ppp/incoming.tacacs file : 
+plugin /usr/sbin/tacacs.so
++pap
+-chap
+debug
+tacacs
+tacacs-server 194.149.85.3
+tacacs-secret "secret"
+tacacs-authorization
+tacacs-accounting
+-detach
+
+Sample of /etc/ppp/options : 
+ms-dns 194.149.85.30
+netmask 255.255.255.0
+crtscts
+modem
+-detach
+
+Sample of /etc/ppp/options.ttyS0 (one per serial line) : 
+rout-dom.stben.be:puser1.stben.be
+
+
+This file contains executable (tacacs.so) source (tacacs.c) and Makefile. If you 
+want to compile it you should get tac library from web site of Pavel Krawczyk.
+The code for a TACACS+ server is disponible from cisco ftp server or from our 
+server. 
+
+User guide for Cisco server. 
+Send all bug report at Jean-Louis Nol (jln@stben.be). 
+ 
+http://www.stben.be/tacacs/
\ No newline at end of file
diff --git a/pppd/plugins/minconn.c b/pppd/plugins/minconn.c
index c12216a..3a34666 100644
--- a/pppd/plugins/minconn.c
+++ b/pppd/plugins/minconn.c
@@ -36,7 +36,10 @@
 #include <time.h>
 #include "pppd.h"
 
-char pppd_version[] = VERSION;
+#ifndef DYNAMIC_PLUGINS
+#define	plugin_init minconn_plugin_init
+#endif
+char minconn_pppd_version[] = VERSION;
 
 static int minconnect = 0;
 
diff --git a/pppd/plugins/passprompt.c b/pppd/plugins/passprompt.c
index babb6dc..4d5d774 100644
--- a/pppd/plugins/passprompt.c
+++ b/pppd/plugins/passprompt.c
@@ -14,7 +14,10 @@
 #include <syslog.h>
 #include "pppd.h"
 
-char pppd_version[] = VERSION;
+#ifndef DYNAMIC_PLUGINS
+#define	plugin_init passprompt_plugin_init
+#endif
+char passprompt_pppd_version[] = VERSION;
 
 static char promptprog[PATH_MAX+1];
 
diff --git a/pppd/plugins/passwordfd.c b/pppd/plugins/passwordfd.c
index d718f3b..b85dc6c 100644
--- a/pppd/plugins/passwordfd.c
+++ b/pppd/plugins/passwordfd.c
@@ -14,7 +14,10 @@
 
 #include "pppd.h"
 
-char pppd_version[] = VERSION;
+#ifndef DYNAMIC_PLUGINS
+#define	plugin_init passwordfd_plugin_init
+#endif
+char passwordfd_pppd_version[] = VERSION;
 
 static int passwdfd = -1;
 static char save_passwd[MAXSECRETLEN];
diff --git a/pppd/plugins/pppoatm/Makefile.linux b/pppd/plugins/pppoatm/Makefile.linux
index 20f62e6..49a4e8e 100644
--- a/pppd/plugins/pppoatm/Makefile.linux
+++ b/pppd/plugins/pppoatm/Makefile.linux
@@ -1,9 +1,16 @@
 #CC	= gcc
-COPTS	= -O2 -g
-CFLAGS	= $(COPTS) -I../.. -I../../../include -fPIC
-LDFLAGS	= -shared
+#COPTS	= -O2 -g
+CFLAGS	= $(COPTS) -I../.. -I../../../include
 INSTALL	= install
 
+ifeq ($(CONFIG_USER_PPPD_WITH_DYNAMIC_PLUGINS),y)
+CFLAGS  += -fPIC
+LDFLAGS = -shared
+PLUGIN := pppoatm.so
+else
+PLUGIN := libpppoatm.o
+endif
+
 #***********************************************************************
 
 DESTDIR = $(INSTROOT)@DESTDIR@
@@ -11,7 +18,6 @@ LIBDIR = $(DESTDIR)/lib/pppd/$(VERSION)
 
 VERSION = $(shell awk -F '"' '/VERSION/ { print $$2; }' ../../patchlevel.h)
 
-PLUGIN := pppoatm.so
 PLUGIN_OBJS := pppoatm.o 
 
 #*******
@@ -32,15 +38,18 @@ endif
 #*********
 all: $(PLUGIN)
 
-$(PLUGIN): $(PLUGIN_OBJS)
+pppoatm.so: $(PLUGIN_OBJS)
 	$(CC) $(CFLAGS) -o $@ -shared $^ $(LIBS)
 
+libpppoatm.o: $(PLUGIN_OBJS)
+	$(LD) -r -o $@ $^
+
 install: all
 	$(INSTALL) -d -m 755 $(LIBDIR)
 	$(INSTALL) -c -m 4550 $(PLUGIN) $(LIBDIR)
 
 clean:
-	rm -f *.o *.so
+	rm -f *.o *.so *.a
 
 %.o: %.c
 	$(CC) $(CFLAGS) -c -o $@ $<
diff --git a/pppd/plugins/pppoatm/pppoatm.c b/pppd/plugins/pppoatm/pppoatm.c
index d693350..d6409cb 100644
--- a/pppd/plugins/pppoatm/pppoatm.c
+++ b/pppd/plugins/pppoatm/pppoatm.c
@@ -27,7 +27,10 @@
 #include <net/if.h>
 #include <sys/ioctl.h>
 
-const char pppd_version[] = VERSION;
+#ifndef DYNAMIC_PLUGINS
+#define	plugin_init pppoa_plugin_init
+#endif
+const char pppoatm_pppd_version[] = VERSION;
 
 static struct sockaddr_atmpvc pvcaddr;
 static char *qosstr = NULL;
diff --git a/pppd/plugins/pppol2tp/Makefile.linux b/pppd/plugins/pppol2tp/Makefile.linux
index ea3538e..9a7a702 100644
--- a/pppd/plugins/pppol2tp/Makefile.linux
+++ b/pppd/plugins/pppol2tp/Makefile.linux
@@ -1,9 +1,18 @@
 #CC	= gcc
-COPTS	= -O2 -g
-CFLAGS	= $(COPTS) -I. -I../.. -I../../../include -fPIC
-LDFLAGS	= -shared
+#COPTS	= -O2 -g
+CFLAGS	+= $(COPTS) -I. -I../.. -I../../../include
 INSTALL	= install
 
+ifeq ($(CONFIG_USER_PPPD_WITH_DYNAMIC_PLUGINS),y)
+CFLAGS  += -fPIC -DDYNAMIC_PLUGINS=1
+LDFLAGS = -shared
+SO = so
+PLUGINS := pppol2tp.so openl2tp.so
+else
+PLUGINS := libpppol2tp.o
+SO = o
+endif
+
 #***********************************************************************
 
 DESTDIR = @DESTDIR@
@@ -11,13 +20,14 @@ LIBDIR = $(DESTDIR)/lib/pppd/$(VERSION)
 
 VERSION = $(shell awk -F '"' '/VERSION/ { print $$2; }' ../../patchlevel.h)
 
-PLUGINS := pppol2tp.so openl2tp.so
-
 all: $(PLUGINS)
 
 %.so: %.o
 	$(CC) $(CFLAGS) -o $@ -shared $^ $(LIBS)
 
+libpppol2tp.o: pppol2tp.o openl2tp.o
+	$(CC) $(CFLAGS) -c -o $@ $^
+
 install: all
 	$(INSTALL) -d -m 755 $(LIBDIR)
 	$(INSTALL) -c -m 755 $(PLUGINS) $(LIBDIR)
diff --git a/pppd/plugins/pppol2tp/openl2tp.c b/pppd/plugins/pppol2tp/openl2tp.c
index 9643b96..65bcb40 100644
--- a/pppd/plugins/pppol2tp/openl2tp.c
+++ b/pppd/plugins/pppol2tp/openl2tp.c
@@ -47,8 +47,8 @@
 #include <linux/if_ether.h>
 #include <linux/ppp_defs.h>
 #include <linux/if_ppp.h>
-#include <linux/if_pppox.h>
 #include <linux/if_pppol2tp.h>
+#include <linux/if_pppox.h>
 
 #include "l2tp_event.h"
 
@@ -59,7 +59,10 @@ extern void (*pppol2tp_send_accm_hook)(int tunnel_id, int session_id,
 				       uint32_t send_accm, uint32_t recv_accm);
 extern void (*pppol2tp_ip_updown_hook)(int tunnel_id, int session_id, int up);
 
-const char pppd_version[] = VERSION;
+#ifndef DYNAMIC_PLUGINS
+#define	plugin_init openl2tp_plugin_init
+#endif
+const char openl2tp_pppd_version[] = VERSION;
 
 static int openl2tp_fd = -1;
 
diff --git a/pppd/plugins/pppol2tp/pppol2tp.c b/pppd/plugins/pppol2tp/pppol2tp.c
index 0e28606..dc33453 100644
--- a/pppd/plugins/pppol2tp/pppol2tp.c
+++ b/pppd/plugins/pppol2tp/pppol2tp.c
@@ -46,15 +46,18 @@
 #include <linux/if_ether.h>
 #include <linux/ppp_defs.h>
 #include <linux/if_ppp.h>
-#include <linux/if_pppox.h>
 #include <linux/if_pppol2tp.h>
+#include <linux/if_pppox.h>
 
 /* should be added to system's socket.h... */
 #ifndef SOL_PPPOL2TP
 #define SOL_PPPOL2TP	273
 #endif
 
-const char pppd_version[] = VERSION;
+#ifndef DYNAMIC_PLUGINS
+#define	plugin_init pppol2tp_plugin_init
+#endif
+const char pppol2tp_pppd_version[] = VERSION;
 
 static int setdevname_pppol2tp(char **argv);
 
diff --git a/pppd/plugins/pptp/Makefile.linux b/pppd/plugins/pptp/Makefile.linux
new file mode 100644
index 0000000..cff2eed
--- /dev/null
+++ b/pppd/plugins/pptp/Makefile.linux
@@ -0,0 +1,42 @@
+#
+# This program may be distributed according to the terms of the GNU
+# General Public License, version 2 or (at your option) any later version.
+#
+# $Id: Makefile.linux,v 1.9 2012/05/04 21:48:00 dgolle Exp $
+#***********************************************************************
+
+DESTDIR = $(INSTROOT)@DESTDIR@
+LIBDIR = $(DESTDIR)/lib/pppd/$(PPPDVERSION)
+
+PPPDVERSION = $(shell awk -F '"' '/VERSION/ { print $$2; }' ../../patchlevel.h)
+
+INSTALL	= install
+
+COPTS=-O2 -g
+CFLAGS  = $(COPTS) -I. -I../.. -I../../../include -DPPPD_VERSION=\"$(PPPDVERSION)\"
+
+ifeq ($(CONFIG_USER_PPPD_WITH_DYNAMIC_PLUGINS),y)
+CFLAGS += -fPIC
+TARGET = pptp.so
+else
+TARGET = libpptp.o
+endif
+
+all: $(TARGET)
+
+%.o: %.c
+	$(CC) $(CFLAGS) -c -o $@ $<
+
+pptp.so: dirutil.o orckit_quirks.o pptp.o pptp_callmgr.o pptp_ctrl.o pptp_quirks.o util.o vector.o
+	$(CC) -o pptp.so -shared dirutil.o orckit_quirks.o pptp.o pptp_callmgr.o pptp_ctrl.o pptp_quirks.o util.o vector.o
+
+libpptp.o: dirutil.o orckit_quirks.o pptp.o pptp_callmgr.o pptp_ctrl.o pptp_quirks.o util.o vector.o
+	$(LD) -r -o $@ $^
+
+install: all
+	$(INSTALL) -d -m 755 $(LIBDIR)
+	$(INSTALL) -c -m 4550 pptp.so $(LIBDIR)
+
+clean:
+	rm -f *.o *.so
+
diff --git a/pppd/plugins/pptp/dirutil.c b/pppd/plugins/pptp/dirutil.c
new file mode 100644
index 0000000..e7b1a77
--- /dev/null
+++ b/pppd/plugins/pptp/dirutil.c
@@ -0,0 +1,68 @@
+/* dirutil.c ... directory utilities.
+ *               C. Scott Ananian <cananian@alumni.princeton.edu>
+ *
+ * $Id: dirutil.c,v 1.2 2003/06/17 17:25:47 reink Exp $
+ */
+
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdlib.h>
+#include "dirutil.h"
+
+/* Returned malloc'ed string representing basename */
+char *basenamex(char *pathname)
+{
+    char *dup = strdup(pathname);
+    char *ptr = strrchr(stripslash(dup), '/');
+    if (ptr == NULL) return dup;
+    ptr = strdup(ptr+1);
+    free(dup);
+    return ptr;
+}
+
+/* Return malloc'ed string representing directory name (no trailing slash) */
+char *dirnamex(char *pathname)
+{
+    char *dup = strdup(pathname);
+    char *ptr = strrchr(stripslash(dup), '/');
+    if (ptr == NULL) { free(dup); return strdup("."); }
+    if (ptr == dup && dup[0] == '/') ptr++;
+    *ptr = '\0';
+    return dup;
+}
+
+/* In-place modify a string to remove trailing slashes.  Returns arg.
+ * stripslash("/") returns "/";
+ */
+char *stripslash(char *pathname) {
+    int len = strlen(pathname);
+    while (len > 1 && pathname[len - 1] == '/')
+        pathname[--len] = '\0';
+    return pathname;
+}
+
+/* ensure dirname exists, creating it if necessary. */
+int make_valid_path(char *dir, mode_t mode)
+{
+    struct stat st;
+    char *tmp = NULL, *path = stripslash(strdup(dir));
+    int retval;
+    if (stat(path, &st) == 0) { /* file exists */
+        if (S_ISDIR(st.st_mode)) { retval = 1; goto end; }
+        else { retval = 0; goto end; } /* not a directory.  Oops. */
+    }
+    /* Directory doesn't exist.  Let's make it. */
+    /*   Make parent first. */
+    if (!make_valid_path(tmp = dirnamex(path), mode)) { retval = 0; goto end; }
+    /*   Now make this 'un. */
+    if (mkdir(path, mode) < 0) { retval = 0; goto end; }
+    /* Success. */
+    retval = 1;
+
+end:
+    if (tmp != NULL) free(tmp);
+    if (path != NULL) free(path);
+    return retval;
+}
diff --git a/pppd/plugins/pptp/dirutil.h b/pppd/plugins/pptp/dirutil.h
new file mode 100644
index 0000000..4c9aa87
--- /dev/null
+++ b/pppd/plugins/pptp/dirutil.h
@@ -0,0 +1,14 @@
+/* dirutil.h ... directory utilities.
+ *               C. Scott Ananian <cananian@alumni.princeton.edu>
+ *
+ * $Id: dirutil.h,v 1.1.1.1 2000/12/23 08:19:51 scott Exp $
+ */
+
+/* Returned malloc'ed string representing basename */
+char *basenamex(char *pathname);
+/* Return malloc'ed string representing directory name (no trailing slash) */
+char *dirnamex(char *pathname);
+/* In-place modify a string to remove trailing slashes.  Returns arg. */
+char *stripslash(char *pathname);
+/* ensure dirname exists, creating it if necessary. */
+int make_valid_path(char *dirname, mode_t mode);
diff --git a/pppd/plugins/pptp/orckit_quirks.c b/pppd/plugins/pptp/orckit_quirks.c
new file mode 100644
index 0000000..1d03737
--- /dev/null
+++ b/pppd/plugins/pptp/orckit_quirks.c
@@ -0,0 +1,86 @@
+/* orckit_quirks.c ...... fix quirks in orckit adsl modems
+ *                        mulix <mulix@actcom.co.il>
+ *
+ * $Id: orckit_quirks.c,v 1.3 2002/03/01 01:23:36 quozl Exp $
+ */
+
+#include <string.h>
+#include <sys/types.h>
+#include <netinet/in.h>
+#include "pptp_msg.h"
+#include "pptp_options.h"
+#include "pptp_ctrl.h"
+#include "util.h"
+
+
+
+/* return 0 on success, non zero otherwise */
+int
+orckit_atur3_build_hook(struct pptp_out_call_rqst* packet)
+{
+    unsigned int name_length = 10;
+
+    struct pptp_out_call_rqst fixed_packet = {
+	PPTP_HEADER_CTRL(PPTP_OUT_CALL_RQST),
+	0, /* hton16(call->callid) */
+	0, /* hton16(call->sernum) */
+	hton32(PPTP_BPS_MIN), hton32(PPTP_BPS_MAX),
+	hton32(PPTP_BEARER_DIGITAL), hton32(PPTP_FRAME_ANY),
+	hton16(PPTP_WINDOW), 0, hton16(name_length), 0,
+	{'R','E','L','A','Y','_','P','P','P','1',0}, {0}
+    };
+
+    if (!packet)
+	return -1;
+
+    memcpy(packet, &fixed_packet, sizeof(*packet));
+
+    return 0;
+}
+
+/* return 0 on success, non zero otherwise */
+int
+orckit_atur3_set_link_hook(struct pptp_set_link_info* packet,
+			   int peer_call_id)
+{
+    struct pptp_set_link_info fixed_packet = {
+	PPTP_HEADER_CTRL(PPTP_SET_LINK_INFO),
+	hton16(peer_call_id),
+	0,
+	0xffffffff,
+	0xffffffff};
+
+    if (!packet)
+	return -1;
+
+    memcpy(packet, &fixed_packet, sizeof(*packet));
+    return 0;
+}
+
+/* return 0 on success, non 0 otherwise */
+int
+orckit_atur3_start_ctrl_conn_hook(struct pptp_start_ctrl_conn* packet)
+{
+    struct pptp_start_ctrl_conn fixed_packet = {
+	{0}, /* we'll set the header later */
+	hton16(PPTP_VERSION), 0, 0,
+	hton32(PPTP_FRAME_ASYNC), hton32(PPTP_BEARER_ANALOG),
+	hton16(0) /* max channels */,
+	hton16(0x6021),
+	{'R','E','L','A','Y','_','P','P','P','1',0}, /* hostname */
+	{'M','S',' ','W','i','n',' ','N','T',0} /* vendor */
+    };
+
+    if (!packet)
+	return -1;
+
+    /* grab the header from the original packet, since we dont
+       know if this is a request or a reply */
+    memcpy(&fixed_packet.header, &packet->header, sizeof(struct pptp_header));
+
+    /* and now overwrite the full packet, effectively preserving the header */
+    memcpy(packet, &fixed_packet, sizeof(*packet));
+    return 0;
+}
+
+
diff --git a/pppd/plugins/pptp/orckit_quirks.h b/pppd/plugins/pptp/orckit_quirks.h
new file mode 100644
index 0000000..ad0193d
--- /dev/null
+++ b/pppd/plugins/pptp/orckit_quirks.h
@@ -0,0 +1,27 @@
+/* orckit_quirks.h ...... fix quirks in orckit adsl modems
+ *                        mulix <mulix@actcom.co.il>
+ *
+ * $Id: orckit_quirks.h,v 1.2 2001/11/23 03:42:51 quozl Exp $
+ */
+
+#ifndef INC_ORCKIT_QUIRKS_H_
+#define INC_ORCKIT_QUIRKS_H_
+
+#include "pptp_options.h"
+#include "pptp_ctrl.h"
+#include "pptp_msg.h"
+
+/* return 0 on success, non zero otherwise */
+int
+orckit_atur3_build_hook(struct pptp_out_call_rqst* packt);
+
+/* return 0 on success, non zero otherwise */
+int
+orckit_atur3_set_link_hook(struct pptp_set_link_info* packet,
+			   int peer_call_id);
+
+/* return 0 on success, non zero otherwise */
+int
+orckit_atur3_start_ctrl_conn_hook(struct pptp_start_ctrl_conn* packet);
+
+#endif /* INC_ORCKIT_QUIRKS_H_ */
diff --git a/pppd/plugins/pptp/pppd-pptp.8 b/pppd/plugins/pptp/pppd-pptp.8
new file mode 100644
index 0000000..e0ddb54
--- /dev/null
+++ b/pppd/plugins/pptp/pppd-pptp.8
@@ -0,0 +1,68 @@
+.\" manual page [] for PPTP plugin for pppd 2.4
+.\" $Id: pppd-pptp.8,v 1.0 2007/10/17 13:27:17 kad Exp $
+.\" SH section heading
+.\" SS subsection heading
+.\" LP paragraph
+.\" IP indented paragraph
+.\" TP hanging label
+.TH PPPD-PPTP 8
+.SH NAME
+pptp.so \- PPTP VPN plugin for
+.BR pppd (8)
+.SH SYNOPSIS
+.B pppd
+[
+.I options
+]
+plugin pptp.so
+.SH DESCRIPTION
+.LP
+The PPTP plugin for pppd performs interaction with pptp kernel module
+and has built-in call manager (client part of PPTP).
+It pasees necessary paremeters from \fIoptions\fR into kernel module 
+to configure ppp-pptp channel. If it runs in client mode, then additionally 
+call manager starts up. PPTPD daemon automaticaly invokes this plugin
+in server mode and passes necessary options, so additional configuration
+is not needed.
+
+.SH OPTIONS for client mode
+The PPTP plugin introduces one additional pppd option:
+.TP
+.BI "pptp_server " server " (required)"
+Specifies ip address or hostname of pptp server.
+.TP
+.BI "pptp_window " packets " (optional)"
+The amount of sliding window size. 
+Set to 0 to turn off sliding window.
+    to 3-10 for low speed connections.
+    to >10 for hi speed connections.
+Default is 50
+.TP
+.BI "pptp_phone " phone " (optional)"
+The phone string that sended to pptp server.
+.SH USAGE
+Sample configuration file:
+.nf
+plugin "pptp.so"
+pptp_server 192.168.0.1
+pptp_window 100
+name myname
+remotename pptp
+noauth
+refuse-eap
+refuse-chap
+refuse-mschap
+nobsdcomp
+nodeflate
+novj
+novjccomp
+require-mppe-128
+lcp-echo-interval 20
+lcp-echo-failure  3
+.fi
+
+.SH SEE ALSO
+.BR pppd (8) "  " pptpd (8) "  " pptpd.conf (5)
+
+.SH AUTHOR
+xeb xeb@mail.ru
diff --git a/pppd/plugins/pptp/pptp.c b/pppd/plugins/pptp/pptp.c
new file mode 100644
index 0000000..6dc0556
--- /dev/null
+++ b/pppd/plugins/pptp/pptp.c
@@ -0,0 +1,325 @@
+/***************************************************************************
+ *   Copyright (C) 2006 by Kozlov D. <xeb@mail.ru>                         *
+ *   some cleanup done (C) 2012 by Daniel Golle <dgolle@allnet.de>         *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#define PPTP_VERSION "1.00"
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <sys/un.h>
+#include <netdb.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <syslog.h>
+#include <unistd.h>
+#include <signal.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <sys/wait.h>
+#include <sys/ioctl.h>
+
+#include "pppd.h"
+#include "fsm.h"
+#include "lcp.h"
+#include "ipcp.h"
+#include "ccp.h"
+#include "pathnames.h"
+
+#include "pptp_callmgr.h"
+#include <net/if.h>
+#include <net/ethernet.h>
+#include <linux/if_pppox.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#ifndef DYNAMIC_PLUGINS
+#define	plugin_init pptp_plugin_init
+#endif
+
+extern char** environ;
+
+char pppd_version[] = PPPD_VERSION;
+extern int new_style_driver;
+
+
+char *pptp_server = NULL;
+char *pptp_client = NULL;
+char *pptp_phone = NULL;
+int pptp_window=50;
+int pptp_sock=-1;
+struct in_addr localbind = { INADDR_NONE };
+
+static int callmgr_sock;
+static int pptp_fd;
+int call_ID;
+
+static int open_callmgr(int call_id,struct in_addr inetaddr, char *phonenr,int window);
+static void launch_callmgr(int call_is,struct in_addr inetaddr, char *phonenr,int window);
+static int get_call_id(int sock, pid_t gre, pid_t pppd, u_int16_t *peer_call_id);
+
+static option_t Options[] =
+{
+    { "pptp_server", o_string, &pptp_server,
+      "PPTP Server" },
+    { "pptp_client", o_string, &pptp_client,
+      "PPTP Client" },
+    { "pptp_sock",o_int, &pptp_sock,
+      "PPTP socket" },
+    { "pptp_phone", o_string, &pptp_phone,
+      "PPTP Phone number" },
+    { "pptp_window",o_int, &pptp_window,
+      "PPTP window" },
+    { NULL }
+};
+
+static int pptp_connect(void);
+static void pptp_disconnect(void);
+
+struct channel pptp_channel = {
+    options: Options,
+    check_options: NULL,
+    connect: &pptp_connect,
+    disconnect: &pptp_disconnect,
+    establish_ppp: &generic_establish_ppp,
+    disestablish_ppp: &generic_disestablish_ppp,
+    close: NULL,
+    cleanup: NULL
+};
+
+static int pptp_start_server(void)
+{
+	pptp_fd=pptp_sock;
+	sprintf(ppp_devnam,"pptp (%s)",pptp_client);
+
+	return pptp_fd;
+}
+static int pptp_start_client(void)
+{
+	socklen_t len;
+	struct sockaddr_pppox src_addr,dst_addr;
+	struct hostent *hostinfo;
+
+	hostinfo=gethostbyname(pptp_server);
+  if (!hostinfo)
+	{
+		error("PPTP: Unknown host %s\n", pptp_server);
+		return -1;
+	}
+	dst_addr.sa_addr.pptp.sin_addr=*(struct in_addr*)hostinfo->h_addr;
+	{
+		int sock;
+		struct sockaddr_in addr;
+		len=sizeof(addr);
+		addr.sin_addr=dst_addr.sa_addr.pptp.sin_addr;
+		addr.sin_family=AF_INET;
+		addr.sin_port=htons(1700);
+		sock=socket(AF_INET,SOCK_DGRAM,0);
+		if (connect(sock,(struct sockaddr*)&addr,sizeof(addr)))
+		{
+			close(sock);
+			error("PPTP: connect failed (%s)\n",strerror(errno));
+			return -1;
+		}
+		getsockname(sock,(struct sockaddr*)&addr,&len);
+		src_addr.sa_addr.pptp.sin_addr=addr.sin_addr;
+		close(sock);
+	}
+
+	src_addr.sa_family=AF_PPPOX;
+	src_addr.sa_protocol=PX_PROTO_PPTP;
+	src_addr.sa_addr.pptp.call_id=0;
+
+	dst_addr.sa_family=AF_PPPOX;
+	dst_addr.sa_protocol=PX_PROTO_PPTP;
+	dst_addr.sa_addr.pptp.call_id=0;
+
+	pptp_fd=socket(AF_PPPOX,SOCK_STREAM,PX_PROTO_PPTP);
+	if (pptp_fd<0)
+	{
+		error("PPTP: failed to create PPTP socket (%s)\n",strerror(errno));
+		return -1;
+	}
+	if (bind(pptp_fd,(struct sockaddr*)&src_addr,sizeof(src_addr)))
+	{
+		close(pptp_fd);
+		error("PPTP: failed to bind PPTP socket (%s)\n",strerror(errno));
+		return -1;
+	}
+	len=sizeof(src_addr);
+	getsockname(pptp_fd,(struct sockaddr*)&src_addr,&len);
+	call_ID=src_addr.sa_addr.pptp.call_id;
+
+  do {
+        /*
+         * Open connection to call manager (Launch call manager if necessary.)
+         */
+        callmgr_sock = open_callmgr(src_addr.sa_addr.pptp.call_id,dst_addr.sa_addr.pptp.sin_addr, pptp_phone, pptp_window);
+	if (callmgr_sock<0)
+	{
+		close(pptp_fd);
+		return -1;
+        }
+        /* Exchange PIDs, get call ID */
+    } while (get_call_id(callmgr_sock, getpid(), getpid(), &dst_addr.sa_addr.pptp.call_id) < 0);
+
+	if (connect(pptp_fd,(struct sockaddr*)&dst_addr,sizeof(dst_addr)))
+	{
+		close(callmgr_sock);
+		close(pptp_fd);
+		error("PPTP: failed to connect PPTP socket (%s)\n",strerror(errno));
+		return -1;
+	}
+
+	sprintf(ppp_devnam,"pptp (%s)",pptp_server);
+
+	return pptp_fd;
+}
+static int pptp_connect(void)
+{
+	if ((!pptp_server && !pptp_client) || (pptp_server && pptp_client))
+	{
+		fatal("PPTP: unknown mode (you must specify pptp_server or pptp_client option)");
+		return -1;
+	}
+
+	if (pptp_server) return pptp_start_client();
+	return pptp_start_server();
+}
+
+static void pptp_disconnect(void)
+{
+	if (pptp_server) close(callmgr_sock);
+	close(pptp_fd);
+}
+
+static int open_callmgr(int call_id,struct in_addr inetaddr, char *phonenr,int window)
+{
+    /* Try to open unix domain socket to call manager. */
+    struct sockaddr_un where;
+    const int NUM_TRIES = 3;
+    int i, fd;
+    pid_t pid;
+    int status;
+    /* Open socket */
+    if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)
+    {
+        fatal("Could not create unix domain socket: %s", strerror(errno));
+    }
+    /* Make address */
+    callmgr_name_unixsock(&where, inetaddr, localbind);
+    for (i = 0; i < NUM_TRIES; i++)
+    {
+        if (connect(fd, (struct sockaddr *) &where, sizeof(where)) < 0)
+        {
+            /* couldn't connect.  We'll have to launch this guy. */
+
+            unlink (where.sun_path);
+
+            /* fork and launch call manager process */
+            switch (pid = fork())
+            {
+                case -1: /* failure */
+                    fatal("fork() to launch call manager failed.");
+                case 0: /* child */
+                {
+                    /* close the pty and gre in the call manager */
+                    close(fd);
+                    close(pptp_fd);
+                    launch_callmgr(call_id,inetaddr,phonenr,window);
+                }
+                default: /* parent */
+                    waitpid(pid, &status, 0);
+                    if (status!= 0)
+		    {
+			close(fd);
+			error("Call manager exited with error %d", status);
+			return -1;
+		    }
+                    break;
+            }
+            sleep(1);
+        }
+        else return fd;
+    }
+    close(fd);
+    error("Could not launch call manager after %d tries.", i);
+    return -1;   /* make gcc happy */
+}
+
+/*** call the call manager main ***********************************************/
+static void launch_callmgr(int call_id,struct in_addr inetaddr, char *phonenr,int window)
+{
+    dbglog("pptp: call manager for %s\n", inet_ntoa(inetaddr));
+    dbglog("window size:\t%d\n",window);
+    if (phonenr) dbglog("phone number:\t'%s'\n",phonenr);
+    dbglog("call id:\t%d\n",call_id);
+    exit(callmgr_main(inetaddr, phonenr, window, call_id));
+}
+
+/*** exchange data with the call manager  *************************************/
+/* XXX need better error checking XXX */
+static int get_call_id(int sock, pid_t gre, pid_t pppd,
+		u_int16_t *peer_call_id)
+{
+    u_int16_t m_call_id, m_peer_call_id;
+    /* write pid's to socket */
+    /* don't bother with network byte order, because pid's are meaningless
+     * outside the local host.
+     */
+    int rc;
+    rc = write(sock, &gre, sizeof(gre));
+    if (rc != sizeof(gre))
+        return -1;
+    rc = write(sock, &pppd, sizeof(pppd));
+    if (rc != sizeof(pppd))
+        return -1;
+    rc = read(sock,  &m_call_id, sizeof(m_call_id));
+    if (rc != sizeof(m_call_id))
+        return -1;
+    rc = read(sock,  &m_peer_call_id, sizeof(m_peer_call_id));
+    if (rc != sizeof(m_peer_call_id))
+        return -1;
+    /*
+     * XXX FIXME ... DO ERROR CHECKING & TIME-OUTS XXX
+     * (Rhialto: I am assuming for now that timeouts are not relevant
+     * here, because the read and write calls would return -1 (fail) when
+     * the peer goes away during the process. We know it is (or was)
+     * running because the connect() call succeeded.)
+     * (James: on the other hand, if the route to the peer goes away, we
+     * wouldn't get told by read() or write() for quite some time.)
+     */
+    *peer_call_id = m_peer_call_id;
+    return 0;
+}
+
+void plugin_init(void)
+{
+    add_options(Options);
+
+    info("PPTP plugin version %s", PPTP_VERSION);
+
+    the_channel = &pptp_channel;
+    modem = 0;
+}
diff --git a/pppd/plugins/pptp/pptp_callmgr.c b/pppd/plugins/pptp/pptp_callmgr.c
new file mode 100644
index 0000000..14245ad
--- /dev/null
+++ b/pppd/plugins/pptp/pptp_callmgr.c
@@ -0,0 +1,381 @@
+/* pptp_callmgr.c ... Call manager for PPTP connections.
+ *                    Handles TCP port 1723 protocol.
+ *                    C. Scott Ananian <cananian@alumni.princeton.edu>
+ *
+ * $Id: pptp_callmgr.c,v 1.20 2005/03/31 07:42:39 quozl Exp $
+ */
+#include <signal.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <sys/un.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+#include <setjmp.h>
+#include <stdio.h>
+#include <errno.h>
+#include "pptp_callmgr.h"
+#include "pptp_ctrl.h"
+#include "pptp_msg.h"
+#include "dirutil.h"
+#include "vector.h"
+#include "util.h"
+#include "pppd.h"
+
+extern struct in_addr localbind; /* from pptp.c */
+extern int call_ID;
+
+int open_inetsock(struct in_addr inetaddr);
+int open_unixsock(struct in_addr inetaddr);
+void close_inetsock(int fd, struct in_addr inetaddr);
+void close_unixsock(int fd, struct in_addr inetaddr);
+
+sigjmp_buf callmgr_env;
+
+void callmgr_sighandler(int sig) {
+    /* TODO: according to signal(2), siglongjmp() is unsafe used here */
+    siglongjmp (callmgr_env, 1);
+}
+
+void callmgr_do_nothing(int sig) {
+    /* do nothing signal handler */
+}
+
+struct local_callinfo {
+    int unix_sock;
+    pid_t pid[2];
+};
+
+struct local_conninfo {
+    VECTOR * call_list;
+    fd_set * call_set;
+};
+
+/* Call callback */
+void call_callback(PPTP_CONN *conn, PPTP_CALL *call, enum call_state state)
+{
+    struct local_callinfo *lci;
+    struct local_conninfo *conninfo;
+    u_int16_t call_id[2];
+    switch(state) {
+        case CALL_OPEN_DONE:
+            /* okey dokey.  This means that the call_id and peer_call_id are
+             * now valid, so lets send them on to our friends who requested
+             * this call.  */
+            lci = pptp_call_closure_get(conn, call); assert(lci != NULL);
+            pptp_call_get_ids(conn, call, &call_id[0], &call_id[1]);
+            write(lci->unix_sock, &call_id, sizeof(call_id));
+            /* Our duty to the fatherland is now complete. */
+            break;
+        case CALL_OPEN_FAIL:
+        case CALL_CLOSE_RQST:
+        case CALL_CLOSE_DONE:
+            /* don't need to do anything here, except make sure tables
+             * are sync'ed */
+            dbglog("Closing connection (call state)");
+            conninfo = pptp_conn_closure_get(conn);
+            lci = pptp_call_closure_get(conn, call);
+            assert(lci != NULL && conninfo != NULL);
+            if (vector_contains(conninfo->call_list, lci->unix_sock)) {
+                vector_remove(conninfo->call_list, lci->unix_sock);
+                close(lci->unix_sock);
+                FD_CLR(lci->unix_sock, conninfo->call_set);
+            }
+            break;
+        default:
+            dbglog("Unhandled call callback state [%d].", (int) state);
+            break;
+    }
+}
+
+/******************************************************************************
+ * NOTE ABOUT 'VOLATILE':
+ * several variables here get a volatile qualifier to silence warnings
+ * from older (before 3.0) gccs. if the longjmp stuff is removed,
+ * the volatile qualifiers should be removed as well.
+ *****************************************************************************/
+
+/*** Call Manager *************************************************************/
+int callmgr_main(struct in_addr inetaddr, char phonenr[], int window, int pcallid)
+{
+    int inet_sock, unix_sock;
+    fd_set call_set;
+    PPTP_CONN * conn;
+    VECTOR * call_list;
+    int max_fd = 0;
+    volatile int first = 1;
+    int retval;
+    int i;
+    if (pcallid>0) call_ID=pcallid;
+
+    /* Step 1: Open sockets. */
+    if ((inet_sock = open_inetsock(inetaddr)) < 0)
+        fatal("Could not open control connection to %s", inet_ntoa(inetaddr));
+    dbglog("control connection");
+    if ((unix_sock = open_unixsock(inetaddr)) < 0)
+        fatal("Could not open unix socket for %s", inet_ntoa(inetaddr));
+    /* Step 1b: FORK and return status to calling process. */
+    dbglog("unix_sock");
+
+    switch (fork()) {
+        case 0: /* child. stick around. */
+            break;
+        case -1: /* failure.  Fatal. */
+            fatal("Could not fork.");
+        default: /* Parent. Return status to caller. */
+            exit(0);
+    }
+    /* re-open stderr as /dev/null to release it */
+    file2fd("/dev/null", "wb", STDERR_FILENO);
+    /* Step 1c: Clean up unix socket on TERM */
+    if (sigsetjmp(callmgr_env, 1) != 0)
+        goto cleanup;
+    signal(SIGINT, callmgr_sighandler);
+    signal(SIGTERM, callmgr_sighandler);
+    signal(SIGPIPE, callmgr_do_nothing);
+    signal(SIGUSR1, callmgr_do_nothing); /* signal state change
+                                            wake up accept */
+    /* Step 2: Open control connection and register callback */
+    if ((conn = pptp_conn_open(inet_sock, 1, NULL/* callback */)) == NULL) {
+        close(unix_sock); close(inet_sock); fatal("Could not open connection.");
+    }
+    FD_ZERO(&call_set);
+    call_list = vector_create();
+    {
+        struct local_conninfo *conninfo = malloc(sizeof(*conninfo));
+        if (conninfo == NULL) {
+            close(unix_sock); close(inet_sock); fatal("No memory.");
+        }
+        conninfo->call_list = call_list;
+        conninfo->call_set  = &call_set;
+        pptp_conn_closure_put(conn, conninfo);
+    }
+    if (sigsetjmp(callmgr_env, 1) != 0) goto shutdown;
+    /* Step 3: Get FD_SETs */
+    max_fd = unix_sock;
+    do {
+        int rc;
+        fd_set read_set = call_set, write_set;
+        FD_ZERO (&write_set);
+        if (pptp_conn_established(conn)) {
+	  FD_SET (unix_sock, &read_set);
+	  if (unix_sock > max_fd) max_fd = unix_sock;
+	}
+        pptp_fd_set(conn, &read_set, &write_set, &max_fd);
+        for (; max_fd > 0 ; max_fd--) {
+            if (FD_ISSET (max_fd, &read_set) ||
+                    FD_ISSET (max_fd, &write_set))
+                break;
+        }
+        /* Step 4: Wait on INET or UNIX event */
+        if ((rc = select(max_fd + 1, &read_set, &write_set, NULL, NULL)) <0) {
+	  if (errno == EBADF) break;
+	  /* a signal or somesuch. */
+	  continue;
+	}
+        /* Step 5a: Handle INET events */
+        rc = pptp_dispatch(conn, &read_set, &write_set);
+	if (rc < 0)
+	    break;
+        /* Step 5b: Handle new connection to UNIX socket */
+        if (FD_ISSET(unix_sock, &read_set)) {
+            /* New call! */
+            struct sockaddr_un from;
+            int len = sizeof(from);
+            PPTP_CALL * call;
+            struct local_callinfo *lci;
+            int s;
+            /* Accept the socket */
+            FD_CLR (unix_sock, &read_set);
+            if ((s = accept(unix_sock, (struct sockaddr *) &from, &len)) < 0) {
+                warn("Socket not accepted: %s", strerror(errno));
+                goto skip_accept;
+            }
+            /* Allocate memory for local call information structure. */
+            if ((lci = malloc(sizeof(*lci))) == NULL) {
+                warn("Out of memory."); close(s); goto skip_accept;
+            }
+            lci->unix_sock = s;
+            /* Give the initiator time to write the PIDs while we open
+             * the call */
+            call = pptp_call_open(conn, call_ID,call_callback, phonenr,window);
+            /* Read and store the associated pids */
+            read(s, &lci->pid[0], sizeof(lci->pid[0]));
+            read(s, &lci->pid[1], sizeof(lci->pid[1]));
+            /* associate the local information with the call */
+            pptp_call_closure_put(conn, call, (void *) lci);
+            /* The rest is done on callback. */
+            /* Keep alive; wait for close */
+            retval = vector_insert(call_list, s, call); assert(retval);
+            if (s > max_fd) max_fd = s;
+            FD_SET(s, &call_set);
+            first = 0;
+        }
+skip_accept: /* Step 5c: Handle socket close */
+        for (i = 0; i < max_fd + 1; i++)
+            if (FD_ISSET(i, &read_set)) {
+                /* close it */
+                PPTP_CALL * call;
+                retval = vector_search(call_list, i, &call);
+                if (retval) {
+                    struct local_callinfo *lci =
+                        pptp_call_closure_get(conn, call);
+                    dbglog("Closing connection (unhandled)");
+                    free(lci);
+                    /* soft shutdown.  Callback will do hard shutdown later */
+                    pptp_call_close(conn, call);
+                    vector_remove(call_list, i);
+                }
+                FD_CLR(i, &call_set);
+                close(i);
+            }
+    } while (vector_size(call_list) > 0 || first);
+shutdown:
+    {
+        int rc;
+        fd_set read_set, write_set;
+        struct timeval tv;
+	signal(SIGINT, callmgr_do_nothing);
+	signal(SIGTERM, callmgr_do_nothing);
+        /* warn("Shutdown"); */
+        /* kill all open calls */
+        for (i = 0; i < vector_size(call_list); i++) {
+            PPTP_CALL *call = vector_get_Nth(call_list, i);
+            dbglog("Closing connection (shutdown)");
+            pptp_call_close(conn, call);
+        }
+        /* attempt to dispatch these messages */
+        FD_ZERO(&read_set);
+        FD_ZERO(&write_set);
+        pptp_fd_set(conn, &read_set, &write_set, &max_fd);
+	tv.tv_sec = 0;
+	tv.tv_usec = 0;
+	select(max_fd + 1, &read_set, &write_set, NULL, &tv);
+        rc = pptp_dispatch(conn, &read_set, &write_set);
+	if (rc > 0) {
+	  /* wait for a respond, a timeout because there might not be one */
+	  FD_ZERO(&read_set);
+	  FD_ZERO(&write_set);
+	  pptp_fd_set(conn, &read_set, &write_set, &max_fd);
+	  tv.tv_sec = 2;
+	  tv.tv_usec = 0;
+	  select(max_fd + 1, &read_set, &write_set, NULL, &tv);
+	  rc = pptp_dispatch(conn, &read_set, &write_set);
+	  if (rc > 0) {
+	    if (i > 0) sleep(2);
+	    /* no more open calls.  Close the connection. */
+	    pptp_conn_close(conn, PPTP_STOP_LOCAL_SHUTDOWN);
+	    /* wait for a respond, a timeout because there might not be one */
+	    FD_ZERO(&read_set);
+	    FD_ZERO(&write_set);
+	    pptp_fd_set(conn, &read_set, &write_set, &max_fd);
+	    tv.tv_sec = 2;
+	    tv.tv_usec = 0;
+	    select(max_fd + 1, &read_set, &write_set, NULL, &tv);
+	    pptp_dispatch(conn, &read_set, &write_set);
+	    if (rc > 0) sleep(2);
+	  }
+	}
+        /* with extreme prejudice */
+        pptp_conn_destroy(conn);
+        vector_destroy(call_list);
+    }
+cleanup:
+    signal(SIGINT, callmgr_do_nothing);
+    signal(SIGTERM, callmgr_do_nothing);
+    close_inetsock(inet_sock, inetaddr);
+    close_unixsock(unix_sock, inetaddr);
+    return 0;
+}
+
+/*** open_inetsock ************************************************************/
+int open_inetsock(struct in_addr inetaddr)
+{
+    struct sockaddr_in dest, src;
+    int s;
+    dest.sin_family = AF_INET;
+    dest.sin_port   = htons(PPTP_PORT);
+    dest.sin_addr   = inetaddr;
+    if ((s = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
+        warn("socket: %s", strerror(errno));
+        return s;
+    }
+    if (localbind.s_addr != INADDR_NONE) {
+        bzero(&src, sizeof(src));
+        src.sin_family = AF_INET;
+        src.sin_addr   = localbind;
+        if (bind(s, (struct sockaddr *) &src, sizeof(src)) != 0) {
+            warn("bind: %s", strerror(errno));
+            close(s); return -1;
+        }
+    }
+    if (connect(s, (struct sockaddr *) &dest, sizeof(dest)) < 0) {
+        warn("connect: %s", strerror(errno));
+        close(s); return -1;
+    }
+    return s;
+}
+
+/*** open_unixsock ************************************************************/
+int open_unixsock(struct in_addr inetaddr)
+{
+    struct sockaddr_un where;
+    struct stat st;
+    char *dir;
+    int s;
+    if ((s = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {
+        warn("socket: %s", strerror(errno));
+        return s;
+    }
+    callmgr_name_unixsock( &where, inetaddr, localbind);
+    if (stat(where.sun_path, &st) >= 0)
+    {
+        warn("Call manager for %s is already running.", inet_ntoa(inetaddr));
+        close(s); return -1;
+    }
+   /* Make sure path is valid. */
+    dir = dirnamex(where.sun_path);
+    if (!make_valid_path(dir, 0770))
+        fatal("Could not make path to %s: %s", where.sun_path, strerror(errno));
+    free(dir);
+    if (bind(s, (struct sockaddr *) &where, sizeof(where)) < 0) {
+        warn("bind: %s", strerror(errno));
+        close(s); return -1;
+    }
+    chmod(where.sun_path, 0777);
+    listen(s, 127);
+    return s;
+}
+
+/*** close_inetsock ***********************************************************/
+void close_inetsock(int fd, struct in_addr inetaddr)
+{
+    close(fd);
+}
+
+/*** close_unixsock ***********************************************************/
+void close_unixsock(int fd, struct in_addr inetaddr)
+{
+    struct sockaddr_un where;
+    close(fd);
+    callmgr_name_unixsock(&where, inetaddr, localbind);
+    unlink(where.sun_path);
+}
+
+/*** make a unix socket address ***********************************************/
+void callmgr_name_unixsock(struct sockaddr_un *where,
+			   struct in_addr inetaddr,
+			   struct in_addr localbind)
+{
+    char localaddr[16], remoteaddr[16];
+    where->sun_family = AF_UNIX;
+    strncpy(localaddr,  inet_ntoa(localbind), 16);
+    strncpy(remoteaddr, inet_ntoa(inetaddr),  16);
+    snprintf(where->sun_path, sizeof(where->sun_path),
+            PPTP_SOCKET_PREFIX "%s:%i", remoteaddr,call_ID);
+}
diff --git a/pppd/plugins/pptp/pptp_callmgr.h b/pppd/plugins/pptp/pptp_callmgr.h
new file mode 100644
index 0000000..634243a
--- /dev/null
+++ b/pppd/plugins/pptp/pptp_callmgr.h
@@ -0,0 +1,17 @@
+/* pptp_callmgr.h ... Call manager for PPTP connections.
+ *                    Handles TCP port 1723 protocol.
+ *                    C. Scott Ananian <cananian@alumni.princeton.edu>
+ *
+ * $Id: pptp_callmgr.h,v 1.3 2003/02/17 00:22:17 quozl Exp $
+ */
+
+#define PPTP_SOCKET_PREFIX "/var/run/pptp/"
+
+int callmgr_main(struct in_addr inetaddr,
+		char phonenr[],
+		int window,
+		int pcallid);
+
+void callmgr_name_unixsock(struct sockaddr_un *where,
+			   struct in_addr inetaddr,
+			   struct in_addr localbind);
diff --git a/pppd/plugins/pptp/pptp_ctrl.c b/pppd/plugins/pptp/pptp_ctrl.c
new file mode 100644
index 0000000..9712d9a
--- /dev/null
+++ b/pppd/plugins/pptp/pptp_ctrl.c
@@ -0,0 +1,1077 @@
+/* pptp_ctrl.c ... handle PPTP control connection.
+ *                 C. Scott Ananian <cananian@alumni.princeton.edu>
+ *
+ * $Id: pptp_ctrl.c,v 1.31 2005/03/31 07:42:39 quozl Exp $
+ */
+
+#include <errno.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <assert.h>
+#include <signal.h>
+#include <string.h>
+#include <ctype.h>
+#include <fcntl.h>
+#include "pptp_msg.h"
+#include "pptp_ctrl.h"
+#include "pptp_options.h"
+#include "vector.h"
+#include "util.h"
+#include "pptp_quirks.h"
+
+/* BECAUSE OF SIGNAL LIMITATIONS, EACH PROCESS CAN ONLY MANAGE ONE
+ * CONNECTION.  SO THIS 'PPTP_CONN' STRUCTURE IS A BIT MISLEADING.
+ * WE'LL KEEP CONNECTION-SPECIFIC INFORMATION IN THERE ANYWAY (AS
+ * OPPOSED TO USING GLOBAL VARIABLES), BUT BEWARE THAT THE ENTIRE
+ * UNIX SIGNAL-HANDLING SEMANTICS WOULD HAVE TO CHANGE (OR THE
+ * TIME-OUT CODE DRASTICALLY REWRITTEN) BEFORE YOU COULD DO A
+ * PPTP_CONN_OPEN MORE THAN ONCE PER PROCESS AND GET AWAY WITH IT.
+ */
+
+/* This structure contains connection-specific information that the
+ * signal handler needs to see.  Thus, it needs to be in a global
+ * variable.  If you end up using pthreads or something (why not
+ * just processes?), this would have to be placed in a thread-specific
+ * data area, using pthread_get|set_specific, etc., so I've
+ * conveniently encapsulated it for you.
+ * [linux threads will have to support thread-specific signals
+ *  before this would work at all, which, as of this writing
+ *  (linux-threads v0.6, linux kernel 2.1.72), it does not.]
+ */
+
+/* Globals */
+
+/* control the number of times echo packets will be logged */
+static int nlogecho = 10;
+
+static struct thread_specific {
+    struct sigaction old_sigaction; /* evil signals */
+    PPTP_CONN * conn;
+} global;
+
+#define INITIAL_BUFSIZE 512 /* initial i/o buffer size. */
+
+struct PPTP_CONN {
+    int inet_sock;
+    /* Connection States */
+    enum {
+        CONN_IDLE, CONN_WAIT_CTL_REPLY, CONN_WAIT_STOP_REPLY, CONN_ESTABLISHED
+    } conn_state; /* on startup: CONN_IDLE */
+    /* Keep-alive states */
+    enum {
+        KA_NONE, KA_OUTSTANDING
+    } ka_state;  /* on startup: KA_NONE */
+    /* Keep-alive ID; monotonically increasing (watch wrap-around!) */
+    u_int32_t ka_id; /* on startup: 1 */
+    /* Other properties. */
+    u_int16_t version;
+    u_int16_t firmware_rev;
+    u_int8_t  hostname[64], vendor[64];
+    /* XXX these are only PNS properties, currently XXX */
+    /* Call assignment information. */
+    u_int16_t call_serial_number;
+    VECTOR *call;
+    void * closure;
+    pptp_conn_cb callback;
+    /******* IO buffers ******/
+    char * read_buffer, *write_buffer;
+    size_t read_alloc,   write_alloc;
+    size_t read_size,    write_size;
+};
+
+struct PPTP_CALL {
+    /* Call properties */
+    enum {
+        PPTP_CALL_PAC, PPTP_CALL_PNS
+    } call_type;
+    union {
+        enum pptp_pac_state {
+            PAC_IDLE, PAC_WAIT_REPLY, PAC_ESTABLISHED, PAC_WAIT_CS_ANS
+        } pac;
+        enum pptp_pns_state {
+            PNS_IDLE, PNS_WAIT_REPLY, PNS_ESTABLISHED, PNS_WAIT_DISCONNECT
+        } pns;
+    } state;
+    u_int16_t call_id, peer_call_id;
+    u_int16_t sernum;
+    u_int32_t speed;
+    /* For user data: */
+    pptp_call_cb callback;
+    void * closure;
+};
+
+
+/* PPTP error codes: ----------------------------------------------*/
+
+/* (General Error Codes) */
+static const struct {
+    const char *name, *desc;
+} pptp_general_errors[] = {
+#define PPTP_GENERAL_ERROR_NONE                 0
+    { "(None)", "No general error" },
+#define PPTP_GENERAL_ERROR_NOT_CONNECTED        1
+    { "(Not-Connected)", "No control connection exists yet for this "
+        "PAC-PNS pair" },
+#define PPTP_GENERAL_ERROR_BAD_FORMAT           2
+    { "(Bad-Format)", "Length is wrong or Magic Cookie value is incorrect" },
+#define PPTP_GENERAL_ERROR_BAD_VALUE            3
+    { "(Bad-Value)", "One of the field values was out of range or "
+            "reserved field was non-zero" },
+#define PPTP_GENERAL_ERROR_NO_RESOURCE          4
+    { "(No-Resource)", "Insufficient resources to handle this command now" },
+#define PPTP_GENERAL_ERROR_BAD_CALLID           5
+    { "(Bad-Call ID)", "The Call ID is invalid in this context" },
+#define PPTP_GENERAL_ERROR_PAC_ERROR            6
+    { "(PAC-Error)", "A generic vendor-specific error occured in the PAC" }
+};
+
+#define  MAX_GENERAL_ERROR ( sizeof(pptp_general_errors) / \
+        sizeof(pptp_general_errors[0]) - 1)
+
+/* Outgoing Call Reply Result Codes */
+static const char *pptp_out_call_reply_result[] = {
+/* 0 */	"Unknown Result Code",
+/* 1 */	"Connected",
+/* 2 */	"General Error",
+/* 3 */	"No Carrier Detected",
+/* 4 */	"Busy Signal",
+/* 5 */	"No Dial Tone",
+/* 6 */	"Time Out",
+/* 7 */	"Not Accepted, Call is administratively prohibited" };
+
+#define MAX_OUT_CALL_REPLY_RESULT 7
+
+/* Call Disconnect Notify  Result Codes */
+static const char *pptp_call_disc_ntfy[] = {
+/* 0 */	"Unknown Result Code",
+/* 1 */	"Lost Carrier",
+/* 2 */	"General Error",
+/* 3 */	"Administrative Shutdown",
+/* 4 */	"(your) Request" };
+
+#define MAX_CALL_DISC_NTFY 4
+
+/* Call Disconnect Notify  Result Codes */
+static const char *pptp_start_ctrl_conn_rply[] = {
+/* 0 */	"Unknown Result Code",
+/* 1 */	"Successful Channel Establishment",
+/* 2 */	"General Error",
+/* 3 */	"Command Channel Already Exists",
+/* 4 */	"Requester is not Authorized" };
+
+#define MAX_START_CTRL_CONN_REPLY 4
+
+/* timing options */
+int idle_wait = PPTP_TIMEOUT;
+int max_echo_wait = PPTP_TIMEOUT;
+
+/* Local prototypes */
+static void pptp_reset_timer(void);
+static void pptp_handle_timer();
+/* Write/read as much as we can without blocking. */
+int pptp_write_some(PPTP_CONN * conn);
+int pptp_read_some(PPTP_CONN * conn);
+/* Make valid packets from read_buffer */
+int pptp_make_packet(PPTP_CONN * conn, void **buf, size_t *size);
+/* Add packet to write_buffer */
+int pptp_send_ctrl_packet(PPTP_CONN * conn, void * buffer, size_t size);
+/* Dispatch packets (general) */
+int pptp_dispatch_packet(PPTP_CONN * conn, void * buffer, size_t size);
+/* Dispatch packets (control messages) */
+int ctrlp_disp(PPTP_CONN * conn, void * buffer, size_t size);
+/* Set link info, for pptp servers that need it.
+   this is a noop, unless the user specified a quirk and
+   there's a set_link hook defined in the quirks table
+   for that quirk */
+void pptp_set_link(PPTP_CONN * conn, int peer_call_id);
+
+/*** log error information in control packets *********************************/
+static void ctrlp_error( int result, int error, int cause,
+        const char *result_text[], int max_result)
+{
+    if( cause >= 0)
+        warn("Result code is %d '%s'. Error code is %d, Cause code is %d",
+                result, result_text[result <= max_result ?  result : 0], error,
+                cause );
+    else
+        warn("Reply result code is %d '%s'. Error code is %d",
+                result, result_text[result <= max_result ?  result : 0], error);
+    if ((error > 0) && (error <= MAX_GENERAL_ERROR)){
+        if( result != PPTP_RESULT_GENERAL_ERROR )
+            warn("Result code is something else then \"general error\", "
+                    "so the following error is probably bogus.");
+        warn("Error is '%s', Error message: '%s'",
+                pptp_general_errors[error].name,
+                pptp_general_errors[error].desc);
+    }
+}
+
+static const char *ctrl_msg_types[] = {
+         "invalid control message type",
+/*         (Control Connection Management) */
+         "Start-Control-Connection-Request",            /* 1 */
+         "Start-Control-Connection-Reply",              /* 2 */
+         "Stop-Control-Connection-Request",             /* 3 */
+         "Stop-Control-Connection-Reply",               /* 4 */
+         "Echo-Request",                                /* 5 */
+         "Echo-Reply",                                  /* 6 */
+/*         (Call Management) */
+         "Outgoing-Call-Request",                       /* 7 */
+         "Outgoing-Call-Reply",                         /* 8 */
+         "Incoming-Call-Request",                       /* 9 */
+         "Incoming-Call-Reply",                        /* 10 */
+         "Incoming-Call-Connected",                    /* 11 */
+         "Call-Clear-Request",                         /* 12 */
+         "Call-Disconnect-Notify",                     /* 13 */
+/*         (Error Reporting) */
+         "WAN-Error-Notify",                           /* 14 */
+/*         (PPP Session Control) */
+         "Set-Link-Info"                              /* 15 */
+};
+#define MAX_CTRLMSG_TYPE 15
+
+/*** report a sent packet ****************************************************/
+static void ctrlp_rep( void * buffer, int size, int isbuff)
+{
+    struct pptp_header *packet = buffer;
+    unsigned int type;
+    if(size < sizeof(struct pptp_header)) return;
+    type = ntoh16(packet->ctrl_type);
+    /* FIXME: do not report sending echo requests as long as they are
+     * sent in a signal handler. This may dead lock as the syslog call
+     * is not reentrant */
+    if( type ==  PPTP_ECHO_RQST ) return;
+    /* don't keep reporting sending of echo's */
+    if( (type == PPTP_ECHO_RQST || type == PPTP_ECHO_RPLY) && nlogecho <= 0 ) return;
+    dbglog("%s control packet type is %d '%s'\n",isbuff ? "Buffered" : "Sent",
+            type, ctrl_msg_types[type <= MAX_CTRLMSG_TYPE ? type : 0]);
+
+}
+
+
+
+/* Open new pptp_connection.  Returns NULL on failure. */
+PPTP_CONN * pptp_conn_open(int inet_sock, int isclient, pptp_conn_cb callback)
+{
+    PPTP_CONN *conn;
+    /* Allocate structure */
+    if ((conn = malloc(sizeof(*conn))) == NULL) return NULL;
+    if ((conn->call = vector_create()) == NULL) { free(conn); return NULL; }
+    /* Initialize */
+    conn->inet_sock = inet_sock;
+    conn->conn_state = CONN_IDLE;
+    conn->ka_state  = KA_NONE;
+    conn->ka_id     = 1;
+    conn->call_serial_number = 0;
+    conn->callback  = callback;
+    /* Create I/O buffers */
+    conn->read_size = conn->write_size = 0;
+    conn->read_alloc = conn->write_alloc = INITIAL_BUFSIZE;
+    conn->read_buffer =
+        malloc(sizeof(*(conn->read_buffer)) * conn->read_alloc);
+    conn->write_buffer =
+        malloc(sizeof(*(conn->write_buffer)) * conn->write_alloc);
+    if (conn->read_buffer == NULL || conn->write_buffer == NULL) {
+        if (conn->read_buffer  != NULL) free(conn->read_buffer);
+        if (conn->write_buffer != NULL) free(conn->write_buffer);
+        vector_destroy(conn->call); free(conn); return NULL;
+    }
+    /* Make this socket non-blocking. */
+    fcntl(conn->inet_sock, F_SETFL, O_NONBLOCK);
+    /* Request connection from server, if this is a client */
+    if (isclient) {
+        struct pptp_start_ctrl_conn packet = {
+            PPTP_HEADER_CTRL(PPTP_START_CTRL_CONN_RQST),
+            hton16(PPTP_VERSION), 0, 0,
+            hton32(PPTP_FRAME_CAP), hton32(PPTP_BEARER_CAP),
+            hton16(PPTP_MAX_CHANNELS), hton16(PPTP_FIRMWARE_VERSION),
+            PPTP_HOSTNAME, PPTP_VENDOR
+        };
+        /* fix this packet, if necessary */
+        int idx, rc;
+        idx = get_quirk_index();
+        if (idx != -1 && pptp_fixups[idx].start_ctrl_conn) {
+            if ((rc = pptp_fixups[idx].start_ctrl_conn(&packet)))
+                warn("calling the start_ctrl_conn hook failed (%d)", rc);
+        }
+        if (pptp_send_ctrl_packet(conn, &packet, sizeof(packet)))
+            conn->conn_state = CONN_WAIT_CTL_REPLY;
+        else
+            return NULL; /* could not send initial start request. */
+    }
+    /* Set up interval/keep-alive timer */
+    /*   First, register handler for SIGALRM */
+    sigpipe_create();
+    sigpipe_assign(SIGALRM);
+    global.conn = conn;
+    /* Reset event timer */
+    pptp_reset_timer();
+    /* all done. */
+    return conn;
+}
+
+int pptp_conn_established(PPTP_CONN *conn) {
+  return (conn->conn_state == CONN_ESTABLISHED);
+}
+
+/* This currently *only* works for client call requests.
+ * We need to do something else to allocate calls for incoming requests.
+ */
+PPTP_CALL * pptp_call_open(PPTP_CONN * conn, int call_id,pptp_call_cb callback,
+        char *phonenr,int window)
+{
+    PPTP_CALL * call;
+    int idx, rc;
+    /* Send off the call request */
+    struct pptp_out_call_rqst packet = {
+        PPTP_HEADER_CTRL(PPTP_OUT_CALL_RQST),
+        0,0, /*call_id, sernum */
+        hton32(PPTP_BPS_MIN), hton32(PPTP_BPS_MAX),
+        hton32(PPTP_BEARER_CAP), hton32(PPTP_FRAME_CAP),
+        hton16(window), 0, 0, 0, {0}, {0}
+    };
+    assert(conn && conn->call);
+    assert(conn->conn_state == CONN_ESTABLISHED);
+    /* Assign call id */
+    if (!call_id && !vector_scan(conn->call, 0, PPTP_MAX_CHANNELS - 1, &call_id))
+        /* no more calls available! */
+        return NULL;
+    /* allocate structure. */
+    if ((call = malloc(sizeof(*call))) == NULL) return NULL;
+    /* Initialize call structure */
+    call->call_type = PPTP_CALL_PNS;
+    call->state.pns = PNS_IDLE;
+    call->call_id   = (u_int16_t) call_id;
+    call->sernum    = conn->call_serial_number++;
+    call->callback  = callback;
+    call->closure   = NULL;
+    packet.call_id = htons(call->call_id);
+    packet.call_sernum = htons(call->sernum);
+    /* if we have a quirk, build a new packet to fit it */
+    idx = get_quirk_index();
+    if (idx != -1 && pptp_fixups[idx].out_call_rqst_hook) {
+        if ((rc = pptp_fixups[idx].out_call_rqst_hook(&packet)))
+            warn("calling the out_call_rqst hook failed (%d)", rc);
+    }
+    /* fill in the phone number if it was specified */
+    if (phonenr) {
+        strncpy(packet.phone_num, phonenr, sizeof(packet.phone_num));
+        packet.phone_len = strlen(phonenr);
+        if( packet.phone_len > sizeof(packet.phone_num))
+            packet.phone_len = sizeof(packet.phone_num);
+        packet.phone_len = hton16 (packet.phone_len);
+    }
+    if (pptp_send_ctrl_packet(conn, &packet, sizeof(packet))) {
+        pptp_reset_timer();
+        call->state.pns = PNS_WAIT_REPLY;
+        /* and add it to the call vector */
+        vector_insert(conn->call, call_id, call);
+        return call;
+    } else { /* oops, unsuccessful. Deallocate. */
+        free(call);
+        return NULL;
+    }
+}
+
+/*** pptp_call_close **********************************************************/
+void pptp_call_close(PPTP_CONN * conn, PPTP_CALL * call)
+{
+    struct pptp_call_clear_rqst rqst = {
+        PPTP_HEADER_CTRL(PPTP_CALL_CLEAR_RQST), 0, 0
+    };
+    assert(conn && conn->call); assert(call);
+    assert(vector_contains(conn->call, call->call_id));
+    /* haven't thought about PAC yet */
+    assert(call->call_type == PPTP_CALL_PNS);
+    assert(call->state.pns != PNS_IDLE);
+    rqst.call_id = hton16(call->call_id);
+    /* don't check state against WAIT_DISCONNECT... allow multiple disconnect
+     * requests to be made.
+     */
+    pptp_send_ctrl_packet(conn, &rqst, sizeof(rqst));
+    pptp_reset_timer();
+    call->state.pns = PNS_WAIT_DISCONNECT;
+    /* call structure will be freed when we have confirmation of disconnect. */
+}
+
+/*** hard close ***************************************************************/
+void pptp_call_destroy(PPTP_CONN *conn, PPTP_CALL *call)
+{
+    assert(conn && conn->call); assert(call);
+    assert(vector_contains(conn->call, call->call_id));
+    /* notify */
+    if (call->callback != NULL) call->callback(conn, call, CALL_CLOSE_DONE);
+    /* deallocate */
+    vector_remove(conn->call, call->call_id);
+    free(call);
+}
+
+/*** this is a soft close *****************************************************/
+void pptp_conn_close(PPTP_CONN * conn, u_int8_t close_reason)
+{
+    struct pptp_stop_ctrl_conn rqst = {
+        PPTP_HEADER_CTRL(PPTP_STOP_CTRL_CONN_RQST),
+        hton8(close_reason), 0, 0
+    };
+    int i;
+    assert(conn && conn->call);
+    /* avoid repeated close attempts */
+    if (conn->conn_state == CONN_IDLE || conn->conn_state == CONN_WAIT_STOP_REPLY)
+        return;
+    /* close open calls, if any */
+    for (i = 0; i < vector_size(conn->call); i++)
+        pptp_call_close(conn, vector_get_Nth(conn->call, i));
+    /* now close connection */
+    info("Closing PPTP connection");
+    pptp_send_ctrl_packet(conn, &rqst, sizeof(rqst));
+    pptp_reset_timer(); /* wait 60 seconds for reply */
+    conn->conn_state = CONN_WAIT_STOP_REPLY;
+    return;
+}
+
+/*** this is a hard close *****************************************************/
+void pptp_conn_destroy(PPTP_CONN * conn)
+{
+    int i;
+    assert(conn != NULL); assert(conn->call != NULL);
+    /* destroy all open calls */
+    for (i = 0; i < vector_size(conn->call); i++)
+        pptp_call_destroy(conn, vector_get_Nth(conn->call, i));
+    /* notify */
+    if (conn->callback != NULL) conn->callback(conn, CONN_CLOSE_DONE);
+    sigpipe_close();
+    close(conn->inet_sock);
+    /* deallocate */
+    vector_destroy(conn->call);
+    free(conn);
+}
+
+/*** Deal with messages, in a non-blocking manner
+ * Add file descriptors used by pptp to fd_set.
+ */
+void pptp_fd_set(PPTP_CONN * conn, fd_set * read_set, fd_set * write_set,
+                 int * max_fd)
+{
+    assert(conn && conn->call);
+    /* Add fd to write_set if there are outstanding writes. */
+    if (conn->write_size > 0)
+        FD_SET(conn->inet_sock, write_set);
+    /* Always add fd to read_set. (always want something to read) */
+    FD_SET(conn->inet_sock, read_set);
+    if (*max_fd < conn->inet_sock) *max_fd = conn->inet_sock;
+    /* Add signal pipe file descriptor to set */
+    int sig_fd = sigpipe_fd();
+    FD_SET(sig_fd, read_set);
+    if (*max_fd < sig_fd) *max_fd = sig_fd;
+}
+
+/*** handle any pptp file descriptors set in fd_set, and clear them ***********/
+int pptp_dispatch(PPTP_CONN * conn, fd_set * read_set, fd_set * write_set)
+{
+    int r = 0;
+    assert(conn && conn->call);
+    /* Check for signals */
+    if (FD_ISSET(sigpipe_fd(), read_set)) {
+        if (sigpipe_read() == SIGALRM) pptp_handle_timer();
+	FD_CLR(sigpipe_fd(), read_set);
+    }
+    /* Check write_set could be set. */
+    if (FD_ISSET(conn->inet_sock, write_set)) {
+        FD_CLR(conn->inet_sock, write_set);
+        if (conn->write_size > 0)
+            r = pptp_write_some(conn);/* write as much as we can without blocking */
+    }
+    /* Check read_set */
+    if (r >= 0 && FD_ISSET(conn->inet_sock, read_set)) {
+        void *buffer; size_t size;
+        FD_CLR(conn->inet_sock, read_set);
+        r = pptp_read_some(conn); /* read as much as we can without blocking */
+	if (r < 0)
+	    return r;
+        /* make packets of the buffer, while we can. */
+        while (r >= 0 && pptp_make_packet(conn, &buffer, &size)) {
+            r = pptp_dispatch_packet(conn, buffer, size);
+            free(buffer);
+        }
+    }
+    /* That's all, folks.  Simple, eh? */
+    return r;
+}
+
+/*** Non-blocking write *******************************************************/
+int pptp_write_some(PPTP_CONN * conn) {
+    ssize_t retval;
+    assert(conn && conn->call);
+    retval = write(conn->inet_sock, conn->write_buffer, conn->write_size);
+    if (retval < 0) { /* error. */
+        if (errno == EAGAIN || errno == EINTR) {
+            return 0;
+        } else { /* a real error */
+            warn("write error: %s", strerror(errno));
+	    return -1;
+        }
+    }
+    assert(retval <= conn->write_size);
+    conn->write_size -= retval;
+    memmove(conn->write_buffer, conn->write_buffer + retval, conn->write_size);
+    ctrlp_rep(conn->write_buffer, retval, 0);
+    return 0;
+}
+
+/*** Non-blocking read ********************************************************/
+int pptp_read_some(PPTP_CONN * conn)
+{
+    ssize_t retval;
+    assert(conn && conn->call);
+    if (conn->read_size == conn->read_alloc) { /* need to alloc more memory */
+        char *new_buffer = realloc(conn->read_buffer,
+                sizeof(*(conn->read_buffer)) * conn->read_alloc * 2);
+        if (new_buffer == NULL) {
+            warn("Out of memory"); return -1;
+        }
+        conn->read_alloc *= 2;
+        conn->read_buffer = new_buffer;
+    }
+    retval = read(conn->inet_sock, conn->read_buffer + conn->read_size,
+            conn->read_alloc  - conn->read_size);
+    if (retval == 0) {
+        warn("read returned zero, peer has closed");
+        return -1;
+    }
+    if (retval < 0) {
+        if (errno == EINTR || errno == EAGAIN)
+	    return 0;
+        else { /* a real error */
+            warn("read error: %s", strerror(errno));
+            return -1;
+        }
+    }
+    conn->read_size += retval;
+    assert(conn->read_size <= conn->read_alloc);
+    return 0;
+}
+
+/*** Packet formation *********************************************************/
+int pptp_make_packet(PPTP_CONN * conn, void **buf, size_t *size)
+{
+    struct pptp_header *header;
+    size_t bad_bytes = 0;
+    assert(conn && conn->call); assert(buf != NULL); assert(size != NULL);
+    /* Give up unless there are at least sizeof(pptp_header) bytes */
+    while ((conn->read_size-bad_bytes) >= sizeof(struct pptp_header)) {
+        /* Throw out bytes until we have a valid header. */
+        header = (struct pptp_header *) (conn->read_buffer + bad_bytes);
+        if (ntoh32(header->magic) != PPTP_MAGIC) goto throwitout;
+        if (ntoh16(header->reserved0) != 0)
+            warn("reserved0 field is not zero! (0x%x) Cisco feature? \n",
+                    ntoh16(header->reserved0));
+        if (ntoh16(header->length) < sizeof(struct pptp_header)) goto throwitout;
+        if (ntoh16(header->length) > PPTP_CTRL_SIZE_MAX) goto throwitout;
+        /* well.  I guess it's good. Let's see if we've got it all. */
+        if (ntoh16(header->length) > (conn->read_size-bad_bytes))
+            /* nope.  Let's wait until we've got it, then. */
+            goto flushbadbytes;
+        /* One last check: */
+        if ((ntoh16(header->pptp_type) == PPTP_MESSAGE_CONTROL) &&
+                (ntoh16(header->length) !=
+                         PPTP_CTRL_SIZE(ntoh16(header->ctrl_type))))
+            goto throwitout;
+        /* well, I guess we've got it. */
+        *size = ntoh16(header->length);
+        *buf = malloc(*size);
+        if (*buf == NULL) { warn("Out of memory."); return 0; /* ack! */ }
+        memcpy(*buf, conn->read_buffer + bad_bytes, *size);
+        /* Delete this packet from the read_buffer. */
+        conn->read_size -= (bad_bytes + *size);
+        memmove(conn->read_buffer, conn->read_buffer + bad_bytes + *size,
+                conn->read_size);
+        if (bad_bytes > 0)
+            warn("%lu bad bytes thrown away.", (unsigned long) bad_bytes);
+        return 1;
+throwitout:
+        bad_bytes++;
+    }
+flushbadbytes:
+    /* no more packets.  Let's get rid of those bad bytes */
+    conn->read_size -= bad_bytes;
+    memmove(conn->read_buffer, conn->read_buffer + bad_bytes, conn->read_size);
+    if (bad_bytes > 0)
+        warn("%lu bad bytes thrown away.", (unsigned long) bad_bytes);
+    return 0;
+}
+
+/*** pptp_send_ctrl_packet ****************************************************/
+int pptp_send_ctrl_packet(PPTP_CONN * conn, void * buffer, size_t size)
+{
+    assert(conn && conn->call); assert(buffer);
+    if( conn->write_size > 0) pptp_write_some( conn);
+    if( conn->write_size == 0) {
+        ssize_t retval;
+        retval = write(conn->inet_sock, buffer, size);
+        if (retval < 0) { /* error. */
+            if (errno == EAGAIN || errno == EINTR) {
+                /* ignore */;
+                retval = 0;
+            } else { /* a real error */
+                warn("write error: %s", strerror(errno));
+                pptp_conn_destroy(conn); /* shut down fast. */
+                return 0;
+            }
+        }
+        ctrlp_rep( buffer, retval, 0);
+        size -= retval;
+        if( size <= 0) return 1;
+    }
+    /* Shove anything not written into the write buffer */
+    if (conn->write_size + size > conn->write_alloc) { /* need more memory */
+        char *new_buffer = realloc(conn->write_buffer,
+                sizeof(*(conn->write_buffer)) * conn->write_alloc * 2);
+        if (new_buffer == NULL) {
+            warn("Out of memory"); return 0;
+        }
+        conn->write_alloc *= 2;
+        conn->write_buffer = new_buffer;
+    }
+    memcpy(conn->write_buffer + conn->write_size, buffer, size);
+    conn->write_size += size;
+    ctrlp_rep( buffer,size,1);
+    return 1;
+}
+
+/*** Packet Dispatch **********************************************************/
+int pptp_dispatch_packet(PPTP_CONN * conn, void * buffer, size_t size)
+{
+    int r = 0;
+    struct pptp_header *header = (struct pptp_header *)buffer;
+    assert(conn && conn->call); assert(buffer);
+    assert(ntoh32(header->magic) == PPTP_MAGIC);
+    assert(ntoh16(header->length) == size);
+    switch (ntoh16(header->pptp_type)) {
+        case PPTP_MESSAGE_CONTROL:
+            r = ctrlp_disp(conn, buffer, size);
+            break;
+        case PPTP_MESSAGE_MANAGE:
+            /* MANAGEMENT messages aren't even part of the spec right now. */
+            dbglog("PPTP management message received, but not understood.");
+            break;
+        default:
+            dbglog("Unknown PPTP control message type received: %u",
+                    (unsigned int) ntoh16(header->pptp_type));
+            break;
+    }
+    return r;
+}
+
+/*** log echo request/replies *************************************************/
+static void logecho( int type)
+{
+    /* hack to stop flooding the log files (the most interesting part is right
+     * after the connection built-up) */
+    if( nlogecho > 0) {
+        dbglog("Echo Re%s received.", type == PPTP_ECHO_RQST ? "quest" :"ply");
+        if( --nlogecho == 0)
+            dbglog("no more Echo Reply/Request packets will be reported.");
+    }
+}
+
+/*** pptp_dispatch_ctrl_packet ************************************************/
+int ctrlp_disp(PPTP_CONN * conn, void * buffer, size_t size)
+{
+    struct pptp_header *header = (struct pptp_header *)buffer;
+    u_int8_t close_reason = PPTP_STOP_NONE;
+    assert(conn && conn->call); assert(buffer);
+    assert(ntoh32(header->magic) == PPTP_MAGIC);
+    assert(ntoh16(header->length) == size);
+    assert(ntoh16(header->pptp_type) == PPTP_MESSAGE_CONTROL);
+    if (size < PPTP_CTRL_SIZE(ntoh16(header->ctrl_type))) {
+        warn("Invalid packet received [type: %d; length: %d].",
+                (int) ntoh16(header->ctrl_type), (int) size);
+        return 0;
+    }
+    switch (ntoh16(header->ctrl_type)) {
+        /* ----------- STANDARD Start-Session MESSAGES ------------ */
+        case PPTP_START_CTRL_CONN_RQST:
+        {
+            struct pptp_start_ctrl_conn *packet =
+                (struct pptp_start_ctrl_conn *) buffer;
+            struct pptp_start_ctrl_conn reply = {
+                PPTP_HEADER_CTRL(PPTP_START_CTRL_CONN_RPLY),
+                hton16(PPTP_VERSION), 0, 0,
+                hton32(PPTP_FRAME_CAP), hton32(PPTP_BEARER_CAP),
+                hton16(PPTP_MAX_CHANNELS), hton16(PPTP_FIRMWARE_VERSION),
+                PPTP_HOSTNAME, PPTP_VENDOR };
+            int idx, rc;
+            dbglog("Received Start Control Connection Request");
+            /* fix this packet, if necessary */
+            idx = get_quirk_index();
+            if (idx != -1 && pptp_fixups[idx].start_ctrl_conn) {
+                if ((rc = pptp_fixups[idx].start_ctrl_conn(&reply)))
+                    warn("calling the start_ctrl_conn hook failed (%d)", rc);
+            }
+            if (conn->conn_state == CONN_IDLE) {
+                if (ntoh16(packet->version) < PPTP_VERSION) {
+                    /* Can't support this (earlier) PPTP_VERSION */
+                    reply.version = packet->version;
+                    /* protocol version not supported */
+                    reply.result_code = hton8(5);
+                    pptp_send_ctrl_packet(conn, &reply, sizeof(reply));
+                    pptp_reset_timer(); /* give sender a chance for a retry */
+                } else { /* same or greater version */
+                    if (pptp_send_ctrl_packet(conn, &reply, sizeof(reply))) {
+                        conn->conn_state = CONN_ESTABLISHED;
+                        dbglog("server connection ESTABLISHED.");
+                        pptp_reset_timer();
+                    }
+                }
+            }
+            break;
+        }
+        case PPTP_START_CTRL_CONN_RPLY:
+        {
+            struct pptp_start_ctrl_conn *packet =
+                (struct pptp_start_ctrl_conn *) buffer;
+            dbglog("Received Start Control Connection Reply");
+            if (conn->conn_state == CONN_WAIT_CTL_REPLY) {
+                /* XXX handle collision XXX [see rfc] */
+                if (ntoh16(packet->version) != PPTP_VERSION) {
+                    if (conn->callback != NULL)
+                        conn->callback(conn, CONN_OPEN_FAIL);
+                    close_reason = PPTP_STOP_PROTOCOL;
+                    goto pptp_conn_close;
+                }
+                if (ntoh8(packet->result_code) != 1 &&
+                    /* J'ai change le if () afin que la connection ne se ferme
+                     * pas pour un "rien" :p adel@cybercable.fr -
+                     *
+                     * Don't close the connection if the result code is zero
+                     * (feature found in certain ADSL modems)
+                     */
+                        ntoh8(packet->result_code) != 0) {
+                    dbglog("Negative reply received to our Start Control "
+                            "Connection Request");
+                    ctrlp_error(packet->result_code, packet->error_code,
+                            -1, pptp_start_ctrl_conn_rply,
+                            MAX_START_CTRL_CONN_REPLY);
+                    if (conn->callback != NULL)
+                        conn->callback(conn, CONN_OPEN_FAIL);
+                    close_reason = PPTP_STOP_PROTOCOL;
+                    goto pptp_conn_close;
+                }
+                conn->conn_state = CONN_ESTABLISHED;
+                /* log session properties */
+                conn->version      = ntoh16(packet->version);
+                conn->firmware_rev = ntoh16(packet->firmware_rev);
+                memcpy(conn->hostname, packet->hostname, sizeof(conn->hostname));
+                memcpy(conn->vendor, packet->vendor, sizeof(conn->vendor));
+                pptp_reset_timer(); /* 60 seconds until keep-alive */
+                dbglog("Client connection established.");
+                if (conn->callback != NULL)
+                    conn->callback(conn, CONN_OPEN_DONE);
+            } /* else goto pptp_conn_close; */
+            break;
+        }
+            /* ----------- STANDARD Stop-Session MESSAGES ------------ */
+        case PPTP_STOP_CTRL_CONN_RQST:
+        {
+            /* conn_state should be CONN_ESTABLISHED, but it could be
+             * something else */
+            struct pptp_stop_ctrl_conn reply = {
+                PPTP_HEADER_CTRL(PPTP_STOP_CTRL_CONN_RPLY),
+                hton8(1), hton8(PPTP_GENERAL_ERROR_NONE), 0
+            };
+            dbglog("Received Stop Control Connection Request.");
+            if (conn->conn_state == CONN_IDLE) break;
+            if (pptp_send_ctrl_packet(conn, &reply, sizeof(reply))) {
+                if (conn->callback != NULL)
+                    conn->callback(conn, CONN_CLOSE_RQST);
+                conn->conn_state = CONN_IDLE;
+		return -1;
+            }
+            break;
+        }
+        case PPTP_STOP_CTRL_CONN_RPLY:
+        {
+            dbglog("Received Stop Control Connection Reply.");
+            /* conn_state should be CONN_WAIT_STOP_REPLY, but it
+             * could be something else */
+            if (conn->conn_state == CONN_IDLE) break;
+            conn->conn_state = CONN_IDLE;
+	    return -1;
+        }
+            /* ----------- STANDARD Echo/Keepalive MESSAGES ------------ */
+        case PPTP_ECHO_RPLY:
+        {
+            struct pptp_echo_rply *packet =
+                (struct pptp_echo_rply *) buffer;
+            logecho( PPTP_ECHO_RPLY);
+            if ((conn->ka_state == KA_OUTSTANDING) &&
+                    (ntoh32(packet->identifier) == conn->ka_id)) {
+                conn->ka_id++;
+                conn->ka_state = KA_NONE;
+                pptp_reset_timer();
+            }
+            break;
+        }
+        case PPTP_ECHO_RQST:
+        {
+            struct pptp_echo_rqst *packet =
+                (struct pptp_echo_rqst *) buffer;
+            struct pptp_echo_rply reply = {
+                PPTP_HEADER_CTRL(PPTP_ECHO_RPLY),
+                packet->identifier, /* skip hton32(ntoh32(id)) */
+                hton8(1), hton8(PPTP_GENERAL_ERROR_NONE), 0
+            };
+            logecho( PPTP_ECHO_RQST);
+            pptp_send_ctrl_packet(conn, &reply, sizeof(reply));
+            pptp_reset_timer();
+            break;
+        }
+            /* ----------- OUTGOING CALL MESSAGES ------------ */
+        case PPTP_OUT_CALL_RQST:
+        {
+            struct pptp_out_call_rqst *packet =
+                (struct pptp_out_call_rqst *)buffer;
+            struct pptp_out_call_rply reply = {
+                PPTP_HEADER_CTRL(PPTP_OUT_CALL_RPLY),
+                0 /* callid */, packet->call_id, 1, PPTP_GENERAL_ERROR_NONE, 0,
+                hton32(PPTP_CONNECT_SPEED),
+                hton16(PPTP_WINDOW), hton16(PPTP_DELAY), 0
+            };
+            dbglog("Received Outgoing Call Request.");
+            /* XXX PAC: eventually this should make an outgoing call. XXX */
+            reply.result_code = hton8(7); /* outgoing calls verboten */
+            pptp_send_ctrl_packet(conn, &reply, sizeof(reply));
+            break;
+        }
+        case PPTP_OUT_CALL_RPLY:
+        {
+            struct pptp_out_call_rply *packet =
+                (struct pptp_out_call_rply *)buffer;
+            PPTP_CALL * call;
+            u_int16_t callid = ntoh16(packet->call_id_peer);
+            dbglog("Received Outgoing Call Reply.");
+            if (!vector_search(conn->call, (int) callid, &call)) {
+                dbglog("PPTP_OUT_CALL_RPLY received for non-existant call: "
+                        "peer call ID (us)  %d call ID (them) %d.",
+                        callid, ntoh16(packet->call_id));
+                break;
+            }
+            if (call->call_type != PPTP_CALL_PNS) {
+                dbglog("Ack!  How did this call_type get here?"); /* XXX? */
+                break;
+            }
+            if (call->state.pns != PNS_WAIT_REPLY) {
+                warn("Unexpected(?) Outgoing Call Reply will be ignored.");
+                break;
+            }
+            /* check for errors */
+            if (packet->result_code != 1) {
+                /* An error.  Log it verbosely. */
+                dbglog("Our outgoing call request [callid %d] has not been "
+                        "accepted.", (int) callid);
+                ctrlp_error(packet->result_code, packet->error_code,
+                        packet->cause_code, pptp_out_call_reply_result,
+                        MAX_OUT_CALL_REPLY_RESULT);
+                call->state.pns = PNS_IDLE;
+                if (call->callback != NULL)
+                    call->callback(conn, call, CALL_OPEN_FAIL);
+                pptp_call_destroy(conn, call);
+            } else {
+                /* connection established */
+                call->state.pns = PNS_ESTABLISHED;
+                call->peer_call_id = ntoh16(packet->call_id);
+                call->speed        = ntoh32(packet->speed);
+                pptp_reset_timer();
+                /* call pptp_set_link. unless the user specified a quirk
+                   and this quirk has a set_link hook, this is a noop */
+                pptp_set_link(conn, call->peer_call_id);
+                if (call->callback != NULL)
+                    call->callback(conn, call, CALL_OPEN_DONE);
+                dbglog("Outgoing call established (call ID %u, peer's "
+                        "call ID %u).\n", call->call_id, call->peer_call_id);
+            }
+            break;
+        }
+            /* ----------- INCOMING CALL MESSAGES ------------ */
+            /* XXX write me XXX */
+            /* ----------- CALL CONTROL MESSAGES ------------ */
+        case PPTP_CALL_CLEAR_RQST:
+        {
+            struct pptp_call_clear_rqst *packet =
+                (struct pptp_call_clear_rqst *)buffer;
+            struct pptp_call_clear_ntfy reply = {
+                PPTP_HEADER_CTRL(PPTP_CALL_CLEAR_NTFY), packet->call_id,
+                1, PPTP_GENERAL_ERROR_NONE, 0, 0, {0}
+            };
+            dbglog("Received Call Clear Request.");
+            if (vector_contains(conn->call, ntoh16(packet->call_id))) {
+                PPTP_CALL * call;
+                vector_search(conn->call, ntoh16(packet->call_id), &call);
+                if (call->callback != NULL)
+                    call->callback(conn, call, CALL_CLOSE_RQST);
+                pptp_send_ctrl_packet(conn, &reply, sizeof(reply));
+                pptp_call_destroy(conn, call);
+                dbglog("Call closed (RQST) (call id %d)", (int) call->call_id);
+            }
+            break;
+        }
+        case PPTP_CALL_CLEAR_NTFY:
+        {
+            struct pptp_call_clear_ntfy *packet =
+                (struct pptp_call_clear_ntfy *)buffer;
+            dbglog("Call disconnect notification received (call id %d)",
+                    ntoh16(packet->call_id));
+            if (vector_contains(conn->call, ntoh16(packet->call_id))) {
+                PPTP_CALL * call;
+                ctrlp_error(packet->result_code, packet->error_code,
+                        packet->cause_code, pptp_call_disc_ntfy,
+                        MAX_CALL_DISC_NTFY);
+                vector_search(conn->call, ntoh16(packet->call_id), &call);
+                pptp_call_destroy(conn, call);
+            }
+            /* XXX we could log call stats here XXX */
+            /* XXX not all servers send this XXX */
+            break;
+        }
+        case PPTP_SET_LINK_INFO:
+        {
+            /* I HAVE NO CLUE WHAT TO DO IF send_accm IS NOT 0! */
+            /* this is really dealt with in the HDLC deencapsulation, anyway. */
+            struct pptp_set_link_info *packet =
+                (struct pptp_set_link_info *)buffer;
+            /* log it. */
+            dbglog("PPTP_SET_LINK_INFO received from peer_callid %u",
+                    (unsigned int) ntoh16(packet->call_id_peer));
+            dbglog("  send_accm is %08lX, recv_accm is %08lX",
+                    (unsigned long) ntoh32(packet->send_accm),
+                    (unsigned long) ntoh32(packet->recv_accm));
+            if (!(ntoh32(packet->send_accm) == 0 &&
+                    ntoh32(packet->recv_accm) == 0))
+                warn("Non-zero Async Control Character Maps are not supported!");
+            break;
+        }
+        default:
+            dbglog("Unrecognized Packet %d received.",
+                    (int) ntoh16(((struct pptp_header *)buffer)->ctrl_type));
+            /* goto pptp_conn_close; */
+            break;
+    }
+    return 0;
+pptp_conn_close:
+    warn("pptp_conn_close(%d)", (int) close_reason);
+    pptp_conn_close(conn, close_reason);
+    return 0;
+}
+
+/*** pptp_set_link **************************************************************/
+void pptp_set_link(PPTP_CONN* conn, int peer_call_id)
+{
+    int idx, rc;
+    /* if we need to send a set_link packet because of buggy
+       hardware or pptp server, do it now */
+    if ((idx = get_quirk_index()) != -1 && pptp_fixups[idx].set_link_hook) {
+        struct pptp_set_link_info packet;
+        if ((rc = pptp_fixups[idx].set_link_hook(&packet, peer_call_id)))
+            warn("calling the set_link hook failed (%d)", rc);
+        if (pptp_send_ctrl_packet(conn, &packet, sizeof(packet))) {
+            pptp_reset_timer();
+        }
+    }
+}
+
+/*** Get info from call structure *********************************************/
+/* NOTE: The peer_call_id is undefined until we get a server response. */
+void pptp_call_get_ids(PPTP_CONN * conn, PPTP_CALL * call,
+		       u_int16_t * call_id, u_int16_t * peer_call_id)
+{
+    assert(conn != NULL); assert(call != NULL);
+    *call_id = call->call_id;
+    *peer_call_id = call->peer_call_id;
+}
+
+/*** pptp_call_closure_put ****************************************************/
+void   pptp_call_closure_put(PPTP_CONN * conn, PPTP_CALL * call, void *cl)
+{
+    assert(conn != NULL); assert(call != NULL);
+    call->closure = cl;
+}
+
+/*** pptp_call_closure_get ****************************************************/
+void * pptp_call_closure_get(PPTP_CONN * conn, PPTP_CALL * call)
+{
+    assert(conn != NULL); assert(call != NULL);
+    return call->closure;
+}
+
+/*** pptp_conn_closure_put ****************************************************/
+void   pptp_conn_closure_put(PPTP_CONN * conn, void *cl)
+{
+    assert(conn != NULL);
+    conn->closure = cl;
+}
+
+/*** pptp_conn_closure_get ****************************************************/
+void * pptp_conn_closure_get(PPTP_CONN * conn)
+{
+    assert(conn != NULL);
+    return conn->closure;
+}
+
+/*** Reset keep-alive timer ***************************************************/
+static void pptp_reset_timer(void)
+{
+    const struct itimerval tv = { {  0, 0 },   /* stop on time-out */
+        { idle_wait, 0 } };
+    if (idle_wait) setitimer(ITIMER_REAL, &tv, NULL);
+}
+
+
+/*** Handle keep-alive timer **************************************************/
+static void pptp_handle_timer()
+{
+    int i;
+    /* "Keep Alives and Timers, 1": check connection state */
+    if (global.conn->conn_state != CONN_ESTABLISHED) {
+        if (global.conn->conn_state == CONN_WAIT_STOP_REPLY)
+            /* hard close. */
+            pptp_conn_destroy(global.conn);
+        else /* soft close */
+            pptp_conn_close(global.conn, PPTP_STOP_NONE);
+    }
+    /* "Keep Alives and Timers, 2": check echo status */
+    if (global.conn->ka_state == KA_OUTSTANDING) {
+        /* no response to keep-alive */
+        info("closing control connection due to missing echo reply");
+	pptp_conn_close(global.conn, PPTP_STOP_NONE);
+    } else { /* ka_state == NONE */ /* send keep-alive */
+        struct pptp_echo_rqst rqst = {
+            PPTP_HEADER_CTRL(PPTP_ECHO_RQST), hton32(global.conn->ka_id) };
+        pptp_send_ctrl_packet(global.conn, &rqst, sizeof(rqst));
+        global.conn->ka_state = KA_OUTSTANDING;
+    }
+    /* check incoming/outgoing call states for !IDLE && !ESTABLISHED */
+    for (i = 0; i < vector_size(global.conn->call); i++) {
+        PPTP_CALL * call = vector_get_Nth(global.conn->call, i);
+        if (call->call_type == PPTP_CALL_PNS) {
+            if (call->state.pns == PNS_WAIT_REPLY) {
+                /* send close request */
+                pptp_call_close(global.conn, call);
+                assert(call->state.pns == PNS_WAIT_DISCONNECT);
+            } else if (call->state.pns == PNS_WAIT_DISCONNECT) {
+                /* hard-close the call */
+                pptp_call_destroy(global.conn, call);
+            }
+        } else if (call->call_type == PPTP_CALL_PAC) {
+            if (call->state.pac == PAC_WAIT_REPLY) {
+                /* XXX FIXME -- drop the PAC connection XXX */
+            } else if (call->state.pac == PAC_WAIT_CS_ANS) {
+                /* XXX FIXME -- drop the PAC connection XXX */
+            }
+        }
+    }
+    pptp_reset_timer();
+}
diff --git a/pppd/plugins/pptp/pptp_ctrl.h b/pppd/plugins/pptp/pptp_ctrl.h
new file mode 100644
index 0000000..a7bb506
--- /dev/null
+++ b/pppd/plugins/pptp/pptp_ctrl.h
@@ -0,0 +1,57 @@
+/* pptp_ctrl.h ... handle PPTP control connection.
+ *                 C. Scott Ananian <cananian@alumni.princeton.edu>
+ *
+ * $Id: pptp_ctrl.h,v 1.5 2004/11/09 01:42:32 quozl Exp $
+ */
+
+#ifndef INC_PPTP_CTRL_H
+#define INC_PPTP_CTRL_H
+#include <sys/types.h>
+
+typedef struct PPTP_CONN PPTP_CONN;
+typedef struct PPTP_CALL PPTP_CALL;
+
+enum call_state { CALL_OPEN_RQST,  CALL_OPEN_DONE, CALL_OPEN_FAIL,
+		  CALL_CLOSE_RQST, CALL_CLOSE_DONE };
+enum conn_state { CONN_OPEN_RQST,  CONN_OPEN_DONE, CONN_OPEN_FAIL,
+		  CONN_CLOSE_RQST, CONN_CLOSE_DONE };
+
+typedef void (*pptp_call_cb)(PPTP_CONN*, PPTP_CALL*, enum call_state);
+typedef void (*pptp_conn_cb)(PPTP_CONN*, enum conn_state);
+
+/* if 'isclient' is true, then will send 'conn open' packet to other host.
+ * not necessary if this is being opened by a server process after
+ * receiving a conn_open packet from client.
+ */
+PPTP_CONN * pptp_conn_open(int inet_sock, int isclient,
+			   pptp_conn_cb callback);
+PPTP_CALL * pptp_call_open(PPTP_CONN * conn, int call_id,
+			   pptp_call_cb callback, char *phonenr,int window);
+int pptp_conn_established(PPTP_CONN * conn);
+/* soft close.  Will callback on completion. */
+void pptp_call_close(PPTP_CONN * conn, PPTP_CALL * call);
+/* hard close. */
+void pptp_call_destroy(PPTP_CONN *conn, PPTP_CALL *call);
+/* soft close.  Will callback on completion. */
+void pptp_conn_close(PPTP_CONN * conn, u_int8_t close_reason);
+/* hard close */
+void pptp_conn_destroy(PPTP_CONN * conn);
+
+/* Add file descriptors used by pptp to fd_set. */
+void pptp_fd_set(PPTP_CONN * conn, fd_set * read_set, fd_set * write_set, int *max_fd);
+/* handle any pptp file descriptors set in fd_set, and clear them */
+int pptp_dispatch(PPTP_CONN * conn, fd_set * read_set, fd_set * write_set);
+
+/* Get info about connection, call */
+void pptp_call_get_ids(PPTP_CONN * conn, PPTP_CALL * call,
+		       u_int16_t * call_id, u_int16_t * peer_call_id);
+/* Arbitrary user data about this call/connection.
+ * It is the caller's responsibility to free this data before calling
+ * pptp_call|conn_close()
+ */
+void * pptp_conn_closure_get(PPTP_CONN * conn);
+void   pptp_conn_closure_put(PPTP_CONN * conn, void *cl);
+void * pptp_call_closure_get(PPTP_CONN * conn, PPTP_CALL * call);
+void   pptp_call_closure_put(PPTP_CONN * conn, PPTP_CALL * call, void *cl);
+
+#endif /* INC_PPTP_CTRL_H */
diff --git a/pppd/plugins/pptp/pptp_msg.h b/pppd/plugins/pptp/pptp_msg.h
new file mode 100644
index 0000000..e50ce0c
--- /dev/null
+++ b/pppd/plugins/pptp/pptp_msg.h
@@ -0,0 +1,303 @@
+/*  pptp.h:  packet structures and magic constants for the PPTP protocol 
+ *           C. Scott Ananian <cananian@alumni.princeton.edu>            
+ *
+ * $Id: pptp_msg.h,v 1.3 2003/02/15 10:37:21 quozl Exp $
+ */
+
+#ifndef INC_PPTP_H
+#define INC_PPTP_H
+
+/* Grab definitions of int16, int32, etc. */
+#include <sys/types.h>
+/* define "portable" htons, etc. */
+#define hton8(x)  (x)
+#define ntoh8(x)  (x)
+#define hton16(x) htons(x)
+#define ntoh16(x) ntohs(x)
+#define hton32(x) htonl(x)
+#define ntoh32(x) ntohl(x)
+
+/* PPTP magic numbers: ----------------------------------------- */
+
+#define PPTP_MAGIC 0x1A2B3C4D /* Magic cookie for PPTP datagrams */
+#define PPTP_PORT  1723       /* PPTP TCP port number            */
+#define PPTP_PROTO 47         /* PPTP IP protocol number         */
+
+/* Control Connection Message Types: --------------------------- */
+
+#define PPTP_MESSAGE_CONTROL		1
+#define PPTP_MESSAGE_MANAGE		2
+
+/* Control Message Types: -------------------------------------- */
+
+/* (Control Connection Management) */
+#define PPTP_START_CTRL_CONN_RQST	1
+#define PPTP_START_CTRL_CONN_RPLY	2
+#define PPTP_STOP_CTRL_CONN_RQST	3
+#define PPTP_STOP_CTRL_CONN_RPLY	4
+#define PPTP_ECHO_RQST			5
+#define PPTP_ECHO_RPLY			6
+
+/* (Call Management) */
+#define PPTP_OUT_CALL_RQST		7
+#define PPTP_OUT_CALL_RPLY		8
+#define PPTP_IN_CALL_RQST		9
+#define PPTP_IN_CALL_RPLY		10
+#define PPTP_IN_CALL_CONNECT		11
+#define PPTP_CALL_CLEAR_RQST		12
+#define PPTP_CALL_CLEAR_NTFY		13
+
+/* (Error Reporting) */
+#define PPTP_WAN_ERR_NTFY		14
+
+/* (PPP Session Control) */
+#define PPTP_SET_LINK_INFO		15
+
+/* PPTP version information: --------------------------------------*/
+#define PPTP_VERSION_STRING	"1.00"
+#define PPTP_VERSION		0x100
+#define PPTP_FIRMWARE_STRING	"0.01"
+#define PPTP_FIRMWARE_VERSION	0x001
+
+/* PPTP capabilities: ---------------------------------------------*/
+
+/* (Framing capabilities for msg sender) */
+#define PPTP_FRAME_ASYNC	1
+#define PPTP_FRAME_SYNC		2
+#define PPTP_FRAME_ANY          3
+
+/* (Bearer capabilities for msg sender) */
+#define PPTP_BEARER_ANALOG	1
+#define PPTP_BEARER_DIGITAL 	2
+#define PPTP_BEARER_ANY		3
+
+#define PPTP_RESULT_GENERAL_ERROR 2
+
+/* (Reasons to close a connection) */
+#define PPTP_STOP_NONE		  1 /* no good reason                        */
+#define PPTP_STOP_PROTOCOL	  2 /* can't support peer's protocol version */
+#define PPTP_STOP_LOCAL_SHUTDOWN  3 /* requester is being shut down          */
+
+/* PPTP datagram structures (all data in network byte order): ----------*/
+
+struct pptp_header {
+  u_int16_t length;	  /* message length in octets, including header */
+  u_int16_t pptp_type;	  /* PPTP message type. 1 for control message.  */
+  u_int32_t magic;	  /* this should be PPTP_MAGIC.                 */
+  u_int16_t ctrl_type;	  /* Control message type (0-15)                */
+  u_int16_t reserved0;	  /* reserved.  MUST BE ZERO.                   */
+};
+
+struct pptp_start_ctrl_conn { /* for control message types 1 and 2 */
+  struct pptp_header header;
+
+  u_int16_t version;      /* PPTP protocol version.  = PPTP_VERSION     */
+  u_int8_t  result_code;  /* these two fields should be zero on rqst msg*/
+  u_int8_t  error_code;   /* 0 unless result_code==2 (General Error)    */
+  u_int32_t framing_cap;  /* Framing capabilities                       */
+  u_int32_t bearer_cap;   /* Bearer Capabilities                        */
+  u_int16_t max_channels; /* Maximum Channels (=0 for PNS, PAC ignores) */
+  u_int16_t firmware_rev; /* Firmware or Software Revision              */
+  u_int8_t  hostname[64]; /* Host Name (64 octets, zero terminated)     */
+  u_int8_t  vendor[64];   /* Vendor string (64 octets, zero term.)      */
+  /* MS says that end of hostname/vendor fields should be filled with   */
+  /* octets of value 0, but Win95 PPTP driver doesn't do this.          */
+};
+
+struct pptp_stop_ctrl_conn { /* for control message types 3 and 4 */
+  struct pptp_header header;
+
+  u_int8_t reason_result; /* reason for rqst, result for rply          */
+  u_int8_t error_code;	  /* MUST be 0, unless rply result==2 (general err)*/
+  u_int16_t reserved1;    /* MUST be 0                                */
+};
+
+struct pptp_echo_rqst { /* for control message type 5 */
+  struct pptp_header header;
+  u_int32_t identifier;   /* arbitrary value set by sender which is used */
+                          /* to match up reply and request               */
+};
+
+struct pptp_echo_rply { /* for control message type 6 */
+  struct pptp_header header;
+  u_int32_t identifier;	  /* should correspond to id of rqst             */
+  u_int8_t result_code;
+  u_int8_t error_code;    /* =0, unless result_code==2 (general error)   */
+  u_int16_t reserved1;    /* MUST BE ZERO                                */
+};
+
+struct pptp_out_call_rqst { /* for control message type 7 */
+  struct pptp_header header;
+  u_int16_t call_id;	  /* Call ID (unique id used to multiplex data)  */
+  u_int16_t call_sernum;  /* Call Serial Number (used for logging)       */
+  u_int32_t bps_min;      /* Minimum BPS (lowest acceptable line speed)  */
+  u_int32_t bps_max;	  /* Maximum BPS (highest acceptable line speed) */
+  u_int32_t bearer;	  /* Bearer type                                 */
+  u_int32_t framing;      /* Framing type                                */
+  u_int16_t recv_size;	  /* Recv. Window Size (no. of buffered packets) */
+  u_int16_t delay;	  /* Packet Processing Delay (in 1/10 sec)       */
+  u_int16_t phone_len;	  /* Phone Number Length (num. of valid digits)  */
+  u_int16_t reserved1;    /* MUST BE ZERO				 */
+  u_int8_t  phone_num[64]; /* Phone Number (64 octets, null term.)       */
+  u_int8_t subaddress[64]; /* Subaddress (64 octets, null term.)         */
+};
+
+struct pptp_out_call_rply { /* for control message type 8 */
+  struct pptp_header header;
+  u_int16_t call_id;      /* Call ID (used to multiplex data over tunnel)*/
+  u_int16_t call_id_peer; /* Peer's Call ID (call_id of pptp_out_call_rqst)*/
+  u_int8_t  result_code;  /* Result Code (1 is no errors)                */
+  u_int8_t  error_code;   /* Error Code (=0 unless result_code==2)       */
+  u_int16_t cause_code;   /* Cause Code (addt'l failure information)     */
+  u_int32_t speed;        /* Connect Speed (in BPS)                      */
+  u_int16_t recv_size;    /* Recv. Window Size (no. of buffered packets) */
+  u_int16_t delay;	  /* Packet Processing Delay (in 1/10 sec)       */
+  u_int32_t channel;      /* Physical Channel ID (for logging)           */
+};
+
+struct pptp_in_call_rqst { /* for control message type 9 */
+  struct pptp_header header;
+  u_int16_t call_id;	  /* Call ID (unique id used to multiplex data)  */
+  u_int16_t call_sernum;  /* Call Serial Number (used for logging)       */
+  u_int32_t bearer;	  /* Bearer type                                 */
+  u_int32_t channel;      /* Physical Channel ID (for logging)           */
+  u_int16_t dialed_len;   /* Dialed Number Length (# of valid digits)    */
+  u_int16_t dialing_len;  /* Dialing Number Length (# of valid digits)   */
+  u_int8_t dialed_num[64]; /* Dialed Number (64 octets, zero term.)      */
+  u_int8_t dialing_num[64]; /* Dialing Number (64 octets, zero term.)    */
+  u_int8_t subaddress[64];  /* Subaddress (64 octets, zero term.)        */
+};
+
+struct pptp_in_call_rply { /* for control message type 10 */
+  struct pptp_header header;
+  u_int16_t call_id;      /* Call ID (used to multiplex data over tunnel)*/
+  u_int16_t call_id_peer; /* Peer's Call ID (call_id of pptp_out_call_rqst)*/
+  u_int8_t  result_code;  /* Result Code (1 is no errors)                */
+  u_int8_t  error_code;   /* Error Code (=0 unless result_code==2)       */
+  u_int16_t recv_size;    /* Recv. Window Size (no. of buffered packets) */
+  u_int16_t delay;	  /* Packet Processing Delay (in 1/10 sec)       */
+  u_int16_t reserved1;    /* MUST BE ZERO                                */
+};
+
+struct pptp_in_call_connect { /* for control message type 11 */
+  struct pptp_header header;
+  u_int16_t call_id_peer; /* Peer's Call ID (call_id of pptp_out_call_rqst)*/
+  u_int16_t reserved1;    /* MUST BE ZERO                                */
+  u_int32_t speed;        /* Connect Speed (in BPS)                      */
+  u_int16_t recv_size;    /* Recv. Window Size (no. of buffered packets) */
+  u_int16_t delay;	  /* Packet Processing Delay (in 1/10 sec)       */
+  u_int32_t framing;      /* Framing type                                */
+};
+
+struct pptp_call_clear_rqst { /* for control message type 12 */
+  struct pptp_header header;
+  u_int16_t call_id;      /* Call ID (used to multiplex data over tunnel)*/
+  u_int16_t reserved1;    /* MUST BE ZERO                                */
+};
+
+struct pptp_call_clear_ntfy { /* for control message type 13 */
+  struct pptp_header header;
+  u_int16_t call_id;      /* Call ID (used to multiplex data over tunnel)*/
+  u_int8_t  result_code;  /* Result Code                                 */
+  u_int8_t  error_code;   /* Error Code (=0 unless result_code==2)       */
+  u_int16_t cause_code;   /* Cause Code (for ISDN, is Q.931 cause code)  */
+  u_int16_t reserved1;    /* MUST BE ZERO                                */
+  u_int8_t call_stats[128]; /* Call Statistics: 128 octets, ascii, 0-term */
+};
+
+struct pptp_wan_err_ntfy {    /* for control message type 14 */
+  struct pptp_header header;
+  u_int16_t call_id_peer; /* Peer's Call ID (call_id of pptp_out_call_rqst)*/
+  u_int16_t reserved1;    /* MUST BE ZERO                                */
+  u_int32_t crc_errors;   /* CRC errors 				 */
+  u_int32_t frame_errors; /* Framing errors 				 */
+  u_int32_t hard_errors;  /* Hardware overruns 				 */
+  u_int32_t buff_errors;  /* Buffer overruns				 */
+  u_int32_t time_errors;  /* Time-out errors				 */
+  u_int32_t align_errors; /* Alignment errors				 */
+};
+
+struct pptp_set_link_info {   /* for control message type 15 */
+  struct pptp_header header;
+  u_int16_t call_id_peer; /* Peer's Call ID (call_id of pptp_out_call_rqst) */
+  u_int16_t reserved1;    /* MUST BE ZERO                                   */
+  u_int32_t send_accm;    /* Send ACCM (for PPP packets; default 0xFFFFFFFF)*/
+  u_int32_t recv_accm;    /* Receive ACCM (for PPP pack.;default 0xFFFFFFFF)*/
+};
+
+/* helpful #defines: -------------------------------------------- */
+#define pptp_isvalid_ctrl(header, type, length) \
+ (!( ( ntoh16(((struct pptp_header *)header)->length)    < (length)  ) ||   \
+     ( ntoh16(((struct pptp_header *)header)->pptp_type) !=(type)    ) ||   \
+     ( ntoh32(((struct pptp_header *)header)->magic)     !=PPTP_MAGIC) ||   \
+     ( ntoh16(((struct pptp_header *)header)->ctrl_type) > PPTP_SET_LINK_INFO) || \
+     ( ntoh16(((struct pptp_header *)header)->reserved0) !=0         ) ))
+
+#define PPTP_HEADER_CTRL(type)  \
+{ hton16(PPTP_CTRL_SIZE(type)), \
+  hton16(PPTP_MESSAGE_CONTROL), \
+  hton32(PPTP_MAGIC),           \
+  hton16(type), 0 }             
+
+#define PPTP_CTRL_SIZE(type) ( \
+(type==PPTP_START_CTRL_CONN_RQST)?sizeof(struct pptp_start_ctrl_conn):	\
+(type==PPTP_START_CTRL_CONN_RPLY)?sizeof(struct pptp_start_ctrl_conn):	\
+(type==PPTP_STOP_CTRL_CONN_RQST )?sizeof(struct pptp_stop_ctrl_conn):	\
+(type==PPTP_STOP_CTRL_CONN_RPLY )?sizeof(struct pptp_stop_ctrl_conn):	\
+(type==PPTP_ECHO_RQST           )?sizeof(struct pptp_echo_rqst):	\
+(type==PPTP_ECHO_RPLY           )?sizeof(struct pptp_echo_rply):	\
+(type==PPTP_OUT_CALL_RQST       )?sizeof(struct pptp_out_call_rqst):	\
+(type==PPTP_OUT_CALL_RPLY       )?sizeof(struct pptp_out_call_rply):	\
+(type==PPTP_IN_CALL_RQST        )?sizeof(struct pptp_in_call_rqst):	\
+(type==PPTP_IN_CALL_RPLY        )?sizeof(struct pptp_in_call_rply):	\
+(type==PPTP_IN_CALL_CONNECT     )?sizeof(struct pptp_in_call_connect):	\
+(type==PPTP_CALL_CLEAR_RQST     )?sizeof(struct pptp_call_clear_rqst):	\
+(type==PPTP_CALL_CLEAR_NTFY     )?sizeof(struct pptp_call_clear_ntfy):	\
+(type==PPTP_WAN_ERR_NTFY        )?sizeof(struct pptp_wan_err_ntfy):	\
+(type==PPTP_SET_LINK_INFO       )?sizeof(struct pptp_set_link_info):	\
+0)
+#define max(a,b) (((a)>(b))?(a):(b))
+#define PPTP_CTRL_SIZE_MAX (			\
+max(sizeof(struct pptp_start_ctrl_conn),	\
+max(sizeof(struct pptp_echo_rqst),		\
+max(sizeof(struct pptp_echo_rply),		\
+max(sizeof(struct pptp_out_call_rqst),		\
+max(sizeof(struct pptp_out_call_rply),		\
+max(sizeof(struct pptp_in_call_rqst),		\
+max(sizeof(struct pptp_in_call_rply),		\
+max(sizeof(struct pptp_in_call_connect),	\
+max(sizeof(struct pptp_call_clear_rqst),	\
+max(sizeof(struct pptp_call_clear_ntfy),	\
+max(sizeof(struct pptp_wan_err_ntfy),		\
+max(sizeof(struct pptp_set_link_info), 0)))))))))))))
+
+
+/* gre header structure: -------------------------------------------- */
+
+#define PPTP_GRE_PROTO  0x880B
+#define PPTP_GRE_VER    0x1
+
+#define PPTP_GRE_FLAG_C	0x80
+#define PPTP_GRE_FLAG_R	0x40
+#define PPTP_GRE_FLAG_K	0x20
+#define PPTP_GRE_FLAG_S	0x10
+#define PPTP_GRE_FLAG_A	0x80
+
+#define PPTP_GRE_IS_C(f) ((f)&PPTP_GRE_FLAG_C)
+#define PPTP_GRE_IS_R(f) ((f)&PPTP_GRE_FLAG_R)
+#define PPTP_GRE_IS_K(f) ((f)&PPTP_GRE_FLAG_K)
+#define PPTP_GRE_IS_S(f) ((f)&PPTP_GRE_FLAG_S)
+#define PPTP_GRE_IS_A(f) ((f)&PPTP_GRE_FLAG_A)
+
+struct pptp_gre_header {
+  u_int8_t flags;		/* bitfield */
+  u_int8_t ver;			/* should be PPTP_GRE_VER (enhanced GRE) */
+  u_int16_t protocol;		/* should be PPTP_GRE_PROTO (ppp-encaps) */
+  u_int16_t payload_len;	/* size of ppp payload, not inc. gre header */
+  u_int16_t call_id;		/* peer's call_id for this session */
+  u_int32_t seq;		/* sequence number.  Present if S==1 */
+  u_int32_t ack;		/* seq number of highest packet recieved by */
+  				/*  sender in this session */
+};
+
+#endif /* INC_PPTP_H */
diff --git a/pppd/plugins/pptp/pptp_options.h b/pppd/plugins/pptp/pptp_options.h
new file mode 100644
index 0000000..ebc1c31
--- /dev/null
+++ b/pppd/plugins/pptp/pptp_options.h
@@ -0,0 +1,41 @@
+/* pptp_options.h ...... various constants used in the PPTP protocol.
+ *                       #define STANDARD to emulate NT 4.0 exactly.
+ *                       C. Scott Ananian <cananian@alumni.princeton.edu>
+ *
+ * $Id: pptp_options.h,v 1.3 2004/11/09 01:42:32 quozl Exp $
+ */
+
+#ifndef INC_PPTP_OPTIONS_H
+#define INC_PPTP_OPTIONS_H
+
+#undef  PPTP_FIRMWARE_STRING
+#undef  PPTP_FIRMWARE_VERSION
+#define PPTP_BUF_MAX 65536
+#define PPTP_TIMEOUT 60 /* seconds */
+extern int idle_wait;
+extern int max_echo_wait;
+#define PPTP_CONNECT_SPEED 1000000000
+#define PPTP_WINDOW 3
+#define PPTP_DELAY  0
+#define PPTP_BPS_MIN 2400
+#define PPTP_BPS_MAX 1000000000
+
+#ifndef STANDARD
+#define PPTP_MAX_CHANNELS 65535
+#define PPTP_FIRMWARE_STRING "0.01"
+#define PPTP_FIRMWARE_VERSION 0x001
+#define PPTP_HOSTNAME {'l','o','c','a','l',0}
+#define PPTP_VENDOR   {'c','a','n','a','n','i','a','n',0}
+#define PPTP_FRAME_CAP  PPTP_FRAME_ANY
+#define PPTP_BEARER_CAP PPTP_BEARER_ANY
+#else
+#define PPTP_MAX_CHANNELS 5
+#define PPTP_FIRMWARE_STRING "0.01"
+#define PPTP_FIRMWARE_VERSION 0
+#define PPTP_HOSTNAME {'l','o','c','a','l',0}
+#define PPTP_VENDOR   {'N','T',0}
+#define PPTP_FRAME_CAP  2
+#define PPTP_BEARER_CAP 1
+#endif
+
+#endif /* INC_PPTP_OPTIONS_H */
diff --git a/pppd/plugins/pptp/pptp_quirks.c b/pppd/plugins/pptp/pptp_quirks.c
new file mode 100644
index 0000000..e4c9013
--- /dev/null
+++ b/pppd/plugins/pptp/pptp_quirks.c
@@ -0,0 +1,54 @@
+/* pptp_quirks.c ...... various options to fix quirks found in buggy adsl modems
+ *                      mulix <mulix@actcom.co.il>
+ *
+ * $Id: pptp_quirks.c,v 1.2 2001/11/23 03:42:51 quozl Exp $
+ */
+
+#include <string.h>
+#include "orckit_quirks.h"
+#include "pptp_quirks.h"
+
+static int quirk_index = -1;
+
+struct pptp_fixup pptp_fixups[] = {
+    {BEZEQ_ISRAEL, ORCKIT, ORCKIT_ATUR3,
+     orckit_atur3_build_hook,
+     orckit_atur3_start_ctrl_conn_hook,
+     orckit_atur3_set_link_hook}
+};
+
+static int fixups_sz = sizeof(pptp_fixups)/sizeof(pptp_fixups[0]);
+
+/* return 0 on success, non 0 otherwise */
+int set_quirk_index(int index)
+{
+    if (index >= 0 && index < fixups_sz) {
+	quirk_index = index;
+	return 0;
+    }
+
+    return -1;
+}
+
+int get_quirk_index()
+{
+    return quirk_index;
+}
+
+/* return the index for this isp in the quirks table, -1 if not found */
+int find_quirk(const char* isp_name)
+{
+    int i = 0;
+    if (isp_name) {
+	while (i < fixups_sz && pptp_fixups[i].isp) {
+	    if (!strcmp(pptp_fixups[i].isp, isp_name)) {
+		return i;
+	    }
+	    ++i;
+	}
+    }
+
+    return -1;
+}
+
+
diff --git a/pppd/plugins/pptp/pptp_quirks.h b/pppd/plugins/pptp/pptp_quirks.h
new file mode 100644
index 0000000..291f3d6
--- /dev/null
+++ b/pppd/plugins/pptp/pptp_quirks.h
@@ -0,0 +1,59 @@
+/* pptp_quirks.h ...... various options to fix quirks found in buggy adsl modems
+ *                      mulix <mulix@actcom.co.il>
+ *
+ * $Id: pptp_quirks.h,v 1.1 2001/11/20 06:30:10 quozl Exp $
+ */
+
+#ifndef INC_PPTP_QUIRKS_H
+#define INC_PPTP_QUIRKS_H
+
+/* isp defs - correspond to slots in the fixups table */
+#define BEZEQ_ISRAEL "BEZEQ_ISRAEL"
+
+/* vendor defs */
+
+#define ORCKIT 1
+#define ALCATEL 2
+
+/* device defs */
+
+#define ORCKIT_ATUR2 1
+#define ORCKIT_ATUR3 2
+
+#include "pptp_msg.h"
+#include "pptp_ctrl.h"
+
+struct pptp_fixup {
+    const char* isp;    /* which isp? e.g. Bezeq in Israel */
+    int vendor; /* which vendor? e.g. Orckit */
+    int device; /* which device? e.g. Orckit Atur3 */
+
+    /* use this hook to build your own out call request packet */
+    int (*out_call_rqst_hook)(struct pptp_out_call_rqst* packet);
+
+    /* use this hook to build your own start control connection packet */
+    /* note that this hook is called from two different places, depending
+       on whether this is a request or reply */
+    int (*start_ctrl_conn)(struct pptp_start_ctrl_conn* packet);
+
+    /* use this hook if you need to send a 'set_link' packet once
+       the connection is established */
+    int (*set_link_hook)(struct pptp_set_link_info* packet,
+			 int peer_call_id);
+};
+
+extern struct pptp_fixup pptp_fixups[];
+
+/* find the index for this isp in the quirks table */
+/* return the index on success, -1 if not found */
+int find_quirk(const char* isp_name);
+
+/* set the global quirk index. return 0 on success, non 0 otherwise */
+int set_quirk_index(int index);
+
+/* get the global quirk index. return the index on success,
+   -1 if no quirk is defined */
+int get_quirk_index();
+
+
+#endif /* INC_PPTP_QUIRKS_H */
diff --git a/pppd/plugins/pptp/util.c b/pppd/plugins/pptp/util.c
new file mode 100644
index 0000000..49cd158
--- /dev/null
+++ b/pppd/plugins/pptp/util.c
@@ -0,0 +1,109 @@
+/* util.c ....... error message utilities.
+ *                C. Scott Ananian <cananian@alumni.princeton.edu>
+ *
+ * $Id: util.c,v 1.11 2005/08/22 00:49:48 quozl Exp $
+ */
+
+#include <stdio.h>
+#include <stdarg.h>
+#include <syslog.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include "util.h"
+
+#define MAKE_STRING(label) 				\
+va_list ap;						\
+char buf[256], string[256];				\
+va_start(ap, format);					\
+vsnprintf(buf, sizeof(buf), format, ap);		\
+snprintf(string, sizeof(string), "%s %s[%s:%s:%d]: %s",	\
+	 log_string, label, func, file, line, buf);	\
+va_end(ap)
+
+/*** connect a file to a file descriptor **************************************/
+int file2fd(const char *path, const char *mode, int fd)
+{
+    int ok = 0;
+    FILE *file = NULL;
+    file = fopen(path, mode);
+    if (file != NULL && dup2(fileno(file), fd) != -1)
+        ok = 1;
+    if (file) fclose(file);
+    return ok;
+}
+
+/* signal to pipe delivery implementation */
+#include <unistd.h>
+#include <fcntl.h>
+#include <signal.h>
+#include <string.h>
+
+/* pipe private to process */
+static int sigpipe[2];
+
+/* create a signal pipe, returns 0 for success, -1 with errno for failure */
+int sigpipe_create()
+{
+  int rc;
+  
+  rc = pipe(sigpipe);
+  if (rc < 0) return rc;
+  
+  fcntl(sigpipe[0], F_SETFD, FD_CLOEXEC);
+  fcntl(sigpipe[1], F_SETFD, FD_CLOEXEC);
+  
+#ifdef O_NONBLOCK
+#define FLAG_TO_SET O_NONBLOCK
+#else
+#ifdef SYSV
+#define FLAG_TO_SET O_NDELAY
+#else /* BSD */
+#define FLAG_TO_SET FNDELAY
+#endif
+#endif
+  
+  rc = fcntl(sigpipe[1], F_GETFL);
+  if (rc != -1)
+    rc = fcntl(sigpipe[1], F_SETFL, rc | FLAG_TO_SET);
+  if (rc < 0) return rc;
+  return 0;
+#undef FLAG_TO_SET
+}
+
+/* generic handler for signals, writes signal number to pipe */
+void sigpipe_handler(int signum)
+{
+  write(sigpipe[1], &signum, sizeof(signum));
+  signal(signum, sigpipe_handler);
+}
+
+/* assign a signal number to the pipe */
+void sigpipe_assign(int signum)
+{
+  struct sigaction sa;
+
+  memset(&sa, 0, sizeof(sa));
+  sa.sa_handler = sigpipe_handler;
+  sigaction(signum, &sa, NULL);
+}
+
+/* return the signal pipe read file descriptor for select(2) */
+int sigpipe_fd()
+{
+  return sigpipe[0];
+}
+
+/* read and return the pending signal from the pipe */
+int sigpipe_read()
+{
+  int signum;
+  read(sigpipe[0], &signum, sizeof(signum));
+  return signum;
+}
+
+void sigpipe_close()
+{
+  close(sigpipe[0]);
+  close(sigpipe[1]);
+}
+
diff --git a/pppd/plugins/pptp/util.h b/pppd/plugins/pptp/util.h
new file mode 100644
index 0000000..acc5a4f
--- /dev/null
+++ b/pppd/plugins/pptp/util.h
@@ -0,0 +1,31 @@
+/* util.h ....... error message utilities.
+ *                C. Scott Ananian <cananian@alumni.princeton.edu>
+ *
+ * $Id: util.h,v 1.6 2005/03/10 01:18:20 quozl Exp $
+ */
+
+#ifndef INC_UTIL_H
+#define INC_UTIL_H
+
+int file2fd(const char *path, const char *mode, int fd);
+
+/* signal to pipe delivery implementation */
+
+/* create a signal pipe, returns 0 for success, -1 with errno for failure */
+int sigpipe_create();
+
+/* generic handler for signals, writes signal number to pipe */
+void sigpipe_handler(int signum);
+
+/* assign a signal number to the pipe */
+void sigpipe_assign(int signum);
+
+/* return the signal pipe read file descriptor for select(2) */
+int sigpipe_fd();
+
+/* read and return the pending signal from the pipe */
+int sigpipe_read();
+
+void sigpipe_close();
+
+#endif /* INC_UTIL_H */
diff --git a/pppd/plugins/pptp/vector.c b/pppd/plugins/pptp/vector.c
new file mode 100644
index 0000000..a26c5de
--- /dev/null
+++ b/pppd/plugins/pptp/vector.c
@@ -0,0 +1,209 @@
+/* vector.c ..... store a vector of PPTP_CALL information and search it
+ *                efficiently.
+ *                C. Scott Ananian <cananian@alumni.princeton.edu>
+ *
+ * $Id: vector.c,v 1.3 2003/06/17 10:12:55 reink Exp $
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+#include "pptp_ctrl.h"
+#include "vector.h"
+/* #define VECTOR_DEBUG */
+#ifndef TRUE
+#define TRUE 1
+#endif
+#ifndef FALSE
+#define FALSE 0
+#endif
+
+struct vector_item {
+    int key;
+    PPTP_CALL *call;
+};
+
+struct vector_struct {
+    struct vector_item *item;
+    int size;
+    int alloc;
+#ifdef VECTOR_DEBUG
+    int key_max;
+#endif
+};
+
+static struct vector_item *binary_search(VECTOR *v, int key);
+
+/*** vector_create ************************************************************/
+VECTOR *vector_create()
+{
+    const int INITIAL_SIZE = 4;
+
+    VECTOR *v = malloc(sizeof(*v));
+    if (v == NULL) return v;
+
+    v->size = 0;
+    v->alloc = INITIAL_SIZE;
+    v->item = malloc(sizeof(*(v->item)) * (v->alloc));
+#ifdef VECTOR_DEBUG
+    v->key_max = -1;
+#endif
+    if (v->item == NULL) { free(v); return NULL; }
+    else return v;
+}
+
+/*** vector_destroy ***********************************************************/
+void vector_destroy(VECTOR *v)
+{
+    free(v->item);
+#ifdef VECTOR_DEBUG
+    v->item = NULL;
+#endif
+    free(v);
+}
+
+/*** vector_size **************************************************************/
+int vector_size(VECTOR *v)
+{
+    assert(v != NULL);
+    return v->size;
+}
+
+/*** vector_insert*************************************************************
+ * nice thing about file descriptors is that we are assured by POSIX 
+ * that they are monotonically increasing.
+ */
+int vector_insert(VECTOR *v, int key, PPTP_CALL * call)
+{
+    int i;
+    assert(v != NULL && call != NULL);
+    assert(!vector_contains(v, key));
+#ifdef VECTOR_DEBUG
+    assert(v->key_max < key);
+#endif
+    if (!(v->size < v->alloc)) {
+        void *tmp = realloc(v->item, sizeof(*(v->item)) * 2 * v->alloc);
+        if (tmp != NULL) {
+            v->alloc *= 2;
+            v->item = tmp;
+        } else return FALSE; /* failed to alloc memory. */
+    }
+    assert(v->size < v->alloc);
+    /* for safety, we make this work in the general case;
+     * but this is optimized for adding call to the end of the vector.
+     */
+    for(i = v->size - 1; i >= 0; i--)
+        if (v->item[i].key < key)
+            break;
+    /* insert after item i */
+    memmove(&v->item[i + 2], &v->item[i + 1],
+            (v->size - i - 1) * sizeof(*(v->item)));
+    v->item[i + 1].key  = key;
+    v->item[i + 1].call = call;
+    v->size++;
+#ifdef VECTOR_DEBUG
+    if (v->key_max < key) /* ie, always. */
+        v->key_max = key;
+#endif
+    return TRUE;
+}
+
+/*** vector_remove ************************************************************/
+int  vector_remove(VECTOR *v, int key)
+{
+    struct vector_item *tmp;
+    assert(v != NULL);
+    if ((tmp =binary_search(v,key)) == NULL) return FALSE;
+    assert(tmp >= v->item && tmp < v->item + v->size);
+    memmove(tmp, tmp + 1, (v->size - (v->item - tmp) - 1) * sizeof(*(v->item)));
+    v->size--;
+    return TRUE;
+}
+
+/*** vector_search ************************************************************/
+int  vector_search(VECTOR *v, int key, PPTP_CALL **call)
+{
+    struct vector_item *tmp;
+    assert(v != NULL);
+    tmp = binary_search(v, key);
+    if (tmp ==NULL) return FALSE;
+    *call = tmp->call;
+    return TRUE;
+}
+
+/*** vector_contains **********************************************************/
+int  vector_contains(VECTOR *v, int key)
+{
+    assert(v != NULL);
+    return (binary_search(v, key) != NULL);
+}
+
+/*** vector_item **************************************************************/
+static struct vector_item *binary_search(VECTOR *v, int key)
+{
+    int l,r,x;
+    l = 0;
+    r = v->size - 1;
+    while (r >= l) {
+        x = (l + r)/2;
+        if (key <  v->item[x].key) r = x - 1; else l = x + 1;
+        if (key == v->item[x].key) return &(v->item[x]);
+    }
+    return NULL;
+}
+
+/*** vector_scan ***************************************************************
+ * Hmm.  Let's be fancy and use a binary search for the first
+ * unused key, taking advantage of the list is stored sorted; ie
+ * we can look at pointers and keys at two different locations, 
+ * and if (ptr1 - ptr2) = (key1 - key2) then all the slots
+ * between ptr1 and ptr2 are filled.  Note that ptr1-ptr2 should
+ * never be greater than key1-key2 (no duplicate keys!)... we
+ * check for this.
+ */
+int vector_scan(VECTOR *v, int lo, int hi, int *key)
+{
+    int l,r,x;
+    assert(v != NULL);
+    assert(key != NULL);
+    if ((v->size<1) || (lo < v->item[0].key)) { *key = lo; return TRUE; }
+    /* our array bounds */
+    l = 0;  r = v->size - 1;
+    while (r > l) {
+        /* check for a free spot right after l */
+        if (v->item[l].key + 1 < v->item[l + 1].key) { /* found it! */
+            *key = v->item[l].key + 1;
+            return TRUE;
+        }
+        /* no dice. Let's see if the free spot is before or after the midpoint */
+        x = (l + r)/2;
+        /* Okay, we have right (r), left (l) and the probe (x). */
+        assert(x - l <= v->item[x].key - v->item[l].key);
+        assert(r - x <= v->item[r].key - v->item[x].key);
+        if (x - l < v->item[x].key - v->item[l].key)
+            /* room between l and x */
+            r = x;
+        else /* no room between l and x */
+            if (r - x < v->item[r].key - v->item[x].key)
+                /* room between x and r */
+                l = x;
+            else /* no room between x and r, either */
+                break; /* game over, man. */
+    }
+    /* no room found in already allocated space.  Check to see if
+     * there's free space above allocated entries. */
+    if (v->item[v->size - 1].key < hi) {
+        *key = v->item[v->size - 1].key + 1;
+        return TRUE;
+    }
+    /* outta luck */
+    return FALSE;
+}
+
+/*** vector_get_Nth ***********************************************************/
+PPTP_CALL * vector_get_Nth(VECTOR *v, int n)
+{
+    assert(v != NULL);
+    assert(0 <= n && n < vector_size(v));
+    return v->item[n].call;
+}
diff --git a/pppd/plugins/pptp/vector.h b/pppd/plugins/pptp/vector.h
new file mode 100644
index 0000000..b18899f
--- /dev/null
+++ b/pppd/plugins/pptp/vector.h
@@ -0,0 +1,31 @@
+/* vector.h ..... store a vector of PPTP_CALL information and search it
+ *                efficiently.
+ *                C. Scott Ananian <cananian@alumni.princeton.edu>
+ *
+ * $Id: vector.h,v 1.1.1.1 2000/12/23 08:19:51 scott Exp $
+ */
+
+#ifndef INC_VECTOR_H
+#define INC_VECTOR_H
+
+#include "pptp_ctrl.h" /* for definition of PPTP_CALL */
+
+typedef struct vector_struct VECTOR;
+
+VECTOR *vector_create();
+void vector_destroy(VECTOR *v);
+
+int vector_size(VECTOR *v);
+
+/* vector_insert and vector_search return TRUE on success, FALSE on failure. */
+int  vector_insert(VECTOR *v, int key, PPTP_CALL * call);
+int  vector_remove(VECTOR *v, int key);
+int  vector_search(VECTOR *v, int key, PPTP_CALL ** call);
+/* vector_contains returns FALSE if not found, TRUE if found. */
+int  vector_contains(VECTOR *v, int key);
+/* find first unused key. Returns TRUE on success, FALSE if no. */
+int  vector_scan(VECTOR *v, int lo, int hi, int *key);
+/* get a specific PPTP_CALL ... useful only when iterating. */
+PPTP_CALL * vector_get_Nth(VECTOR *v, int n);
+
+#endif /* INC_VECTOR_H */
diff --git a/pppd/plugins/radius/Makefile.linux b/pppd/plugins/radius/Makefile.linux
index 24ed3e5..6556eb7 100644
--- a/pppd/plugins/radius/Makefile.linux
+++ b/pppd/plugins/radius/Makefile.linux
@@ -11,14 +11,22 @@ VERSION = $(shell awk -F '"' '/VERSION/ { print $$2; }' ../../patchlevel.h)
 
 INSTALL	= install
 
-PLUGIN=radius.so radattr.so radrealms.so
-CFLAGS=-I. -I../.. -I../../../include -O2 -fPIC -DRC_LOG_FACILITY=LOG_DAEMON
+ifeq ($(CONFIG_USER_PPPD_WITH_DYNAMIC_PLUGINS),y)
+PLUGIN = radius.so radattr.so radrealms.so
+CFLAGS += -fPIC
+else
+PLUGIN = libradius.o
+endif
+
+CFLAGS += -I. -I../.. -I../../../include -DRC_LOG_FACILITY=LOG_DAEMON
 
 # Uncomment the next line to include support for Microsoft's
 # MS-CHAP authentication protocol.
 CHAPMS=y
 # Uncomment the next line to include support for MPPE.
-MPPE=y
+ifeq ($(CONFIG_USER_PPPD_WITH_MPPE),y)                                                                                  
+MPPE=y                                                                                                                  
+endif                                                                                                                   
 # Uncomment the next lint to include support for traffic limiting
 MAXOCTETS=y
 
@@ -53,9 +61,19 @@ radrealms.so: radrealms.o
 
 CLIENTOBJS = avpair.o buildreq.o config.o dict.o ip_util.o \
 	clientid.o sendserver.o lock.o util.o md5.o
+
 libradiusclient.a: $(CLIENTOBJS)
 	$(AR) rv $@ $?
 
+libradius.o: radius.o $(CLIENTOBJS)
+	$(LD) -r -o $@ $^
+
+libradattr.a: radattr.o
+	$(AR) rv $@ $?
+
+libradrealms.a: radrealms.o
+	$(AR) rv $@ $?
+
 clean:
 	rm -f *.o *.so *.a
 
diff --git a/pppd/plugins/radius/avpair.c b/pppd/plugins/radius/avpair.c
index 716d23f..752739c 100644
--- a/pppd/plugins/radius/avpair.c
+++ b/pppd/plugins/radius/avpair.c
@@ -358,6 +358,24 @@ VALUE_PAIR *rc_avpair_get (VALUE_PAIR *vp, UINT4 attr)
 	return (vp);
 }
 
+/*
+ * Function: rc_vsa_get
+ *
+ * Purpose: Find the first vendor specific attribute value-pair (which matches the given
+ *          attribute and vendor) from the specified value-pair list.
+ *
+ * Returns: found value_pair
+ *
+ */
+
+VALUE_PAIR *rc_vsa_get (VALUE_PAIR *vp, UINT4 vendor_code, UINT4 attr)
+{
+	for (; vp != (VALUE_PAIR *) NULL && (vp->attribute != attr && vp->vendorcode != vendor_code); vp = vp->next)
+	{
+		continue;
+	}
+	return (vp);
+}
 /*
  * Function: rc_avpair_copy
  *
diff --git a/pppd/plugins/radius/buildreq.c b/pppd/plugins/radius/buildreq.c
index 955b052..420e907 100644
--- a/pppd/plugins/radius/buildreq.c
+++ b/pppd/plugins/radius/buildreq.c
@@ -41,12 +41,13 @@ int rc_get_nas_id(VALUE_PAIR **sendpairs)
 		/*
 		 * Fill in NAS-IP-Address
 		 */
-		if ((client_id = rc_own_ipaddress()) == 0)
-			return (ERROR_RC);
-
-		if (rc_avpair_add(sendpairs, PW_NAS_IP_ADDRESS, &client_id,
+		client_id = rc_own_ipaddress();
+		
+		if (client_id != 0) { 
+			if (rc_avpair_add(sendpairs, PW_NAS_IP_ADDRESS, &client_id,
 				  0, VENDOR_NONE) == NULL)
-			return (ERROR_RC);
+				  return (ERROR_RC);
+		}
 	}
 
 	return (OK_RC);
diff --git a/pppd/plugins/radius/config.c b/pppd/plugins/radius/config.c
index a29e5e8..f7cc8b3 100644
--- a/pppd/plugins/radius/config.c
+++ b/pppd/plugins/radius/config.c
@@ -384,17 +384,19 @@ static int test_config(char *filename)
 		error("%s: login_timeout <= 0 is illegal", filename);
 		return (-1);
 	}
+#if 0
 	if (rc_conf_str("mapfile") == NULL)
 	{
 		error("%s: mapfile not specified", filename);
 		return (-1);
 	}
+
 	if (rc_conf_str("nologin") == NULL)
 	{
 		error("%s: nologin not specified", filename);
 		return (-1);
 	}
-
+#endif
 	return 0;
 }
 
diff --git a/pppd/plugins/radius/radattr.c b/pppd/plugins/radius/radattr.c
index 1fe7daa..573fe1c 100644
--- a/pppd/plugins/radius/radattr.c
+++ b/pppd/plugins/radius/radattr.c
@@ -25,7 +25,10 @@ extern void (*radius_attributes_hook)(VALUE_PAIR *);
 static void print_attributes(VALUE_PAIR *);
 static void cleanup(void *opaque, int arg);
 
-char pppd_version[] = VERSION;
+#ifndef DYNAMIC_PLUGINS
+#define	plugin_init radattr_plugin_init
+#endif
+char radattr_pppd_version[] = VERSION;
 
 /**********************************************************************
 * %FUNCTION: plugin_init
diff --git a/pppd/plugins/radius/radius.c b/pppd/plugins/radius/radius.c
index 4ba5f52..e5808e9 100644
--- a/pppd/plugins/radius/radius.c
+++ b/pppd/plugins/radius/radius.c
@@ -44,6 +44,11 @@ static char const RCSID[] =
 #include <netinet/in.h>
 #include <stdlib.h>
 
+#ifndef DYNAMIC_PLUGINS
+#define	plugin_init radius_plugin_init
+#endif
+char radius_pppd_version[] = VERSION;
+
 #define BUF_LEN 1024
 
 #define MD5_HASH_SIZE	16
@@ -136,8 +141,6 @@ void (*radius_pre_auth_hook)(char const *user,
 
 static struct radius_state rstate;
 
-char pppd_version[] = VERSION;
-
 /**********************************************************************
 * %FUNCTION: plugin_init
 * %ARGUMENTS:
@@ -147,8 +150,8 @@ char pppd_version[] = VERSION;
 * %DESCRIPTION:
 *  Initializes RADIUS plugin.
 ***********************************************************************/
-void
-plugin_init(void)
+
+void plugin_init(void)
 {
     pap_check_hook = radius_secret_check;
     pap_auth_hook = radius_pap_auth;
@@ -169,6 +172,7 @@ plugin_init(void)
 
     add_options(Options);
 
+    external_auth = 1;
     info("RADIUS plugin initialized.");
 }
 
@@ -307,6 +311,18 @@ radius_pap_auth(char *user,
 	}
     }
 
+    /* Before we free all our av pairs, we need to see if we've got group information
+       back
+     */
+    {
+		VALUE_PAIR *sg_group_attr = rc_vsa_get(received, VENDOR_SECURE, PW_SG_GROUP);
+		if (sg_group_attr != NULL) {
+			/* We have a group - set the auth_group variable. It will be free'd
+			   by auth_peer_success or fail 
+			 */
+			auth_group = strdup(sg_group_attr->strvalue);
+		}
+    }
     /* free value pairs */
     rc_avpair_free(received);
     rc_avpair_free(send);
@@ -486,7 +502,20 @@ radius_chap_verify(char *user, char *ourname, int id,
 	    }
 	}
     }
-
+    
+    /* Before we free all our av pairs, we need to see if we've got group information
+       back
+     */
+    {
+		VALUE_PAIR *sg_group_attr = rc_vsa_get(received, VENDOR_SECURE, PW_SG_GROUP);
+		if (sg_group_attr != NULL) {
+			/* We have a group - set the auth_group variable. It will be free'd
+			   by auth_peer_success or fail 
+			 */
+			auth_group = strdup(sg_group_attr->strvalue);
+		}
+    }
+     
     rc_avpair_free(received);
     rc_avpair_free (send);
     return (result == OK_RC);
@@ -542,8 +571,8 @@ radius_setparams(VALUE_PAIR *vp, char *msg, REQUEST_INFO *req_info,
     int ms_chap2_success = 0;
 #ifdef MPPE
     int mppe_enc_keys = 0;	/* whether or not these were received */
-    int mppe_enc_policy = 0;
-    int mppe_enc_types = 0;
+    int mppe_enc_policy = MPPE_ENC_POL_ENC_ALLOWED;
+    int mppe_enc_types =  MPPE_ENC_TYPES_RC4_40 | MPPE_ENC_TYPES_RC4_128;
 #endif
 #ifdef MSDNS
     ipcp_options *wo = &ipcp_wantoptions[0];
@@ -569,8 +598,8 @@ radius_setparams(VALUE_PAIR *vp, char *msg, REQUEST_INFO *req_info,
 	    switch (vp->attribute) {
 	    case PW_SERVICE_TYPE:
 		/* check for service type       */
-		/* if not FRAMED then exit      */
-		if (vp->lvalue != PW_FRAMED) {
+		/* if not framed or authenticate, exit      */
+		if (vp->lvalue != PW_FRAMED && vp->lvalue != PW_AUTHENTICATE_ONLY)  {
 		    slprintf(msg, BUF_LEN, "RADIUS: wrong service type %ld for %s",
 			     vp->lvalue, rstate.user);
 		    return -1;
@@ -737,7 +766,9 @@ radius_setparams(VALUE_PAIR *vp, char *msg, REQUEST_INFO *req_info,
 #ifdef MPPE
     /*
      * Require both policy and key attributes to indicate a valid key.
-     * Note that if the policy value was '0' we don't set the key!
+     * If the policy is not provided, but the keys have, then we set
+     * a default policy of allowing all types of encryption. This works
+     * around a bug in IAS in W2K3.
      */
     if (mppe_enc_policy && mppe_enc_keys) {
 	mppe_keys_set = 1;
@@ -1274,12 +1305,13 @@ radius_init(char *msg)
 		 rc_conf_str("dictionary"));
 	return -1;
     }
-
+#if 0
     if (rc_read_mapfile(rc_conf_str("mapfile")) != 0)	{
 	slprintf(msg, BUF_LEN, "RADIUS: Can't read map file %s",
 		 rc_conf_str("mapfile"));
 	return -1;
     }
+#endif 
 
     /* Add av pairs saved during option parsing */
     while (avpopt) {
diff --git a/pppd/plugins/radius/radrealms.c b/pppd/plugins/radius/radrealms.c
index 7a30370..301f2f1 100644
--- a/pppd/plugins/radius/radrealms.c
+++ b/pppd/plugins/radius/radrealms.c
@@ -23,7 +23,10 @@ static char const RCSID[] =
 #include <string.h>
 #include <stdlib.h>
 
-char pppd_version[] = VERSION;
+#ifndef DYNAMIC_PLUGINS
+#define	plugin_init radrealms_plugin_init
+#endif
+char radrealms_pppd_version[] = VERSION;
 
 char radrealms_config[MAXPATHLEN] = "/etc/radiusclient/realms";
 
diff --git a/pppd/plugins/rp-pppoe/Makefile.linux b/pppd/plugins/rp-pppoe/Makefile.linux
index 5d7a271..676f12e 100644
--- a/pppd/plugins/rp-pppoe/Makefile.linux
+++ b/pppd/plugins/rp-pppoe/Makefile.linux
@@ -25,9 +25,17 @@ INSTALL	= install
 # Version is set ONLY IN THE MAKEFILE!  Don't delete this!
 RP_VERSION=3.8p
 
-COPTS=-O2 -g
-CFLAGS=$(COPTS) -I../../../include '-DRP_VERSION="$(RP_VERSION)"'
-all: rp-pppoe.so pppoe-discovery
+#COPTS=-O2 -g
+CFLAGS+=$(COPTS) -I../../../include '-DRP_VERSION="$(RP_VERSION)"'
+
+ifeq ($(CONFIG_USER_PPPD_WITH_DYNAMIC_PLUGINS),y)
+CFLAGS += -fPIC
+TARGET = rp-pppoe.so pppoe-discovery
+else
+TARGET = libpppoe.o
+endif
+
+all: $(TARGET)
 
 pppoe-discovery: pppoe-discovery.o debug.o
 	$(CC) -o pppoe-discovery pppoe-discovery.o debug.o
@@ -48,17 +56,20 @@ install: all
 	$(INSTALL) -s -c -m 555 pppoe-discovery $(BINDIR)
 
 clean:
-	rm -f *.o *.so pppoe-discovery
+	rm -f *.o *.so *.a pppoe-discovery
 
 plugin.o: plugin.c
-	$(CC) $(CFLAGS) -I../../.. -c -o plugin.o -fPIC plugin.c
+	$(CC) $(CFLAGS) -I../../.. -c -o plugin.o plugin.c
+
+libpppoe.o: plugin.o discovery.o if.o common.o debug.o
+	$(LD) -r -o $@ $^
 
 discovery.o: discovery.c
-	$(CC) $(CFLAGS) -I../../.. -c -o discovery.o -fPIC discovery.c
+	$(CC) $(CFLAGS) -I../../.. -c -o discovery.o discovery.c
 
 if.o: if.c
-	$(CC) $(CFLAGS) -I../../.. -c -o if.o -fPIC if.c
+	$(CC) $(CFLAGS) -I../../.. -c -o if.o if.c
 
 common.o: common.c
-	$(CC) $(CFLAGS) -I../../.. -c -o common.o -fPIC common.c
+	$(CC) $(CFLAGS) -I../../.. -c -o common.o common.c
 
diff --git a/pppd/plugins/rp-pppoe/config.h b/pppd/plugins/rp-pppoe/config.h
index 5703087..5d2dada 100644
--- a/pppd/plugins/rp-pppoe/config.h
+++ b/pppd/plugins/rp-pppoe/config.h
@@ -102,7 +102,7 @@
 #define HAVE_NETPACKET_PACKET_H 1
 
 /* Define if you have the <sys/cdefs.h> header file.  */
-#define HAVE_SYS_CDEFS_H 1
+/* #undef HAVE_SYS_CDEFS_H */
 
 /* Define if you have the <sys/dlpi.h> header file.  */
 /* #undef HAVE_SYS_DLPI_H */
diff --git a/pppd/plugins/rp-pppoe/pppoe.h b/pppd/plugins/rp-pppoe/pppoe.h
index 9ab2eee..b827620 100644
--- a/pppd/plugins/rp-pppoe/pppoe.h
+++ b/pppd/plugins/rp-pppoe/pppoe.h
@@ -47,6 +47,8 @@
 #include <sys/socket.h>
 #endif
 
+#include <netinet/in.h>
+
 /* Ugly header files on some Linux boxes... */
 #if defined(HAVE_LINUX_IF_H)
 #include <linux/if.h>
@@ -80,12 +82,6 @@
 #error Could not find a 32-bit integer type
 #endif
 
-#ifdef HAVE_LINUX_IF_ETHER_H
-#include <linux/if_ether.h>
-#endif
-
-#include <netinet/in.h>
-
 #ifdef HAVE_NETINET_IF_ETHER_H
 #include <sys/types.h>
 
@@ -97,6 +93,9 @@
 #endif
 #endif
 
+#ifdef HAVE_LINUX_IF_ETHER_H
+#include <linux/if_ether.h>
+#endif
 
 
 /* Ethernet frame types according to RFC 2516 */
--- a/pppd/plugins/rp-pppoe/pppoe-discovery.c
+++ b/pppd/plugins/rp-pppoe/pppoe-discovery.c
@@ -47,6 +47,10 @@
 #include <net/if_arp.h>
 #endif
 
+#if !defined(__GLIBC__)
+#define error(msg)	printf("pppoe-discovery: " msg)
+#endif
+
 char *xstrdup(const char *s);
 void usage(void);
 
diff --git a/pppd/plugins/tacacs.c b/pppd/plugins/tacacs.c
new file mode 100644
index 0000000..6475d14
--- /dev/null
+++ b/pppd/plugins/tacacs.c
@@ -0,0 +1,375 @@
+/* tacacs.c v.0.3 Plugin for pppd. Implement TACACS+ protocol.
+ * Copyright (C)-2000 Jean-Louis Noel (jln@stben.be)
+ *
+ * Redistribution and use in source and binary forms are permitted
+ * provided that the above copyright notice and this paragraph are
+ * duplicated in all such forms and that any documentation,
+ * advertising materials, and other materials.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <syslog.h>
+#include <pppd.h>
+#include <sys/socket.h>
+#include <netdb.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <tacplus.h>
+#include <libtac.h>
+#include <fsm.h>
+#include <ipcp.h>
+#include <magic.h>
+#include <time.h>
+
+#ifndef DYNAMIC_PLUGINS
+#define	plugin_init tacacs_plugin_init
+#endif
+char tacacs_pppd_version[] = VERSION;
+
+extern char *ttyname(int);
+
+static bool   plugin_loaded = 0;
+static bool   use_tacacs  = 0;
+static bool   use_authorize  = 0;
+static bool   use_account = 0;
+static bool   authorized = 0;
+static bool   logged_in = 0;
+static int    task_id;
+static u_long tac_server = -1;
+static char   tac_secret_buffer[MAXSECRETLEN] = "";
+static char   tty[32];
+
+static int (*prev_pap_check_hook) __P((void));
+static int (*prev_pap_auth_hook) __P((char *user, char *passwd, char **msgp,
+				 struct wordlist **paddrs,
+				 struct wordlist **popts));
+static void (*prev_ip_up_hook) __P((void));
+static void (*prev_ip_down_hook) __P((void));
+
+
+static int
+tacacs_get_server(char **argv);
+
+
+static option_t tacacs_options[] =
+{
+    { "tacacs", o_bool, &use_tacacs,
+      "Use TACACS+ functions", 1 },
+    { "tacacs-accounting", o_bool, &use_account,
+      "Send TACACS+ accounting packets", 1 },
+    { "tacacs-authorization", o_bool, &use_authorize,
+      "Use TACACS+ to authorize for PPP", 1 },
+    { "tacacs-server", o_special, tacacs_get_server,
+      "TACACS+ server IP address" },
+    { "tacacs-secret", o_string, tac_secret_buffer,
+      "Key used to encrypt TACACS+ packets",OPT_STATIC,NULL,MAXSECRETLEN},
+    { NULL }
+};
+
+static int
+tacacs_get_server(char **argv)
+{
+    struct in_addr addr;
+    struct hostent *h;
+    
+    if (inet_aton(*argv, &addr) == 0) {
+	h = gethostbyname(*argv);
+	if (h == NULL) {
+	    option_error("invalid TACACS+ server '%s'", *argv);
+	    return 0;
+	}
+	memcpy((char*)&addr, h->h_addr, sizeof(addr));
+    }
+
+    tac_server = addr.s_addr;
+
+    return 1;
+}
+
+static int
+tacacs_check(void)
+{
+    int tac_fd;
+    int ret;
+
+    if (prev_pap_check_hook) {
+	ret = prev_pap_check_hook();
+	if (ret >= 0) {
+	    return ret;
+	}
+    }
+    
+    if (!use_tacacs)
+	return -1;
+
+    if (tac_server == -1)
+	return 0;
+
+    tac_fd = tac_connect(&tac_server, 1);
+    if (tac_fd < 0)
+	return 0;
+    
+    close(tac_fd);
+
+    return 1;
+}
+    
+static int
+tacacs_auth(char *t_user, char *t_passwd, char**t_msgp,
+			struct wordlist **t_paddrs, struct wordlist **t_popts)
+{
+    int  tac_fd;
+    char *msg;
+    struct areply   arep;
+    struct tac_attrib *attr;
+    struct tac_attrib *attrentry;
+    struct wordlist **pnextaddr;
+    struct wordlist *addr;
+    int addrlen;
+    int ret;
+
+    if (prev_pap_auth_hook) {
+	ret = prev_pap_auth_hook(t_user, t_passwd, t_msgp, t_paddrs, t_popts);
+	if (ret >= 0) {
+	    return ret;
+	}
+    }
+    
+    if (!use_tacacs) return -1;
+
+    *t_msgp = "TACACS+ server failed";
+    *t_popts = NULL;
+
+    /* start authentication */
+
+    if (tac_server == -1)
+	return 0;
+    
+    tac_fd = tac_connect(&tac_server, 1);
+    if (tac_fd < 0)
+	return 0;
+
+    if (tac_authen_pap_send(tac_fd, t_user, t_passwd, tty) < 0)
+	return 0;
+
+    msg = tac_authen_pap_read(tac_fd);
+    if (msg != NULL) {
+	*t_msgp = msg;
+	return 0;
+    }
+
+    close(tac_fd);
+
+    /* user/password is valid, now check authorization */
+    if (use_authorize) {
+	tac_fd = tac_connect(&tac_server, 1);
+    	if (tac_fd < 0)
+	    return 0;
+
+	attr = NULL;
+	tac_add_attrib(&attr, "service", "ppp");
+	tac_add_attrib(&attr, "protocol", "ip");
+
+	if (tac_author_send(tac_fd, t_user, tty, attr) < 0)
+	    return 0;
+
+	tac_author_read(tac_fd, &arep);
+	if (arep.status != AUTHOR_STATUS_PASS_ADD
+	        && arep.status != AUTHOR_STATUS_PASS_REPL) {
+	    *t_msgp = arep.msg;
+    	    return 0;
+	}
+
+	tac_free_attrib(&attr);
+	close(tac_fd);
+
+	/* Build up list of allowable addresses */
+	*t_paddrs = NULL; /* Default to allow all */
+	pnextaddr = t_paddrs;
+	for (attrentry=arep.attr; attrentry!=NULL; attrentry=attrentry->next) {
+	    if (strncmp(attrentry->attr, "addr=", 5) == 0) {
+		addrlen = attrentry->attr_len - 5;
+
+		/* Allocate a buffer for both the structure and the address */
+		addr = (struct wordlist*)malloc(sizeof(struct wordlist)
+						+ addrlen + 1);
+		if (addr == NULL)
+		    novm("TACACS+ address");
+
+		addr->word = (char*)(addr+1);
+		strncpy(addr->word, attrentry->attr+5, addrlen);
+		addr->word[addrlen] = '\0';
+
+		addr->next = NULL;
+		*pnextaddr = addr;
+		pnextaddr = &addr->next;
+	    }
+	}
+
+	tac_free_attrib(&arep.attr);
+    }
+    
+    *t_msgp = "Login succeeded";
+    syslog(LOG_INFO,"TACACS+ login succeeded for %s", t_user);
+
+    authorized = 1;
+
+    return 1;
+}
+
+
+static void
+accounting_start(void)
+{
+    int  tac_fd;
+    char *phone;
+    char *msg;
+    struct tac_attrib   *attr;
+    struct in_addr      peer_addr;
+    char   buf[40];
+
+    if (prev_ip_up_hook) {
+	prev_ip_up_hook();
+    }
+    
+    if (use_tacacs && use_account && authorized) {
+	authorized = 0;
+	logged_in = 1;
+
+	if (tac_server == -1)
+	    return;
+    
+	tac_fd = tac_connect(&tac_server, 1);
+	if (tac_fd < 0)
+	    return;
+
+	/* start accounting */
+	attr = NULL;
+
+	sprintf(buf, "%lu", time(0));
+	tac_add_attrib(&attr, "start_time", buf);
+
+	sprintf(buf, "%hu", task_id);
+	tac_add_attrib(&attr, "task_id", buf);
+
+	phone = getenv("CALLER_ID");
+	if (!phone)
+	    phone = "Unknow";
+	tac_add_attrib(&attr, "phone_#", phone);
+
+	tac_add_attrib(&attr, "service", "ppp");
+	tac_add_attrib(&attr, "protocol", "ip");
+
+	peer_addr.s_addr = ipcp_hisoptions[0].hisaddr;
+	sprintf(buf, "%s", inet_ntoa(peer_addr));
+
+	tac_account_send(tac_fd, TAC_PLUS_ACCT_FLAG_START, peer_authname, tty, buf, attr);
+
+	msg = tac_account_read(tac_fd);
+	if (msg != NULL)
+	    syslog(LOG_ERR,"TACACS+ start accounting failed: %s", msg);
+
+	close(tac_fd); 
+	tac_free_attrib(&attr);
+    }
+}
+
+static void
+accounting_stop(void)
+{
+    int  tac_fd;
+    char *msg;
+    struct tac_attrib *attr;
+    struct in_addr      peer_addr;
+    char   buf[40];
+
+    if (prev_ip_down_hook) {
+	prev_ip_down_hook();
+    }
+    
+    if (use_tacacs && use_account && logged_in) {
+	logged_in = 0;
+
+	if (tac_server == -1)
+	    return;
+    
+	tac_fd = tac_connect(&tac_server, 1);
+	if (tac_fd < 0)
+	    return;
+
+	/* stop accounting */
+	attr = NULL;
+
+	sprintf(buf, "%lu", time(0));
+	tac_add_attrib(&attr, "stop_time", buf);
+	sprintf(buf, "%hu", task_id);
+	tac_add_attrib(&attr, "task_id", buf);
+	if (link_stats_valid) {
+	    sprintf(buf, "%d", link_stats.bytes_out);
+	    tac_add_attrib(&attr, "bytes_out", buf);
+	    sprintf(buf, "%d", link_stats.bytes_in);
+	    tac_add_attrib(&attr, "bytes_in", buf);
+	    sprintf(buf, "%d", link_connect_time);
+	    tac_add_attrib(&attr, "elapsed_time", buf);
+	    peer_addr.s_addr = ipcp_hisoptions[0].hisaddr;
+	    sprintf(buf, "%s", inet_ntoa(peer_addr));
+	}
+	
+	tac_account_send(tac_fd, TAC_PLUS_ACCT_FLAG_STOP, peer_authname, tty, buf, attr);
+	
+	msg = tac_account_read(tac_fd);
+	if (msg != NULL)
+	    syslog(LOG_ERR,"TACACS+ stop accounting failed: %s\n", msg);
+	
+	close(tac_fd);
+	tac_free_attrib(&attr);
+    }
+}
+
+void plugin_init(void)
+{
+    char *ptr;
+
+    /* Prevent initialising twice */
+    if (!plugin_loaded) {
+	plugin_loaded = 1;
+
+	syslog(LOG_INFO,"TACACS+ 0.3 Init functions");
+	
+	/* Initialize global variables */
+	magic_init();
+	task_id = (short)magic();
+	
+	ptr = devnam;
+	if (strncmp(ptr, "/dev/", 5) == 0)
+	    ptr += 5;
+	strncpy(tty, ptr, 31);
+	tty[31] = '\0';
+	
+	/* set variables in libtac */
+	tac_secret = tac_secret_buffer;
+	tac_encryption = 1;
+	
+	/* install pppd hooks */
+	add_options(tacacs_options);
+	
+	prev_pap_check_hook = pap_check_hook;
+	pap_check_hook = tacacs_check;
+	
+	prev_pap_auth_hook = pap_auth_hook;
+	pap_auth_hook = tacacs_auth;
+	
+	prev_ip_up_hook = ip_up_hook;
+	ip_up_hook = accounting_start;
+	
+	prev_ip_down_hook = ip_down_hook;
+	ip_down_hook = accounting_stop;
+	external_auth = 1;
+    }
+}
diff --git a/pppd/plugins/tacc/.gitignore b/pppd/plugins/tacc/.gitignore
new file mode 100644
index 0000000..2460008
--- /dev/null
+++ b/pppd/plugins/tacc/.gitignore
@@ -0,0 +1 @@
+!Makefile
diff --git a/pppd/plugins/tacc/ChangeLog.tacacs b/pppd/plugins/tacc/ChangeLog.tacacs
new file mode 100644
index 0000000..fef836a
--- /dev/null
+++ b/pppd/plugins/tacc/ChangeLog.tacacs
@@ -0,0 +1,77 @@
+1.6.9
+* Compatibility changes for FreeBSD, fixed problems reported
+  by Valery <kifa@feo.sf.ukrtel.net>
+
+1.6.8
+* Accounting now can send remote port attribute, code sent
+  by Jean-Louis Noel <jln@stben.be>
+
+1.6.7
+* Synchronized with libtac distributed with pam_tacplus module.
+  Actually, that version contained all bugfixes sent by people
+  during last year. Now both are equal.
+* Various code cleanups.
+
+1.6.6
+* Fixed 3 major bugs reported by Ran Shalgi <Ran@infit.com>
+
+1.6.5
+* Bugfixes and compatibility changes (now compiles on FreeBSD)
+
+1.6.4
+* Fixed bug in password reading timeout :)
+* Fixed small bug in logwtmp() declarations in tacc.c
+
+1.6.3
+* Added timeout for reading password from user
+* Updated and fixed MD5 implementation, thanks to
+  Ricardo Matsura <ricardo.matsura@digitro.com.br>
+* Fixed bug in ipcp.c(pppd) which prevented pppd from sending
+  accounting STOP packets
+
+1.6.2
+* ppp-2.3.4: fixed bugs in `auth.c' - missing various if(usetacacs)
+* Fixes for glibc compatibility
+
+1.6.1
+* Fixed bugs in `author_s.c' and `acct_s.c', thanks to Ricardo again :)
+* Better random numbers on Linux (/dev/urandom instead of PRNG)
+
+1.6
+* Moved all TACACS+ functions to library
+* Driver ported to pppd 2.3.4
+
+1.5
+* Many changes in `tacc' user interface
+* Separate distribution for `tacc' and `pppd' patch since this version
+* Manual page for tacc(1)
+
+1.4
+* Added more TACACS+ accounting attributes
+* Fixed some bugs in accounting
+* Functions now return server messages 
+* Accounting and authorization now works on IPCP level
+* Multiple TACACS+ servers may be defined
+* Major changes in the way of handling TACACS+ AAA 
+* Fixes in handling packet length, thanks to 
+  Stefan Hadjistoytchev <sth_bg@geocities.com>
+
+1.3
+* Added simple TACACS+ accounting
+* New options for pppd to enable TACACS+, authorization and accounting
+* TACACS+ procedures are no longer called from login() function 
+* Minor fixes in tacc.c and auth_tac.c
+
+1.2
+* Changed names of some internal functions (prepending "_")
+* tac_send and tac_read functions now accept file descriptor on input
+* _tac_crypt() was rewritten to be more RFC compliant
+* New function _tac_header()
+
+1.1
+* Added `tacc' client
+
+1.0
+* First working version, basic TACACS+ PAP authentication
+  on top of pppd login() function
+
diff --git a/pppd/plugins/tacc/Makefile b/pppd/plugins/tacc/Makefile
new file mode 100644
index 0000000..af7fa68
--- /dev/null
+++ b/pppd/plugins/tacc/Makefile
@@ -0,0 +1,43 @@
+## debugging flags
+## -DDEBUGTAC will cause every TACACS+ function report it's progress
+## and errors to syslog(3)
+## -lefence links ElectricFence bounds checking library
+#CFLAGS = -ggdb3 -DDEBUGTAC
+#LDFLAGS = -ggdb3 -lefence
+
+## uncomment this if using BIND 8.1
+#CFLAGS += -D__inet_aton=inet_aton
+
+## standard includes
+CFLAGS += -Iinclude -Ilib -Iextras
+
+## uncomment -lutil if using glibc/FreeBSD
+LDFLAGS += -Llib -ltac -lutil
+## uncomment this and comment out the above on old FreeBSD installations
+# LDFLAGS += -lutil
+
+OBJ = tacc.o
+OBJ += extras/getopt.o
+
+## uncomment on old FreeBSD installations
+#OBJ += lib/acct_r.o lib/acct_s.o lib/attrib.o lib/authen_r.o lib/authen_s.o lib/author_r.o lib/author_s.o lib/connect.o lib/crypt.o lib/hdr_check.o lib/header.o lib/magic.o lib/md5.o lib/messages.o lib/version.o lib/xalloc.o
+
+all: tacc
+
+libtac: lib
+	(cd lib; make OPTIMIZE="$(OPTIMIZE)")
+
+support: extras 
+	(cd extras; make)
+
+tacc: support libtac tacc.o 
+	$(CC) $(CFLAGS) -o tacc $(OBJ) $(LDFLAGS) $(LDLIBS)
+
+install: tacc tacc.1
+	install -s tacc /usr/local/sbin
+	install tacc.1 /usr/local/man/man1
+
+clean:
+	rm -f *.o tacc
+	(cd lib; make clean)
+	(cd extras; make clean)
diff --git a/pppd/plugins/tacc/README b/pppd/plugins/tacc/README
new file mode 100644
index 0000000..ce0fc81
--- /dev/null
+++ b/pppd/plugins/tacc/README
@@ -0,0 +1,57 @@
+INTRODUCTION
+
+This distribution contains:
+
+	* libtac		TACACS+ client library implementing necessary
+			 		subset of TACACS+ functionality
+	* tacc			simple TACACS+ client and login utility
+	* pppd-*.patch	pppd TACACS+ driver for versions 2.2.0g
+					and 2.3.4
+
+NEWS
+
+Jean-Louis Noel <jln@stben.be> has written a plugin for
+pppd-2.3.11 and higher, which cleanly solves problem with
+new pppd versions. Now you don't need to patch pppd sources
+to use TACACS+. The plugin source and installation instructions
+are avaiable at http://www.stben.be/tacacs/.
+
+NOTE
+
+The 1.6.x versions of libtac/tacc are quite stable now and development
+is discontinued. Instead, I'm currently writing version 2.0 which will
+less a quick hack (which 1.6 really is), and more a protocol implementation.
+New 1.6 versions will be only bugfixes.
+
+INSTALLATION
+
+1. Edit and configure files:
+
+	* tacc.c
+	* Makefile
+	* lib/Makefile
+
+2. Type 'make'. This should produce library (lib/libtac.a)
+	and tacc program.
+
+3. 'make install' will copy the 'tacc' binary program to /usr/local/sbin
+	and 'tacc.1' manual page to /usr/local/man/man1.
+
+4. If you want pppd driver built, copy patch for proper pppd version
+	to the top of pppd source code tree (e.g. /usr/src/ppp-2.3.4)
+	and type 'patch -p0 <ppp-2.x.x.patch'
+
+5. Configure and make pppd as described in file README.tacacs from pppd
+   directory.
+
+DOCUMENTATION
+
+You can find more information about this program on:
+http://www.ceti.com.pl/~kravietz/progs/tacacs.html
+
+There is brief information on using tacc in tacc(1) manual page.
+
+AUTHOR 
+
+libtac, tacc and pppd TACACS+ driver were written by
+Pawel Krawczyk <kravietz@ceti.com.pl>
diff --git a/pppd/plugins/tacc/extras/Makefile b/pppd/plugins/tacc/extras/Makefile
new file mode 100644
index 0000000..9d2228d
--- /dev/null
+++ b/pppd/plugins/tacc/extras/Makefile
@@ -0,0 +1,8 @@
+.c.o:
+	$(CC) $(CFLAGS) -c $<
+
+all:	getopt.c getopt.h
+	$(CC) $(CFLAGS) -c getopt.c	
+
+clean:
+	rm -f *.o
diff --git a/pppd/plugins/tacc/extras/getopt.c b/pppd/plugins/tacc/extras/getopt.c
new file mode 100644
index 0000000..55fad84
--- /dev/null
+++ b/pppd/plugins/tacc/extras/getopt.c
@@ -0,0 +1,755 @@
+/* Getopt for GNU.
+   NOTE: getopt is now part of the C library, so if you don't know what
+   "Keep this file name-space clean" means, talk to roland@gnu.ai.mit.edu
+   before changing it!
+
+   Copyright (C) 1987, 88, 89, 90, 91, 92, 1993
+   	Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by the
+   Free Software Foundation; either version 2, or (at your option) any
+   later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#ifndef __STDC__
+#  ifndef const
+#    define const
+#  endif
+#endif
+
+/* This tells Alpha OSF/1 not to define a getopt prototype in <stdio.h>.  */
+#ifndef _NO_PROTO
+#define _NO_PROTO
+#endif
+
+#include <stdio.h>
+#include "tailor.h"
+
+/* Comment out all this code if we are using the GNU C Library, and are not
+   actually compiling the library itself.  This code is part of the GNU C
+   Library, but also included in many other GNU distributions.  Compiling
+   and linking in this code is a waste when using the GNU C library
+   (especially if it is a shared library).  Rather than having every GNU
+   program understand `configure --with-gnu-libc' and omit the object files,
+   it is simpler to just do this in the source for each such file.  */
+
+#if defined (_LIBC) || !defined (__GNU_LIBRARY__)
+
+
+/* This needs to come after some library #include
+   to get __GNU_LIBRARY__ defined.  */
+#ifdef	__GNU_LIBRARY__
+/* Don't include stdlib.h for non-GNU C libraries because some of them
+   contain conflicting prototypes for getopt.  */
+#include <stdlib.h>
+#endif	/* GNU C library.  */
+
+/* If GETOPT_COMPAT is defined, `+' as well as `--' can introduce a
+   long-named option.  Because this is not POSIX.2 compliant, it is
+   being phased out.  */
+/* #define GETOPT_COMPAT */
+
+/* This version of `getopt' appears to the caller like standard Unix `getopt'
+   but it behaves differently for the user, since it allows the user
+   to intersperse the options with the other arguments.
+
+   As `getopt' works, it permutes the elements of ARGV so that,
+   when it is done, all the options precede everything else.  Thus
+   all application programs are extended to handle flexible argument order.
+
+   Setting the environment variable POSIXLY_CORRECT disables permutation.
+   Then the behavior is completely standard.
+
+   GNU application programs can use a third alternative mode in which
+   they can distinguish the relative order of options and other arguments.  */
+
+#include "getopt.h"
+
+/* For communication from `getopt' to the caller.
+   When `getopt' finds an option that takes an argument,
+   the argument value is returned here.
+   Also, when `ordering' is RETURN_IN_ORDER,
+   each non-option ARGV-element is returned here.  */
+
+char *optarg = 0;
+
+/* Index in ARGV of the next element to be scanned.
+   This is used for communication to and from the caller
+   and for communication between successive calls to `getopt'.
+
+   On entry to `getopt', zero means this is the first call; initialize.
+
+   When `getopt' returns EOF, this is the index of the first of the
+   non-option elements that the caller should itself scan.
+
+   Otherwise, `optind' communicates from one call to the next
+   how much of ARGV has been scanned so far.  */
+
+/* XXX 1003.2 says this must be 1 before any call.  */
+int optind = 0;
+
+/* The next char to be scanned in the option-element
+   in which the last option character we returned was found.
+   This allows us to pick up the scan where we left off.
+
+   If this is zero, or a null string, it means resume the scan
+   by advancing to the next ARGV-element.  */
+
+static char *nextchar;
+
+/* Callers store zero here to inhibit the error message
+   for unrecognized options.  */
+
+int opterr = 1;
+
+/* Set to an option character which was unrecognized.
+   This must be initialized on some systems to avoid linking in the
+   system's own getopt implementation.  */
+
+#define BAD_OPTION '\0'
+int optopt = BAD_OPTION;
+
+/* Describe how to deal with options that follow non-option ARGV-elements.
+
+   If the caller did not specify anything,
+   the default is REQUIRE_ORDER if the environment variable
+   POSIXLY_CORRECT is defined, PERMUTE otherwise.
+
+   REQUIRE_ORDER means don't recognize them as options;
+   stop option processing when the first non-option is seen.
+   This is what Unix does.
+   This mode of operation is selected by either setting the environment
+   variable POSIXLY_CORRECT, or using `+' as the first character
+   of the list of option characters.
+
+   PERMUTE is the default.  We permute the contents of ARGV as we scan,
+   so that eventually all the non-options are at the end.  This allows options
+   to be given in any order, even with programs that were not written to
+   expect this.
+
+   RETURN_IN_ORDER is an option available to programs that were written
+   to expect options and other ARGV-elements in any order and that care about
+   the ordering of the two.  We describe each non-option ARGV-element
+   as if it were the argument of an option with character code 1.
+   Using `-' as the first character of the list of option characters
+   selects this mode of operation.
+
+   The special argument `--' forces an end of option-scanning regardless
+   of the value of `ordering'.  In the case of RETURN_IN_ORDER, only
+   `--' can cause `getopt' to return EOF with `optind' != ARGC.  */
+
+static enum
+{
+  REQUIRE_ORDER, PERMUTE, RETURN_IN_ORDER
+} ordering;
+
+#ifdef	__GNU_LIBRARY__
+/* We want to avoid inclusion of string.h with non-GNU libraries
+   because there are many ways it can cause trouble.
+   On some systems, it contains special magic macros that don't work
+   in GCC.  */
+#include <string.h>
+#define	my_index	strchr
+#define	my_strlen	strlen
+#else
+
+/* Avoid depending on library functions or files
+   whose names are inconsistent.  */
+
+#if __STDC__ || defined(PROTO)
+extern char *getenv(const char *name);
+extern int  strcmp (const char *s1, const char *s2);
+extern int  strncmp(const char *s1, const char *s2, int n);
+
+static int my_strlen(const char *s);
+static char *my_index (const char *str, int chr);
+#else
+extern char *getenv ();
+#endif
+
+static int
+my_strlen (str)
+     const char *str;
+{
+  int n = 0;
+  while (*str++)
+    n++;
+  return n;
+}
+
+static char *
+my_index (str, chr)
+     const char *str;
+     int chr;
+{
+  while (*str)
+    {
+      if (*str == chr)
+	return (char *) str;
+      str++;
+    }
+  return 0;
+}
+
+#endif				/* GNU C library.  */
+
+/* Handle permutation of arguments.  */
+
+/* Describe the part of ARGV that contains non-options that have
+   been skipped.  `first_nonopt' is the index in ARGV of the first of them;
+   `last_nonopt' is the index after the last of them.  */
+
+static int first_nonopt;
+static int last_nonopt;
+
+/* Exchange two adjacent subsequences of ARGV.
+   One subsequence is elements [first_nonopt,last_nonopt)
+   which contains all the non-options that have been skipped so far.
+   The other is elements [last_nonopt,optind), which contains all
+   the options processed since those non-options were skipped.
+
+   `first_nonopt' and `last_nonopt' are relocated so that they describe
+   the new indices of the non-options in ARGV after they are moved.
+
+   To perform the swap, we first reverse the order of all elements. So
+   all options now come before all non options, but they are in the
+   wrong order. So we put back the options and non options in original
+   order by reversing them again. For example:
+       original input:      a b c -x -y
+       reverse all:         -y -x c b a
+       reverse options:     -x -y c b a
+       reverse non options: -x -y a b c
+*/
+
+#if __STDC__ || defined(PROTO)
+static void exchange (char **argv);
+#endif
+
+static void
+exchange (argv)
+     char **argv;
+{
+  char *temp, **first, **last;
+
+  /* Reverse all the elements [first_nonopt, optind) */
+  first = &argv[first_nonopt];
+  last  = &argv[optind-1];
+  while (first < last) {
+    temp = *first; *first = *last; *last = temp; first++; last--;
+  }
+  /* Put back the options in order */
+  first = &argv[first_nonopt];
+  first_nonopt += (optind - last_nonopt);
+  last  = &argv[first_nonopt - 1];
+  while (first < last) {
+    temp = *first; *first = *last; *last = temp; first++; last--;
+  }
+
+  /* Put back the non options in order */
+  first = &argv[first_nonopt];
+  last_nonopt = optind;
+  last  = &argv[last_nonopt-1];
+  while (first < last) {
+    temp = *first; *first = *last; *last = temp; first++; last--;
+  }
+}
+
+/* Scan elements of ARGV (whose length is ARGC) for option characters
+   given in OPTSTRING.
+
+   If an element of ARGV starts with '-', and is not exactly "-" or "--",
+   then it is an option element.  The characters of this element
+   (aside from the initial '-') are option characters.  If `getopt'
+   is called repeatedly, it returns successively each of the option characters
+   from each of the option elements.
+
+   If `getopt' finds another option character, it returns that character,
+   updating `optind' and `nextchar' so that the next call to `getopt' can
+   resume the scan with the following option character or ARGV-element.
+
+   If there are no more option characters, `getopt' returns `EOF'.
+   Then `optind' is the index in ARGV of the first ARGV-element
+   that is not an option.  (The ARGV-elements have been permuted
+   so that those that are not options now come last.)
+
+   OPTSTRING is a string containing the legitimate option characters.
+   If an option character is seen that is not listed in OPTSTRING,
+   return BAD_OPTION after printing an error message.  If you set `opterr' to
+   zero, the error message is suppressed but we still return BAD_OPTION.
+
+   If a char in OPTSTRING is followed by a colon, that means it wants an arg,
+   so the following text in the same ARGV-element, or the text of the following
+   ARGV-element, is returned in `optarg'.  Two colons mean an option that
+   wants an optional arg; if there is text in the current ARGV-element,
+   it is returned in `optarg', otherwise `optarg' is set to zero.
+
+   If OPTSTRING starts with `-' or `+', it requests different methods of
+   handling the non-option ARGV-elements.
+   See the comments about RETURN_IN_ORDER and REQUIRE_ORDER, above.
+
+   Long-named options begin with `--' instead of `-'.
+   Their names may be abbreviated as long as the abbreviation is unique
+   or is an exact match for some defined option.  If they have an
+   argument, it follows the option name in the same ARGV-element, separated
+   from the option name by a `=', or else the in next ARGV-element.
+   When `getopt' finds a long-named option, it returns 0 if that option's
+   `flag' field is nonzero, the value of the option's `val' field
+   if the `flag' field is zero.
+
+   The elements of ARGV aren't really const, because we permute them.
+   But we pretend they're const in the prototype to be compatible
+   with other systems.
+
+   LONGOPTS is a vector of `struct option' terminated by an
+   element containing a name which is zero.
+
+   LONGIND returns the index in LONGOPT of the long-named option found.
+   It is only valid when a long-named option has been found by the most
+   recent call.
+
+   If LONG_ONLY is nonzero, '-' as well as '--' can introduce
+   long-named options.  */
+
+int
+_getopt_internal (argc, argv, optstring, longopts, longind, long_only)
+     int argc;
+     char *const *argv;
+     const char *optstring;
+     const struct option *longopts;
+     int *longind;
+     int long_only;
+{
+  int option_index;
+
+  optarg = 0;
+
+  /* Initialize the internal data when the first call is made.
+     Start processing options with ARGV-element 1 (since ARGV-element 0
+     is the program name); the sequence of previously skipped
+     non-option ARGV-elements is empty.  */
+
+  if (optind == 0)
+    {
+      first_nonopt = last_nonopt = optind = 1;
+
+      nextchar = NULL;
+
+      /* Determine how to handle the ordering of options and nonoptions.  */
+
+      if (optstring[0] == '-')
+	{
+	  ordering = RETURN_IN_ORDER;
+	  ++optstring;
+	}
+      else if (optstring[0] == '+')
+	{
+	  ordering = REQUIRE_ORDER;
+	  ++optstring;
+	}
+      else if (getenv ("POSIXLY_CORRECT") != NULL)
+	ordering = REQUIRE_ORDER;
+      else
+	ordering = PERMUTE;
+    }
+
+  if (nextchar == NULL || *nextchar == '\0')
+    {
+      if (ordering == PERMUTE)
+	{
+	  /* If we have just processed some options following some non-options,
+	     exchange them so that the options come first.  */
+
+	  if (first_nonopt != last_nonopt && last_nonopt != optind)
+	    exchange ((char **) argv);
+	  else if (last_nonopt != optind)
+	    first_nonopt = optind;
+
+	  /* Now skip any additional non-options
+	     and extend the range of non-options previously skipped.  */
+
+	  while (optind < argc
+		 && (argv[optind][0] != '-' || argv[optind][1] == '\0')
+#ifdef GETOPT_COMPAT
+		 && (longopts == NULL
+		     || argv[optind][0] != '+' || argv[optind][1] == '\0')
+#endif				/* GETOPT_COMPAT */
+		 )
+	    optind++;
+	  last_nonopt = optind;
+	}
+
+      /* Special ARGV-element `--' means premature end of options.
+	 Skip it like a null option,
+	 then exchange with previous non-options as if it were an option,
+	 then skip everything else like a non-option.  */
+
+      if (optind != argc && !strcmp (argv[optind], "--"))
+	{
+	  optind++;
+
+	  if (first_nonopt != last_nonopt && last_nonopt != optind)
+	    exchange ((char **) argv);
+	  else if (first_nonopt == last_nonopt)
+	    first_nonopt = optind;
+	  last_nonopt = argc;
+
+	  optind = argc;
+	}
+
+      /* If we have done all the ARGV-elements, stop the scan
+	 and back over any non-options that we skipped and permuted.  */
+
+      if (optind == argc)
+	{
+	  /* Set the next-arg-index to point at the non-options
+	     that we previously skipped, so the caller will digest them.  */
+	  if (first_nonopt != last_nonopt)
+	    optind = first_nonopt;
+	  return EOF;
+	}
+
+      /* If we have come to a non-option and did not permute it,
+	 either stop the scan or describe it to the caller and pass it by.  */
+
+      if ((argv[optind][0] != '-' || argv[optind][1] == '\0')
+#ifdef GETOPT_COMPAT
+	  && (longopts == NULL
+	      || argv[optind][0] != '+' || argv[optind][1] == '\0')
+#endif				/* GETOPT_COMPAT */
+	  )
+	{
+	  if (ordering == REQUIRE_ORDER)
+	    return EOF;
+	  optarg = argv[optind++];
+	  return 1;
+	}
+
+      /* We have found another option-ARGV-element.
+	 Start decoding its characters.  */
+
+      nextchar = (argv[optind] + 1
+		  + (longopts != NULL && argv[optind][1] == '-'));
+    }
+
+  if (longopts != NULL
+      && ((argv[optind][0] == '-'
+	   && (argv[optind][1] == '-' || long_only))
+#ifdef GETOPT_COMPAT
+	  || argv[optind][0] == '+'
+#endif				/* GETOPT_COMPAT */
+	  ))
+    {
+      const struct option *p;
+      char *s = nextchar;
+      int exact = 0;
+      int ambig = 0;
+      const struct option *pfound = NULL;
+      int indfound = 0;
+
+      while (*s && *s != '=')
+	s++;
+
+      /* Test all options for either exact match or abbreviated matches.  */
+      for (p = longopts, option_index = 0; p->name;
+	   p++, option_index++)
+	if (!strncmp (p->name, nextchar, s - nextchar))
+	  {
+	    if (s - nextchar == my_strlen (p->name))
+	      {
+		/* Exact match found.  */
+		pfound = p;
+		indfound = option_index;
+		exact = 1;
+		break;
+	      }
+	    else if (pfound == NULL)
+	      {
+		/* First nonexact match found.  */
+		pfound = p;
+		indfound = option_index;
+	      }
+	    else
+	      /* Second nonexact match found.  */
+	      ambig = 1;
+	  }
+
+      if (ambig && !exact)
+	{
+	  if (opterr)
+	    fprintf (stderr, "%s: option `%s' is ambiguous\n",
+		     argv[0], argv[optind]);
+	  nextchar += my_strlen (nextchar);
+	  optind++;
+	  return BAD_OPTION;
+	}
+
+      if (pfound != NULL)
+	{
+	  option_index = indfound;
+	  optind++;
+	  if (*s)
+	    {
+	      /* Don't test has_arg with >, because some C compilers don't
+		 allow it to be used on enums.  */
+	      if (pfound->has_arg)
+		optarg = s + 1;
+	      else
+		{
+		  if (opterr)
+		    {
+		      if (argv[optind - 1][1] == '-')
+			/* --option */
+			fprintf (stderr,
+				 "%s: option `--%s' doesn't allow an argument\n",
+				 argv[0], pfound->name);
+		      else
+			/* +option or -option */
+			fprintf (stderr,
+			     "%s: option `%c%s' doesn't allow an argument\n",
+			     argv[0], argv[optind - 1][0], pfound->name);
+		    }
+		  nextchar += my_strlen (nextchar);
+		  return BAD_OPTION;
+		}
+	    }
+	  else if (pfound->has_arg == 1)
+	    {
+	      if (optind < argc)
+		optarg = argv[optind++];
+	      else
+		{
+		  if (opterr)
+		    fprintf (stderr, "%s: option `%s' requires an argument\n",
+			     argv[0], argv[optind - 1]);
+		  nextchar += my_strlen (nextchar);
+		  return optstring[0] == ':' ? ':' : BAD_OPTION;
+		}
+	    }
+	  nextchar += my_strlen (nextchar);
+	  if (longind != NULL)
+	    *longind = option_index;
+	  if (pfound->flag)
+	    {
+	      *(pfound->flag) = pfound->val;
+	      return 0;
+	    }
+	  return pfound->val;
+	}
+      /* Can't find it as a long option.  If this is not getopt_long_only,
+	 or the option starts with '--' or is not a valid short
+	 option, then it's an error.
+	 Otherwise interpret it as a short option.  */
+      if (!long_only || argv[optind][1] == '-'
+#ifdef GETOPT_COMPAT
+	  || argv[optind][0] == '+'
+#endif				/* GETOPT_COMPAT */
+	  || my_index (optstring, *nextchar) == NULL)
+	{
+	  if (opterr)
+	    {
+	      if (argv[optind][1] == '-')
+		/* --option */
+		fprintf (stderr, "%s: unrecognized option `--%s'\n",
+			 argv[0], nextchar);
+	      else
+		/* +option or -option */
+		fprintf (stderr, "%s: unrecognized option `%c%s'\n",
+			 argv[0], argv[optind][0], nextchar);
+	    }
+	  nextchar = (char *) "";
+	  optind++;
+	  return BAD_OPTION;
+	}
+    }
+
+  /* Look at and handle the next option-character.  */
+
+  {
+    char c = *nextchar++;
+    char *temp = my_index (optstring, c);
+
+    /* Increment `optind' when we start to process its last character.  */
+    if (*nextchar == '\0')
+      ++optind;
+
+    if (temp == NULL || c == ':')
+      {
+	if (opterr)
+	  {
+#if 0
+	    if (c < 040 || c >= 0177)
+	      fprintf (stderr, "%s: unrecognized option, character code 0%o\n",
+		       argv[0], c);
+	    else
+	      fprintf (stderr, "%s: unrecognized option `-%c'\n", argv[0], c);
+#else
+	    /* 1003.2 specifies the format of this message.  */
+	    fprintf (stderr, "%s: illegal option -- %c\n", argv[0], c);
+#endif
+	  }
+	optopt = c;
+	return BAD_OPTION;
+      }
+    if (temp[1] == ':')
+      {
+	if (temp[2] == ':')
+	  {
+	    /* This is an option that accepts an argument optionally.  */
+	    if (*nextchar != '\0')
+	      {
+		optarg = nextchar;
+		optind++;
+	      }
+	    else
+	      optarg = 0;
+	    nextchar = NULL;
+	  }
+	else
+	  {
+	    /* This is an option that requires an argument.  */
+	    if (*nextchar != '\0')
+	      {
+		optarg = nextchar;
+		/* If we end this ARGV-element by taking the rest as an arg,
+		   we must advance to the next element now.  */
+		optind++;
+	      }
+	    else if (optind == argc)
+	      {
+		if (opterr)
+		  {
+#if 0
+		    fprintf (stderr, "%s: option `-%c' requires an argument\n",
+			     argv[0], c);
+#else
+		    /* 1003.2 specifies the format of this message.  */
+		    fprintf (stderr, "%s: option requires an argument -- %c\n",
+			     argv[0], c);
+#endif
+		  }
+		optopt = c;
+		if (optstring[0] == ':')
+		  c = ':';
+		else
+		  c = BAD_OPTION;
+	      }
+	    else
+	      /* We already incremented `optind' once;
+		 increment it again when taking next ARGV-elt as argument.  */
+	      optarg = argv[optind++];
+	    nextchar = NULL;
+	  }
+      }
+    return c;
+  }
+}
+
+int
+getopt (argc, argv, optstring)
+     int argc;
+     char *const *argv;
+     const char *optstring;
+{
+  return _getopt_internal (argc, argv, optstring,
+			   (const struct option *) 0,
+			   (int *) 0,
+			   0);
+}
+
+int
+getopt_long (argc, argv, options, long_options, opt_index)
+     int argc;
+     char *const *argv;
+     const char *options;
+     const struct option *long_options;
+     int *opt_index;
+{
+  return _getopt_internal (argc, argv, options, long_options, opt_index, 0);
+}
+
+#endif	/* _LIBC or not __GNU_LIBRARY__.  */
+
+#ifdef TEST
+
+/* Compile with -DTEST to make an executable for use in testing
+   the above definition of `getopt'.  */
+
+int
+main (argc, argv)
+     int argc;
+     char **argv;
+{
+  int c;
+  int digit_optind = 0;
+
+  while (1)
+    {
+      int this_option_optind = optind ? optind : 1;
+
+      c = getopt (argc, argv, "abc:d:0123456789");
+      if (c == EOF)
+	break;
+
+      switch (c)
+	{
+	case '0':
+	case '1':
+	case '2':
+	case '3':
+	case '4':
+	case '5':
+	case '6':
+	case '7':
+	case '8':
+	case '9':
+	  if (digit_optind != 0 && digit_optind != this_option_optind)
+	    printf ("digits occur in two different argv-elements.\n");
+	  digit_optind = this_option_optind;
+	  printf ("option %c\n", c);
+	  break;
+
+	case 'a':
+	  printf ("option a\n");
+	  break;
+
+	case 'b':
+	  printf ("option b\n");
+	  break;
+
+	case 'c':
+	  printf ("option c with value `%s'\n", optarg);
+	  break;
+
+	case BAD_OPTION:
+	  break;
+
+	default:
+	  printf ("?? getopt returned character code 0%o ??\n", c);
+	}
+    }
+
+  if (optind < argc)
+    {
+      printf ("non-option ARGV-elements: ");
+      while (optind < argc)
+	printf ("%s ", argv[optind++]);
+      printf ("\n");
+    }
+
+  exit (0);
+}
+
+#endif /* TEST */
diff --git a/pppd/plugins/tacc/extras/getopt.h b/pppd/plugins/tacc/extras/getopt.h
new file mode 100644
index 0000000..0abce6e
--- /dev/null
+++ b/pppd/plugins/tacc/extras/getopt.h
@@ -0,0 +1,127 @@
+/* Declarations for getopt.
+   Copyright (C) 1989, 1990, 1991, 1992, 1993 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by the
+   Free Software Foundation; either version 2, or (at your option) any
+   later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
+
+#ifndef _GETOPT_H
+#define _GETOPT_H 1
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+/* For communication from `getopt' to the caller.
+   When `getopt' finds an option that takes an argument,
+   the argument value is returned here.
+   Also, when `ordering' is RETURN_IN_ORDER,
+   each non-option ARGV-element is returned here.  */
+
+extern char *optarg;
+
+/* Index in ARGV of the next element to be scanned.
+   This is used for communication to and from the caller
+   and for communication between successive calls to `getopt'.
+
+   On entry to `getopt', zero means this is the first call; initialize.
+
+   When `getopt' returns EOF, this is the index of the first of the
+   non-option elements that the caller should itself scan.
+
+   Otherwise, `optind' communicates from one call to the next
+   how much of ARGV has been scanned so far.  */
+
+extern int optind;
+
+/* Callers store zero here to inhibit the error message `getopt' prints
+   for unrecognized options.  */
+
+extern int opterr;
+
+/* Set to an option character which was unrecognized.  */
+
+extern int optopt;
+
+/* Describe the long-named options requested by the application.
+   The LONG_OPTIONS argument to getopt_long or getopt_long_only is a vector
+   of `struct option' terminated by an element containing a name which is
+   zero.
+
+   The field `has_arg' is:
+   no_argument		(or 0) if the option does not take an argument,
+   required_argument	(or 1) if the option requires an argument,
+   optional_argument 	(or 2) if the option takes an optional argument.
+
+   If the field `flag' is not NULL, it points to a variable that is set
+   to the value given in the field `val' when the option is found, but
+   left unchanged if the option is not found.
+
+   To have a long-named option do something other than set an `int' to
+   a compiled-in constant, such as set a value from `optarg', set the
+   option's `flag' field to zero and its `val' field to a nonzero
+   value (the equivalent single-letter option character, if there is
+   one).  For long options that have a zero `flag' field, `getopt'
+   returns the contents of the `val' field.  */
+
+struct option
+{
+#if	__STDC__
+  const char *name;
+#else
+  char *name;
+#endif
+  /* has_arg can't be an enum because some compilers complain about
+     type mismatches in all the code that assumes it is an int.  */
+  int has_arg;
+  int *flag;
+  int val;
+};
+
+/* Names for the values of the `has_arg' field of `struct option'.  */
+
+#define	no_argument		0
+#define required_argument	1
+#define optional_argument	2
+
+#if __STDC__ || defined(PROTO)
+#if defined(__GNU_LIBRARY__)
+/* Many other libraries have conflicting prototypes for getopt, with
+   differences in the consts, in stdlib.h.  To avoid compilation
+   errors, only prototype getopt for the GNU C library.  */
+extern int getopt (int argc, char *const *argv, const char *shortopts);
+#endif /* not __GNU_LIBRARY__ */
+extern int getopt_long (int argc, char *const *argv, const char *shortopts,
+		        const struct option *longopts, int *longind);
+extern int getopt_long_only (int argc, char *const *argv,
+			     const char *shortopts,
+		             const struct option *longopts, int *longind);
+
+/* Internal only.  Users should not call this directly.  */
+extern int _getopt_internal (int argc, char *const *argv,
+			     const char *shortopts,
+		             const struct option *longopts, int *longind,
+			     int long_only);
+#else /* not __STDC__ */
+extern int getopt ();
+extern int getopt_long ();
+extern int getopt_long_only ();
+
+extern int _getopt_internal ();
+#endif /* not __STDC__ */
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif /* _GETOPT_H */
diff --git a/pppd/plugins/tacc/extras/tailor.h b/pppd/plugins/tacc/extras/tailor.h
new file mode 100644
index 0000000..a97d8be
--- /dev/null
+++ b/pppd/plugins/tacc/extras/tailor.h
@@ -0,0 +1,328 @@
+/* tailor.h -- target dependent definitions
+ * Copyright (C) 1992-1993 Jean-loup Gailly.
+ * This is free software; you can redistribute it and/or modify it under the
+ * terms of the GNU General Public License, see the file COPYING.
+ */
+
+/* The target dependent definitions should be defined here only.
+ * The target dependent functions should be defined in tailor.c.
+ */
+
+/* $Id: tailor.h,v 0.18 1993/06/14 19:32:20 jloup Exp $ */
+
+#if defined(__MSDOS__) && !defined(MSDOS)
+#  define MSDOS
+#endif
+
+#if defined(__OS2__) && !defined(OS2)
+#  define OS2
+#endif
+
+#if defined(OS2) && defined(MSDOS) /* MS C under OS/2 */
+#  undef MSDOS
+#endif
+
+#ifdef MSDOS
+#  ifdef __GNUC__
+     /* DJGPP version 1.09+ on MS-DOS.
+      * The DJGPP 1.09 stat() function must be upgraded before gzip will
+      * fully work.
+      * No need for DIRENT, since <unistd.h> defines POSIX_SOURCE which
+      * implies DIRENT.
+      */
+#    define near
+#  else
+#    define MAXSEG_64K
+#    ifdef __TURBOC__
+#      define NO_OFF_T
+#      ifdef __BORLANDC__
+#        define DIRENT
+#      else
+#        define NO_UTIME
+#      endif
+#    else /* MSC */
+#      define HAVE_SYS_UTIME_H
+#      define NO_UTIME_H
+#    endif
+#  endif
+#  define PATH_SEP2 '\\'
+#  define PATH_SEP3 ':'
+#  define MAX_PATH_LEN  128
+#  define NO_MULTIPLE_DOTS
+#  define MAX_EXT_CHARS 3
+#  define Z_SUFFIX "z"
+#  define NO_CHOWN
+#  define PROTO
+#  define STDC_HEADERS
+#  define NO_SIZE_CHECK
+#  define casemap(c) tolow(c) /* Force file names to lower case */
+#  include <io.h>
+#  define OS_CODE  0x00
+#  define SET_BINARY_MODE(fd) setmode(fd, O_BINARY)
+#  if !defined(NO_ASM) && !defined(ASMV)
+#    define ASMV
+#  endif
+#else
+#  define near
+#endif
+
+#ifdef OS2
+#  define PATH_SEP2 '\\'
+#  define PATH_SEP3 ':'
+#  define MAX_PATH_LEN  260
+#  ifdef OS2FAT
+#    define NO_MULTIPLE_DOTS
+#    define MAX_EXT_CHARS 3
+#    define Z_SUFFIX "z"
+#    define casemap(c) tolow(c)
+#  endif
+#  define NO_CHOWN
+#  define PROTO
+#  define STDC_HEADERS
+#  include <io.h>
+#  define OS_CODE  0x06
+#  define SET_BINARY_MODE(fd) setmode(fd, O_BINARY)
+#  ifdef _MSC_VER
+#    define HAVE_SYS_UTIME_H
+#    define NO_UTIME_H
+#    define MAXSEG_64K
+#    undef near
+#    define near _near
+#  endif
+#  ifdef __EMX__
+#    define HAVE_SYS_UTIME_H
+#    define NO_UTIME_H
+#    define DIRENT
+#    define EXPAND(argc,argv) \
+       {_response(&argc, &argv); _wildcard(&argc, &argv);}
+#  endif
+#  ifdef __BORLANDC__
+#    define DIRENT
+#  endif
+#  ifdef __ZTC__
+#    define NO_DIR
+#    define NO_UTIME_H
+#    include <dos.h>
+#    define EXPAND(argc,argv) \
+       {response_expand(&argc, &argv);}
+#  endif
+#endif
+
+#ifdef WIN32 /* Windows NT */
+#  define HAVE_SYS_UTIME_H
+#  define NO_UTIME_H
+#  define PATH_SEP2 '\\'
+#  define PATH_SEP3 ':'
+#  define MAX_PATH_LEN  260
+#  define NO_CHOWN
+#  define PROTO
+#  define STDC_HEADERS
+#  define SET_BINARY_MODE(fd) setmode(fd, O_BINARY)
+#  include <io.h>
+#  include <malloc.h>
+#  ifdef NTFAT
+#    define NO_MULTIPLE_DOTS
+#    define MAX_EXT_CHARS 3
+#    define Z_SUFFIX "z"
+#    define casemap(c) tolow(c) /* Force file names to lower case */
+#  endif
+#  define OS_CODE  0x0b
+#endif
+
+#ifdef MSDOS
+#  ifdef __TURBOC__
+#    include <alloc.h>
+#    define DYN_ALLOC
+     /* Turbo C 2.0 does not accept static allocations of large arrays */
+     void * fcalloc (unsigned items, unsigned size);
+     void fcfree (void *ptr);
+#  else /* MSC */
+#    include <malloc.h>
+#    define fcalloc(nitems,itemsize) halloc((long)(nitems),(itemsize))
+#    define fcfree(ptr) hfree(ptr)
+#  endif
+#else
+#  ifdef MAXSEG_64K
+#    define fcalloc(items,size) calloc((items),(size))
+#  else
+#    define fcalloc(items,size) malloc((size_t)(items)*(size_t)(size))
+#  endif
+#  define fcfree(ptr) free(ptr)
+#endif
+
+#if defined(VAXC) || defined(VMS)
+#  define PATH_SEP ']'
+#  define PATH_SEP2 ':'
+#  define SUFFIX_SEP ';'
+#  define NO_MULTIPLE_DOTS
+#  define Z_SUFFIX "-gz"
+#  define RECORD_IO 1
+#  define casemap(c) tolow(c)
+#  define OS_CODE  0x02
+#  define OPTIONS_VAR "GZIP_OPT"
+#  define STDC_HEADERS
+#  define NO_UTIME
+#  define EXPAND(argc,argv) vms_expand_args(&argc,&argv);
+#  include <file.h>
+#  define unlink delete
+#  ifdef VAXC
+#    define NO_FCNTL_H
+#    include <unixio.h>
+#  endif
+#endif
+
+#ifdef AMIGA
+#  define PATH_SEP2 ':'
+#  define STDC_HEADERS
+#  define OS_CODE  0x01
+#  define ASMV
+#  ifdef __GNUC__
+#    define DIRENT
+#    define HAVE_UNISTD_H
+#  else /* SASC */
+#    define NO_STDIN_FSTAT
+#    define SYSDIR
+#    define NO_SYMLINK
+#    define NO_CHOWN
+#    define NO_FCNTL_H
+#    include <fcntl.h> /* for read() and write() */
+#    define direct dirent
+     extern void _expand_args(int *argc, char ***argv);
+#    define EXPAND(argc,argv) _expand_args(&argc,&argv);
+#    undef  O_BINARY /* disable useless --ascii option */
+#  endif
+#endif
+
+#if defined(ATARI) || defined(atarist)
+#  ifndef STDC_HEADERS
+#    define STDC_HEADERS
+#    define HAVE_UNISTD_H
+#    define DIRENT
+#  endif
+#  define ASMV
+#  define OS_CODE  0x05
+#  ifdef TOSFS
+#    define PATH_SEP2 '\\'
+#    define PATH_SEP3 ':'
+#    define MAX_PATH_LEN  128
+#    define NO_MULTIPLE_DOTS
+#    define MAX_EXT_CHARS 3
+#    define Z_SUFFIX "z"
+#    define NO_CHOWN
+#    define casemap(c) tolow(c) /* Force file names to lower case */
+#    define NO_SYMLINK
+#  endif
+#endif
+
+#ifdef MACOS
+#  define PATH_SEP ':'
+#  define DYN_ALLOC
+#  define PROTO
+#  define NO_STDIN_FSTAT
+#  define NO_CHOWN
+#  define NO_UTIME
+#  define chmod(file, mode) (0)
+#  define OPEN(name, flags, mode) open(name, flags)
+#  define OS_CODE  0x07
+#  ifdef MPW
+#    define isatty(fd) ((fd) <= 2)
+#  endif
+#endif
+
+#ifdef __50SERIES /* Prime/PRIMOS */
+#  define PATH_SEP '>'
+#  define STDC_HEADERS
+#  define NO_MEMORY_H
+#  define NO_UTIME_H
+#  define NO_UTIME
+#  define NO_CHOWN 
+#  define NO_STDIN_FSTAT 
+#  define NO_SIZE_CHECK 
+#  define NO_SYMLINK
+#  define RECORD_IO  1
+#  define casemap(c)  tolow(c) /* Force file names to lower case */
+#  define put_char(c) put_byte((c) & 0x7F)
+#  define get_char(c) ascii2pascii(get_byte())
+#  define OS_CODE  0x0F    /* temporary, subject to change */
+#  ifdef SIGTERM
+#    undef SIGTERM         /* We don't want a signal handler for SIGTERM */
+#  endif
+#endif
+
+#if defined(pyr) && !defined(NOMEMCPY) /* Pyramid */
+#  define NOMEMCPY /* problem with overlapping copies */
+#endif
+
+#ifdef TOPS20
+#  define OS_CODE  0x0a
+#endif
+
+#ifndef unix
+#  define NO_ST_INO /* don't rely on inode numbers */
+#endif
+
+
+	/* Common defaults */
+
+#ifndef OS_CODE
+#  define OS_CODE  0x03  /* assume Unix */
+#endif
+
+#ifndef PATH_SEP
+#  define PATH_SEP '/'
+#endif
+
+#ifndef casemap
+#  define casemap(c) (c)
+#endif
+
+#ifndef OPTIONS_VAR
+#  define OPTIONS_VAR "GZIP"
+#endif
+
+#ifndef Z_SUFFIX
+#  define Z_SUFFIX ".gz"
+#endif
+
+#ifdef MAX_EXT_CHARS
+#  define MAX_SUFFIX  MAX_EXT_CHARS
+#else
+#  define MAX_SUFFIX  30
+#endif
+
+#ifndef MAKE_LEGAL_NAME
+#  ifdef NO_MULTIPLE_DOTS
+#    define MAKE_LEGAL_NAME(name)   make_simple_name(name)
+#  else
+#    define MAKE_LEGAL_NAME(name)
+#  endif
+#endif
+
+#ifndef MIN_PART
+#  define MIN_PART 3
+   /* keep at least MIN_PART chars between dots in a file name. */
+#endif
+
+#ifndef EXPAND
+#  define EXPAND(argc,argv)
+#endif
+
+#ifndef RECORD_IO
+#  define RECORD_IO 0
+#endif
+
+#ifndef SET_BINARY_MODE
+#  define SET_BINARY_MODE(fd)
+#endif
+
+#ifndef OPEN
+#  define OPEN(name, flags, mode) open(name, flags, mode)
+#endif
+
+#ifndef get_char
+#  define get_char() get_byte()
+#endif
+
+#ifndef put_char
+#  define put_char(c) put_byte(c)
+#endif
diff --git a/pppd/plugins/tacc/include/libtac.h b/pppd/plugins/tacc/include/libtac.h
new file mode 100644
index 0000000..74ec0d2
--- /dev/null
+++ b/pppd/plugins/tacc/include/libtac.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright 1997-2000 by Pawel Krawczyk <kravietz@ceti.pl>
+ * Portions copyright 2000 by Jean-Louis Noel <jln@stben.be>
+ *
+ * See http://www.ceti.com.pl/~kravietz/progs/tacacs.html
+ * for details.
+ *
+ */
+
+#ifndef _AUTH_TAC_H
+#define _AUTH_TAC_H
+
+#if defined(DEBUGTAC) && !defined(TACDEBUG)
+#define TACDEBUG(x)	syslog x;
+#else
+#define TACDEBUG(x)
+#endif
+
+/* version.c */
+extern int tac_ver_major;
+extern int tac_ver_minor;
+extern int tac_ver_patch;
+
+/* header.c */
+extern int session_id;
+extern int tac_encryption;
+extern char *tac_secret;
+
+extern int tac_connect(u_long *server, int servers);
+extern int tac_authen_pap_send(int fd, char *user, char *pass, char *tty);
+extern char *tac_authen_pap_read(int fd);
+extern HDR *_tac_req_header(u_char type);
+extern void _tac_crypt(u_char *buf, HDR *th, int length);
+extern u_char *_tac_md5_pad(int len, HDR *hdr);
+extern void tac_add_attrib(struct tac_attrib **attr, char *name, char *value);
+extern void tac_free_attrib(struct tac_attrib **attr);
+extern int tac_account_send(int fd, int type, char *user, char *tty, char *rem_addr,
+	 struct tac_attrib *attr);
+extern char *tac_account_read(int fd);
+extern void *xcalloc(size_t nmemb, size_t size);
+extern void *xrealloc(void *ptr, size_t size);
+extern char *_tac_check_header(HDR *th, int type);
+extern int tac_author_send(int fd, char *username, char *tty, 
+	struct tac_attrib *attr);
+extern void tac_author_read(int fd, struct areply *arep);
+
+#endif
+
diff --git a/pppd/plugins/tacc/include/tacplus.h b/pppd/plugins/tacc/include/tacplus.h
new file mode 100644
index 0000000..9d094ef
--- /dev/null
+++ b/pppd/plugins/tacc/include/tacplus.h
@@ -0,0 +1,259 @@
+/* 
+   Copyright (c) 1995-1998 by Cisco systems, Inc.
+   Portions copyright 1997-2000 by Pawel Krawczyk <kravietz@ceti.pl>
+
+   Permission to use, copy, modify, and distribute this software for
+   any purpose and without fee is hereby granted, provided that this
+   copyright and permission notice appear on all copies of the
+   software and supporting documentation, the name of Cisco Systems,
+   Inc. not be used in advertising or publicity pertaining to
+   distribution of the program without specific prior permission, and
+   notice be given in supporting documentation that modification,
+   copying and distribution is by permission of Cisco Systems, Inc.
+
+   Cisco Systems, Inc. makes no representations about the suitability
+   of this software for any purpose.  THIS SOFTWARE IS PROVIDED ``AS
+   IS'' AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,
+   WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+   FITNESS FOR A PARTICULAR PURPOSE.
+*/
+
+#ifndef _TACPLUS_H
+#define _TACPLUS_H
+
+#include <sys/types.h>
+
+struct tac_attrib {
+	char *attr;
+	u_char attr_len;
+	struct tac_attrib *next;
+};
+
+struct areply {
+	struct tac_attrib *attr;
+	char *msg;
+	int status;
+};
+
+#ifndef TAC_PLUS_MAXSERVERS		
+#define TAC_PLUS_MAXSERVERS		4
+#endif
+
+#ifndef TAC_PLUS_PORT
+#define	TAC_PLUS_PORT			49
+#endif
+
+#define TAC_PLUS_READ_TIMEOUT		180	/* seconds */
+#define TAC_PLUS_WRITE_TIMEOUT		180	/* seconds */
+
+/* All tacacs+ packets have the same header format */
+
+struct tac_plus_pak_hdr {
+    u_char version;
+
+#define TAC_PLUS_MAJOR_VER_MASK 0xf0
+#define TAC_PLUS_MAJOR_VER      0xc0
+
+#define TAC_PLUS_MINOR_VER_0    0x0
+#define TAC_PLUS_VER_0  (TAC_PLUS_MAJOR_VER | TAC_PLUS_MINOR_VER_0)
+
+#define TAC_PLUS_MINOR_VER_1    0x01
+#define TAC_PLUS_VER_1  (TAC_PLUS_MAJOR_VER | TAC_PLUS_MINOR_VER_1)
+
+    u_char type;
+
+#define TAC_PLUS_AUTHEN			1
+#define TAC_PLUS_AUTHOR			2
+#define TAC_PLUS_ACCT			3
+
+    u_char seq_no;		/* packet sequence number */
+    u_char encryption;		/* packet is encrypted or cleartext */
+
+#define TAC_PLUS_ENCRYPTED 0x0		/* packet is encrypted */
+#define TAC_PLUS_CLEAR     0x1		/* packet is not encrypted */
+
+    int session_id;		/* session identifier FIXME: Is this needed? */
+    int datalength;		/* length of encrypted data following this
+				 * header */
+    /* datalength bytes of encrypted data */
+};
+
+#define TAC_PLUS_HDR_SIZE 12
+
+typedef struct tac_plus_pak_hdr HDR;
+
+/* Authentication packet NAS sends to us */ 
+
+struct authen_start {
+    u_char action;
+
+#define TAC_PLUS_AUTHEN_LOGIN    0x1
+#define TAC_PLUS_AUTHEN_CHPASS   0x2
+#define TAC_PLUS_AUTHEN_SENDPASS 0x3 /* deprecated */
+#define TAC_PLUS_AUTHEN_SENDAUTH 0x4
+
+    u_char priv_lvl;
+
+#define TAC_PLUS_PRIV_LVL_MIN 0x0
+#define TAC_PLUS_PRIV_LVL_MAX 0xf
+
+    u_char authen_type;
+
+#define TAC_PLUS_AUTHEN_TYPE_ASCII  1
+#define TAC_PLUS_AUTHEN_TYPE_PAP    2
+#define TAC_PLUS_AUTHEN_TYPE_CHAP   3
+#define TAC_PLUS_AUTHEN_TYPE_ARAP   4
+
+    u_char service;
+
+#define TAC_PLUS_AUTHEN_SVC_LOGIN  1
+#define TAC_PLUS_AUTHEN_SVC_ENABLE 2
+#define TAC_PLUS_AUTHEN_SVC_PPP    3
+#define TAC_PLUS_AUTHEN_SVC_ARAP   4
+#define TAC_PLUS_AUTHEN_SVC_PT     5
+#define TAC_PLUS_AUTHEN_SVC_RCMD   6
+#define TAC_PLUS_AUTHEN_SVC_X25    7
+#define TAC_PLUS_AUTHEN_SVC_NASI   8
+
+    u_char user_len;
+    u_char port_len;
+    u_char rem_addr_len;
+    u_char data_len;
+    /* <user_len bytes of char data> */
+    /* <port_len bytes of char data> */
+    /* <rem_addr_len bytes of u_char data> */
+    /* <data_len bytes of u_char data> */
+};
+
+#define TAC_AUTHEN_START_FIXED_FIELDS_SIZE 8
+
+/* Authentication continue packet NAS sends to us */ 
+struct authen_cont {
+    u_short user_msg_len;
+    u_short user_data_len;
+    u_char flags;
+
+#define TAC_PLUS_CONTINUE_FLAG_ABORT 0x1
+
+    /* <user_msg_len bytes of u_char data> */
+    /* <user_data_len bytes of u_char data> */
+};
+
+#define TAC_AUTHEN_CONT_FIXED_FIELDS_SIZE 5
+
+/* Authentication reply packet we send to NAS */ 
+struct authen_reply {
+    u_char status;
+
+#define TAC_PLUS_AUTHEN_STATUS_PASS     1
+#define TAC_PLUS_AUTHEN_STATUS_FAIL     2
+#define TAC_PLUS_AUTHEN_STATUS_GETDATA  3
+#define TAC_PLUS_AUTHEN_STATUS_GETUSER  4
+#define TAC_PLUS_AUTHEN_STATUS_GETPASS  5
+#define TAC_PLUS_AUTHEN_STATUS_RESTART  6
+#define TAC_PLUS_AUTHEN_STATUS_ERROR    7 
+#define TAC_PLUS_AUTHEN_STATUS_FOLLOW   0x21
+
+    u_char flags;
+
+#define TAC_PLUS_AUTHEN_FLAG_NOECHO     0x1
+
+    u_short msg_len;
+    u_short data_len;
+
+    /* <msg_len bytes of char data> */
+    /* <data_len bytes of u_char data> */
+};
+
+#define TAC_AUTHEN_REPLY_FIXED_FIELDS_SIZE 6
+
+#define AUTHEN_METH_NONE             0x01
+#define AUTHEN_METH_KRB5             0x02
+#define AUTHEN_METH_LINE             0x03
+#define AUTHEN_METH_ENABLE           0x04
+#define AUTHEN_METH_LOCAL            0x05
+#define AUTHEN_METH_TACACSPLUS       0x06
+#define AUTHEN_METH_RCMD             0x20
+
+struct acct {
+    u_char flags;
+
+#define TAC_PLUS_ACCT_FLAG_MORE     0x1
+#define TAC_PLUS_ACCT_FLAG_START    0x2
+#define TAC_PLUS_ACCT_FLAG_STOP     0x4
+#define TAC_PLUS_ACCT_FLAG_WATCHDOG 0x8
+	    
+    u_char authen_method;
+    u_char priv_lvl;
+    u_char authen_type;
+    u_char authen_service;
+    u_char user_len;
+    u_char port_len;
+    u_char rem_addr_len;
+    u_char arg_cnt; /* the number of cmd args */
+    /* one u_char containing size for each arg */
+    /* <user_len bytes of char data> */
+    /* <port_len bytes of char data> */
+    /* <rem_addr_len bytes of u_char data> */
+    /* char data for args 1 ... n */
+};
+
+#define TAC_ACCT_REQ_FIXED_FIELDS_SIZE 9
+
+struct acct_reply {
+    u_short msg_len;
+    u_short data_len;
+    u_char status;
+
+#define TAC_PLUS_ACCT_STATUS_SUCCESS 0x1
+#define TAC_PLUS_ACCT_STATUS_ERROR   0x2
+#define TAC_PLUS_ACCT_STATUS_FOLLOW  0x21
+
+};
+
+#define TAC_ACCT_REPLY_FIXED_FIELDS_SIZE 5
+
+/* An authorization request packet */
+struct author {
+    u_char authen_method;
+    u_char priv_lvl;
+    u_char authen_type;
+    u_char service;
+
+    u_char user_len;
+    u_char port_len;
+    u_char rem_addr_len;
+    u_char arg_cnt;		/* the number of args */
+
+    /* <arg_cnt u_chars containing the lengths of args 1 to arg n> */
+    /* <user_len bytes of char data> */
+    /* <port_len bytes of char data> */
+    /* <rem_addr_len bytes of u_char data> */
+    /* <char data for each arg> */
+};
+
+#define TAC_AUTHOR_REQ_FIXED_FIELDS_SIZE 8
+
+/* An authorization reply packet */
+struct author_reply {
+    u_char status;
+    u_char arg_cnt;
+    u_short msg_len;
+    u_short data_len;
+
+#define AUTHOR_STATUS_PASS_ADD       0x01
+#define AUTHOR_STATUS_PASS_REPL      0x02
+#define AUTHOR_STATUS_FAIL           0x10
+#define AUTHOR_STATUS_ERROR          0x11
+#define AUTHOR_STATUS_FOLLOW	     0x21
+
+    /* <arg_cnt u_chars containing the lengths of arg 1 to arg n> */
+    /* <msg_len bytes of char data> */
+    /* <data_len bytes of char data> */
+    /* <char data for each arg> */
+};
+
+#define TAC_AUTHOR_REPLY_FIXED_FIELDS_SIZE 6
+
+
+#endif
diff --git a/pppd/plugins/tacc/lib/Makefile b/pppd/plugins/tacc/lib/Makefile
new file mode 100644
index 0000000..4ae17a8
--- /dev/null
+++ b/pppd/plugins/tacc/lib/Makefile
@@ -0,0 +1,48 @@
+#CFLAGS = -pipe -fPIC -I../include $(OPTIMIZE)
+CFLAGS += -I../include
+LIBRARY = libtac.a
+
+LIBSRCS = 	connect.c \
+			header.c \
+			version.c \
+			xalloc.c \
+			messages.c \
+			hdr_check.c \
+			attrib.c \
+			crypt.c \
+			author_s.c \
+			author_r.c \
+			authen_s.c \
+			authen_r.c \
+			acct_r.c \
+			acct_s.c
+
+
+LIBOBJS = 	connect.o \
+			header.o \
+			version.o \
+			xalloc.o \
+			messages.o \
+			hdr_check.o \
+			attrib.o \
+			crypt.o \
+			author_s.o \
+			author_r.o \
+			authen_s.o \
+			authen_r.o \
+			acct_r.o \
+			acct_s.o
+
+ifneq ($(findstring uClibc,$(LIBCDIR)),uClibc)
+LIBOBJS += md5.o
+LIBSRCS += md5.c
+endif
+
+all: $(LIBRARY)
+
+$(LIBRARY): $(LIBOBJS) Makefile
+	$(AR) rc $(LIBRARY) $(LIBOBJS)
+	$(RANLIB) $(LIBRARY)
+
+clean: 
+	rm -f core $(LIBRARY) $(LIBOBJS)
diff --git a/pppd/plugins/tacc/lib/acct_r.c b/pppd/plugins/tacc/lib/acct_r.c
new file mode 100644
index 0000000..f183970
--- /dev/null
+++ b/pppd/plugins/tacc/lib/acct_r.c
@@ -0,0 +1,86 @@
+/*
+ * Copyright 1997-2000 by Pawel Krawczyk <kravietz@ceti.pl>
+ *
+ * See http://www.ceti.com.pl/~kravietz/progs/tacacs.html
+ * for details.
+ *
+ * tac_account_read  Read accounting reply from server.
+ */
+
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <syslog.h>
+#include <netinet/in.h>
+
+#include "tacplus.h"
+#include "libtac.h"
+#include "messages.h"
+
+char *tac_account_read(int fd) {
+	HDR th;
+	struct acct_reply *tb;
+	int len_from_header, r, len_from_body;
+	char *msg = NULL;
+
+	r=read(fd, &th, TAC_PLUS_HDR_SIZE);
+	if(r < TAC_PLUS_HDR_SIZE) {
+  		syslog(LOG_ERR,
+ 			"%s: short PAP acct header, %d of %d: %m", __FUNCTION__,
+		 	r, TAC_PLUS_HDR_SIZE);
+  		return(system_err_msg);
+ 	}
+
+ 	/* check the reply fields in header */
+	msg = _tac_check_header(&th, TAC_PLUS_ACCT);
+	if(msg != NULL) 
+			return(msg);
+
+ 	len_from_header=ntohl(th.datalength);
+ 	tb=(struct acct_reply *) xcalloc(1, len_from_header);
+
+ 	/* read reply packet body */
+ 	r=read(fd, tb, len_from_header);
+ 	if(r < len_from_header) {
+  		syslog(LOG_ERR,
+			 "%s: incomplete message body, %d bytes, expected %d: %m",
+			 __FUNCTION__,
+			 r, len_from_header);
+  		return(system_err_msg);
+ 	}
+
+ 	/* decrypt the body */
+ 	_tac_crypt((u_char *) tb, &th, len_from_header);
+
+ 	/* check the length fields */
+ 	len_from_body=sizeof(tb->msg_len) + sizeof(tb->data_len) +
+            sizeof(tb->status) + tb->msg_len + tb->data_len;
+
+ 	if(len_from_header != len_from_body) {
+  		syslog(LOG_ERR,
+			"%s: invalid reply content, incorrect key?",
+			__FUNCTION__);
+  		return(system_err_msg);
+ 	}
+
+ 	/* save status and clean up */
+ 	r=tb->status;
+	if(tb->msg_len) {
+		msg=(char *) xcalloc(1, tb->msg_len);
+		bcopy(tb+TAC_ACCT_REPLY_FIXED_FIELDS_SIZE, msg, tb->msg_len); 
+	} else
+		msg="Accounting failed";
+
+ 	free(tb);
+
+ 	/* server logged our request successfully */
+	if(r == TAC_PLUS_ACCT_STATUS_SUCCESS) {
+		TACDEBUG((LOG_DEBUG, "%s: accounted ok", __FUNCTION__))
+		return(NULL);
+	}
+	/* return pointer to server message */
+	syslog(LOG_DEBUG, "%s: accounting failed, server reply was %d (%s)", 
+					__FUNCTION__, r, msg);
+ 	return(msg);
+
+}
diff --git a/pppd/plugins/tacc/lib/acct_s.c b/pppd/plugins/tacc/lib/acct_s.c
new file mode 100644
index 0000000..8562583
--- /dev/null
+++ b/pppd/plugins/tacc/lib/acct_s.c
@@ -0,0 +1,135 @@
+/*
+ * Copyright 1997-2000 by Pawel Krawczyk <kravietz@ceti.pl>
+ * Portions copyright 2000 by Jean-Louis Noel <jln@stben.be>
+ *
+ * See http://www.ceti.com.pl/~kravietz/progs/tacacs.html
+ * for details.
+ *
+ * tac_account_send  Send accounting event information to server.
+ */
+
+#include <unistd.h>
+#include <string.h>
+#include <stdlib.h>
+#include <netinet/in.h>
+#include <sys/param.h>
+#include <syslog.h>
+
+#include "tacplus.h"
+#include "libtac.h"
+#include "xalloc.h"
+
+int tac_account_send(int fd, int type, char *user, char *tty, char *rem_addr,
+	 struct tac_attrib *attr) {
+	HDR *th;
+	struct acct tb;
+	u_char user_len, port_len;
+	u_char rem_addr_len = 0;
+	struct tac_attrib *a;
+	int i = 0; 	/* arg count */
+	int pkt_len = 0;
+	int pktl = 0;
+	int w; /* write count */
+	u_char *pkt;
+	int ret = 0;
+
+	th=_tac_req_header(TAC_PLUS_ACCT);
+
+	if(!user || !tty)
+			return -1;
+	
+	/* set header options */
+ 	th->version=TAC_PLUS_VER_0;
+ 	th->encryption=tac_encryption ? TAC_PLUS_ENCRYPTED : TAC_PLUS_CLEAR;
+
+	TACDEBUG((LOG_DEBUG, "%s: user '%s', tty '%s', encrypt: %s, type: %s", \
+			__FUNCTION__, user, tty, \
+			(tac_encryption) ? "yes" : "no", \
+			(type == TAC_PLUS_ACCT_FLAG_START) ? "START" : "STOP"))
+	
+	user_len=(u_char) strlen(user);
+	port_len=(u_char) strlen(tty);
+	if(rem_addr)
+		rem_addr_len=(u_char) strlen(rem_addr);
+
+	tb.flags=(u_char) type;
+	tb.authen_method=AUTHEN_METH_TACACSPLUS;
+	tb.priv_lvl=TAC_PLUS_PRIV_LVL_MIN;
+	tb.authen_type=TAC_PLUS_AUTHEN_TYPE_PAP;
+	tb.authen_service=TAC_PLUS_AUTHEN_SVC_PPP;
+	tb.user_len=user_len;
+	tb.port_len=port_len;
+	tb.rem_addr_len=rem_addr_len;
+
+	/* allocate packet */
+	pkt=(u_char *) xcalloc(1, TAC_ACCT_REQ_FIXED_FIELDS_SIZE);
+	pkt_len=sizeof(tb);
+
+	/* fill attribute length fields */
+	a = attr;
+	while(a) {
+		
+		pktl = pkt_len;
+		pkt_len += sizeof(a->attr_len);
+	    pkt = xrealloc(pkt, pkt_len);
+
+		bcopy(&a->attr_len, pkt + pktl, sizeof(a->attr_len));
+		i++;
+
+		a = a->next;
+	}
+
+	/* fill the arg count field and add the fixed fields to packet */
+	tb.arg_cnt = i;
+	bcopy(&tb, pkt, TAC_ACCT_REQ_FIXED_FIELDS_SIZE);
+
+#define PUTATTR(data, len) \
+	pktl = pkt_len; \
+	pkt_len += len; \
+	pkt = xrealloc(pkt, pkt_len); \
+	bcopy(data, pkt + pktl, len);
+
+	/* fill user and port fields */
+	PUTATTR(user, user_len)
+	PUTATTR(tty, port_len)
+	if(rem_addr)
+		PUTATTR(rem_addr, rem_addr_len)
+
+	/* fill attributes */
+	a = attr;
+	while(a) {
+		PUTATTR(a->attr, a->attr_len)
+
+		a = a->next;
+	}
+
+	/* finished building packet, fill len_from_header in header */
+	th->datalength = htonl(pkt_len);
+
+	/* write header */
+ 	w=write(fd, th, TAC_PLUS_HDR_SIZE);
+
+	if(w < TAC_PLUS_HDR_SIZE) {
+		syslog(LOG_ERR, "%s: acct hdr send failed: wrote %d of %d",
+				__FUNCTION__, w,
+				TAC_PLUS_HDR_SIZE);
+		ret = -1;
+	}
+	
+	/* encrypt packet body  */
+ 	_tac_crypt(pkt, th, pkt_len);
+
+	/* write body */
+	w=write(fd, pkt, pkt_len);
+	if(w < pkt_len) {
+		syslog(LOG_ERR, "%s: acct body send failed: wrote %d of %d", 
+				__FUNCTION__, w,
+				pkt_len);
+		ret = -1;
+	}
+
+	free(pkt);
+	free(th);
+
+	return(ret);
+}
diff --git a/pppd/plugins/tacc/lib/attrib.c b/pppd/plugins/tacc/lib/attrib.c
new file mode 100644
index 0000000..57b5a6d
--- /dev/null
+++ b/pppd/plugins/tacc/lib/attrib.c
@@ -0,0 +1,72 @@
+/*
+ * Copyright 1997-2000 by Pawel Krawczyk <kravietz@ceti.pl>
+ *
+ * See http://www.ceti.com.pl/~kravietz/progs/tacacs.html
+ * for details.
+ *
+ * attrib.c  Procedures for handling internal list of attributes
+ *			 for accounting and authorization functions. 
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <syslog.h>
+
+#include "tacplus.h"
+#include "libtac.h"
+#include "xalloc.h"
+
+void tac_add_attrib(struct tac_attrib **attr, char *name, char *value) {
+	struct tac_attrib *a;
+	u_char l1 = (u_char) strlen(name);
+	u_char l2 = (u_char) strlen(value);
+	int total_len = l1 + l2 + 1; /* "name" + "=" + "value" */
+
+	if(total_len > 255) {
+			syslog(LOG_WARNING, "%s: attribute `%s' total length exceeds 255 characters, skipping", __FUNCTION__, name);
+			return;
+	}
+	
+	/* initialize the list if application passed us a null pointer */
+	if(*attr == NULL) {
+		*attr = (struct tac_attrib *) xcalloc(1, sizeof(struct tac_attrib));
+		a = *attr;
+	} else {
+		/* find the last allocated block */
+		a = *attr;
+		while(a->next != NULL)
+			a = a->next; /* a holds last allocated block */
+
+		a->next = (struct tac_attrib *) xcalloc(1, sizeof(struct tac_attrib)); 
+		a = a->next; /* set current block pointer to the new one */
+	}
+
+	/* fill the block */
+	a->attr_len=total_len;
+	a->attr = (char *) xcalloc(1, total_len);
+	bcopy(name, a->attr, l1);         /* paste name */
+	*(a->attr+l1)='='; 		          /* insert "=" */
+	bcopy(value, (a->attr+l1+1), l2); /* paste value */
+
+	a->next = NULL; /* make sure it's null */
+
+}
+
+void tac_free_attrib(struct tac_attrib **attr) {
+	struct tac_attrib *a;
+	struct tac_attrib *b;
+
+	if(*attr == NULL)
+			return;
+
+	a  = b = *attr;
+	
+	/* find last allocated block */
+	do {
+			a = b;
+			b = a->next;
+			free(a->attr);
+			free(a);
+	} while (b != NULL);
+
+}
diff --git a/pppd/plugins/tacc/lib/authen_r.c b/pppd/plugins/tacc/lib/authen_r.c
new file mode 100644
index 0000000..8ce0532
--- /dev/null
+++ b/pppd/plugins/tacc/lib/authen_r.c
@@ -0,0 +1,94 @@
+/*
+ * Copyright 1997-2000 by Pawel Krawczyk <kravietz@ceti.pl>
+ *
+ * See http://www.ceti.com.pl/~kravietz/progs/tacacs.html
+ * for details.
+ *
+ * authen_r.c  Read PAP authentication reply from server.
+ */
+
+#include <unistd.h>
+#include <stdlib.h>
+#include <syslog.h>
+#include <string.h>
+#include <netinet/in.h>
+
+#include "tacplus.h"
+#include "libtac.h"
+#include "messages.h"
+
+/* reads packet from TACACS+ server; returns:
+ *            NULL    if the authentication succeded
+ *  string pointer    if it failed
+ */
+char *tac_authen_pap_read(int fd) {
+ 	HDR th;
+ 	struct authen_reply *tb;
+ 	int len_from_header, r, len_from_body;
+	char *msg = NULL;
+
+ 	/* read the reply header */
+ 	r=read(fd, &th, TAC_PLUS_HDR_SIZE);
+ 	if(r < TAC_PLUS_HDR_SIZE) {
+  		syslog(LOG_ERR,
+ 			"%s: error reading PAP authen header, read %d of %d: %m",
+			__FUNCTION__,
+		 	r, TAC_PLUS_HDR_SIZE);
+  		return(system_err_msg);
+ 	}
+
+ 	/* check the reply fields in header */
+	msg = _tac_check_header(&th, TAC_PLUS_AUTHEN);
+	if(msg != NULL)
+			return(msg);
+ 
+ 	len_from_header=ntohl(th.datalength);
+ 	tb=(struct authen_reply *) xcalloc(1, len_from_header);
+
+ 	/* read reply packet body */
+ 	r=read(fd, tb, len_from_header);
+ 	if(r < len_from_header) {
+  		syslog(LOG_ERR,
+			 "%s: incomplete message body, %d bytes, expected %d: %m",
+			 __FUNCTION__,
+			 r, len_from_header);
+  		return(system_err_msg);
+ 	}
+
+ 	/* decrypt the body */
+ 	_tac_crypt((u_char *) tb, &th, len_from_header);
+
+ 	/* check the length fields */
+ 	len_from_body=sizeof(tb->status) + sizeof(tb->flags) +
+            sizeof(tb->msg_len) + sizeof(tb->data_len) +
+            tb->msg_len + tb->data_len;
+
+ 	if(len_from_header != len_from_body) {
+  		syslog(LOG_ERR,
+			"%s: invalid reply content, incorrect key?",
+			__FUNCTION__);
+  		return(system_err_msg);
+ 	}
+
+ 	/* save status and clean up */
+ 	r=tb->status;
+	if(tb->msg_len) {
+		msg=(char *) xcalloc(1, tb->msg_len);
+		bcopy(tb+TAC_AUTHEN_REPLY_FIXED_FIELDS_SIZE, msg, tb->msg_len); 
+	} else
+		msg="Login incorrect";
+
+ 	free(tb);
+
+ 	/* server authenticated username and password successfully */
+ 	if(r == TAC_PLUS_AUTHEN_STATUS_PASS) {
+		TACDEBUG((LOG_DEBUG, "%s: authentication ok", __FUNCTION__))
+		return(NULL);
+	}
+		
+	/* return pointer to server message */
+	syslog(LOG_DEBUG, "%s: authentication failed, server reply was %d (%s)", 
+					__FUNCTION__, r, msg);
+ 	return(msg);
+
+} /* tac_authen_pap_read */
diff --git a/pppd/plugins/tacc/lib/authen_s.c b/pppd/plugins/tacc/lib/authen_s.c
new file mode 100644
index 0000000..c45a630
--- /dev/null
+++ b/pppd/plugins/tacc/lib/authen_s.c
@@ -0,0 +1,102 @@
+/*
+ * Copyright 1997-2000 by Pawel Krawczyk <kravietz@ceti.pl>
+ *
+ * See http://www.ceti.com.pl/~kravietz/progs/tacacs.html
+ * for details.
+ *
+ * authen_s.c  Send PAP authentication request to the server.
+ */
+
+#include <stdlib.h>
+#include <unistd.h>
+#include <netinet/in.h>
+#include <sys/param.h>
+#include <syslog.h>
+#include <string.h>
+
+#include "tacplus.h"
+#include "libtac.h"
+
+/* this function sends a packet do TACACS+ server, asking
+ * for validation of given username and password
+ */
+int tac_authen_pap_send(int fd, char *user, char *pass, char *tty)
+{
+ 	HDR *th; 		 /* TACACS+ packet header */
+ 	struct authen_start tb; /* message body */
+ 	int user_len, port_len, pass_len, bodylength, w;
+ 	int pkt_len=0;
+ 	u_char *pkt;
+	int ret=0;
+
+ 	th=_tac_req_header(TAC_PLUS_AUTHEN);
+
+ 	/* set some header options */
+ 	th->version=TAC_PLUS_VER_1;
+ 	th->encryption=tac_encryption ? TAC_PLUS_ENCRYPTED : TAC_PLUS_CLEAR;
+
+	TACDEBUG((LOG_DEBUG, "%s: user '%s', pass '%s', tty '%s', encrypt: %s", \
+		 __FUNCTION__, user, pass, tty, \
+	 	(tac_encryption) ? "yes" : "no"))	 
+	
+ 	/* get size of submitted data */
+ 	user_len=strlen(user);
+ 	port_len=strlen(tty);
+ 	pass_len=strlen(pass);
+
+ 	/* fill the body of message */
+ 	tb.action=TAC_PLUS_AUTHEN_LOGIN;
+ 	tb.priv_lvl=TAC_PLUS_PRIV_LVL_MIN;
+ 	tb.authen_type=TAC_PLUS_AUTHEN_TYPE_PAP;
+ 	tb.service=TAC_PLUS_AUTHEN_SVC_PPP;
+ 	tb.user_len=user_len;
+ 	tb.port_len=port_len;
+ 	tb.rem_addr_len=0;          /* may be e.g Caller-ID in future */
+ 	tb.data_len=pass_len;
+
+ 	/* fill body length in header */
+ 	bodylength=sizeof(tb) + user_len
+		+ port_len + pass_len; /* + rem_addr_len */
+
+ 	th->datalength= htonl(bodylength);
+
+ 	/* we can now write the header */
+ 	w=write(fd, th, TAC_PLUS_HDR_SIZE);
+	if(w < 0 || w < TAC_PLUS_HDR_SIZE) {
+		syslog(LOG_ERR, "%s: short write on PAP header: wrote %d of %d: %m", 
+						__FUNCTION__, w, TAC_PLUS_HDR_SIZE);
+		ret=-1;
+	}
+
+ 	/* build the packet */
+ 	pkt=(u_char *) xcalloc(1, bodylength+10);
+
+ 	bcopy(&tb, pkt+pkt_len, sizeof(tb)); /* packet body beginning */
+ 	pkt_len+=sizeof(tb);
+ 	bcopy(user, pkt+pkt_len, user_len);  /* user */
+ 	pkt_len+=user_len;
+ 	bcopy(tty, pkt+pkt_len, port_len);   /* tty */
+ 	pkt_len+=port_len;
+ 	bcopy(pass, pkt+pkt_len, pass_len);  /* password */
+ 	pkt_len+=pass_len;
+
+ 	/* pkt_len == bodylength ? */
+	if(pkt_len != bodylength) {
+		TACDEBUG((LOG_DEBUG, "tac_authen_send: bodylength %d != pkt_len %d", bodylength, pkt_len));
+	} 
+ 	
+	/* encrypt the body */
+ 	_tac_crypt(pkt, th, bodylength);
+
+ 	w=write(fd, pkt, pkt_len);
+	if(w < 0 || w < pkt_len) {
+		syslog(LOG_ERR, "%s: short write on PAP body: wrote %d of %d: %m",
+					   __FUNCTION__, w, pkt_len);
+		ret=-1;
+	}
+
+ 	free(pkt);
+ 	free(th);
+
+ 	return(ret);
+} /* tac_authen_pap_send */
diff --git a/pppd/plugins/tacc/lib/author_r.c b/pppd/plugins/tacc/lib/author_r.c
new file mode 100644
index 0000000..8af05c4
--- /dev/null
+++ b/pppd/plugins/tacc/lib/author_r.c
@@ -0,0 +1,185 @@
+/*
+ * Copyright 1997-2000 by Pawel Krawczyk <kravietz@ceti.pl>
+ *
+ * See http://www.ceti.com.pl/~kravietz/progs/tacacs.html
+ * for details.
+ *
+ * author_r.c  Reads authorization reply from the server.
+ */
+
+#include <unistd.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <syslog.h>
+#include <netinet/in.h>
+#include <string.h>
+
+#include "tacplus.h"
+#include "xalloc.h"
+#include "libtac.h"
+#include "messages.h"
+
+/* This function returns structure containing 
+    1. status (granted/denied)
+    2. message for the user
+    3. list of attributes returned by server
+   The attributes should be applied to service authorization
+   is requested for, but actually the aren't. Attributes are
+   discarded. 
+*/
+void tac_author_read(int fd, struct areply *re) {
+	HDR th;
+	struct author_reply *tb = NULL;
+	int len_from_header, r, len_from_body;
+	char *pktp;
+	char *msg = NULL;
+
+	bzero(re, sizeof(struct areply));
+	
+	r=read(fd, &th, TAC_PLUS_HDR_SIZE);
+	if(r < TAC_PLUS_HDR_SIZE) {
+  		syslog(LOG_ERR,
+ 			"%s: short author header, %d of %d: %m", __FUNCTION__,
+		 	r, TAC_PLUS_HDR_SIZE);
+		re->msg = system_err_msg;
+		re->status = AUTHOR_STATUS_ERROR;
+		goto AuthorExit;
+ 	}
+
+	/* check header consistency */
+	msg = _tac_check_header(&th, TAC_PLUS_AUTHOR);
+	if(msg != NULL) {
+		/* no need to process body if header is broken */
+		re->msg = msg;
+		re->status = AUTHOR_STATUS_ERROR;
+		goto AuthorExit;
+	}
+
+ 	len_from_header=ntohl(th.datalength);
+ 	tb=(struct author_reply *) xcalloc(1, len_from_header);
+
+ 	/* read reply packet body */
+ 	r=read(fd, tb, len_from_header);
+ 	if(r < len_from_header) {
+  		syslog(LOG_ERR,
+			 "%s: short author body, %d of %d: %m", __FUNCTION__,
+			 r, len_from_header);
+		re->msg = system_err_msg;
+		re->status = AUTHOR_STATUS_ERROR;
+		goto AuthorExit;
+ 	}
+
+ 	/* decrypt the body */
+ 	_tac_crypt((u_char *) tb, &th, len_from_header);
+
+ 	/* check consistency of the reply body
+	 * len_from_header = declared in header
+	 * len_from_body = value computed from body fields
+	 */
+ 	len_from_body = TAC_AUTHOR_REPLY_FIXED_FIELDS_SIZE +
+	    		tb->msg_len + tb->data_len;
+	    
+	pktp = (u_char *) tb + TAC_AUTHOR_REPLY_FIXED_FIELDS_SIZE;
+	
+	for(r = 0; r < tb->arg_cnt; r++) {
+	    len_from_body += sizeof(u_char); /* add arg length field's size*/
+	    len_from_body += *pktp; /* add arg length itself */
+		pktp++;
+	}
+	
+ 	if(len_from_header != len_from_body) {
+  		syslog(LOG_ERR,
+			"%s: inconsistent author reply body, incorrect key?",
+			__FUNCTION__);
+		re->msg = system_err_msg;
+		re->status = AUTHOR_STATUS_ERROR;
+		goto AuthorExit;
+ 	}
+
+	/* packet seems to be consistent, prepare return messages */
+	/* server message for user */
+	if(tb->msg_len) {
+		char *msg = (char *) xcalloc(1, tb->msg_len+1);
+		bcopy((u_char *) tb+TAC_AUTHOR_REPLY_FIXED_FIELDS_SIZE
+				+ (tb->arg_cnt)*sizeof(u_char),
+				msg, tb->msg_len);
+		re->msg = msg;
+	}
+
+	/* server message to syslog */
+	if(tb->data_len) {
+		char *smsg=(char *) xcalloc(1, tb->data_len+1);
+		bcopy((u_char *) tb + TAC_AUTHOR_REPLY_FIXED_FIELDS_SIZE
+				+ (tb->arg_cnt)*sizeof(u_char)
+				+ tb->msg_len, smsg, 
+				tb->data_len);
+		syslog(LOG_ERR, "%s: author failed: %s", __FUNCTION__,smsg);
+		free(smsg);
+	}
+
+	/* prepare status */
+	switch(tb->status) {
+		/* success conditions */
+		/* XXX support optional vs mandatory arguments */
+		case AUTHOR_STATUS_PASS_ADD:
+		case AUTHOR_STATUS_PASS_REPL:
+			{
+				char *argp; 
+
+				if(!re->msg) re->msg=author_ok_msg;
+				re->status=tb->status;
+			
+				/* add attributes received to attribute list returned to
+				   the client */
+				pktp = (u_char *) tb + TAC_AUTHOR_REPLY_FIXED_FIELDS_SIZE;
+				argp = pktp + (tb->arg_cnt * sizeof(u_char)) + tb->msg_len +
+						tb->data_len;
+				/* argp points to current argument string
+				   pktp holds current argument length */
+				for(r=0; r < tb->arg_cnt; r++) {
+					char buff[256];
+					char *sep;
+					char *value;
+					
+					bcopy(argp, buff, *pktp);
+					buff[(int)*pktp] = '\0';
+					sep=index(buff, '=');
+					if(sep == NULL)
+							index(buff, '*');
+					if(sep == NULL)
+							syslog(LOG_WARNING, "%s: attribute contains no separator: %s", __FUNCTION__, buff);
+					*sep = '\0';
+					value = ++sep;
+					/* now buff points to attribute name,
+					   value to the attribute value */
+					tac_add_attrib(&re->attr, buff, value);
+					
+					argp += *pktp;
+					pktp++; 
+				}
+			}
+			
+			break;
+
+		/* authorization failure conditions */
+		/* failing to follow is allowed by RFC, page 23  */
+		case AUTHOR_STATUS_FOLLOW: 
+		case AUTHOR_STATUS_FAIL:
+			if(!re->msg) re->msg=author_fail_msg;
+			re->status=AUTHOR_STATUS_FAIL;
+			break;
+
+		/* error conditions */	
+		case AUTHOR_STATUS_ERROR:
+		default:
+			if(!re->msg) re->msg=author_err_msg;
+			re->status=AUTHOR_STATUS_ERROR;
+	}
+
+AuthorExit:
+
+	free(tb);	
+	TACDEBUG((LOG_DEBUG, "%s: server replied '%s'", __FUNCTION__, \
+			re->msg))
+	
+}
diff --git a/pppd/plugins/tacc/lib/author_s.c b/pppd/plugins/tacc/lib/author_s.c
new file mode 100644
index 0000000..12d70ec
--- /dev/null
+++ b/pppd/plugins/tacc/lib/author_s.c
@@ -0,0 +1,127 @@
+/*
+ * Copyright 1997-2000 by Pawel Krawczyk <kravietz@ceti.pl>
+ *
+ * See http://www.ceti.com.pl/~kravietz/progs/tacacs.html
+ * for details.
+ *
+ * author_s.c  Send authorization request to the server.
+ */
+
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <syslog.h>
+#include <netinet/in.h>
+#include <sys/param.h>
+
+#include "tacplus.h"
+#include "libtac.h"
+#include "xalloc.h"
+
+/* Send authorization request to the server, along with attributes
+   specified in attribute list prepared with tac_add_attrib.
+*/
+int tac_author_send(int fd, char *user, char *tty, struct tac_attrib *attr) {
+	HDR *th;
+	struct author tb;
+	u_char user_len, port_len;
+	struct tac_attrib *a;
+	int i = 0; 			/* attributes count */
+	int pkt_len = 0; 	/* current packet length */
+	int pktl = 0;		/* temporary storage for previous pkt_len values */
+	int w; 				/* write() return value */
+	u_char *pkt;		/* packet building pointer */
+	int ret = 0;
+
+	th=_tac_req_header(TAC_PLUS_AUTHOR);
+
+	/* set header options */
+ 	th->version=TAC_PLUS_VER_0;
+ 	th->encryption=tac_encryption ? TAC_PLUS_ENCRYPTED : TAC_PLUS_CLEAR;
+
+	TACDEBUG((LOG_DEBUG, "%s: user '%s', tty '%s', encrypt: %s", \
+		       	__FUNCTION__, user, \
+			tty, tac_encryption ? "yes" : "no"))
+	
+	user_len=(u_char) strlen(user);
+	port_len=(u_char) strlen(tty);
+
+	tb.authen_method=AUTHEN_METH_TACACSPLUS;
+	tb.priv_lvl=TAC_PLUS_PRIV_LVL_MIN;
+	tb.authen_type=TAC_PLUS_AUTHEN_TYPE_PAP;
+	tb.service=TAC_PLUS_AUTHEN_SVC_PPP;
+	tb.user_len=user_len;
+	tb.port_len=port_len;
+	tb.rem_addr_len=0;
+
+	/* allocate packet */
+	pkt=(u_char *) xcalloc(1, TAC_AUTHOR_REQ_FIXED_FIELDS_SIZE);
+	pkt_len=sizeof(tb);
+
+	/* fill attribute length fields */
+	a = attr;
+	while(a) {
+		
+		pktl = pkt_len;
+		pkt_len += sizeof(a->attr_len);
+		pkt = xrealloc(pkt, pkt_len);
+
+		bcopy(&a->attr_len, pkt + pktl, sizeof(a->attr_len));
+		i++;
+
+		a = a->next;
+	}
+
+	/* fill the arg count field and add the fixed fields to packet */
+	tb.arg_cnt = i;
+	bcopy(&tb, pkt, TAC_AUTHOR_REQ_FIXED_FIELDS_SIZE);
+
+#define PUTATTR(data, len) \
+	pktl = pkt_len; \
+	pkt_len += len; \
+	pkt = xrealloc(pkt, pkt_len); \
+	bcopy(data, pkt + pktl, len);
+
+	/* fill user and port fields */
+	PUTATTR(user, user_len)
+	PUTATTR(tty, port_len)
+
+	/* fill attributes */
+	a = attr;
+	while(a) {
+		PUTATTR(a->attr, a->attr_len)
+
+		a = a->next;
+	}
+
+	/* finished building packet, fill len_from_header in header */
+	th->datalength = htonl(pkt_len);
+
+	/* write header */
+ 	w=write(fd, th, TAC_PLUS_HDR_SIZE);
+
+	if(w < TAC_PLUS_HDR_SIZE) {
+		syslog(LOG_ERR, "%s: author hdr send failed: wrote %d of %d", 
+				__FUNCTION__, w,
+				TAC_PLUS_HDR_SIZE);
+		ret = -1;
+	}
+	
+	/* encrypt packet body  */
+ 	_tac_crypt(pkt, th, pkt_len);
+
+	/* write body */
+	w=write(fd, pkt, pkt_len);
+	if(w < pkt_len) {
+		syslog(LOG_ERR, "%s: author body send failed: wrote %d of %d", 
+				__FUNCTION__, w,
+				pkt_len);
+		ret = -1;
+	}
+
+	free(pkt);
+	free(th);
+
+	return(ret);
+}
diff --git a/pppd/plugins/tacc/lib/connect.c b/pppd/plugins/tacc/lib/connect.c
new file mode 100644
index 0000000..4c02b25
--- /dev/null
+++ b/pppd/plugins/tacc/lib/connect.c
@@ -0,0 +1,83 @@
+/*
+ * Copyright 1997-2000 by Pawel Krawczyk <kravietz@ceti.pl>
+ *
+ * See http://www.ceti.com.pl/~kravietz/progs/tacacs.html
+ * for details.
+ *
+ * connect.c  Open connection to server.
+ */
+
+#include <string.h>
+#include <netdb.h>
+#include <syslog.h>
+#include <stdlib.h>
+#include <signal.h>
+#include <netinet/in.h>
+#include <sys/param.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+
+#include "tacplus.h"
+#include "libtac.h"
+
+/* Returns file descriptor of open connection
+   to the first available server from list passed
+   in server table.
+*/
+int tac_connect(u_long *server, int servers) {
+	struct sockaddr_in serv_addr;
+	struct servent *s;
+	int fd;
+	int tries = 0;
+
+	if(!servers) {
+		syslog(LOG_ERR, "%s: no TACACS+ servers defined", __FUNCTION__);
+		return(-1);
+	}
+
+	while(tries < servers) {	
+
+ 		bzero( (char *) &serv_addr, sizeof(serv_addr));
+		serv_addr.sin_family = AF_INET;
+		serv_addr.sin_addr.s_addr = server[tries];
+
+		s=getservbyname("tacacs", "tcp");
+		if(s == NULL) 
+			serv_addr.sin_port = htons(TAC_PLUS_PORT);
+		else
+			serv_addr.sin_port = s->s_port;
+
+		if((fd=socket(AF_INET, SOCK_STREAM, 0)) < 0) {
+			syslog(LOG_WARNING, 
+				"%s: socket creation error for %s: %m",
+				__FUNCTION__, inet_ntoa(serv_addr.sin_addr));
+			tries++;
+			continue;
+		}
+
+		if(connect(fd, (struct sockaddr *) &serv_addr, 
+				   sizeof(serv_addr)) < 0) {
+			syslog(LOG_WARNING, 
+				"%s: connection to %s failed: %m",
+				__FUNCTION__, inet_ntoa(serv_addr.sin_addr));
+			tries++;
+			continue;
+		}
+
+		/* connected ok */
+		TACDEBUG((LOG_DEBUG, "%s: connected to %s", __FUNCTION__, \
+			       	inet_ntoa(serv_addr.sin_addr)));
+
+		return(fd);
+	}
+
+	/* all attempts failed */
+	syslog(LOG_ERR, "%s: all possible TACACS+ servers failed", __FUNCTION__); 
+	return(-1);
+
+} /* tac_connect */
+
+
+int tac_connect_single(u_long server) {
+	return(tac_connect(&server, 1));
+} /* tac_connect_single */
diff --git a/pppd/plugins/tacc/lib/crypt.c b/pppd/plugins/tacc/lib/crypt.c
new file mode 100644
index 0000000..15ee65a
--- /dev/null
+++ b/pppd/plugins/tacc/lib/crypt.c
@@ -0,0 +1,100 @@
+/*
+ * Copyright 1997-2000 Pawel Krawczyk <kravietz@ceti.pl>
+ *
+ * See http://www.ceti.com.pl/~kravietz/progs/tacacs.html
+ * for details.
+ *
+ * crypt.c  TACACS+ encryption related functions
+ *
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <syslog.h>
+
+#include "tacplus.h"
+#include "libtac.h"
+#include "xalloc.h"
+#include "md5.h"
+
+/* Produce MD5 pseudo-random pad for TACACS+ encryption.
+   Use data from packet header and secret, which
+   should be a global variable */
+u_char *_tac_md5_pad(int len, HDR *hdr)  {
+ int n, i, bufsize;
+ int bp=0; /* buffer pointer */
+ int pp=0; /* pad pointer */
+ u_char *pad;
+ u_char *buf;
+ MD5_CTX mdcontext;
+
+ /* make pseudo pad */
+ n=(int)(len/16)+1;  /* number of MD5 runs */
+ bufsize=sizeof(hdr->session_id) + strlen(tac_secret) + sizeof(hdr->version)
+         + sizeof(hdr->seq_no) + MD5_LEN + 10;
+ buf= (u_char *) xcalloc(1, bufsize);
+ pad= (u_char *) xcalloc(n, MD5_LEN);
+
+ for(i=0; i<n; i++) {
+ /* MD5_1 = MD5{session_id, secret, version, seq_no}
+    MD5_2 = MD5{session_id, secret, version, seq_no, MD5_1} */
+
+  /* place session_id, key, version and seq_no in buffer */
+  bp=0;
+  bcopy(&hdr->session_id, buf, sizeof(session_id));
+  bp+=sizeof(session_id);
+  bcopy(tac_secret, buf+bp, strlen(tac_secret));
+  bp+=strlen(tac_secret);
+  bcopy(&hdr->version, buf+bp, sizeof(hdr->version));
+  bp+=sizeof(hdr->version);
+  bcopy(&hdr->seq_no, buf+bp, sizeof(hdr->seq_no));
+  bp+=sizeof(hdr->seq_no);
+
+  /* append previous pad if this is not the first run */
+  if(i) {
+    bcopy(pad+((i-1)*MD5_LEN), buf+bp, MD5_LEN);
+    bp+=MD5_LEN;
+  }
+  
+  MD5_Init(&mdcontext);
+  MD5_Update(&mdcontext, buf, bp);
+  /* this is because MD5 implementation has changed between
+   * pppd versions 2.2.0g and 2.3.4
+   */
+#if 1
+  MD5_Final(pad+pp, &mdcontext); /* correct for pppd-2.3.4 */
+#else
+  MD5_Final(&mdcontext); /* correct for pppd-2.2.0g */
+  bcopy(&mdcontext.digest, pad+pp, MD5_LEN);
+#endif
+   
+  pp+=MD5_LEN;
+ }
+
+ free(buf);
+ return(pad);
+ 
+} /* _tac_md5_pad */
+
+/* Perform encryption/decryption on buffer. This means simply XORing
+   each byte from buffer with according byte from pseudo-random
+   pad. */
+void _tac_crypt(u_char *buf, HDR *th, int length) {
+ int i;
+ u_char *pad;
+ 
+ /* null operation if no encryption requested */
+ if(th->encryption == TAC_PLUS_ENCRYPTED) {
+ 
+  pad=_tac_md5_pad(length, th);
+ 
+  for(i=0; i<length; i++) {
+   *(buf+i) ^= pad[i];
+  }
+  
+  free(pad);
+ 
+ } else {
+  syslog(LOG_WARNING, "%s: using no TACACS+ encryption", __FUNCTION__);
+ }
+} /* _tac_crypt */
diff --git a/pppd/plugins/tacc/lib/hdr_check.c b/pppd/plugins/tacc/lib/hdr_check.c
new file mode 100644
index 0000000..547a649
--- /dev/null
+++ b/pppd/plugins/tacc/lib/hdr_check.c
@@ -0,0 +1,46 @@
+/*
+ * Copyright 1997-2000 by Pawel Krawczyk <kravietz@ceti.pl>
+ *
+ * See http://www.ceti.com.pl/~kravietz/progs/tacacs.html
+ * for details.
+ *
+ * hdr_check.c  Perform basic sanity checks on received packet.
+ */
+
+#include <syslog.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <netinet/in.h>
+
+#include "tacplus.h"
+#include "messages.h"
+#include "libtac.h"
+
+/* Checks given reply header for possible inconsistencies:
+ *  1. reply type other than expected
+ *  2. sequence number other than 2
+ *  3. session_id different from one sent in request
+ * Returns pointer to error message
+ * or NULL when the header seems to be correct
+ */
+char *_tac_check_header(HDR *th, int type) {
+
+ 	if(th->type != type) {
+  		syslog(LOG_ERR,
+			 "%s: unrelated reply, type %d, expected %d", 
+			 __FUNCTION__, th->type, type);
+  		return(protocol_err_msg);
+ 	} else if(th->seq_no != 2) {
+  		syslog(LOG_ERR, "%s: not a reply - seq_no %d != 2", 
+						__FUNCTION__, th->seq_no);
+  		return(protocol_err_msg);
+ 	} else if(ntohl(th->session_id) != session_id) {
+  		syslog(LOG_ERR, 
+			"%s: unrelated reply, received session_id %d != sent %d",
+			__FUNCTION__, ntohl(th->session_id), session_id);
+  		return(protocol_err_msg);
+ 	}
+	
+	return(NULL); /* header is ok */	
+
+} /* check header */
diff --git a/pppd/plugins/tacc/lib/header.c b/pppd/plugins/tacc/lib/header.c
new file mode 100644
index 0000000..b3f8a05
--- /dev/null
+++ b/pppd/plugins/tacc/lib/header.c
@@ -0,0 +1,53 @@
+/*
+ * Copyright 1997-2000 by Pawel Krawczyk <kravietz@ceti.pl>
+ *
+ * See http://www.ceti.com.pl/~kravietz/progs/tacacs.html
+ * for details.
+ *
+ * header.c  Create pre-filled header for TACACS+ request.
+ */
+
+#include <sys/types.h>
+#include <netinet/in.h>
+#include <sys/param.h>
+#include "tacplus.h"
+#include "libtac.h"
+#include "xalloc.h"
+#include "magic.h"
+
+/* Miscellaneous variables that are global, because we need
+ * store their values between different functions and connections.
+ */
+/* Session identifier. */
+int session_id;
+
+/* Encryption flag. */
+int tac_encryption;
+
+/* Pointer to TACACS+ shared secret string. */
+char *tac_secret;
+
+/* Returns pre-filled TACACS+ packet header of given type.
+ * 1. you MUST fill th->datalength and th->version
+ * 2. you MAY fill th->encryption
+ * 3. you are responsible for freeing allocated header 
+ * By default packet encryption is enabled. The version
+ * field depends on the TACACS+ request type and thus it
+ * cannot be predefined.
+ */
+HDR *_tac_req_header(u_char type) {
+ 	HDR *th;
+
+ 	th=(HDR *) xcalloc(1, TAC_PLUS_HDR_SIZE);
+
+ 	/* preset some packet options in header */
+ 	th->type=type;
+ 	th->seq_no=1; /* always 1 for request */
+ 	th->encryption=TAC_PLUS_ENCRYPTED;
+ 
+ 	/* make session_id from pseudo-random number */
+ 	session_id = magic();
+ 	th->session_id = htonl(session_id);
+
+ 	return(th);
+}
diff --git a/pppd/plugins/tacc/lib/magic.c b/pppd/plugins/tacc/lib/magic.c
new file mode 100644
index 0000000..0d338af
--- /dev/null
+++ b/pppd/plugins/tacc/lib/magic.c
@@ -0,0 +1,114 @@
+/*
+ * magic.c - PPP Magic Number routines.
+ *
+ * Copyright (c) 1989 Carnegie Mellon University.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms are permitted
+ * provided that the above copyright notice and this paragraph are
+ * duplicated in all such forms and that any documentation,
+ * advertising materials, and other materials related to such
+ * distribution and use acknowledge that the software was developed
+ * by Carnegie Mellon University.  The name of the
+ * University may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#include <unistd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/time.h>
+
+#include "magic.h"
+
+#ifndef linux
+static u_int32_t next;		/* Next value to return */
+#else
+#include <sys/stat.h>
+#include <fcntl.h>
+
+/* on Linux we use /dev/urandom as random numbers source 
+   I find it really cool :) */
+int rfd = 0;	/* /dev/urandom */
+#endif
+
+/*
+ * magic_init - Initialize the magic number generator.
+ *
+ * Attempts to compute a random number seed which will not repeat.
+ * The current method uses the current hostid, current process ID
+ * and current time, currently.
+ */
+void
+magic_init()
+{
+    long seed;
+    struct timeval t;
+
+#ifdef linux
+	rfd = open("/dev/urandom", O_RDONLY);
+	if(rfd != -1) 
+			return;
+	else {
+		rfd = 0;
+#endif
+	/* if /dev/urandom fails, we try traditional method */
+    gettimeofday(&t, NULL);
+    seed = gethostid() ^ t.tv_sec ^ t.tv_usec ^ getpid();
+    srand48(seed);
+#ifdef linux
+	}
+#endif
+}
+
+/*
+ * magic - Returns the next magic number.
+ */
+u_int32_t
+magic()
+{
+#ifdef linux
+	u_int32_t ret = 0;
+
+	if(rfd) 
+	{
+		read(rfd, &ret, sizeof(ret));
+		return(ret);
+	}
+	else
+    	return (u_int32_t) mrand48();
+#else
+    return (u_int32_t) mrand48();
+#endif
+}
+
+#ifdef NO_DRAND48
+/*
+ * Substitute procedures for those systems which don't have
+ * drand48 et al.
+ */
+
+double
+drand48()
+{
+    return (double)random() / (double)0x7fffffffL; /* 2**31-1 */
+}
+
+long
+mrand48()
+{
+    return random();
+}
+
+void
+srand48(seedval)
+long seedval;
+{
+    srandom((int)seedval);
+}
+
+#endif
diff --git a/pppd/plugins/tacc/lib/magic.h b/pppd/plugins/tacc/lib/magic.h
new file mode 100644
index 0000000..1f0bbb9
--- /dev/null
+++ b/pppd/plugins/tacc/lib/magic.h
@@ -0,0 +1,27 @@
+/*
+ * magic.h - PPP Magic Number definitions.
+ *
+ * Copyright (c) 1989 Carnegie Mellon University.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms are permitted
+ * provided that the above copyright notice and this paragraph are
+ * duplicated in all such forms and that any documentation,
+ * advertising materials, and other materials related to such
+ * distribution and use acknowledge that the software was developed
+ * by Carnegie Mellon University.  The name of the
+ * University may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * $Id: magic.h,v 1.3 1994/09/21 06:47:37 paulus Exp $
+ */
+
+#ifndef __P
+#define __P(args)       args
+#endif
+
+void magic_init __P((void));	/* Initialize the magic number generator */
+u_int32_t magic __P((void));	/* Returns the next magic number */
diff --git a/pppd/plugins/tacc/lib/md5.c b/pppd/plugins/tacc/lib/md5.c
new file mode 100644
index 0000000..4517e21
--- /dev/null
+++ b/pppd/plugins/tacc/lib/md5.c
@@ -0,0 +1,309 @@
+
+
+/*
+ ***********************************************************************
+ ** md5.c -- the source code for MD5 routines                         **
+ ** RSA Data Security, Inc. MD5 Message-Digest Algorithm              **
+ ** Created: 2/17/90 RLR                                              **
+ ** Revised: 1/91 SRD,AJ,BSK,JT Reference C ver., 7/10 constant corr. **
+ ***********************************************************************
+ */
+
+/*
+ ***********************************************************************
+ ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved.  **
+ **                                                                   **
+ ** License to copy and use this software is granted provided that    **
+ ** it is identified as the "RSA Data Security, Inc. MD5 Message-     **
+ ** Digest Algorithm" in all material mentioning or referencing this  **
+ ** software or this function.                                        **
+ **                                                                   **
+ ** License is also granted to make and use derivative works          **
+ ** provided that such works are identified as "derived from the RSA  **
+ ** Data Security, Inc. MD5 Message-Digest Algorithm" in all          **
+ ** material mentioning or referencing the derived work.              **
+ **                                                                   **
+ ** RSA Data Security, Inc. makes no representations concerning       **
+ ** either the merchantability of this software or the suitability    **
+ ** of this software for any particular purpose.  It is provided "as  **
+ ** is" without express or implied warranty of any kind.              **
+ **                                                                   **
+ ** These notices must be retained in any copies of any part of this  **
+ ** documentation and/or software.                                    **
+ ***********************************************************************
+ */
+
+/* string.h needed for memcpy() */
+#include <string.h>
+
+#include "md5.h"
+
+/*
+ ***********************************************************************
+ **  Message-digest routines:                                         **
+ **  To form the message digest for a message M                       **
+ **    (1) Initialize a context buffer mdContext using MD5Init        **
+ **    (2) Call MD5Update on mdContext and M                          **
+ **    (3) Call MD5Final on mdContext                                 **
+ **  The message digest is now in mdContext->digest[0...15]           **
+ ***********************************************************************
+ */
+
+/* forward declaration */
+static void Transform ();
+
+static unsigned char PADDING[64] = {
+  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+
+/* F, G, H and I are basic MD5 functions */
+#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
+#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
+#define H(x, y, z) ((x) ^ (y) ^ (z))
+#define I(x, y, z) ((y) ^ ((x) | (~z)))
+
+/* ROTATE_LEFT rotates x left n bits */
+#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))
+
+/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4 */
+/* Rotation is separate from addition to prevent recomputation */
+#define FF(a, b, c, d, x, s, ac) \
+  {(a) += F ((b), (c), (d)) + (x) + (UINT4)(ac); \
+   (a) = ROTATE_LEFT ((a), (s)); \
+   (a) += (b); \
+  }
+#define GG(a, b, c, d, x, s, ac) \
+  {(a) += G ((b), (c), (d)) + (x) + (UINT4)(ac); \
+   (a) = ROTATE_LEFT ((a), (s)); \
+   (a) += (b); \
+  }
+#define HH(a, b, c, d, x, s, ac) \
+  {(a) += H ((b), (c), (d)) + (x) + (UINT4)(ac); \
+   (a) = ROTATE_LEFT ((a), (s)); \
+   (a) += (b); \
+  }
+#define II(a, b, c, d, x, s, ac) \
+  {(a) += I ((b), (c), (d)) + (x) + (UINT4)(ac); \
+   (a) = ROTATE_LEFT ((a), (s)); \
+   (a) += (b); \
+  }
+
+#ifdef __STDC__
+#define UL(x)	x##U
+#else
+#define UL(x)	x
+#endif
+
+/* The routine MD5Init initializes the message-digest context
+   mdContext. All fields are set to zero.
+ */
+void MD5_Init (mdContext)
+MD5_CTX *mdContext;
+{
+  mdContext->i[0] = mdContext->i[1] = (UINT4)0;
+
+  /* Load magic initialization constants.
+   */
+  mdContext->buf[0] = (UINT4)0x67452301;
+  mdContext->buf[1] = (UINT4)0xefcdab89;
+  mdContext->buf[2] = (UINT4)0x98badcfe;
+  mdContext->buf[3] = (UINT4)0x10325476;
+}
+
+/* The routine MD5Update updates the message-digest context to
+   account for the presence of each of the characters inBuf[0..inLen-1]
+   in the message whose digest is being computed.
+ */
+void MD5_Update (mdContext, inBuf, inLen)
+MD5_CTX *mdContext;
+unsigned char *inBuf;
+unsigned int inLen;
+{
+  UINT4 in[16];
+  int mdi;
+  unsigned int i, ii;
+
+  /* compute number of bytes mod 64 */
+  mdi = (int)((mdContext->i[0] >> 3) & 0x3F);
+
+  /* update number of bits */
+  if ((mdContext->i[0] + ((UINT4)inLen << 3)) < mdContext->i[0])
+    mdContext->i[1]++;
+  mdContext->i[0] += ((UINT4)inLen << 3);
+  mdContext->i[1] += ((UINT4)inLen >> 29);
+
+  while (inLen--) {
+    /* add new character to buffer, increment mdi */
+    mdContext->in[mdi++] = *inBuf++;
+
+    /* transform if necessary */
+    if (mdi == 0x40) {
+      for (i = 0, ii = 0; i < 16; i++, ii += 4)
+        in[i] = (((UINT4)mdContext->in[ii+3]) << 24) |
+                (((UINT4)mdContext->in[ii+2]) << 16) |
+                (((UINT4)mdContext->in[ii+1]) << 8) |
+                ((UINT4)mdContext->in[ii]);
+      Transform (mdContext->buf, in);
+      mdi = 0;
+    }
+  }
+}
+
+/* The routine MD5Final terminates the message-digest computation and
+   ends with the desired message digest in mdContext->digest[0...15].
+ */
+void MD5_Final (hash, mdContext)
+unsigned char hash[];
+MD5_CTX *mdContext;
+{
+  UINT4 in[16];
+  int mdi;
+  unsigned int i, ii;
+  unsigned int padLen;
+
+  /* save number of bits */
+  in[14] = mdContext->i[0];
+  in[15] = mdContext->i[1];
+
+  /* compute number of bytes mod 64 */
+  mdi = (int)((mdContext->i[0] >> 3) & 0x3F);
+
+  /* pad out to 56 mod 64 */
+  padLen = (mdi < 56) ? (56 - mdi) : (120 - mdi);
+  MD5Update (mdContext, PADDING, padLen);
+
+  /* append length in bits and transform */
+  for (i = 0, ii = 0; i < 14; i++, ii += 4)
+    in[i] = (((UINT4)mdContext->in[ii+3]) << 24) |
+            (((UINT4)mdContext->in[ii+2]) << 16) |
+            (((UINT4)mdContext->in[ii+1]) << 8) |
+            ((UINT4)mdContext->in[ii]);
+  Transform (mdContext->buf, in);
+
+  /* store buffer in digest */
+  for (i = 0, ii = 0; i < 4; i++, ii += 4) {
+    mdContext->digest[ii] = (unsigned char)(mdContext->buf[i] & 0xFF);
+    mdContext->digest[ii+1] =
+      (unsigned char)((mdContext->buf[i] >> 8) & 0xFF);
+    mdContext->digest[ii+2] =
+      (unsigned char)((mdContext->buf[i] >> 16) & 0xFF);
+    mdContext->digest[ii+3] =
+      (unsigned char)((mdContext->buf[i] >> 24) & 0xFF);
+  }
+  memcpy(hash, mdContext->digest, 16);
+}
+
+/* Basic MD5 step. Transforms buf based on in.
+ */
+static void Transform (buf, in)
+UINT4 *buf;
+UINT4 *in;
+{
+  UINT4 a = buf[0], b = buf[1], c = buf[2], d = buf[3];
+
+  /* Round 1 */
+#define S11 7
+#define S12 12
+#define S13 17
+#define S14 22
+  FF ( a, b, c, d, in[ 0], S11, UL(3614090360)); /* 1 */
+  FF ( d, a, b, c, in[ 1], S12, UL(3905402710)); /* 2 */
+  FF ( c, d, a, b, in[ 2], S13, UL( 606105819)); /* 3 */
+  FF ( b, c, d, a, in[ 3], S14, UL(3250441966)); /* 4 */
+  FF ( a, b, c, d, in[ 4], S11, UL(4118548399)); /* 5 */
+  FF ( d, a, b, c, in[ 5], S12, UL(1200080426)); /* 6 */
+  FF ( c, d, a, b, in[ 6], S13, UL(2821735955)); /* 7 */
+  FF ( b, c, d, a, in[ 7], S14, UL(4249261313)); /* 8 */
+  FF ( a, b, c, d, in[ 8], S11, UL(1770035416)); /* 9 */
+  FF ( d, a, b, c, in[ 9], S12, UL(2336552879)); /* 10 */
+  FF ( c, d, a, b, in[10], S13, UL(4294925233)); /* 11 */
+  FF ( b, c, d, a, in[11], S14, UL(2304563134)); /* 12 */
+  FF ( a, b, c, d, in[12], S11, UL(1804603682)); /* 13 */
+  FF ( d, a, b, c, in[13], S12, UL(4254626195)); /* 14 */
+  FF ( c, d, a, b, in[14], S13, UL(2792965006)); /* 15 */
+  FF ( b, c, d, a, in[15], S14, UL(1236535329)); /* 16 */
+
+  /* Round 2 */
+#define S21 5
+#define S22 9
+#define S23 14
+#define S24 20
+  GG ( a, b, c, d, in[ 1], S21, UL(4129170786)); /* 17 */
+  GG ( d, a, b, c, in[ 6], S22, UL(3225465664)); /* 18 */
+  GG ( c, d, a, b, in[11], S23, UL( 643717713)); /* 19 */
+  GG ( b, c, d, a, in[ 0], S24, UL(3921069994)); /* 20 */
+  GG ( a, b, c, d, in[ 5], S21, UL(3593408605)); /* 21 */
+  GG ( d, a, b, c, in[10], S22, UL(  38016083)); /* 22 */
+  GG ( c, d, a, b, in[15], S23, UL(3634488961)); /* 23 */
+  GG ( b, c, d, a, in[ 4], S24, UL(3889429448)); /* 24 */
+  GG ( a, b, c, d, in[ 9], S21, UL( 568446438)); /* 25 */
+  GG ( d, a, b, c, in[14], S22, UL(3275163606)); /* 26 */
+  GG ( c, d, a, b, in[ 3], S23, UL(4107603335)); /* 27 */
+  GG ( b, c, d, a, in[ 8], S24, UL(1163531501)); /* 28 */
+  GG ( a, b, c, d, in[13], S21, UL(2850285829)); /* 29 */
+  GG ( d, a, b, c, in[ 2], S22, UL(4243563512)); /* 30 */
+  GG ( c, d, a, b, in[ 7], S23, UL(1735328473)); /* 31 */
+  GG ( b, c, d, a, in[12], S24, UL(2368359562)); /* 32 */
+
+  /* Round 3 */
+#define S31 4
+#define S32 11
+#define S33 16
+#define S34 23
+  HH ( a, b, c, d, in[ 5], S31, UL(4294588738)); /* 33 */
+  HH ( d, a, b, c, in[ 8], S32, UL(2272392833)); /* 34 */
+  HH ( c, d, a, b, in[11], S33, UL(1839030562)); /* 35 */
+  HH ( b, c, d, a, in[14], S34, UL(4259657740)); /* 36 */
+  HH ( a, b, c, d, in[ 1], S31, UL(2763975236)); /* 37 */
+  HH ( d, a, b, c, in[ 4], S32, UL(1272893353)); /* 38 */
+  HH ( c, d, a, b, in[ 7], S33, UL(4139469664)); /* 39 */
+  HH ( b, c, d, a, in[10], S34, UL(3200236656)); /* 40 */
+  HH ( a, b, c, d, in[13], S31, UL( 681279174)); /* 41 */
+  HH ( d, a, b, c, in[ 0], S32, UL(3936430074)); /* 42 */
+  HH ( c, d, a, b, in[ 3], S33, UL(3572445317)); /* 43 */
+  HH ( b, c, d, a, in[ 6], S34, UL(  76029189)); /* 44 */
+  HH ( a, b, c, d, in[ 9], S31, UL(3654602809)); /* 45 */
+  HH ( d, a, b, c, in[12], S32, UL(3873151461)); /* 46 */
+  HH ( c, d, a, b, in[15], S33, UL( 530742520)); /* 47 */
+  HH ( b, c, d, a, in[ 2], S34, UL(3299628645)); /* 48 */
+
+  /* Round 4 */
+#define S41 6
+#define S42 10
+#define S43 15
+#define S44 21
+  II ( a, b, c, d, in[ 0], S41, UL(4096336452)); /* 49 */
+  II ( d, a, b, c, in[ 7], S42, UL(1126891415)); /* 50 */
+  II ( c, d, a, b, in[14], S43, UL(2878612391)); /* 51 */
+  II ( b, c, d, a, in[ 5], S44, UL(4237533241)); /* 52 */
+  II ( a, b, c, d, in[12], S41, UL(1700485571)); /* 53 */
+  II ( d, a, b, c, in[ 3], S42, UL(2399980690)); /* 54 */
+  II ( c, d, a, b, in[10], S43, UL(4293915773)); /* 55 */
+  II ( b, c, d, a, in[ 1], S44, UL(2240044497)); /* 56 */
+  II ( a, b, c, d, in[ 8], S41, UL(1873313359)); /* 57 */
+  II ( d, a, b, c, in[15], S42, UL(4264355552)); /* 58 */
+  II ( c, d, a, b, in[ 6], S43, UL(2734768916)); /* 59 */
+  II ( b, c, d, a, in[13], S44, UL(1309151649)); /* 60 */
+  II ( a, b, c, d, in[ 4], S41, UL(4149444226)); /* 61 */
+  II ( d, a, b, c, in[11], S42, UL(3174756917)); /* 62 */
+  II ( c, d, a, b, in[ 2], S43, UL( 718787259)); /* 63 */
+  II ( b, c, d, a, in[ 9], S44, UL(3951481745)); /* 64 */
+
+  buf[0] += a;
+  buf[1] += b;
+  buf[2] += c;
+  buf[3] += d;
+}
+
+/*
+ ***********************************************************************
+ ** End of md5.c                                                      **
+ ******************************** (cut) ********************************
+ */
diff --git a/pppd/plugins/tacc/lib/md5.h b/pppd/plugins/tacc/lib/md5.h
new file mode 100644
index 0000000..5368588
--- /dev/null
+++ b/pppd/plugins/tacc/lib/md5.h
@@ -0,0 +1,60 @@
+/*
+ ***********************************************************************
+ ** md5.h -- header file for implementation of MD5                    **
+ ** RSA Data Security, Inc. MD5 Message-Digest Algorithm              **
+ ** Created: 2/17/90 RLR                                              **
+ ** Revised: 12/27/90 SRD,AJ,BSK,JT Reference C version               **
+ ** Revised (for MD5): RLR 4/27/91                                    **
+ **   -- G modified to have y&~z instead of y&z                       **
+ **   -- FF, GG, HH modified to add in last register done             **
+ **   -- Access pattern: round 2 works mod 5, round 3 works mod 3     **
+ **   -- distinct additive constant for each step                     **
+ **   -- round 4 added, working mod 7                                 **
+ ***********************************************************************
+ */
+
+/*
+ ***********************************************************************
+ ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved.  **
+ **                                                                   **
+ ** License to copy and use this software is granted provided that    **
+ ** it is identified as the "RSA Data Security, Inc. MD5 Message-     **
+ ** Digest Algorithm" in all material mentioning or referencing this  **
+ ** software or this function.                                        **
+ **                                                                   **
+ ** License is also granted to make and use derivative works          **
+ ** provided that such works are identified as "derived from the RSA  **
+ ** Data Security, Inc. MD5 Message-Digest Algorithm" in all          **
+ ** material mentioning or referencing the derived work.              **
+ **                                                                   **
+ ** RSA Data Security, Inc. makes no representations concerning       **
+ ** either the merchantability of this software or the suitability    **
+ ** of this software for any particular purpose.  It is provided "as  **
+ ** is" without express or implied warranty of any kind.              **
+ **                                                                   **
+ ** These notices must be retained in any copies of any part of this  **
+ ** documentation and/or software.                                    **
+ ***********************************************************************
+ */
+
+#ifndef __MD5_INCLUDE__
+
+/* typedef a 32-bit type */
+typedef unsigned int UINT4;
+
+/* Data structure for MD5 (Message-Digest) computation */
+typedef struct {
+  UINT4 i[2];                   /* number of _bits_ handled mod 2^64 */
+  UINT4 buf[4];                                    /* scratch buffer */
+  unsigned char in[64];                              /* input buffer */
+  unsigned char digest[16];     /* actual digest after MD5Final call */
+} MD5_CTX;
+
+void MD5Init ();
+void MD5Update ();
+void MD5Final ();
+
+#define MD5_LEN 16
+
+#define __MD5_INCLUDE__
+#endif /* __MD5_INCLUDE__ */
diff --git a/pppd/plugins/tacc/lib/messages.c b/pppd/plugins/tacc/lib/messages.c
new file mode 100644
index 0000000..fe71562
--- /dev/null
+++ b/pppd/plugins/tacc/lib/messages.c
@@ -0,0 +1,14 @@
+/*
+ * Copyright 1997-2000 by Pawel Krawczyk <kravietz@ceti.pl>
+ *
+ * See http://www.ceti.com.pl/~kravietz/progs/tacacs.html
+ * for details.
+ *
+ * messages.c  Various messages returned to user.
+ */
+
+char *system_err_msg="Authentication error, please contact administrator.";
+char *protocol_err_msg="Protocol error.";
+char *author_ok_msg="Service granted.";
+char *author_fail_msg="Service not allowed.";
+char *author_err_msg="Protocol error.";
diff --git a/pppd/plugins/tacc/lib/messages.h b/pppd/plugins/tacc/lib/messages.h
new file mode 100644
index 0000000..d575214
--- /dev/null
+++ b/pppd/plugins/tacc/lib/messages.h
@@ -0,0 +1,5 @@
+extern char *system_err_msg;
+extern char *protocol_err_msg;
+extern char *author_ok_msg;
+extern char *author_fail_msg;
+extern char *author_err_msg;
diff --git a/pppd/plugins/tacc/lib/version.c b/pppd/plugins/tacc/lib/version.c
new file mode 100644
index 0000000..ab454da
--- /dev/null
+++ b/pppd/plugins/tacc/lib/version.c
@@ -0,0 +1,12 @@
+/*
+ * Copyright 1997-2000 by Pawel Krawczyk <kravietz@ceti.pl>
+ *
+ * See http://www.ceti.com.pl/~kravietz/progs/tacacs.html
+ * for details.
+ *
+ * version.c  TACACS+ library version.
+ */
+
+int tac_ver_major = 1;
+int tac_ver_minor = 6;
+int tac_ver_patch = 9; /* patchlevel */
diff --git a/pppd/plugins/tacc/lib/xalloc.c b/pppd/plugins/tacc/lib/xalloc.c
new file mode 100644
index 0000000..4985f5c
--- /dev/null
+++ b/pppd/plugins/tacc/lib/xalloc.c
@@ -0,0 +1,31 @@
+/*
+ * Copyright 1997-2000 by Pawel Krawczyk <kravietz@ceti.pl>
+ *
+ * See http://www.ceti.com.pl/~kravietz/progs/tacacs.html
+ * for details.
+ *
+ * xalloc.c  Failsafe memory allocation functions.
+ *           Taken from excellent glibc.info ;)
+ */
+
+#include <syslog.h>
+#include <stdlib.h>
+
+void *xcalloc(size_t nmemb, size_t size) {
+	register void *val = calloc(nmemb, size);
+	if(val == 0) {
+		syslog(LOG_ERR, "%s: calloc(%u,%u) failed", __FUNCTION__, 
+			(unsigned)nmemb, (unsigned)size);
+		exit(1);
+	}
+	return val;
+}
+
+void *xrealloc(void *ptr, size_t size) {
+	register void *val = realloc(ptr, size);
+	if(val == 0) {
+		syslog(LOG_ERR, "%s: realloc(%u) failed", __FUNCTION__, (unsigned)size);
+		exit(1);
+	}
+	return val;
+}
diff --git a/pppd/plugins/tacc/lib/xalloc.h b/pppd/plugins/tacc/lib/xalloc.h
new file mode 100644
index 0000000..017e30b
--- /dev/null
+++ b/pppd/plugins/tacc/lib/xalloc.h
@@ -0,0 +1,2 @@
+extern void *xcalloc(size_t nmemb, size_t size);
+extern void *xrealloc(void *ptr, size_t size);
diff --git a/pppd/plugins/tacc/pppd-2.2.0g.patch b/pppd/plugins/tacc/pppd-2.2.0g.patch
new file mode 100644
index 0000000..3d7c62e
--- /dev/null
+++ b/pppd/plugins/tacc/pppd-2.2.0g.patch
@@ -0,0 +1,2089 @@
+diff -ruN ppp-2.2.0g/README.tacacs ppp-2.2.0g.tacacs/README.tacacs
+--- ppp-2.2.0g/README.tacacs	Thu Jan  1 01:00:00 1970
++++ ppp-2.2.0g.tacacs/README.tacacs	Mon Feb 16 18:52:45 1998
+@@ -0,0 +1,124 @@
++
++                          TACACS+ support for pppd
++                                      
++   
++    Copyright 1997 by Pawel Krawczyk <kravietz@ceti.com.pl>
++    
++                           Distributed under GPL
++                                      
++Introduction
++
++   This module supports subset of TACACS+ functions allowing a Linux
++   dialup server to authenticate, authorize and account users on remote
++   authentication server. This includes:
++   
++     * PAP authentication
++     * authorization for IP protocol
++     * accounting of PPP session beginning and end
++       
++   All above functions are performed from within pppd program with
++   username and password passed with PPP protocol. In addition, there is
++   standalone TACACS+ client program - tacc, which can be used as
++   replacement for login program in getty style dialup server programs.
++   
++Installation
++
++    1. Download the distribution:
++       http://ceti.com.pl/~kravietz/progs/tacc-1.5.tar.gz
++    2. Download and original pppd sources. This program was developed on
++       version 2.2.0g. You can find pppd sources on local sunsite.unc.edu
++       mirror.
++    3. Compile tacc, by entering tacc-1.5 subdirectory and typing make.
++    4. Apply the patch to pppd source tree:
++
++        patch -p0 <pppd-tacacs.patch
++    5. Configure pppd sources as described in INSTALL file.
++    6. Run make in pppd subdirectory, with the following extra
++       parameters:
++       
++        USE_TACACS_PLUS=1
++                to actually compile pppd with TACACS+ support
++                
++        USE_BIND8=1
++                if your are using BIND 8.x; this is a small workaround to
++                use old functions from libc; if you don't use BIND 8.x,
++                simply omit this parameter
++                
++    7. You should now have two programs: tacc and pppd. You should
++       install them in appropriate directory and configure your dialup
++       server to actually use them. The following is example of my
++       /etc/mgetty/login.conf:
++
++/AutoPPP/ -     autoppp /usr/sbin/pppd auth -chap +pap tacacs debug -detach
++*         -     @       /usr/local/sbin/tacc @
++
++    8. Configure your TACACS+ server. You can get it from
++       ftp://ftpeng.cisco.com/pub/tacacs/. Following options are
++       necessary in tac_plus configuration file:
++       
++        default authentication = file filename
++                passwd(5) file; use /etc/passwd even if you have shadow
++                passwords suite installed
++                
++        key = "string"
++                key used to encrypt TACACS+ packets over the network
++                
++        user = DEFAULT { default service = permit }
++                permit all valid and authenticated users to use PPP
++                
++       For more details about configuring TACACS+ server refer to
++       users_guide in the server distribution.
++    9. To enable TACACS+ authentication in pppd use the following options
++       in /etc/ppp/options file:
++       
++        tacacs-server aaa.bbb.ccc.ddd
++                TACACS+ server IP address (multiple allowed)
++                
++        tacacs-secret string
++                key used to encrypt TACACS+ packets over the network;
++                should be same as the key defined on TACACS+ server
++                
++        -tacacs-encryption
++                send packets cleartext; this is for debugging only, do
++                not use in real operations
++                
++        tacacs-accounting
++                if you want pppd to send TACACS+ accounting packets to
++                the server; currently it includes only start and stop
++                messages
++                
++        tacacs-authorize
++                if you want pppd to request authorization for use of PPP
++                for already authenticated user; currently this is limited
++                to service PPP and protocol IP
++                
++   10. When running pppd (probably from mgetty or similiar software), add
++       tacacs option, e.g.:
++
++        /usr/sbin/pppd auth +pap -chap tacacs
++
++   Note that since current version you should use tacacs option instead
++       of previous login! This option tell pppd to actually use TACACS+
++       functions.
++   11. Test if this works. If not, that's probably because keys on
++       authentication and dialup servers are different. tacc can be used
++       to test if the TACACS+ server is working correctly:
++
++        $ tacc -TRA -u user -p pass -s localhost -k 'secret key' -w
++        Authentication OK
++        Authorization OK: Service granted.
++        Accounting: START ok
++        Accounting: STOP ok
++        $ _
++       In case of problems recompiling auth_tac.c with -DDEBUGTAC will
++       cause every TACACS+ function report its progress and errors to
++       syslog. I'll appreciate such log file very much if you send me a
++       bug report.
++       
++                                     tacc
++                                       
++   tacc documentation was moved to manual page. It was also extended ;)
++     _________________________________________________________________
++   
++   Latest versions of this patch can be found on:
++   http://www.ceti.com.pl/~kravietz/progs/tacacs.html
+diff -ruN ppp-2.2.0g/pppd/ChangeLog.tacacs ppp-2.2.0g.tacacs/pppd/ChangeLog.tacacs
+--- ppp-2.2.0g/pppd/ChangeLog.tacacs	Thu Jan  1 01:00:00 1970
++++ ppp-2.2.0g.tacacs/pppd/ChangeLog.tacacs	Mon Feb 16 18:05:13 1998
+@@ -0,0 +1,31 @@
++1.5
++* Many changes in `tacc', mostly in user interface
++* 'tacc' is no longer distributed as patch to pppd
++
++1.4
++* Added more TACACS+ accounting attributes
++* Fixed some bugs in accounting
++* Functions now return server messages 
++* Accounting and authorization now work both for IP and IPX
++* Multiple TACACS+ servers may be defined
++* Major changes in the way of handling TACACS+ AAA 
++
++1.3
++* Added simple TACACS+ accounting
++* New options for pppd to enable TACACS+, authorization and accounting
++* TACACS+ procedures are no longer called from login() function 
++* Minor fixes in tacc.c and auth_tac.c
++
++1.2
++* Changed names of some internal functions (prepending "_")
++* tac_send and tac_read functions now accept file descriptor on input
++* _tac_crypt() was rewritten to be more RFC compliant
++* New function _tac_header()
++
++1.1
++* Added `tacc' client
++
++1.0
++* First working version, basic TACACS+ PAP authentication
++  on top of login() function
++
+diff -ruN ppp-2.2.0g/pppd/Makefile.linux ppp-2.2.0g.tacacs/pppd/Makefile.linux
+--- ppp-2.2.0g/pppd/Makefile.linux	Thu Feb  5 13:34:39 1998
++++ ppp-2.2.0g.tacacs/pppd/Makefile.linux	Mon Feb 16 18:10:58 1998
+@@ -20,18 +20,32 @@
+ HEADERS := $(HEADERS) .depend
+ endif
+ 
+-# CC = gcc
+-DEBUG_FLAGS = -DDEBUGALL
++CC = gcc
++#DEBUG_FLAGS = -DDEBUGTAC
+ COMPILE_FLAGS = -D_linux_=1 -DHAVE_PATHS_H
+-COPTS = -O2 # -g
++#COPTS = -Wall -ggdb3
++COPTS = -O2
+ VER = 2.2.0
+-LIBS = -lbsd -lbind -L/usr/local/lib
++LIBS = -lbsd
+ 
+ CFLAGS= $(COPTS) $(DEBUG_FLAGS) $(COMPILE_FLAGS)
+ SOURCE= RELNOTES Makefile.linux $(PPPDSRCS) $(HEADERS) $(MANPAGES)
+ 
+ ifdef USE_MS_DNS
+ CFLAGS   += -DUSE_MS_DNS=1
++endif
++
++ifdef USE_TACACS_PLUS
++CFLAGS   += -DUSE_TACACS_PLUS=1
++PPPDSRCS += auth_tac.c
++HEADERS  += auth_tac.h
++PPPDOBJS += auth_tac.o
++endif
++
++ifdef USE_BIND8
++# this really doesn't make use of BIND8
++# it's workaround to use old BIND4 functions from libc
++CFLAGS   += -D__inet_addr=inet_addr -D__inet_aton=inet_aton -D__inet_ntoa=inet_ntoa
+ endif
+ 
+ ifdef IPX_CHANGE
+diff -ruN ppp-2.2.0g/pppd/auth.c ppp-2.2.0g.tacacs/pppd/auth.c
+--- ppp-2.2.0g/pppd/auth.c	Fri Mar 15 18:19:48 1996
++++ ppp-2.2.0g.tacacs/pppd/auth.c	Wed Feb 11 15:19:31 1998
+@@ -48,6 +48,7 @@
+ #include <netdb.h>
+ #include <netinet/in.h>
+ #include <arpa/inet.h>
++#include <linux/if_ppp.h>
+ 
+ #ifdef HAS_SHADOW
+ #include <shadow.h>
+@@ -66,6 +67,14 @@
+ #include "ccp.h"
+ #include "pathnames.h"
+ 
++#ifdef USE_TACACS_PLUS
++#include "tacplus.h"
++#include "auth_tac.h"
++int task_id; 			/* task identifier for accounting */
++char *tac_username; 		/* storage between tac_login() and logout()
++				   also IPCP and IPXCP use this */
++#endif
++
+ #if defined(sun) && defined(sparc)
+ #include <alloca.h>
+ #endif /*sparc*/
+@@ -397,16 +406,23 @@
+     ret = UPAP_AUTHACK;
+     f = fopen(filename, "r");
+     if (f == NULL) {
+-	if (!uselogin) {
++	if (!uselogin
++#ifdef USE_TACACS_PLUS
++		&& !usetacacs
++#endif
++ 	) {
+ 	    syslog(LOG_ERR, "Can't open PAP password file %s: %m", filename);
+ 	    ret = UPAP_AUTHNAK;
+ 	}
+-    } else {
++    } 
++
++    else {
+ 	check_access(f, filename);
+ 	if (scan_authfile(f, user, our_name, secret, &addrs, filename) < 0
+ 	    || (secret[0] != 0 && (cryptpap || strcmp(passwd, secret) != 0)
+ 		&& strcmp(crypt(passwd, secret), secret) != 0)) {
+-	    syslog(LOG_WARNING, "PAP authentication failure for %s", user);
++	    syslog(LOG_WARNING, "PAP authfile authentication failure for %s",
++									user);
+ 	    ret = UPAP_AUTHNAK;
+ 	}
+ 	fclose(f);
+@@ -419,6 +435,17 @@
+ 	}
+     }
+ 
++#if 0 /* currently obsolete, call to tac_login was moved to upap.c */
++#ifdef USE_TACACS_PLUS
++    if(usetacacs && ret == UPAP_AUTHACK) {
++      ret = tac_login(user, passwd);
++      if(ret == UPAP_AUTHNAK) {
++       syslog(LOG_WARNING, "PAP TACACS+ authentication failure for %s", user);
++      }
++    }
++#endif
++#endif
++
+     if (ret == UPAP_AUTHNAK) {
+ 	*msg = "Login incorrect";
+ 	*msglen = strlen(*msg);
+@@ -510,6 +537,84 @@
+ }
+ #endif
+ 
++#ifdef USE_TACACS_PLUS
++/* do TACACS+ authentication instead of 
++ * checking username and password against local
++ * passwd(5) files
++ *
++ * returns:
++ *	UPAP_AUTHNAK: Login failed.
++ *	UPAP_AUTHACK: Login succeeded.
++ */
++int
++tac_login(auser, apasswd, userlen, passlen, msg, msglen)
++	char *auser;
++	char *apasswd;
++	int userlen;
++	int passlen;
++	char **msg;
++	int *msglen;
++{
++    char buf[40];
++    char *tty;
++    char *tacmsg;
++    int tac_fd;
++    struct tac_attrib *attr;
++    char passwd[256], user[256];
++
++    BCOPY(apasswd, passwd, passlen);
++    passwd[passlen] = '\0';
++    BCOPY(auser, user, userlen);
++    user[userlen] = '\0';
++
++    /* record tty name */
++    tty = devnam;
++    if(strncmp(tty, "/dev/", 5) == 0)
++	tty += 5;
++
++    tac_fd=tac_connect(tac_server, tac_servers);
++
++    if(tac_fd < 0) {
++ 	*msg = "TACACS+ server error";
++	*msglen = strlen(*msg);
++    	return(UPAP_AUTHNAK);
++    }
++
++    if(tac_authen_pap_send(tac_fd, user, passwd, tty) < 0) {
++    	*msg = "TACACS+ error";
++	*msglen = strlen(*msg);
++    	return(UPAP_AUTHNAK);
++    }
++
++    tacmsg=tac_authen_pap_read(tac_fd);
++
++    /* authentication failed, return */
++    if(tacmsg != NULL) {
++     	syslog(LOG_ERR, "TACACS+ authentication failed for `%s': %s",
++								user, tacmsg);
++     	*msg = tacmsg;
++     	*msglen = strlen(*msg);
++     	return(UPAP_AUTHNAK);
++    }
++
++    close(tac_fd);
++
++    syslog(LOG_INFO, "user %s logged in", user);
++    logwtmp(tty, user, "");
++    logged_in = TRUE;
++
++    /* store username for accounting and authorization functions */
++    tac_username = (char *) xcalloc(1, strlen(user)+1);
++    strncpy(tac_username, user, strlen(user));
++    
++    *msg = "Login ok";
++    *msglen = strlen(*msg);
++
++    return (UPAP_AUTHACK);
++
++}
++#endif /* USE_TACACS_PLUS */
++
+ /*
+  * login - Check the user name and password against the system
+  * password database, and login the user if OK.
+@@ -590,6 +695,7 @@
+     logged_in = TRUE;
+ 
+     return (UPAP_AUTHACK);
++
+ }
+ 
+ /*
+@@ -605,6 +711,7 @@
+ 	tty += 5;
+     logwtmp(tty, "", "");		/* Wipe out wtmp logout entry */
+     logged_in = FALSE;
++
+ }
+ 
+ 
+diff -ruN ppp-2.2.0g/pppd/auth_tac.c ppp-2.2.0g.tacacs/pppd/auth_tac.c
+--- ppp-2.2.0g/pppd/auth_tac.c	Thu Jan  1 01:00:00 1970
++++ ppp-2.2.0g.tacacs/pppd/auth_tac.c	Mon Feb 16 18:06:14 1998
+@@ -0,0 +1,911 @@
++/* auth_tac.c - TACACS+ PAP authentication for pppd
++ * 
++ * Copyright 1997-98 by Pawel Krawczyk <kravietz@ceti.com.pl>
++ *
++ * Distributed under GPL.
++ *
++ * See http://www.ceti.com.pl/~kravietz/progs/tacacs.html
++ * for details.
++ */
++
++#include <stdio.h>
++#include <unistd.h> 		/* getpid() */
++#include <stdlib.h> 		/* rand(), calloc() */
++#include <time.h>
++#include <syslog.h>
++#include <errno.h>
++#include <netinet/in.h> 	/* htonl,... */
++#include <string.h> 		/* bcopy,... */
++#include <netdb.h> 		/* getservbyname */
++#include "tacplus.h"
++#include "md5.h"
++#include "magic.h"
++#include "auth_tac.h"
++//#include "pppd.h"
++
++#define MD5_LEN 16
++
++int tac_ver_major=1;
++int tac_ver_minor=5;
++
++/* external and global vars used */
++int session_id; 		/* session storage for session_id */
++extern char *tac_secret;    	/* TACACS+ shared secret */
++extern int tac_encryption;  	/* do we encrypt packets? */
++char *system_err_msg="Authentication error, please contact administrator.";
++char *protocol_err_msg="Protocol error.";
++char *author_ok_msg="Service granted.";
++char *author_fail_msg="Service not allowed.";
++char *author_err_msg="Protocol error.";
++
++/* functions in this file */
++int tac_connect(u_long *server, int servers);
++int tac_authen_pap_send(int fd, char *user, char *pass, char *tty);
++char *tac_authen_pap_read(int fd);
++HDR *_tac_req_header(u_char type);
++void _tac_crypt(u_char *buf, HDR *th, int length);
++char *_tac_check_header(HDR *th, int type);
++u_char *tac_pseudo_pad(int len, HDR *hdr);
++void tac_add_attrib(struct tac_attrib *attr, char *name, char *value);
++void tac_free_attrib(struct tac_attrib *attr);
++int tac_account_send(int fd, int type, char *user, char *tty,
++	 struct tac_attrib *attr);
++char *tac_account_read(int fd);
++int tac_author_send(int fd, char *username, char *tty, 
++	struct tac_attrib *attr);
++struct areply *tac_author_read(int fd);
++void *xcalloc(size_t nmemb, size_t size);
++void *xrealloc(void *ptr, size_t size);
++
++/* this functions returns file descriptor
++ * of connection to the TACACS+ server 
++ *
++ * since v1.4 it also supports switching to
++ * secondary servers if some of them don't work
++ */
++int tac_connect(u_long *server, int servers) {
++	struct sockaddr_in serv_addr;
++	struct servent *s;
++	int fd;
++	int tries = 0;
++
++	if(!servers) {
++		syslog(LOG_ERR, "no TACACS+ servers defines");
++		return(-1);
++	}
++
++	while(tries < servers) {	
++
++ 		bzero( (char *) &serv_addr, sizeof(serv_addr));
++		serv_addr.sin_addr.s_addr = server[tries];
++
++		s=getservbyname("tacacs", "tcp");
++		if(s == NULL) 
++			serv_addr.sin_port = htons(TAC_PLUS_PORT);
++		else
++			serv_addr.sin_port = s->s_port;
++
++		if((fd=socket(AF_INET, SOCK_STREAM, 0)) < 0) {
++       	   		syslog(LOG_WARNING, 
++				"socket creation error for %s: %m",
++							ip_ntoa(server[tries]));
++			tries++;
++			continue;
++		}
++
++		if(connect(fd, (struct sockaddr *) &serv_addr, 
++						sizeof(serv_addr)) < 0)
++    		{
++     	  		syslog(LOG_WARNING, 
++				"connection to %s failed: %m",
++						ip_ntoa(server[tries]));
++			tries++;
++			continue;
++    		}
++
++		/* connected ok */
++		TACDEBUG((LOG_DEBUG, "%s: connected to %s", __FUNCTION__, \
++			       	ip_ntoa(server[tries])));
++		return(fd);
++	}
++
++	/* all attempts failed */
++	syslog(LOG_ERR, "all possible TACACS+ servers failed");
++	return(-1);
++
++} /* tac_connect */
++
++/* this function returns pre-filled TACACS+
++ * packet header of given type
++ * 1. you MUST fill th->datalength and th->version
++ * 2. you MAY fill th->encryption, th->version
++ * 3. you are responsible for freeing allocated header 
++ */
++HDR *_tac_req_header(u_char type) {
++ 	HDR *th;
++
++ 	th=(HDR *) xcalloc(1, TAC_PLUS_HDR_SIZE);
++
++ 	/* preset some packet options in header */
++ 	th->type=type;
++ 	th->seq_no=1; /* always 1 for request */
++ 	th->encryption=TAC_PLUS_ENCRYPTED;
++ 
++ 	/* make session_id from pseudo-random number */
++ 	session_id=magic();
++ 	th->session_id=htonl(session_id);
++
++ 	return(th);
++}
++
++int tac_author_send(int fd, char *user, char *tty, struct tac_attrib *attr) {
++	HDR *th;
++	struct author tb;
++	u_char user_len, port_len;
++	struct tac_attrib *a;
++	int i = 0; 	/* arg count */
++	int pkt_len = 0;
++	int w; /* write count */
++	u_char *pkt;
++	u_char *pktp;
++	int ret = 0;
++
++	th=_tac_req_header(TAC_PLUS_AUTHOR);
++
++	/* set header options */
++ 	th->version=TAC_PLUS_VER_0;
++ 	th->encryption=tac_encryption ? TAC_PLUS_ENCRYPTED : TAC_PLUS_CLEAR;
++
++	TACDEBUG((LOG_DEBUG, "%s: user '%s', tty '%s', encrypt: %s", \
++		       	__FUNCTION__, user, \
++			tty, tac_encryption ? "yes" : "no"))
++	
++	user_len=(u_char) strlen(user);
++	port_len=(u_char) strlen(tty);
++
++	tb.authen_method=AUTHEN_METH_TACACSPLUS;
++	tb.priv_lvl=TAC_PLUS_PRIV_LVL_MIN;
++	tb.authen_type=TAC_PLUS_AUTHEN_TYPE_PAP;
++	tb.service=TAC_PLUS_AUTHEN_SVC_PPP;
++	tb.user_len=user_len;
++	tb.port_len=port_len;
++	tb.rem_addr_len=0;
++
++	/* allocate packet */
++	pkt=(u_char *) xcalloc(1, TAC_AUTHOR_REQ_FIXED_FIELDS_SIZE);
++	pkt_len=sizeof(tb);
++
++	/* fill attribute length fields */
++	a = attr;
++	while(a->attr != 0 && a) {
++		
++		pktp=pkt + pkt_len; /* save before it's increased */
++		pkt_len += sizeof(a->attr_len);
++		pkt = xrealloc(pkt, pkt_len);	
++		bcopy(&a->attr_len, pktp, sizeof(a->attr_len));
++		i++;
++
++		a = a->next;
++	}
++
++	/* fill the arg count field and add the fixed fields to packet */
++	tb.arg_cnt = i;
++	bcopy(&tb, pkt, TAC_AUTHOR_REQ_FIXED_FIELDS_SIZE);
++
++#define PUTATTR(data, len) \
++	pktp = pkt + pkt_len; \
++	pkt_len += len; \
++	pkt = xrealloc(pkt, pkt_len); \
++	bcopy(data, pktp, len);
++
++	/* fill user and port fields */
++	/*
++	pktp = pkt + pkt_len;
++	pkt_len += user_len;
++	pkt = xrealloc(pkt, pkt_len);
++	bcopy(user, pktp, user_len);
++	*/
++
++	PUTATTR(user, user_len)
++	
++	/*	
++	pktp = pkt + pkt_len;
++	pkt_len += port_len;
++	pkt = xrealloc(pkt, pkt_len);
++	bcopy(tty, pktp, port_len);
++	*/
++	
++	PUTATTR(tty, port_len)
++
++	/* fill attributes */
++	a = attr;
++	while(a->attr != 0 && a) {
++		/*
++		pktp = pkt + pkt_len;
++		pkt_len += a->attr_len;
++		pkt = xrealloc(pkt, pkt_len);
++		bcopy(a->attr, pktp, a->attr_len);
++		*/
++		PUTATTR(a->attr, a->attr_len)
++
++		a = a->next;
++	}
++
++	/* finished building packet, fill len_from_header in header */
++	th->datalength = htonl(pkt_len);
++
++	/* write header */
++ 	w=write(fd, th, TAC_PLUS_HDR_SIZE);
++
++	if(w < TAC_PLUS_HDR_SIZE) {
++		syslog(LOG_ERR, "author hdr send failed: wrote %d of %d", w,
++				TAC_PLUS_HDR_SIZE);
++		ret = -1;
++	}
++	
++	/* encrypt packet body  */
++ 	_tac_crypt(pkt, th, pkt_len);
++
++	/* write body */
++	w=write(fd, pkt, pkt_len);
++	if(w < pkt_len) {
++		syslog(LOG_ERR, "author body send failed: wrote %d of %d", w,
++				pkt_len);
++		ret = -1;
++	}
++
++	free(pkt);
++	free(th);
++
++	return(ret);
++}
++
++struct areply *tac_author_read(int fd) {
++	HDR th;
++	struct author_reply *tb;
++	int len_from_header, r, len_from_body;
++	char *pktp;
++	char *msg = NULL;
++
++	struct areply *re = (struct areply *) xcalloc(1, sizeof(struct areply));
++	
++	r=read(fd, &th, TAC_PLUS_HDR_SIZE);
++	if(r < TAC_PLUS_HDR_SIZE) {
++  		syslog(LOG_ERR,
++ 			"short author header, %d of %d: %m",
++		 	r, TAC_PLUS_HDR_SIZE);
++		re->msg = system_err_msg;
++		re->status = AUTHOR_STATUS_ERROR;
++  		return(re);
++ 	}
++
++	/* check header consistency */
++	msg = _tac_check_header(&th, TAC_PLUS_AUTHOR);
++	if(msg != NULL) {
++		/* no need to process body if header is broken */
++		re->msg = msg;
++		re->status = AUTHOR_STATUS_ERROR;
++		return(re); 
++	}
++
++ 	len_from_header=ntohl(th.datalength);
++ 	tb=(struct author_reply *) xcalloc(1, len_from_header);
++
++ 	/* read reply packet body */
++ 	r=read(fd, tb, len_from_header);
++ 	if(r < len_from_header) {
++  		syslog(LOG_ERR,
++			 "short author body, %d of %d: %m",
++			 r, len_from_header);
++		re->msg = system_err_msg;
++		re->status = AUTHOR_STATUS_ERROR;
++  		return(re);
++ 	}
++
++ 	/* decrypt the body */
++ 	_tac_crypt((u_char *) tb, &th, len_from_header);
++
++ 	/* check consistency of the reply body
++	 * len_from_header = declared in header
++	 * len_from_body = value computed from body fields
++	 */
++ 	len_from_body = TAC_AUTHOR_REPLY_FIXED_FIELDS_SIZE +
++	    		tb->msg_len + tb->data_len;
++	    
++	pktp = (u_char *) tb + TAC_AUTHOR_REPLY_FIXED_FIELDS_SIZE;
++	
++	for(r = 0; r < tb->arg_cnt; r++) {
++	    len_from_body += sizeof(u_char); /* add arg length field's size*/
++	    len_from_body += *pktp; /* add arg length itself */
++	}
++	
++ 	if(len_from_header != len_from_body) {
++  		syslog(LOG_ERR,
++			"inconsistent author reply body, incorrect key?");
++		re->msg = system_err_msg;
++		re->status = AUTHOR_STATUS_ERROR;
++  		return(re);
++ 	}
++
++	/* packet seems to be consistent, prepare return messages */
++	/* server message for user */
++	if(tb->msg_len) {
++		char *msg = (char *) xcalloc(1, tb->msg_len+1);
++		bcopy(tb+TAC_AUTHOR_REPLY_FIXED_FIELDS_SIZE
++				+ (tb->arg_cnt)*sizeof(u_char),
++				msg, tb->msg_len);
++		re->msg = msg;
++	}
++
++	/* server message to syslog */
++	if(tb->data_len) {
++		char *smsg=(char *) xcalloc(1, tb->data_len+1);
++		bcopy(tb + TAC_AUTHOR_REPLY_FIXED_FIELDS_SIZE
++				+ (tb->arg_cnt)*sizeof(u_char)
++				+ tb->msg_len, smsg, 
++				tb->data_len);
++		syslog(LOG_ERR, "author failed: %s", smsg);
++		free(smsg);
++	}
++
++	/* prepare status */
++	switch(tb->status) {
++		/* success conditions */
++		case AUTHOR_STATUS_PASS_ADD:
++		case AUTHOR_STATUS_PASS_REPL:
++			if(!re->msg) re->msg=author_ok_msg;
++			re->status=tb->status;
++			break;
++
++		/* authorization failure conditions */
++		/* failing to follow is allowed by RFC, page 23  */
++		case AUTHOR_STATUS_FOLLOW: 
++		case AUTHOR_STATUS_FAIL:
++			if(!re->msg) re->msg=author_fail_msg;
++			re->status=AUTHOR_STATUS_FAIL;
++			break;
++
++		/* error conditions */	
++		case AUTHOR_STATUS_ERROR:
++		default:
++			if(!re->msg) re->msg=author_err_msg;
++			re->status=AUTHOR_STATUS_ERROR;
++	}
++
++	free(tb);	
++	TACDEBUG((LOG_DEBUG, "%s: server replied '%s'", __FUNCTION__, \
++			re->msg))
++	return(re);
++	
++}
++
++/* checks given reply header for possible inconsistencies:
++ *  - type other tha expected
++ *  - sequence number other than 2
++ *  - session id different from one sent in request
++ * returns pointer to error message
++ * or NULL when header is correct
++ */
++char *_tac_check_header(HDR *th, int type) {
++
++ 	if(th->type != type) {
++  		syslog(LOG_ERR,
++			 "unrelated reply, type %d, expected %d", th->type,
++								type);
++  		return(protocol_err_msg);
++ 	} else if(th->seq_no != 2) {
++  		syslog(LOG_ERR, "not a reply - seq_no %d != 2", th->seq_no);
++  		return(protocol_err_msg);
++ 	} else if(ntohl(th->session_id) != session_id) {
++  		syslog(LOG_ERR, 
++			"unrelated reply, received session_id %d != sent %d",
++                	ntohl(th->session_id), session_id);
++  		return(protocol_err_msg);
++ 	}
++	
++	return(NULL); /* header is ok */	
++
++} /* check header */
++
++int tac_account_send(int fd, int type, char *user, char *tty,
++	 struct tac_attrib *attr) {
++	HDR *th;
++	struct acct tb;
++	u_char user_len, port_len;
++	struct tac_attrib *a;
++	int i = 0; 	/* arg count */
++	int pkt_len = 0;
++	int w; /* write count */
++	u_char *pkt;
++	u_char *pktp;
++	int ret = 0;
++
++	th=_tac_req_header(TAC_PLUS_ACCT);
++
++	/* set header options */
++ 	th->version=TAC_PLUS_VER_0;
++ 	th->encryption=tac_encryption ? TAC_PLUS_ENCRYPTED : TAC_PLUS_CLEAR;
++
++	TACDEBUG((LOG_DEBUG, "%s: user '%s', tty '%s', encrypt: %s, type: %s", \
++			__FUNCTION__, user, tty, \
++			(tac_encryption) ? "yes" : "no", \
++			(type == TAC_PLUS_ACCT_FLAG_START) ? "START" : "STOP"))
++	
++	user_len=(u_char) strlen(user);
++	port_len=(u_char) strlen(tty);
++
++	tb.flags=(u_char) type;
++	tb.authen_method=AUTHEN_METH_TACACSPLUS;
++	tb.priv_lvl=TAC_PLUS_PRIV_LVL_MIN;
++	tb.authen_type=TAC_PLUS_AUTHEN_TYPE_PAP;
++	tb.authen_service=TAC_PLUS_AUTHEN_SVC_PPP;
++	tb.user_len=user_len;
++	tb.port_len=port_len;
++	tb.rem_addr_len=0;
++
++	/* allocate packet */
++	pkt=(u_char *) xcalloc(1, TAC_ACCT_REQ_FIXED_FIELDS_SIZE);
++	pkt_len=sizeof(tb);
++
++	/* fill attribute length fields */
++	a = attr;
++	while(a->attr != 0 && a) {
++		
++		pktp=pkt + pkt_len; /* save before it's increased */
++		pkt_len += sizeof(a->attr_len);
++		pkt = xrealloc(pkt, pkt_len);	
++		bcopy(&a->attr_len, pktp, sizeof(a->attr_len));
++		i++;
++
++		a = a->next;
++	}
++
++	/* fill the arg count field and add the fixed fields to packet */
++	tb.arg_cnt = i;
++	bcopy(&tb, pkt, TAC_ACCT_REQ_FIXED_FIELDS_SIZE);
++
++#define PUTATTR(data, len) \
++	pktp = pkt + pkt_len; \
++	pkt_len += len; \
++	pkt = xrealloc(pkt, pkt_len); \
++	bcopy(data, pktp, len);
++
++	/* fill user and port fields */
++	/*
++	pktp = pkt + pkt_len;
++	pkt_len += user_len;
++	pkt = xrealloc(pkt, pkt_len);
++	bcopy(user, pktp, user_len);
++	*/
++
++	PUTATTR(user, user_len)
++	
++	/*	
++	pktp = pkt + pkt_len;
++	pkt_len += port_len;
++	pkt = xrealloc(pkt, pkt_len);
++	bcopy(tty, pktp, port_len);
++	*/
++	
++	PUTATTR(tty, port_len)
++
++	/* fill attributes */
++	a = attr;
++	while(a->attr != 0 && a) {
++		/*
++		pktp = pkt + pkt_len;
++		pkt_len += a->attr_len;
++		pkt = xrealloc(pkt, pkt_len);
++		bcopy(a->attr, pktp, a->attr_len);
++		*/
++		PUTATTR(a->attr, a->attr_len)
++
++		a = a->next;
++	}
++
++	/* finished building packet, fill len_from_header in header */
++	th->datalength = htonl(pkt_len);
++
++	/* write header */
++ 	w=write(fd, th, TAC_PLUS_HDR_SIZE);
++
++	if(w < TAC_PLUS_HDR_SIZE) {
++		syslog(LOG_ERR, "acct hdr send failed: wrote %d of %d", w,
++				TAC_PLUS_HDR_SIZE);
++		ret = -1;
++	}
++	
++	/* encrypt packet body  */
++ 	_tac_crypt(pkt, th, pkt_len);
++
++	/* write body */
++	w=write(fd, pkt, pkt_len);
++	if(w < pkt_len) {
++		syslog(LOG_ERR, "acct body send failed: wrote %d of %d", w,
++				pkt_len);
++		ret = -1;
++	}
++
++	free(pkt);
++	free(th);
++
++	return(ret);
++}
++
++/* this function sends a packet do TACACS+ server, asking
++ * for validation of given username and password
++ */
++int tac_authen_pap_send(int fd, char *user, char *pass, char *tty)
++{
++ 	HDR *th; 		 /* TACACS+ packet header */
++ 	struct authen_start tb; /* message body */
++ 	int user_len, port_len, pass_len, bodylength, w;
++ 	int pkt_len=0;
++ 	u_char *pkt;
++	int ret=0;
++
++ 	th=_tac_req_header(TAC_PLUS_AUTHEN);
++
++ 	/* set some header options */
++ 	th->version=TAC_PLUS_VER_1;
++ 	th->encryption=tac_encryption ? TAC_PLUS_ENCRYPTED : TAC_PLUS_CLEAR;
++
++	TACDEBUG((LOG_DEBUG, "%s: user '%s', pass '%s', tty '%s', encrypt: %s", \
++		 __FUNCTION__, user, pass, tty, \
++	 	(tac_encryption) ? "yes" : "no"))	 
++	
++ 	/* get size of submitted data */
++ 	user_len=strlen(user);
++ 	port_len=strlen(tty);
++ 	pass_len=strlen(pass);
++
++ 	/* fill the body of message */
++ 	tb.action=TAC_PLUS_AUTHEN_LOGIN;
++ 	tb.priv_lvl=TAC_PLUS_PRIV_LVL_MIN;
++ 	tb.authen_type=TAC_PLUS_AUTHEN_TYPE_PAP;
++ 	tb.service=TAC_PLUS_AUTHEN_SVC_PPP;
++ 	tb.user_len=user_len;
++ 	tb.port_len=port_len;
++ 	tb.rem_addr_len=0;          /* may be e.g Caller-ID in future */
++ 	tb.data_len=pass_len;
++
++ 	/* fill body length in header */
++ 	bodylength=sizeof(tb) + user_len
++		+ port_len + pass_len; /* + rem_addr_len */
++
++ 	th->datalength= htonl(bodylength);
++
++ 	/* we can now write the header */
++ 	w=write(fd, th, TAC_PLUS_HDR_SIZE);
++	if(w < 0 || w < TAC_PLUS_HDR_SIZE) {
++		syslog(LOG_ERR, "short write on PAP header: wrote %d of %d: %m", w, TAC_PLUS_HDR_SIZE);
++		ret=-1;
++	}
++
++ 	/* build the packet */
++ 	pkt=(u_char *) xcalloc(1, bodylength+10);
++
++ 	bcopy(&tb, pkt+pkt_len, sizeof(tb)); /* packet body beginning */
++ 	pkt_len+=sizeof(tb);
++ 	bcopy(user, pkt+pkt_len, user_len);  /* user */
++ 	pkt_len+=user_len;
++ 	bcopy(tty, pkt+pkt_len, port_len);   /* tty */
++ 	pkt_len+=port_len;
++ 	bcopy(pass, pkt+pkt_len, pass_len);  /* password */
++ 	pkt_len+=pass_len;
++
++ 	/* pkt_len == bodylength ? */
++	if(pkt_len != bodylength) {
++		TACDEBUG((LOG_DEBUG, "tac_authen_send: bodylength %d != pkt_len %d", bodylength, pkt_len));
++	} 
++ 	
++	/* encrypt the body */
++ 	_tac_crypt(pkt, th, bodylength);
++
++ 	w=write(fd, pkt, pkt_len);
++	if(w < 0 || w < pkt_len) {
++		syslog(LOG_ERR, "short write on PAP body: wrote %d of %d: %m", w, pkt_len);
++		ret=-1;
++	}
++
++ 	free(pkt);
++ 	free(th);
++
++ 	return(ret);
++} /* tac_authen_pap_send */
++
++char *tac_account_read(int fd) {
++	HDR th;
++	struct acct_reply *tb;
++	int len_from_header, r, len_from_body;
++	char *msg = NULL;
++
++	r=read(fd, &th, TAC_PLUS_HDR_SIZE);
++	if(r < TAC_PLUS_HDR_SIZE) {
++  		syslog(LOG_ERR,
++ 			"short PAP acct header, %d of %d: %m",
++		 	r, TAC_PLUS_HDR_SIZE);
++  		return(system_err_msg);
++ 	}
++
++ 	/* check the reply fields in header */
++ 	if(th.type != TAC_PLUS_ACCT) {
++  		syslog(LOG_ERR,
++			 "unrelated reply, type %d, expected %d", th.type,
++			TAC_PLUS_ACCT);
++  		return(protocol_err_msg);
++ 	} else if(th.seq_no != 2) {
++  		syslog(LOG_ERR, "not a reply - seq_no %d != 2", th.seq_no);
++  		return(protocol_err_msg);
++ 	} else if(ntohl(th.session_id) != session_id) {
++  		syslog(LOG_ERR, 
++			"unrelated reply, received session_id %d != sent %d",
++                	ntohl(th.session_id), session_id);
++  		return(protocol_err_msg);
++ 	}
++
++ 	len_from_header=ntohl(th.datalength);
++ 	tb=(struct acct_reply *) xcalloc(1, len_from_header);
++
++ 	/* read reply packet body */
++ 	r=read(fd, tb, len_from_header);
++ 	if(r < len_from_header) {
++  		syslog(LOG_ERR,
++			 "incomplete message body, %d bytes, expected %d: %m",
++			 r, len_from_header);
++  		return(system_err_msg);
++ 	}
++
++ 	/* decrypt the body */
++ 	_tac_crypt((u_char *) tb, &th, len_from_header);
++
++ 	/* check the length fields */
++ 	len_from_body=sizeof(tb->msg_len) + sizeof(tb->data_len) +
++            sizeof(tb->status) + tb->msg_len + tb->data_len;
++
++ 	if(len_from_header != len_from_body) {
++  		syslog(LOG_ERR,
++			"invalid reply content, incorrect key?");
++  		return(system_err_msg);
++ 	}
++
++ 	/* save status and clean up */
++ 	r=tb->status;
++	if(tb->msg_len) {
++		msg=(char *) xcalloc(1, tb->msg_len);
++		bcopy(tb+TAC_ACCT_REPLY_FIXED_FIELDS_SIZE, msg, tb->msg_len); 
++	} else
++		msg="Accounting failed";
++
++ 	free(tb);
++
++ 	/* server logged our request successfully */
++	if(r == TAC_PLUS_ACCT_STATUS_SUCCESS) {
++		TACDEBUG((LOG_DEBUG, "%s: accounted ok", __FUNCTION__))
++		return(NULL);
++	}
++	/* return pointer to server message */
++	syslog(LOG_DEBUG, "accounting failed, server reply was %d (%s)", 
++								r, msg);
++ 	return(msg);
++
++}
++
++
++/* reads packet from TACACS+ server; returns:
++ *            NULL    if the authentication succeded
++ *  string pointer    if it failed
++ */
++char *tac_authen_pap_read(int fd) {
++ 	HDR th;
++ 	struct authen_reply *tb;
++ 	int len_from_header, r, len_from_body;
++	char *msg = NULL;
++
++ 	/* read the reply header */
++ 	r=read(fd, &th, TAC_PLUS_HDR_SIZE);
++ 	if(r < TAC_PLUS_HDR_SIZE) {
++  		syslog(LOG_ERR,
++ 			"error reading PAP authen header, read %d of %d: %m",
++		 	r, TAC_PLUS_HDR_SIZE);
++  		return(system_err_msg);
++ 	}
++
++ 	/* check the reply fields in header */
++ 	if(th.type != TAC_PLUS_AUTHEN) {
++  		syslog(LOG_ERR,
++			 "unrelated reply, type %d, expected %d", th.type,
++			TAC_PLUS_AUTHEN);
++  		return(protocol_err_msg);
++ 	} else if(th.seq_no != 2) {
++  		syslog(LOG_ERR, "not a reply - seq_no %d != 2", th.seq_no);
++  		return(protocol_err_msg);
++ 	} else if(ntohl(th.session_id) != session_id) {
++  		syslog(LOG_ERR, 
++			"unrelated reply, received session_id %d != sent %d",
++                	ntohl(th.session_id), session_id);
++  		return(protocol_err_msg);
++ 	}
++ 
++ 	len_from_header=ntohl(th.datalength);
++ 	tb=(struct authen_reply *) xcalloc(1, len_from_header);
++
++ 	/* read reply packet body */
++ 	r=read(fd, tb, len_from_header);
++ 	if(r < len_from_header) {
++  		syslog(LOG_ERR,
++			 "incomplete message body, %d bytes, expected %d: %m",
++			 r, len_from_header);
++  		return(system_err_msg);
++ 	}
++
++ 	/* decrypt the body */
++ 	_tac_crypt((u_char *) tb, &th, len_from_header);
++
++ 	/* check the length fields */
++ 	len_from_body=sizeof(tb->status) + sizeof(tb->flags) +
++            sizeof(tb->msg_len) + sizeof(tb->data_len) +
++            tb->msg_len + tb->data_len;
++
++ 	if(len_from_header != len_from_body) {
++  		syslog(LOG_ERR,
++			"invalid reply content, incorrect key?");
++  		return(system_err_msg);
++ 	}
++
++ 	/* save status and clean up */
++ 	r=tb->status;
++	if(tb->msg_len) {
++		msg=(char *) xcalloc(1, tb->msg_len);
++		bcopy(tb+TAC_AUTHEN_REPLY_FIXED_FIELDS_SIZE, msg, tb->msg_len); 
++	} else
++		msg="Login incorrect";
++
++ 	free(tb);
++
++ 	/* server authenticated username and password successfully */
++ 	if(r == TAC_PLUS_AUTHEN_STATUS_PASS) {
++		TACDEBUG((LOG_DEBUG, "%s: authentication ok", __FUNCTION__))
++		return(NULL);
++	}
++		
++	/* return pointer to server message */
++	syslog(LOG_DEBUG, "authentication failed, server reply was %d (%s)", 
++								r, msg);
++ 	return(msg);
++
++} /* tac_authen_pap_read */
++
++void tac_add_attrib(struct tac_attrib *attr, char *name, char *value) {
++	struct tac_attrib *a;
++	u_char l1, l2;
++
++	a = attr;
++
++	/* find last block in chain */
++	while((a->attr != 0) && (a->next != 0)) {
++		a = a->next;
++	}
++	
++	/* fill the block */
++	l1 = (u_char) strlen(name);
++	l2 = (u_char) strlen(value);
++	a->attr_len=l1+l2+1;
++	a->attr = (char *) xcalloc(1, l1+l2+1);
++	bcopy(name, a->attr, l1);
++	*(a->attr+l1)='=';
++	bcopy(value, (a->attr+l1+1), l2);
++
++	/* allocate next structure */
++	a->next=(struct tac_attrib *) xcalloc(1, sizeof(struct tac_attrib));
++	
++}
++
++void tac_free_attrib(struct tac_attrib *attr) {
++	struct tac_attrib *a;
++	struct tac_attrib *b;
++
++	a = attr;
++
++	while(a->attr != 0 && a) {
++		free(a->attr);
++		b = a;
++		a = a->next;
++		free(b);
++	}
++
++}
++
++/* make MD5 pseudo pad for TACACS+ encryption
++   use data from packet header and secret, which
++   should be a global var */
++u_char *_tac_md5_pad(int len, HDR *hdr)  {
++ int n, i, bufsize;
++ int bp=0; /* buffer pointer */
++ int pp=0; /* pad pointer */
++ u_char *pad;
++ u_char *buf;
++ MD5_CTX mdcontext;
++
++ /* make pseudo pad */
++ n=(int)(len/16)+1;  /* number of MD5 runs */
++ bufsize=sizeof(hdr->session_id) + strlen(tac_secret) + sizeof(hdr->version)
++         + sizeof(hdr->seq_no) + MD5_LEN + 10;
++ buf= (u_char *) xcalloc(1, bufsize);
++ pad= (u_char *) xcalloc(n, MD5_LEN);
++
++ for(i=0; i<n; i++) {
++ /* MD5_1 = MD5{session_id, secret, version, seq_no}
++    MD5_2 = MD5{session_id, secret, version, seq_no, MD5_1} */
++
++  /* place session_id, key, version and seq_no in buffer */
++  bp=0;
++  bcopy(&hdr->session_id, buf, sizeof(session_id));
++  bp+=sizeof(session_id);
++  bcopy(tac_secret, buf+bp, strlen(tac_secret));
++  bp+=strlen(tac_secret);
++  bcopy(&hdr->version, buf+bp, sizeof(hdr->version));
++  bp+=sizeof(hdr->version);
++  bcopy(&hdr->seq_no, buf+bp, sizeof(hdr->seq_no));
++  bp+=sizeof(hdr->seq_no);
++
++  /* append previous pad if this is not the first run */
++  if(i) {
++    bcopy(pad+((i-1)*MD5_LEN), buf+bp, MD5_LEN);
++    bp+=MD5_LEN;
++  }
++  
++  MD5Init(&mdcontext);
++  MD5Update(&mdcontext, buf, bp);
++  MD5Final(&mdcontext);
++  bcopy(&mdcontext.digest, pad+pp, MD5_LEN);
++   
++  pp+=MD5_LEN;
++ }
++
++ free(buf);
++ return(pad);
++ 
++} /* _tac_md5_pad */
++
++/* this function simply XORs each byte in buffer with
++   byte in pad; this is used both for encryption and
++   decryption, since XOR is symmetrical */
++void _tac_crypt(u_char *buf, HDR *th, int length) {
++ int i;
++ u_char *pad;
++ 
++ /* null operation if no encryption requested */
++ if(th->encryption == TAC_PLUS_ENCRYPTED) {
++ 
++  pad=_tac_md5_pad(length, th);
++ 
++  for(i=0; i<length; i++) {
++   *(buf+i) ^= pad[i];
++  }
++  
++  free(pad);
++ 
++ } else {
++  syslog(LOG_WARNING, "using no TACACS+ encryption");
++ }
++} /* _tac_crypt */
++
++void *xcalloc(size_t nmemb, size_t size) {
++	register void *val = calloc(nmemb, size);
++	if(val == 0) {
++		syslog(LOG_ERR, "%s: calloc(%u,%u) failed", __FUNCTION__, 
++			nmemb, size);
++		exit(1);
++	}
++	return val;
++}
++
++void *xrealloc(void *ptr, size_t size) {
++	register void *val = realloc(ptr, size);
++	if(val == 0) {
++		syslog(LOG_ERR, "%s: realloc(%u) failed", __FUNCTION__, size);
++		exit(1);
++	}
++	return val;
++}
+diff -ruN ppp-2.2.0g/pppd/auth_tac.h ppp-2.2.0g.tacacs/pppd/auth_tac.h
+--- ppp-2.2.0g/pppd/auth_tac.h	Thu Jan  1 01:00:00 1970
++++ ppp-2.2.0g.tacacs/pppd/auth_tac.h	Mon Feb 16 18:06:14 1998
+@@ -0,0 +1,40 @@
++/*
++ * Copyright 1997 by Pawel Krawczyk <kravietz@ceti.com.pl>
++ *
++ * See http://www.ceti.com.pl/~kravietz/progs/tacacs.html
++ * for details.
++ *
++ */
++
++#ifndef _AUTH_TAC_H
++#define _AUTH_TAC_H
++
++#if defined(DEBUGTAC) && !defined(TACDEBUG)
++#define TACDEBUG(x)	syslog x;
++#else
++#define TACDEBUG(x)
++#endif
++
++extern int tac_ver_major;
++extern int tac_ver_minor;
++
++extern int tac_connect(u_long *server, int servers);
++extern int tac_authen_pap_send(int fd, char *user, char *pass, char *tty);
++extern char *tac_authen_pap_read(int fd);
++extern HDR *_tac_req_header(u_char type);
++extern void _tac_crypt(u_char *buf, HDR *th, int length);
++extern u_char *_tac_md5_pad(int len, HDR *hdr);
++extern void tac_add_attrib(struct tac_attrib *attr, char *name, char *value);
++extern void tac_free_attrib(struct tac_attrib *attr);
++extern int tac_account_send(int fd, int type, char *user, char *tty,
++	 struct tac_attrib *attr);
++extern char *tac_account_read(int fd);
++extern void *xcalloc(size_t nmemb, size_t size);
++extern void *xrealloc(void *ptr, size_t size);
++extern char *_tac_check_header(HDR *th, int type);
++extern int tac_author_send(int fd, char *username, char *tty, 
++	struct tac_attrib *attr);
++extern struct areply *tac_author_read(int fd);
++
++#endif
++
+diff -ruN ppp-2.2.0g/pppd/ipcp.c ppp-2.2.0g.tacacs/pppd/ipcp.c
+--- ppp-2.2.0g/pppd/ipcp.c	Fri Nov 24 01:00:37 1995
++++ ppp-2.2.0g.tacacs/pppd/ipcp.c	Mon Feb 16 18:10:15 1998
+@@ -37,6 +37,22 @@
+ #include "ipcp.h"
+ #include "pathnames.h"
+ 
++#ifdef USE_TACACS_PLUS
++#ifdef _linux_
++#include <net/if.h>
++#include <linux/if_ppp.h>
++#endif
++#include <time.h>
++#include <unistd.h>
++#include <sys/ioctl.h>
++#include "tacplus.h"
++#include "auth_tac.h"
++#include "magic.h"
++extern char *tac_username;
++extern int task_id;
++struct ifpppstatsreq treq;
++#endif
++
+ /* global vars */
+ ipcp_options ipcp_wantoptions[NUM_PPP];	/* Options that we want to request */
+ ipcp_options ipcp_gotoptions[NUM_PPP];	/* Options that peer ack'd */
+@@ -1028,6 +1044,11 @@
+     u_int32_t mask;
+     ipcp_options *ho = &ipcp_hisoptions[f->unit];
+     ipcp_options *go = &ipcp_gotoptions[f->unit];
++#ifdef USE_TACACS_PLUS
++    char *msg;
++    char *tty;
++    struct tac_attrib *attr;
++#endif
+ 
+     IPCPDEBUG((LOG_INFO, "ipcp: up"));
+     go->default_route = 0;
+@@ -1053,13 +1074,64 @@
+     /*
+      * Check that the peer is allowed to use the IP address it wants.
+      */
+-    if (!auth_ip_addr(f->unit, ho->hisaddr)) {
++    if (!auth_ip_addr(f->unit, ho->hisaddr) 
++#ifdef USE_TACACS_PLUS
++		&& (!tac_authorize && usetacacs)
++#endif
++		) {
+ 	syslog(LOG_ERR, "Peer is not authorized to use remote address %s",
+ 	       ip_ntoa(ho->hisaddr));
+ 	ipcp_close(f->unit);
+ 	return;
+     }
+ 
++#ifdef USE_TACACS_PLUS
++	if(usetacacs) {
++		/* this is needed both by acct and author */
++		tty=devnam;
++		if(strncmp(tty, "/dev/", 5) == 0) tty+=5;	
++	}
++
++	if(tac_authorize && usetacacs) {
++		/* ask for authorization to provide IP to the peer */
++		int tac_fd;
++		struct areply *arep;
++
++		TACDEBUG((LOG_DEBUG, "ipcp_up: sending author request for %s", \
++						ip_ntoa(ho->hisaddr)))
++		attr=(struct tac_attrib *)xcalloc(1, sizeof(struct tac_attrib));
++		tac_add_attrib(attr, "service", "ppp");
++		tac_add_attrib(attr, "protocol", "ip"); /* ask for IPCP */
++		tac_add_attrib(attr, "addr", ip_ntoa(ho->hisaddr));
++
++		tac_fd=tac_connect(tac_server, tac_servers);
++
++		if(tac_author_send(tac_fd, tac_username, tty, attr) < 0) {
++			ipcp_close(f->unit);
++			TACDEBUG((LOG_DEBUG, "ipcp_up: error sending request"))
++			return;
++		}
++
++		arep = tac_author_read(tac_fd);
++
++		if(arep->status != AUTHOR_STATUS_PASS_ADD &&
++						arep->status != AUTHOR_STATUS_PASS_REPL) {
++			syslog(LOG_ERR, "IPCP authorization failure: %s", arep->msg);
++			ipcp_close(f->unit);
++			return;
++		}
++		TACDEBUG((LOG_DEBUG, "ipcp_up: successful authorization: %s", \
++						arep->msg));
++
++		/* TODO: check arep->attrib and add to
++		 * ipcp_wantoptions[f->unit].hisaddr 
++		 */
++
++		close(tac_fd);
++		tac_free_attrib(attr);
++	}
++#endif
++
+     syslog(LOG_NOTICE, "local  IP address %s", ip_ntoa(go->ouraddr));
+     syslog(LOG_NOTICE, "remote IP address %s", ip_ntoa(ho->hisaddr));
+ 
+@@ -1093,6 +1165,40 @@
+ 	if (sifproxyarp(f->unit, ho->hisaddr))
+ 	    go->proxy_arp = 1;
+ 
++#ifdef USE_TACACS_PLUS
++	if(tac_accounting && usetacacs) {
++		char buf[40];	
++		int tac_fd;
++
++		TACDEBUG((LOG_NOTICE, "ipcp_up: start accounting"));
++		attr=(struct tac_attrib *)xcalloc(1, sizeof(struct tac_attrib));
++		sprintf(buf, "%lu", time(0));
++  		tac_add_attrib(attr, "start_time", buf);
++		task_id=magic();
++		sprintf(buf, "%u", task_id);
++		tac_add_attrib(attr, "task_id", buf);
++		tac_add_attrib(attr, "service", "ppp");
++		tac_add_attrib(attr, "protocol", "ip");
++		tac_add_attrib(attr, "addr", ip_ntoa(ho->hisaddr));
++		
++ 		tac_fd=tac_connect(tac_server, tac_servers);
++
++		if(tac_fd) {
++			tac_account_send(tac_fd, TAC_PLUS_ACCT_FLAG_START,
++					 	tac_username, tty, attr);
++	
++			tac_free_attrib(attr);
++
++			if(tac_account_read(tac_fd) != NULL) 
++				syslog(LOG_WARNING,
++					"TACACS+ accounting start failed");
++
++			close(tac_fd);	
++		}
++		TACDEBUG((LOG_NOTICE, "ipcp_up: start accounting done"));
++	}
++#endif
++
+     /*
+      * Execute the ip-up script, like this:
+      *	/etc/ppp/ip-up interface tty speed local-IP remote-IP
+@@ -1118,6 +1224,78 @@
+ 
+     ouraddr = ipcp_gotoptions[f->unit].ouraddr;
+     hisaddr = ipcp_hisoptions[f->unit].hisaddr;
++
++#ifdef USE_TACACS_PLUS
++    /* get interface statistics for accounting */
++
++    if(tac_accounting && usetacacs) {
++    	char buf[40];
++    	int tac_fd, reqfd;
++    	struct tac_attrib *attr;
++		char *tty;
++
++		tty=devnam;
++		if(strncmp(tty, "/dev/", 5) == 0) tty+=5;	
++
++    	bzero(&treq, sizeof(treq));
++
++    	/* get interface statistics */
++    	reqfd = socket(AF_INET, SOCK_DGRAM, 0);
++
++#ifdef _linux_
++	treq.stats_ptr = (caddr_t) &treq.stats;
++#endif
++
++    	if(reqfd < 0)
++		syslog(LOG_DEBUG,
++		 "cannot get PPP statistics for %s (socket): %m", ifname);
++    	else {
++		sprintf(treq.ifr__name, "%s", ifname);
++		if(ioctl(reqfd, SIOCGPPPSTATS, &treq) < 0)
++		    syslog(LOG_DEBUG,
++		 	"cannot get PPP statistics for %s (ioctl): %m", ifname);
++		}
++
++     /* send stop accounting packet */
++
++		TACDEBUG((LOG_DEBUG, "ipcp_down: stop accounting"))
++		attr=(struct tac_attrib *) xcalloc(1, sizeof(struct tac_attrib));
++
++		sprintf(buf, "%lu", time(0));
++  		tac_add_attrib(attr, "stop_time", buf);
++		sprintf(buf, "%u", task_id);
++		tac_add_attrib(attr, "task_id", buf);
++		tac_add_attrib(attr, "service", "ppp");
++		tac_add_attrib(attr, "protocol", "ip");
++
++		if(((treq.stats).p).ppp_obytes) {
++			sprintf(buf, "%u", ((treq.stats).p).ppp_obytes);
++			tac_add_attrib(attr, "bytes_out", buf);
++			sprintf(buf, "%u", ((treq.stats).p).ppp_ibytes);
++			tac_add_attrib(attr, "bytes_in", buf);
++			sprintf(buf, "%u", ((treq.stats).p).ppp_opackets);
++			tac_add_attrib(attr, "paks_out", buf);
++			sprintf(buf, "%u", ((treq.stats).p).ppp_ipackets);
++			tac_add_attrib(attr, "paks_in", buf);
++		}
++
++		tac_fd=tac_connect(tac_server, tac_servers);
++
++		if(tac_fd) {
++			tac_account_send(tac_fd, TAC_PLUS_ACCT_FLAG_STOP, 
++					tac_username, tty, attr);
++
++			tac_free_attrib(attr);
++
++			if(tac_account_read(tac_fd) != NULL) 
++				syslog(LOG_DEBUG, "TACACS+ accounting stop failed");
++
++			close(tac_fd);
++		}
++		TACDEBUG((LOG_DEBUG, "ipcp_down: stop accounting done"))
++    }
++#endif
++
+     if (ipcp_gotoptions[f->unit].proxy_arp)
+ 	cifproxyarp(f->unit, hisaddr);
+     if (ipcp_gotoptions[f->unit].default_route) 
+diff -ruN ppp-2.2.0g/pppd/lcp.c ppp-2.2.0g.tacacs/pppd/lcp.c
+--- ppp-2.2.0g/pppd/lcp.c	Fri Apr 12 15:10:31 1996
++++ ppp-2.2.0g.tacacs/pppd/lcp.c	Sun Feb  1 02:47:06 1998
+@@ -1489,6 +1489,7 @@
+ lcp_down(f)
+     fsm *f;
+ {
++
+     lcp_echo_lowerdown(f->unit);
+     ccp_lowerdown(f->unit);
+     ipcp_lowerdown(f->unit);
+diff -ruN ppp-2.2.0g/pppd/main.c ppp-2.2.0g.tacacs/pppd/main.c
+--- ppp-2.2.0g/pppd/main.c	Tue Nov 21 07:53:48 1995
++++ ppp-2.2.0g.tacacs/pppd/main.c	Sun Feb  1 12:39:32 1998
+@@ -244,7 +244,13 @@
+     }
+     syslog(LOG_NOTICE, "pppd %s.%d started by %s, uid %d",
+ 	   VERSION, PATCHLEVEL, p, uid);
+-  
++
++#ifdef USE_TACACS_PLUS
++    if(usetacacs)
++    syslog(LOG_NOTICE, "using TACACS+ driver v%d.%d", tac_ver_major,
++    	tac_ver_minor);
++#endif
++
+     /*
+      * Compute mask of all interesting signals and install signal handlers
+      * for each.  Only one signal handler may be active at a time.  Therefore,
+diff -ruN ppp-2.2.0g/pppd/options.c ppp-2.2.0g.tacacs/pppd/options.c
+--- ppp-2.2.0g/pppd/options.c	Fri Nov 24 01:00:35 1995
++++ ppp-2.2.0g.tacacs/pppd/options.c	Sat Jan 31 22:07:14 1998
+@@ -100,6 +100,18 @@
+ char	*ipparam = NULL;	/* Extra parameter for ip up/down scripts */
+ int	cryptpap;		/* Passwords in pap-secrets are encrypted */
+ 
++#ifdef USE_TACACS_PLUS
++#include "tacplus.h"
++#include "auth_tac.h"
++int usetacacs = 0;		/* Use TACACS+ authentication */
++u_long tac_server[TAC_PLUS_MAXSERVERS];	/* TACACS+ servers addresses */
++int tac_servers = 0;		/* number of configured servers */
++int tac_encryption = 1;         /* Encrypt TACACS+ packets */
++char *tac_secret;		/* Packets encryption key */
++int tac_authorize = 0;		/* Authorize user requesting service */
++int tac_accounting = 0;		/* Do TACACS+ accounting */
++#endif
++
+ #ifdef _linux_
+ int idle_time_limit = 0;
+ static int setidle __P((char **));
+@@ -203,6 +215,15 @@
+ static int setdnsaddr __P((char **));
+ #endif
+ 
++#ifdef USE_TACACS_PLUS
++static int settacacsserver __P((char **));
++static int settacacssecret __P((char **));
++static int setnotacacsencryption __P((void));
++static int settacacsauthorize __P((void));
++static int settacacsaccounting __P((void));
++static int setdotacacs __P((void));
++#endif
++
+ static int number_option __P((char *, u_int32_t *, int));
+ static int readable __P((int fd));
+ 
+@@ -320,6 +341,15 @@
+     {"dns-addr", 1, setdnsaddr}, /* DNS address(es) for the peer's use */
+ #endif
+ 
++#ifdef USE_TACACS_PLUS
++    {"tacacs", 0, setdotacacs},
++    {"tacacs-server", 1, settacacsserver},
++    {"tacacs-secret", 1, settacacssecret},
++    {"-tacacs-encryption", 0, setnotacacsencryption},
++    {"tacacs-authorize", 0, settacacsauthorize},
++    {"tacacs-accounting", 0, settacacsaccounting},
++#endif
++
+     {NULL, 0, NULL}
+ };
+ 
+@@ -2037,3 +2067,70 @@
+     return (1);
+   }
+ #endif /* USE_MS_DNS */
++
++
++#ifdef USE_TACACS_PLUS
++static int
++settacacsserver(argv)
++    char **argv;
++{
++    	if(tac_servers >= TAC_PLUS_MAXSERVERS) {
++    		fprintf(stderr, "Too many tacacs-server options, max is %d",
++			TAC_PLUS_MAXSERVERS);
++		return(0);
++    	}
++    
++    	tac_server[tac_servers] = inet_addr(*argv);
++
++    	if (tac_server[tac_servers] == -1) {
++		fprintf(stderr, "Invalid TACACS+ server address %s\n", *argv);
++		return 0;
++    	}
++
++	tac_servers++;
++    	return(1);
++}
++
++static int
++settacacssecret(argv)
++    char **argv;
++{
++    tac_secret=(char *) calloc(1, strlen(*argv));
++    strncpy(tac_secret, *argv, strlen(*argv));
++    if(*argv == NULL) {
++     fprintf(stderr, "TACACS+ secret is not specified or invalid: \"%s\" ", *argv);
++     return(0);
++    }
++    return(1);
++}
++
++static int
++setnotacacsencryption(void)
++{
++    tac_encryption=0;
++    return(1);
++      
++}
++
++static int
++setdotacacs(void)
++{
++    usetacacs=1;
++    return(1);
++}
++
++static int
++settacacsauthorize(void)
++{
++    tac_authorize=1;
++    return(1);
++}
++
++static int
++settacacsaccounting(void)
++{
++    tac_accounting=1;
++    return(1);
++}
++
++#endif /* USE_TACACS_PLUS */
+diff -ruN ppp-2.2.0g/pppd/pppd.h ppp-2.2.0g.tacacs/pppd/pppd.h
+--- ppp-2.2.0g/pppd/pppd.h	Wed Nov 22 14:48:54 1995
++++ ppp-2.2.0g.tacacs/pppd/pppd.h	Wed Feb 11 16:06:57 1998
+@@ -86,6 +86,18 @@
+ extern char	*ipparam;	/* Extra parameter for ip up/down scripts */
+ extern int	cryptpap;	/* Others' PAP passwords are encrypted */
+ 
++#ifdef USE_TACACS_PLUS
++#include "tacplus.h"
++#include "auth_tac.h"
++extern int usetacacs;		/* Use TACACS+ authentication */
++extern u_long tac_server[TAC_PLUS_MAXSERVERS];	/* TACACS+ server */
++extern int tac_servers;
++extern int tac_encryption;         /* Encrypt TACACS+ packets */
++extern char *tac_secret;		/* Packets encryption key */
++extern int tac_authorize;		/* Authorize user requesting service */
++extern int tac_accounting;		/* Do TACACS+ accounting */
++#endif
++
+ /*
+  * Values for phase.
+  */
+@@ -190,6 +202,9 @@
+ #define DEBUGIPXCP	1
+ #define DEBUGUPAP	1
+ #define DEBUGCHAP	1
++#ifdef USE_TACACS_PLUS
++#define	DEBUGTAC	1
++#endif
+ #endif
+ 
+ #ifndef LOG_PPP			/* we use LOG_LOCAL2 for syslog by default */
+@@ -242,6 +257,12 @@
+ #define CHAPDEBUG(x)	if (debug) syslog x
+ #else
+ #define CHAPDEBUG(x)
++#endif
++
++#ifdef DEBUGTAC
++#define TACDEBUG(x)	syslog x;
++#else
++#define TACDEBUG(x)
+ #endif
+ 
+ #ifndef SIGTYPE
+diff -ruN ppp-2.2.0g/pppd/sys-linux.c ppp-2.2.0g.tacacs/pppd/sys-linux.c
+--- ppp-2.2.0g/pppd/sys-linux.c	Thu Feb  5 13:33:51 1998
++++ ppp-2.2.0g.tacacs/pppd/sys-linux.c	Wed Jan 28 22:34:48 1998
+@@ -72,6 +72,7 @@
+ #include <net/route.h>
+ #include <linux/if_ether.h>
+ #include <netinet/in.h>
++#include <sys/utsname.h>
+ 
+ #include "pppd.h"
+ #include "fsm.h"
+@@ -89,6 +90,7 @@
+ 
+ int sockfd;			/* socket for doing interface ioctls */
+ 
++
+ static char *lock_file;
+ 
+ #define MAX_IFS		5000
+@@ -927,8 +929,16 @@
+ 
+     if (ioctl(sockfd, SIOCADDRT, &rt) < 0)
+       {
+-        syslog (LOG_ERR, "ioctl(SIOCADDRT) device route: %m");
+-        return (0);
++#if 1
++	struct utsname u;
++
++	uname(&u);
++	/* 2.1 kernels (and probably above) */
++	if(strncpy(u.release, "2.1", 3) != 0) {
++          syslog (LOG_ERR, "ioctl(SIOCADDRT) device route: %m");
++          return (0);
++	}
++#endif
+       }
+     return 1;
+   }
+diff -ruN ppp-2.2.0g/pppd/tacplus.h ppp-2.2.0g.tacacs/pppd/tacplus.h
+--- ppp-2.2.0g/pppd/tacplus.h	Thu Jan  1 01:00:00 1970
++++ ppp-2.2.0g.tacacs/pppd/tacplus.h	Mon Feb  9 12:52:10 1998
+@@ -0,0 +1,257 @@
++/* 
++   Copyright (c) 1995-1998 by Cisco systems, Inc.
++   Portions copyright 1997-98 by Pawel Krawczyk <kravietz@ceti.com.pl>
++
++   Permission to use, copy, modify, and distribute this software for
++   any purpose and without fee is hereby granted, provided that this
++   copyright and permission notice appear on all copies of the
++   software and supporting documentation, the name of Cisco Systems,
++   Inc. not be used in advertising or publicity pertaining to
++   distribution of the program without specific prior permission, and
++   notice be given in supporting documentation that modification,
++   copying and distribution is by permission of Cisco Systems, Inc.
++
++   Cisco Systems, Inc. makes no representations about the suitability
++   of this software for any purpose.  THIS SOFTWARE IS PROVIDED ``AS
++   IS'' AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,
++   WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
++   FITNESS FOR A PARTICULAR PURPOSE.
++*/
++
++#ifndef _TACPLUS_H
++#define _TACPLUS_H
++
++struct tac_attrib {
++	char *attr;
++	u_char attr_len;
++	struct tac_attrib *next;
++};
++
++struct areply {
++	struct tac_attrib *attr;
++	char *msg;
++	int status;
++};
++
++#ifndef TAC_PLUS_MAXSERVERS		
++#define TAC_PLUS_MAXSERVERS		4
++#endif
++
++#ifndef TAC_PLUS_PORT
++#define	TAC_PLUS_PORT			49
++#endif
++
++#define TAC_PLUS_READ_TIMEOUT		180	/* seconds */
++#define TAC_PLUS_WRITE_TIMEOUT		180	/* seconds */
++
++/* All tacacs+ packets have the same header format */
++
++struct tac_plus_pak_hdr {
++    u_char version;
++
++#define TAC_PLUS_MAJOR_VER_MASK 0xf0
++#define TAC_PLUS_MAJOR_VER      0xc0
++
++#define TAC_PLUS_MINOR_VER_0    0x0
++#define TAC_PLUS_VER_0  (TAC_PLUS_MAJOR_VER | TAC_PLUS_MINOR_VER_0)
++
++#define TAC_PLUS_MINOR_VER_1    0x01
++#define TAC_PLUS_VER_1  (TAC_PLUS_MAJOR_VER | TAC_PLUS_MINOR_VER_1)
++
++    u_char type;
++
++#define TAC_PLUS_AUTHEN			1
++#define TAC_PLUS_AUTHOR			2
++#define TAC_PLUS_ACCT			3
++
++    u_char seq_no;		/* packet sequence number */
++    u_char encryption;		/* packet is encrypted or cleartext */
++
++#define TAC_PLUS_ENCRYPTED 0x0		/* packet is encrypted */
++#define TAC_PLUS_CLEAR     0x1		/* packet is not encrypted */
++
++    int session_id;		/* session identifier FIXME: Is this needed? */
++    int datalength;		/* length of encrypted data following this
++				 * header */
++    /* datalength bytes of encrypted data */
++};
++
++#define TAC_PLUS_HDR_SIZE 12
++
++typedef struct tac_plus_pak_hdr HDR;
++
++/* Authentication packet NAS sends to us */ 
++
++struct authen_start {
++    u_char action;
++
++#define TAC_PLUS_AUTHEN_LOGIN    0x1
++#define TAC_PLUS_AUTHEN_CHPASS   0x2
++#define TAC_PLUS_AUTHEN_SENDPASS 0x3 /* deprecated */
++#define TAC_PLUS_AUTHEN_SENDAUTH 0x4
++
++    u_char priv_lvl;
++
++#define TAC_PLUS_PRIV_LVL_MIN 0x0
++#define TAC_PLUS_PRIV_LVL_MAX 0xf
++
++    u_char authen_type;
++
++#define TAC_PLUS_AUTHEN_TYPE_ASCII  1
++#define TAC_PLUS_AUTHEN_TYPE_PAP    2
++#define TAC_PLUS_AUTHEN_TYPE_CHAP   3
++#define TAC_PLUS_AUTHEN_TYPE_ARAP   4
++
++    u_char service;
++
++#define TAC_PLUS_AUTHEN_SVC_LOGIN  1
++#define TAC_PLUS_AUTHEN_SVC_ENABLE 2
++#define TAC_PLUS_AUTHEN_SVC_PPP    3
++#define TAC_PLUS_AUTHEN_SVC_ARAP   4
++#define TAC_PLUS_AUTHEN_SVC_PT     5
++#define TAC_PLUS_AUTHEN_SVC_RCMD   6
++#define TAC_PLUS_AUTHEN_SVC_X25    7
++#define TAC_PLUS_AUTHEN_SVC_NASI   8
++
++    u_char user_len;
++    u_char port_len;
++    u_char rem_addr_len;
++    u_char data_len;
++    /* <user_len bytes of char data> */
++    /* <port_len bytes of char data> */
++    /* <rem_addr_len bytes of u_char data> */
++    /* <data_len bytes of u_char data> */
++};
++
++#define TAC_AUTHEN_START_FIXED_FIELDS_SIZE 8
++
++/* Authentication continue packet NAS sends to us */ 
++struct authen_cont {
++    u_short user_msg_len;
++    u_short user_data_len;
++    u_char flags;
++
++#define TAC_PLUS_CONTINUE_FLAG_ABORT 0x1
++
++    /* <user_msg_len bytes of u_char data> */
++    /* <user_data_len bytes of u_char data> */
++};
++
++#define TAC_AUTHEN_CONT_FIXED_FIELDS_SIZE 5
++
++/* Authentication reply packet we send to NAS */ 
++struct authen_reply {
++    u_char status;
++
++#define TAC_PLUS_AUTHEN_STATUS_PASS     1
++#define TAC_PLUS_AUTHEN_STATUS_FAIL     2
++#define TAC_PLUS_AUTHEN_STATUS_GETDATA  3
++#define TAC_PLUS_AUTHEN_STATUS_GETUSER  4
++#define TAC_PLUS_AUTHEN_STATUS_GETPASS  5
++#define TAC_PLUS_AUTHEN_STATUS_RESTART  6
++#define TAC_PLUS_AUTHEN_STATUS_ERROR    7 
++#define TAC_PLUS_AUTHEN_STATUS_FOLLOW   0x21
++
++    u_char flags;
++
++#define TAC_PLUS_AUTHEN_FLAG_NOECHO     0x1
++
++    u_short msg_len;
++    u_short data_len;
++
++    /* <msg_len bytes of char data> */
++    /* <data_len bytes of u_char data> */
++};
++
++#define TAC_AUTHEN_REPLY_FIXED_FIELDS_SIZE 6
++
++#define AUTHEN_METH_NONE             0x01
++#define AUTHEN_METH_KRB5             0x02
++#define AUTHEN_METH_LINE             0x03
++#define AUTHEN_METH_ENABLE           0x04
++#define AUTHEN_METH_LOCAL            0x05
++#define AUTHEN_METH_TACACSPLUS       0x06
++#define AUTHEN_METH_RCMD             0x20
++
++struct acct {
++    u_char flags;
++
++#define TAC_PLUS_ACCT_FLAG_MORE     0x1
++#define TAC_PLUS_ACCT_FLAG_START    0x2
++#define TAC_PLUS_ACCT_FLAG_STOP     0x4
++#define TAC_PLUS_ACCT_FLAG_WATCHDOG 0x8
++	    
++    u_char authen_method;
++    u_char priv_lvl;
++    u_char authen_type;
++    u_char authen_service;
++    u_char user_len;
++    u_char port_len;
++    u_char rem_addr_len;
++    u_char arg_cnt; /* the number of cmd args */
++    /* one u_char containing size for each arg */
++    /* <user_len bytes of char data> */
++    /* <port_len bytes of char data> */
++    /* <rem_addr_len bytes of u_char data> */
++    /* char data for args 1 ... n */
++};
++
++#define TAC_ACCT_REQ_FIXED_FIELDS_SIZE 9
++
++struct acct_reply {
++    u_short msg_len;
++    u_short data_len;
++    u_char status;
++
++#define TAC_PLUS_ACCT_STATUS_SUCCESS 0x1
++#define TAC_PLUS_ACCT_STATUS_ERROR   0x2
++#define TAC_PLUS_ACCT_STATUS_FOLLOW  0x21
++
++};
++
++#define TAC_ACCT_REPLY_FIXED_FIELDS_SIZE 5
++
++/* An authorization request packet */
++struct author {
++    u_char authen_method;
++    u_char priv_lvl;
++    u_char authen_type;
++    u_char service;
++
++    u_char user_len;
++    u_char port_len;
++    u_char rem_addr_len;
++    u_char arg_cnt;		/* the number of args */
++
++    /* <arg_cnt u_chars containing the lengths of args 1 to arg n> */
++    /* <user_len bytes of char data> */
++    /* <port_len bytes of char data> */
++    /* <rem_addr_len bytes of u_char data> */
++    /* <char data for each arg> */
++};
++
++#define TAC_AUTHOR_REQ_FIXED_FIELDS_SIZE 8
++
++/* An authorization reply packet */
++struct author_reply {
++    u_char status;
++    u_char arg_cnt;
++    u_short msg_len;
++    u_short data_len;
++
++#define AUTHOR_STATUS_PASS_ADD       0x01
++#define AUTHOR_STATUS_PASS_REPL      0x02
++#define AUTHOR_STATUS_FAIL           0x10
++#define AUTHOR_STATUS_ERROR          0x11
++#define AUTHOR_STATUS_FOLLOW	     0x21
++
++    /* <arg_cnt u_chars containing the lengths of arg 1 to arg n> */
++    /* <msg_len bytes of char data> */
++    /* <data_len bytes of char data> */
++    /* <char data for each arg> */
++};
++
++#define TAC_AUTHOR_REPLY_FIXED_FIELDS_SIZE 6
++
++
++#endif
+diff -ruN ppp-2.2.0g/pppd/upap.c ppp-2.2.0g.tacacs/pppd/upap.c
+--- ppp-2.2.0g/pppd/upap.c	Mon Jun 12 14:03:25 1995
++++ ppp-2.2.0g.tacacs/pppd/upap.c	Sun Feb  1 16:52:54 1998
+@@ -34,6 +34,11 @@
+ #include "pppd.h"
+ #include "upap.h"
+ 
++#ifdef USE_TACACS_PLUS
++extern int usetacacs;
++extern int tac_login(char *user, char *passwd, int userlen, int passlen, 
++					char **msg, int *msglen);
++#endif
+ 
+ upap_state upap[NUM_PPP];		/* UPAP state; one for each unit */
+ 
+@@ -353,8 +358,15 @@
+     /*
+      * Check the username and password given.
+      */
+-    retcode = check_passwd(u->us_unit, ruser, ruserlen, rpasswd,
+-			   rpasswdlen, &msg, &msglen);
++
++    retcode = 
++#ifdef USE_TACACS_PLUS
++	    usetacacs ? 
++		tac_login(ruser, rpasswd, ruserlen, rpasswdlen, 
++				     &msg, &msglen) : /* use TACACS+ */
++#endif
++		check_passwd(u->us_unit, ruser, ruserlen, rpasswd,
++			  rpasswdlen, &msg, &msglen); /* use local files */
+ 
+     upap_sresp(u, retcode, id, msg, msglen);
+ 
diff --git a/pppd/plugins/tacc/pppd-2.3.4.patch b/pppd/plugins/tacc/pppd-2.3.4.patch
new file mode 100644
index 0000000..ca16d63
--- /dev/null
+++ b/pppd/plugins/tacc/pppd-2.3.4.patch
@@ -0,0 +1,819 @@
+diff -ruN ppp-2.3.4/README.tacacs ppp-2.3.4.tacacs/README.tacacs
+--- ppp-2.3.4/README.tacacs	Thu Jan  1 01:00:00 1970
++++ ppp-2.3.4.tacacs/README.tacacs	Sat May  9 22:42:29 1998
+@@ -0,0 +1,127 @@
++
++                          TACACS+ support for pppd
++                                      
++   
++    Copyright 1997-98 by Pawel Krawczyk <kravietz@ceti.com.pl>
++    
++                           Distributed under GPL
++                                      
++Introduction
++
++   This module supports subset of TACACS+ functions allowing a Linux
++   dialup server to authenticate, authorize and account users on remote
++   authentication server. This includes:
++   
++     * PAP authentication
++     * authorization for IP protocol
++     * accounting of PPP session beginning and end
++       
++   All above functions are performed from within pppd program with
++   username and password passed with PPP protocol. In addition, there is
++   standalone TACACS+ client program - tacc, which can be used as
++   replacement for login program in getty style dialup server programs.
++   
++Installation
++
++    1. Download the distribution from:
++       http://ceti.com.pl/~kravietz/progs/tacacs.html
++    2. Download and original pppd sources. This program was developed on
++       version 2.3.4. You can find pppd sources on local sunsite.unc.edu
++       mirror, or use http://ftpsearch.ntnu.no/
++    3. Compile tacc. You can find instructions in README in tacc subdirectory.
++    4. Apply the patch to pppd source tree:
++
++        patch -p0 <pppd-2.3.4.patch
++
++    5. Configure pppd sources as described in INSTALL file.
++    6. Run make, with the following extra parameter:
++       
++	make USE_TACACS=1
++
++  	You should also check TACACS_DIR definition in pppd/Makefile.linux.
++   	Its set to /usr/src/tacc-1.6.2 by default, you could need to change
++   	it.
++                
++    7. You should now have two programs: tacc and pppd. You should
++       install them in appropriate directory and configure your dialup
++       server to actually use them. The following is example of my
++       /etc/mgetty/login.conf:
++
++/AutoPPP/ -     autoppp /usr/sbin/pppd auth -chap +pap tacacs debug -detach
++*         -     @       /usr/local/sbin/tacc @
++
++    8. Configure your TACACS+ server. You can get it from
++       ftp://ftpeng.cisco.com/pub/tacacs/. Following options are
++       necessary in tac_plus configuration file:
++       
++        default authentication = file filename
++                passwd(5) file; use /etc/passwd even if you have shadow
++                passwords suite installed
++                
++        key = "string"
++                key used to encrypt TACACS+ packets over the network
++                
++        user = DEFAULT { default service = permit }
++                permit all valid and authenticated users to use PPP
++                
++       For more details about configuring TACACS+ server refer to
++       users_guide in the server distribution.
++    9. Following options are recognized by pppd in /etc/ppp/options
++	   file or command line:
++
++	tacacs
++		        Use TACACS+ functions
++       
++	tacacs-server aaa.bbb.ccc.ddd
++                TACACS+ server IP address (multiple allowed)
++                
++	tacacs-secret string
++                key used to encrypt TACACS+ packets over the network;
++                should be same as the key defined on TACACS+ server
++                
++	-tacacs-encryption
++		notacacs-encryption
++                send packets cleartext; this is for debugging only, do
++                not use in real operations
++                
++	tacacs-accounting
++                if you want pppd to send TACACS+ accounting packets to
++                the server; currently it includes only start and stop
++                messages
++                
++ 	tacacs-authorization
++	tacacs-authorize (deprecated)
++                if you want pppd to request authorization for use of PPP
++                for already authenticated user; currently this is limited
++                to service PPP and protocol IP
++                
++   10. When running pppd (probably from mgetty or similiar software), add
++       tacacs option, e.g.:
++
++        /usr/sbin/pppd auth +pap -chap tacacs
++
++   Note that since current version you should use tacacs option instead
++       of previous login! This option tell pppd to actually use TACACS+
++       functions.
++   11. Test if this works. If not, that's probably because keys on
++       authentication and dialup servers are different. tacc can be used
++       to test if the TACACS+ server is working correctly:
++
++        $ tacc -TRA -u user -p pass -s localhost -k 'secret key' -w
++        Authentication OK
++        Authorization OK: Service granted.
++        Accounting: START ok
++        Accounting: STOP ok
++        $ _
++       In case of problems recompiling auth_tac.c with -DDEBUGTAC will
++       cause every TACACS+ function report its progress and errors to
++       syslog. I'll appreciate such log file very much if you send me a
++       bug report.
++       
++                                     tacc
++                                       
++   tacc documentation was moved to manual page. It was also extended ;)
++     _________________________________________________________________
++   
++   Latest versions of this patch can be found on:
++   http://www.ceti.com.pl/~kravietz/progs/tacacs.html
+Binary files ppp-2.3.4/chat/chat.zip and ppp-2.3.4.tacacs/chat/chat.zip differ
+diff -ruN ppp-2.3.4/pppd/Makefile.linux ppp-2.3.4.tacacs/pppd/Makefile.linux
+--- ppp-2.3.4/pppd/Makefile.linux	Wed Apr  1 04:06:37 1998
++++ ppp-2.3.4.tacacs/pppd/Makefile.linux	Sat May  9 22:35:27 1998
+@@ -26,18 +26,19 @@
+ 
+ # CC = gcc
+ #
+-COPTS = -O2 -pipe -Wall -g
++COPTS = -O2 -pipe -Wall -s
++#COPTS = -ggdb3 -pipe
+ VER = 2.3.4
+ LIBS =
+ 
+-ifneq ($(wildcard /usr/lib/libcrypt*),)
+-LIBS += -lcrypt
+-endif
++#ifneq ($(wildcard /usr/lib/libcrypt*),)
++#LIBS += -lcrypt
++#endif
+ 
+ # Uncomment the next 2 lines to include support for Microsoft's
+ # MS-CHAP authentication protocol.
+-CHAPMS=y
+-USE_CRYPT=y
++#CHAPMS=y
++#USE_CRYPT=y
+ ifneq ($(wildcard /usr/lib/libcrypt*),)
+ HAVE_CRYPT_H=y
+ endif
+@@ -48,7 +49,7 @@
+ 
+ INCLUDE_DIRS= -I../include
+ 
+-COMPILE_FLAGS= -D_linux_=1 -DHAVE_PATHS_H -DIPX_CHANGE
++COMPILE_FLAGS= -D_linux_=1 -DHAVE_PATHS_H -DIPX_CHANGE # -D__inet_ntoa=inet_ntoa -D__inet_addr=inet_addr
+ 
+ CFLAGS= $(COPTS) $(COMPILE_FLAGS) $(INCLUDE_DIRS)
+ 
+@@ -83,6 +84,13 @@
+ ifdef LOCKLIB
+ LIBS     := -llock $(LIBS)
+ CFLAGS   += -DLOCKLIB=1
++endif
++
++# TACACS+ library should be in already compiled in separate directory
++ifdef USE_TACACS
++TACACS_DIR :=	/usr/src/tacc-1.6.3
++CFLAGS	+= -DUSE_TACACS_PLUS -I$(TACACS_DIR)/include
++LIBS    := -ltac $(LIBS) -L$(TACACS_DIR)/lib
+ endif
+ 
+ install: pppd
+diff -ruN ppp-2.3.4/pppd/auth.c ppp-2.3.4.tacacs/pppd/auth.c
+--- ppp-2.3.4/pppd/auth.c	Thu Mar 26 05:46:00 1998
++++ ppp-2.3.4.tacacs/pppd/auth.c	Sun Apr 19 09:34:06 1998
+@@ -55,11 +55,20 @@
+ #include <netdb.h>
+ #include <netinet/in.h>
+ #include <arpa/inet.h>
++//#include <linux/if_ppp.h>
+ 
+ #ifdef USE_PAM
+ #include <security/pam_appl.h>
+ #endif
+ 
++#ifdef USE_TACACS_PLUS
++#include "tacplus.h"
++#include "libtac.h"
++short int task_id;		/* connection identifier for accounting */
++char *tac_username;	/* storage between tac_login() and logout(), also used
++					   by IPCP */
++#endif
++
+ #ifdef HAS_SHADOW
+ #include <shadow.h>
+ #ifndef PW_PPP
+@@ -529,7 +538,11 @@
+      * Check whether we have appropriate secrets to use
+      * to authenticate the peer.
+      */
++#ifdef USE_TACACS_PLUS
++    can_auth = wo->neg_upap && (usetacacs || uselogin || have_pap_secret());
++#else
+     can_auth = wo->neg_upap && (uselogin || have_pap_secret());
++#endif
+     if (!can_auth && wo->neg_chap) {
+ 	remote = ipwo->accept_remote? 0: ipwo->hisaddr;
+ 	can_auth = have_chap_secret(remote_name, our_name, remote);
+@@ -582,7 +595,11 @@
+     ao->neg_chap = !refuse_chap
+ 	&& have_chap_secret(user, remote_name, (u_int32_t)0);
+ 
++#ifdef USE_TACACS_PLUS
++    if (go->neg_upap && !uselogin && !usetacacs && !have_pap_secret())
++#else
+     if (go->neg_upap && !uselogin && !have_pap_secret())
++#endif
+ 	go->neg_upap = 0;
+     if (go->neg_chap) {
+ 	remote = ipwo->accept_remote? 0: ipwo->hisaddr;
+@@ -656,7 +673,12 @@
+ 	fclose(f);
+     }
+ 
+-    if (uselogin && ret == UPAP_AUTHACK) {
++#ifdef USE_TACACS_PLUS
++    if ((uselogin || usetacacs)
++#else
++    if (uselogin 
++#endif
++					&& ret == UPAP_AUTHACK) {
+ 	ret = plogin(user, passwd, msg, msglen);
+ 	if (ret == UPAP_AUTHNAK) {
+ 	    syslog(LOG_WARNING, "PAP login failure for %s", user);
+@@ -759,6 +781,82 @@
+ }
+ #endif
+ 
++#ifdef USE_TACACS_PLUS
++/* do TACACS+ authentication instead of 
++ * checking username and password against local
++ * passwd(5) files
++ *
++ * returns:
++ *	UPAP_AUTHNAK: Login failed.
++ *	UPAP_AUTHACK: Login succeeded.
++ */
++int
++tac_login(auser, apasswd, userlen, passlen, msg, msglen)
++	char *auser;
++	char *apasswd;
++	int userlen;
++	int passlen;
++	char **msg;
++	int *msglen;
++{
++    char *tty;
++    char *tacmsg;
++    int tac_fd;
++    char passwd[256], user[256];
++
++    BCOPY(apasswd, passwd, passlen);
++    passwd[passlen] = '\0';
++    BCOPY(auser, user, userlen);
++    user[userlen] = '\0';
++
++    /* record tty name */
++    tty = devnam;
++    if(strncmp(tty, "/dev/", 5) == 0)
++	tty += 5;
++
++    tac_fd=tac_connect(tac_server, tac_servers);
++
++    if(tac_fd < 0) {
++ 	*msg = "TACACS+ server error";
++	*msglen = strlen(*msg);
++    	return(UPAP_AUTHNAK);
++    }
++
++    if(tac_authen_pap_send(tac_fd, user, passwd, tty) < 0) {
++    	*msg = "TACACS+ error";
++	*msglen = strlen(*msg);
++    	return(UPAP_AUTHNAK);
++    }
++
++    tacmsg=tac_authen_pap_read(tac_fd);
++
++    /* authentication failed, return */
++    if(tacmsg != NULL) {
++     	syslog(LOG_ERR, "TACACS+ authentication failed for `%s': %s",
++								user, tacmsg);
++     	*msg = tacmsg;
++     	*msglen = strlen(*msg);
++     	return(UPAP_AUTHNAK);
++    }
++
++    close(tac_fd);
++
++    syslog(LOG_INFO, "user %s logged in", user);
++    logwtmp(tty, user, "");
++    logged_in = TRUE;
++
++    /* store username for accounting and authorization functions */
++    tac_username = (char *) xcalloc(1, strlen(user)+1);
++    strncpy(tac_username, user, strlen(user));
++    
++    *msg = "Login ok";
++    *msglen = strlen(*msg);
++
++    return (UPAP_AUTHACK);
++
++}
++#endif /* USE_TACACS_PLUS */
++
+ /*
+  * plogin - Check the user name and password against the system
+  * password database, and login the user if OK.
+@@ -904,6 +1002,7 @@
+     logged_in = TRUE;
+ 
+     return (UPAP_AUTHACK);
++
+ }
+ 
+ /*
+@@ -941,6 +1040,7 @@
+ #endif
+ 
+     logged_in = FALSE;
++
+ }
+ 
+ 
+diff -ruN ppp-2.3.4/pppd/ipcp.c ppp-2.3.4.tacacs/pppd/ipcp.c
+--- ppp-2.3.4/pppd/ipcp.c	Wed Mar 25 04:08:48 1998
++++ ppp-2.3.4.tacacs/pppd/ipcp.c	Sat May  9 22:33:54 1998
+@@ -39,6 +39,26 @@
+ #include "ipcp.h"
+ #include "pathnames.h"
+ 
++#ifdef USE_TACACS_PLUS
++#ifdef _linux_
++#include <net/if.h>
++#if __GLIBC__ >= 2
++#include <asm/types.h>
++#endif
++#include <linux/if_ppp.h>
++#endif
++#include <time.h>
++#include <unistd.h>
++#include <sys/ioctl.h>
++#include <signal.h>
++#include "tacplus.h"
++#include "libtac.h"
++#include "magic.h"
++extern char *tac_username;
++extern int task_id;
++struct ifpppstatsreq treq;
++#endif
++
+ /* global vars */
+ ipcp_options ipcp_wantoptions[NUM_PPP];	/* Options that we want to request */
+ ipcp_options ipcp_gotoptions[NUM_PPP];	/* Options that peer ack'd */
+@@ -1138,6 +1158,12 @@
+     ipcp_options *go = &ipcp_gotoptions[f->unit];
+     ipcp_options *wo = &ipcp_wantoptions[f->unit];
+ 
++#ifdef USE_TACACS_PLUS
++	char *msg;
++	char *tty;
++	struct tac_attrib *attr;
++#endif
++
+     np_up(f->unit, PPP_IP);
+     IPCPDEBUG((LOG_INFO, "ipcp: up"));
+ 
+@@ -1163,13 +1189,68 @@
+     /*
+      * Check that the peer is allowed to use the IP address it wants.
+      */
+-    if (!auth_ip_addr(f->unit, ho->hisaddr)) {
++    if (!auth_ip_addr(f->unit, ho->hisaddr)
++#ifdef USE_TACACS_PLUS
++					/* if there's TACACS+ authorization it takes
++					   precedence over local authorizaition */
++					&& (!tac_authorize && usetacacs)
++#endif
++					) {
+ 	syslog(LOG_ERR, "Peer is not authorized to use remote address %s",
+ 	       ip_ntoa(ho->hisaddr));
+ 	ipcp_close(f->unit, "Unauthorized remote IP address");
+ 	return;
+     }
+ 
++#ifdef USE_TACACS_PLUS
++	/* Check the TACACS+ authorization for providing IP service */
++
++	if(usetacacs) {
++		/* this is needed both by acct and author */
++		tty=devnam;
++		if(strncmp(tty, "/dev/", 5) == 0) tty+=5;	
++	}
++
++	if(tac_authorize && usetacacs) {
++		/* ask for authorization to provide IP to the peer */
++		int tac_fd;
++		struct areply *arep;
++
++		TACDEBUG((LOG_DEBUG, "ipcp_up: sending author request for %s", \
++						ip_ntoa(ho->hisaddr)))
++		attr=(struct tac_attrib *)xcalloc(1, sizeof(struct tac_attrib));
++		tac_add_attrib(attr, "service", "ppp");
++		tac_add_attrib(attr, "protocol", "ip"); /* ask for IPCP */
++		tac_add_attrib(attr, "addr", ip_ntoa(ho->hisaddr));
++
++		tac_fd=tac_connect(tac_server, tac_servers);
++
++		if(tac_author_send(tac_fd, tac_username, tty, attr) < 0) {
++			ipcp_close(f->unit, "Authorization error");
++			TACDEBUG((LOG_DEBUG, "ipcp_up: error sending request"))
++			return;
++		}
++
++		arep = tac_author_read(tac_fd);
++
++		if(arep->status != AUTHOR_STATUS_PASS_ADD &&
++						arep->status != AUTHOR_STATUS_PASS_REPL) {
++			syslog(LOG_ERR, "IPCP authorization failure: %s", arep->msg);
++			ipcp_close(f->unit, "Authorization failed");
++			return;
++		}
++		TACDEBUG((LOG_DEBUG, "ipcp_up: successful authorization: %s", \
++						arep->msg));
++
++		/* TODO: check arep->attrib and add to
++		 * ipcp_wantoptions[f->unit].hisaddr 
++		 */
++
++		close(tac_fd);
++		tac_free_attrib(attr);
++	}
++#endif
++
+     /* set tcp compression */
+     sifvjcomp(f->unit, ho->neg_vj, ho->cflag, ho->maxslotindex);
+ 
+@@ -1252,6 +1333,40 @@
+ 
+ 	syslog(LOG_NOTICE, "local  IP address %s", ip_ntoa(go->ouraddr));
+ 	syslog(LOG_NOTICE, "remote IP address %s", ip_ntoa(ho->hisaddr));
++
++#ifdef USE_TACACS_PLUS
++	if(tac_accounting && usetacacs) {
++		char buf[40];	
++		int tac_fd;
++
++		TACDEBUG((LOG_NOTICE, "ipcp_up: start accounting"));
++		attr=(struct tac_attrib *)xcalloc(1, sizeof(struct tac_attrib));
++		sprintf(buf, "%lu", time(0));
++  		tac_add_attrib(attr, "start_time", buf);
++		task_id=(short int) magic();
++		sprintf(buf, "%u", task_id);
++		tac_add_attrib(attr, "task_id", buf);
++		tac_add_attrib(attr, "service", "ppp");
++		tac_add_attrib(attr, "protocol", "ip");
++		tac_add_attrib(attr, "addr", ip_ntoa(ho->hisaddr));
++		
++ 		tac_fd=tac_connect(tac_server, tac_servers);
++
++		if(tac_fd) {
++			tac_account_send(tac_fd, TAC_PLUS_ACCT_FLAG_START,
++					 	tac_username, tty, attr);
++	
++			tac_free_attrib(attr);
++
++			if(tac_account_read(tac_fd) != NULL) 
++				syslog(LOG_WARNING,
++					"TACACS+ accounting start failed");
++
++			close(tac_fd);	
++		}
++		TACDEBUG((LOG_NOTICE, "ipcp_up: start accounting done"));
++	}
++#endif
+     }
+ 
+     /*
+@@ -1274,6 +1389,89 @@
+     fsm *f;
+ {
+     IPCPDEBUG((LOG_INFO, "ipcp: down"));
++	
++#ifdef USE_TACACS_PLUS
++    /* get interface statistics for accounting */
++
++    if(tac_accounting && usetacacs) {
++    	char buf[40];
++    	int tac_fd, reqfd;
++    	struct tac_attrib *attr;
++		char *tty;
++
++		tty=devnam;
++		if(strncmp(tty, "/dev/", 5) == 0) tty+=5;	
++
++    	bzero(&treq, sizeof(treq));
++
++    	/* get interface statistics for accounting */
++    	reqfd = socket(AF_INET, SOCK_DGRAM, 0);
++
++#ifdef _linux_
++	treq.stats_ptr = (caddr_t) &treq.stats;
++#endif
++
++    	if(reqfd < 0)
++		syslog(LOG_DEBUG,
++		 "cannot get PPP statistics for %s (socket): %m", ifname);
++    	else {
++		sprintf(treq.ifr__name, "%s", ifname);
++		if(ioctl(reqfd, SIOCGPPPSTATS, &treq) < 0)
++		    syslog(LOG_DEBUG,
++		 	"cannot get PPP statistics for %s (ioctl): %m", ifname);
++		}
++
++     /* send stop accounting packet */
++
++		TACDEBUG((LOG_DEBUG, "ipcp_down: stop accounting"))
++		attr=(struct tac_attrib *) xcalloc(1, sizeof(struct tac_attrib));
++
++		sprintf(buf, "%lu", time(0));
++  		tac_add_attrib(attr, "stop_time", buf);
++		sprintf(buf, "%u", task_id);
++		tac_add_attrib(attr, "task_id", buf);
++		tac_add_attrib(attr, "service", "ppp");
++		tac_add_attrib(attr, "protocol", "ip");
++
++		if(((treq.stats).p).ppp_obytes) {
++			sprintf(buf, "%u", ((treq.stats).p).ppp_obytes);
++			tac_add_attrib(attr, "bytes_out", buf);
++			sprintf(buf, "%u", ((treq.stats).p).ppp_ibytes);
++			tac_add_attrib(attr, "bytes_in", buf);
++			sprintf(buf, "%u", ((treq.stats).p).ppp_opackets);
++			tac_add_attrib(attr, "paks_out", buf);
++			sprintf(buf, "%u", ((treq.stats).p).ppp_ipackets);
++			tac_add_attrib(attr, "paks_in", buf);
++		}
++
++		/* protect from SIGHUP, SIGALRM and SIGCHLD when remote
++		   modem disconnects at this stage */
++		signal(SIGALRM, SIG_IGN);
++		signal(SIGCHLD, SIG_IGN);
++		signal(SIGHUP, SIG_IGN);
++
++		tac_fd=tac_connect(tac_server, tac_servers);
++
++		if(tac_fd > 0) {
++			tac_account_send(tac_fd, TAC_PLUS_ACCT_FLAG_STOP, 
++					tac_username, tty, attr);
++
++			tac_free_attrib(attr);
++
++			if(tac_account_read(tac_fd) != NULL) 
++				syslog(LOG_DEBUG, "TACACS+ accounting stop failed");
++
++			close(tac_fd);
++		}
++		TACDEBUG((LOG_DEBUG, "ipcp_down: stop accounting done"))
++
++		/* reset signals to their default behaviour */
++		signal(SIGALRM, SIG_DFL);
++		signal(SIGCHLD, SIG_DFL);
++		signal(SIGHUP, SIG_DFL);
++    }
++#endif
++	
+     np_down(f->unit, PPP_IP);
+     sifvjcomp(f->unit, 0, 0, 0);
+ 
+diff -ruN ppp-2.3.4/pppd/main.c ppp-2.3.4.tacacs/pppd/main.c
+--- ppp-2.3.4/pppd/main.c	Mon Mar 30 08:25:34 1998
++++ ppp-2.3.4.tacacs/pppd/main.c	Mon Apr 20 17:40:44 1998
+@@ -285,6 +285,12 @@
+     syslog(LOG_NOTICE, "pppd %s.%d%s started by %s, uid %d",
+ 	   VERSION, PATCHLEVEL, IMPLEMENTATION, p, uid);
+   
++#ifdef USE_TACACS_PLUS
++	if(usetacacs)
++			syslog(LOG_NOTICE, "using TACACS+ driver v%d.%d", tac_ver_major,
++							tac_ver_minor);
++#endif
++	
+     /*
+      * Compute mask of all interesting signals and install signal handlers
+      * for each.  Only one signal handler may be active at a time.  Therefore,
+@@ -417,7 +423,10 @@
+ 	 */
+ 	if (lockflag && !default_device) {
+ 	    if (lock(devnam) < 0)
++		die(1);
++/*
+ 		goto fail;
++*/
+ 	    locked = 1;
+ 	}
+ 
+diff -ruN ppp-2.3.4/pppd/options.c ppp-2.3.4.tacacs/pppd/options.c
+--- ppp-2.3.4/pppd/options.c	Thu Mar 26 05:46:07 1998
++++ ppp-2.3.4.tacacs/pppd/options.c	Tue May  5 13:57:03 1998
+@@ -113,6 +113,17 @@
+ int	refuse_pap = 0;		/* Set to say we won't do PAP */
+ int	refuse_chap = 0;	/* Set to say we won't do CHAP */
+ 
++#ifdef USE_TACACS_PLUS
++#include "tacplus.h"
++#include "libtac.h"
++int usetacacs = 0;						/* Use TACACS+ AAA */
++u_long tac_server[TAC_PLUS_MAXSERVERS];	/* TACACS+ server addresses */
++int tac_servers = 0;					/* How many servers are defined */
++int tac_encryption = 1;					/* Do we encrypt packets */
++char *tac_secret;						/* Encryption shared secret */
++int tac_authorize = 0;					/* Authorize services */
++int tac_accounting = 0;					/* Send accounting information */
++#endif
+ #ifdef MSLANMAN
+ int	ms_lanman = 0;    	/* Nonzero if use LanMan password instead of NT */
+ 			  	/* Has meaning only with MS-CHAP challenges */
+@@ -255,6 +266,15 @@
+ static int setmslanman __P((char **));
+ #endif
+ 
++#ifdef USE_TACACS_PLUS
++static int settacacsserver __P((char **));
++static int settacacssecret __P((char **));
++static int setnotacacsencryption __P((void));
++static int settacacsauthorize __P((void));
++static int settacacsaccounting __P((void));
++static int setdotacacs __P((void));
++#endif
++
+ static int number_option __P((char *, u_int32_t *, int));
+ static int int_option __P((char *, int *));
+ static int readable __P((int fd));
+@@ -416,6 +436,17 @@
+     {"ms-lanman", 0, setmslanman},	/* Use LanMan psswd when using MS-CHAP */
+ #endif
+ 
++#ifdef USE_TACACS_PLUS
++    {"tacacs", 0, setdotacacs},
++    {"tacacs-server", 1, settacacsserver},
++    {"tacacs-secret", 1, settacacssecret},
++    {"-tacacs-encryption", 0, setnotacacsencryption},
++    {"notacacs-encryption", 0, setnotacacsencryption},
++    {"tacacs-authorize", 0, settacacsauthorize},
++    {"tacacs-authorization", 0, settacacsauthorize},
++    {"tacacs-accounting", 0, settacacsaccounting},
++#endif
++
+     {NULL, 0, NULL}
+ };
+ 
+@@ -2084,6 +2115,72 @@
+ {
+     return int_option(*argv, &lcp_fsm[0].maxconfreqtransmits);
+ }
++
++#ifdef USE_TACACS_PLUS
++static int
++settacacsserver(argv)
++    char **argv;
++{
++    	if(tac_servers >= TAC_PLUS_MAXSERVERS) {
++    		fprintf(stderr, "Too many tacacs-server options, max is %d",
++			TAC_PLUS_MAXSERVERS);
++		return(0);
++    	}
++    
++    	tac_server[tac_servers] = inet_addr(*argv);
++
++    	if (tac_server[tac_servers] == -1) {
++		fprintf(stderr, "Invalid TACACS+ server address %s\n", *argv);
++		return 0;
++    	}
++
++	tac_servers++;
++    	return(1);
++}
++
++static int
++settacacssecret(argv)
++    char **argv;
++{
++    tac_secret=(char *) calloc(1, strlen(*argv)+1);
++    strncpy(tac_secret, *argv, strlen(*argv));
++    if(*argv == NULL) {
++     fprintf(stderr, "TACACS+ secret is not specified or invalid: \"%s\" ", *argv);
++     return(0);
++    }
++    return(1);
++}
++
++static int
++setnotacacsencryption(void)
++{
++    tac_encryption=0;
++    return(1);
++      
++}
++
++static int
++setdotacacs(void)
++{
++    usetacacs=1;
++    return(1);
++}
++
++static int
++settacacsauthorize(void)
++{
++    tac_authorize=1;
++    return(1);
++}
++
++static int
++settacacsaccounting(void)
++{
++    tac_accounting=1;
++    return(1);
++}
++
++#endif /* USE_TACACS_PLUS */
+ 
+ static int
+ setlcpfails(argv)
+diff -ruN ppp-2.3.4/pppd/pppd.h ppp-2.3.4.tacacs/pppd/pppd.h
+--- ppp-2.3.4/pppd/pppd.h	Thu Mar 26 05:46:07 1998
++++ ppp-2.3.4.tacacs/pppd/pppd.h	Sun Apr 19 09:34:06 1998
+@@ -71,6 +71,18 @@
+ extern char	**script_env;	/* Environment variables for scripts */
+ extern int	detached;	/* Have detached from controlling tty */
+ 
++#ifdef USE_TACACS_PLUS
++#include "tacplus.h"
++#include "libtac.h"
++extern int usetacacs;		/* Use TACACS+ authentication */
++extern u_long tac_server[TAC_PLUS_MAXSERVERS];	/* TACACS+ server */
++extern int tac_servers;
++extern int tac_encryption;         /* Encrypt TACACS+ packets */
++extern char *tac_secret;		/* Packets encryption key */
++extern int tac_authorize;		/* Authorize user requesting service */
++extern int tac_accounting;		/* Do TACACS+ accounting */
++#endif
++
+ /*
+  * Variables set by command-line options.
+  */
+@@ -412,6 +424,9 @@
+ #define DEBUGIPCP	1
+ #define DEBUGUPAP	1
+ #define DEBUGCHAP	1
++#ifdef USE_TACACS_PLUS
++#define	DEBUGTAC	1
++#endif
+ #endif
+ 
+ #ifndef LOG_PPP			/* we use LOG_LOCAL2 for syslog by default */
+@@ -464,6 +479,12 @@
+ #define CHAPDEBUG(x)	if (debug) syslog x
+ #else
+ #define CHAPDEBUG(x)
++#endif
++
++#ifdef DEBUGTAC
++#define TACDEBUG(x)	syslog x;
++#else
++#define TACDEBUG(x)
+ #endif
+ 
+ #ifdef DEBUGIPXCP
+diff -ruN ppp-2.3.4/pppd/upap.c ppp-2.3.4.tacacs/pppd/upap.c
+--- ppp-2.3.4/pppd/upap.c	Wed Apr 30 07:59:56 1997
++++ ppp-2.3.4.tacacs/pppd/upap.c	Sun Apr 19 09:34:06 1998
+@@ -73,6 +73,11 @@
+ static void upap_sauthreq __P((upap_state *));
+ static void upap_sresp __P((upap_state *, int, int, char *, int));
+ 
++#ifdef USE_TACACS_PLUS
++extern int usetacacs;
++extern int tac_login(char *user, char *passwd, int userlen, int passlen, 
++					char **msg, int *msglen);
++#endif
+ 
+ /*
+  * upap_init - Initialize a UPAP unit.
+@@ -380,7 +385,13 @@
+     /*
+      * Check the username and password given.
+      */
+-    retcode = check_passwd(u->us_unit, ruser, ruserlen, rpasswd,
++    retcode = 
++#ifdef USE_TACACS_PLUS
++			usetacacs ? 
++			tac_login(ruser, rpasswd, ruserlen, rpasswdlen,
++							&msg, &msglen) :
++#endif
++			check_passwd(u->us_unit, ruser, ruserlen, rpasswd,
+ 			   rpasswdlen, &msg, &msglen);
+     BZERO(rpasswd, rpasswdlen);
+ 
diff --git a/pppd/plugins/tacc/tacc.1 b/pppd/plugins/tacc/tacc.1
new file mode 100644
index 0000000..997baf4
--- /dev/null
+++ b/pppd/plugins/tacc/tacc.1
@@ -0,0 +1,138 @@
+.TH TACC 1
+.SH NAME
+tacc \- simple TACACS+ client and login program
+.SH SYNOPSIS
+.B tacc
+[-TRAVh] [-qwn] [-u \fIusername\fR] [-p \fIpassword\fR] [-s \fIserver\fR]
+[-k \fIsecret\fR] [-c \fI'command'\fR] [--username=\fIusername\fR]
+[--password=\fIpassword\fR] [--server=\fIserver\fR] [--secret=\fIsecret\fR]
+[--command=\fI'command'\fR | --exec=\fI'command'\fR] [--quiet | --silent]
+[--no-wtmp] [--no-encrypt]
+.PP
+.B tacc
+\fIusername\fR 
+.SH DESCRIPTION
+.B tacc
+is simple TACACS+ client, designed mainly for two purposes:
+.TP
+.B command line mode
+sending arbitrary TACACS+ requests from command line
+.TP
+.B login mode
+sending authentication and authorization requests for username
+supplied in command line and password read from standard input;
+in this case \fBtacc\fR is working in "dumb" mode and compiled-in
+defaults are used
+.PP
+\fBtacc\fR will run in either command line mode or login mode depending 
+on parameters passed from command line. When there's only one non-option
+(i.e. not starting with "\-") parameter, \fBtacc\fR will run in login mode.
+Otherwise, it will parse other parameters described below. Any data not
+explicitly set from command line will be set to default, compiled in
+value.
+.SH "COMMAND LINE OPTIONS" 
+Options specifying action to be performed. At least one is required.
+.TP
+.I "\-T, \-\-authenticate"
+perform authentication of username and password supplied with
+\-u and \-p options
+.TP
+.I "\-R, \-\-authorize"
+request authorization for particular service (in current version
+this is limited to service \fBppp\fR and protocol \fBip\fR)
+.TP
+.I "\-A, \-\-account"
+send accounting requests on session beginning and end
+.ip "Data\ options"
+.TP
+.I "\-h, \-\-help"
+display brief listing of options and exit
+.TP
+.I "\-V, \-\-version"
+display program name, program version and exit
+
+.PP
+Options for passing various data to the program. Only \fB\-u\fR is required.
+If any of other options is not specified, the compiled-in defaul is used.
+
+.TP
+.I "\-u, \-\-username"
+username for authentication, authorization and accounting
+.TP
+.I "\-p, \-\-password"
+password for authentication; if not specified from command line,
+prompt is displayed and password is read from standard input
+.TP
+.I "\-s, \-\-server"
+TACACS+ server address, either IP address or host name; this option
+can be given up to two times, specifying primary and secondary servers
+.TP
+.I "\-k, \-\-secret"
+shared secret used to encrypt and decrypt packets exchanged with
+TACACS+ server
+.TP
+.I "\-c, \-\-command, \-\-exec"
+command to execute after successful performing all specified actions;
+this usually starts PPP or SLIP driver
+
+.PP
+Options modifying program's behaviour.
+
+.TP
+.I "\-q, \-\-quiet, \-\-silent"
+supresses displaying informational and error messages to standard
+output, but still report errors to syslog(3)
+.TP
+.I "\-w, \-\-no\-wtmp"
+supresses writing accounting records to local wtmp(5) files
+.TP
+.I "\-n, \-\-no\-encrypt"
+disables encryption of packets sent to TACACS+ server
+
+.SH "LOGIN MODE"
+In this mode \fBtacc\fR will accept only one parameter, the \fIusername\fR,
+as passed from \fIgetty\fR style programs. It is intended for use as
+replacement for \fIlogin\fR program in \fIgetty\fR configuration file.
+In login mode \fBtacc\fR will use compiled in defaults for server address,
+secret key and command to run after successful authentication and
+authorization. It will also prompt for password and read it from standard
+input, like the \fIlogin\fR program.
+
+.SH LIMITATIONS
+In current version there is no other way to change login mode parameters
+than changing them in the source file and recompiling \fBtacc\fR. It also
+does not implement the full TACACS+ specification, only the subset of
+TACACS+ required to perform PAP authentication, IP authorization
+and start/stop accounting.
+.PP
+There are also some limitations in information sent in accounting packets,
+caused by the fact that \fBtacc\fR doesn't perform PPP connection itself,
+but only spawns \fIpppd\fR to handle the PPP protocol. Because of this
+\fBtacc\fR has no idea on how many data was exchanged with the peer. 
+
+.SH "EXIT CODE"
+\fBtacc\fR returns the following codes at exit:
+.TP
+.B 0
+to indicate success
+.TP
+.B 1
+to indicate authentication failure or remote server error
+.TP
+.B 2
+to indicate local error
+
+.SH "SEE ALSO"
+.TP
+.I ftp://ftp-eng.cisco.com/tacplus/
+CISCO archive with latest versions of TACACS+ specification, API and
+server source code
+.TP
+.I TAC_PLUS Developer's Kit
+distributed with TACACS+ server source code
+.TP
+.I http://ceti.com.pl/~kravietz/progs/tacacs.html
+more information on \fBtacc\fR and TACACS+ support for \fIpppd\fR
+
+.SH AUTHOR
+Pawel Krawczyk <kravietz@ceti.com.pl>
diff --git a/pppd/plugins/tacc/tacc.c b/pppd/plugins/tacc/tacc.c
new file mode 100644
index 0000000..a2b0c3e
--- /dev/null
+++ b/pppd/plugins/tacc/tacc.c
@@ -0,0 +1,610 @@
+/* tacc.c  TACACS+ PAP authentication client
+ * 
+ * Copyright 1997-98 by Pawel Krawczyk <kravietz@ceti.com.pl>
+ * Portions copyright (c) 1989 Carnegie Mellon University.
+ *
+ * See http://www.ceti.com.pl/~kravietz/progs/tacacs.html
+ * for details.
+ *
+ */
+
+#include <stdio.h>
+#include <pwd.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <netdb.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <syslog.h>
+#include <errno.h>
+#include <utmp.h> 
+#include <sys/file.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <signal.h>
+#include <time.h>
+#ifdef __FreeBSD__
+#include "getopt.h"
+#include <libutil.h>
+#else
+#include <getopt.h>
+#endif
+#include <ctype.h>
+
+#include "tacplus.h"
+#include "libtac.h"
+#include "magic.h"
+
+/* CONFIGURABLE PARAMETERS */
+
+/* TACACS+ server FQDN or IP address */
+#define DEFAULT_SERVER "195.116.211.2"
+
+/* key used to encrypt TACACS+ packets 
+ * should be same as key set in TACACS+
+ * server configuration 
+ */ 
+#define DEFAULT_SECRET "dupa-20"
+
+/* Prompt displayed when asking for password */
+#define PASSWORD_PROMPT "Password: "
+
+/* if defined, given command will be run after
+ * successful authentication and proper wtmp
+ * entries will be made 
+ */
+#define DEFAULT_COMMAND "/usr/sbin/pppd -detach"
+
+/* message that will be displayed to user
+ * before starting COMMAND 
+ */
+#define COMMAND_MESSAGE "Starting PPP\n"
+
+/* timeout for reading password from user (seconds) */
+#define GETPASS_TIMEOUT 60
+
+/* end of CONFIGURABLE PARAMETERS */
+
+/* prototypes */
+void sighandler(int sig);
+void showusage(char *argv0);
+unsigned long getservername(char *serv);
+#if (defined(__linux__) && ! __GLIBC__ >= 2) || defined(__FreeBSD)
+int logwtmp (char *line, char *name, char *host);
+#endif
+void showusage(char *progname);
+void showversion(char *progname);
+void authenticate(unsigned long *tac_server, int tac_servers, char *user,
+				char *pass, char *tty);
+void timeout_handler(int signum);
+
+#define	EXIT_OK		0
+#define	EXIT_FAIL	1	/* AAA failure (or server error) */
+#define	EXIT_ERR	2	/* local error */
+
+#define USE_SYSTEM	1
+
+/* globals */
+char *tac_secret = NULL;
+int tac_encryption = 1;
+typedef unsigned char flag;
+flag quiet = 0;
+char *user = NULL; /* global, because of signal handler */
+
+/* command line options */
+static struct option long_options[] = {
+	/* operation */
+	{"authenticate", no_argument, NULL, 'T'},
+	{"authorize", no_argument, NULL, 'R'},
+	{"account", no_argument, NULL, 'A'},
+	{"version", no_argument, NULL, 'V'},
+	{"help", no_argument, NULL, 'h'},
+	
+	/* data */
+	{"username", required_argument, NULL, 'u'},
+	{"password", required_argument, NULL, 'p'},
+	{"server", required_argument, NULL, 's'},
+	{"secret", required_argument, NULL, 'k'},
+	{"command", required_argument, NULL, 'c'},
+	{"exec", required_argument, NULL, 'c'},
+
+	/* modifiers */
+	{"quiet", no_argument, NULL, 'q'},
+	{"silent", no_argument, NULL, 'q'},
+	{"no-wtmp", no_argument, NULL, 'w'},
+	{"no-encrypt", no_argument, NULL, 'n'},
+	{0, 0, 0, 0}
+};
+
+/* command line letters */
+char *opt_string="TRAVhu:p:s:k:c:qwn";
+
+int main(int argc, char **argv) {
+	char *pass = NULL;
+	char *tty;
+	char *command = NULL;
+	unsigned long tac_server[2];
+	int tac_servers = 0;
+	int tac_fd;
+    short int task_id = 0;
+	char buf[40];
+#ifndef USE_SYSTEM
+	pid_t pid;
+#endif
+	char *msg;
+	struct areply arep;
+
+	/* options */
+	flag log_wtmp = 1;
+	flag do_author = 0;
+	flag do_authen = 0;
+	flag do_account = 0;
+	flag login_mode = 0;
+
+	/* check argc */
+	if(argc < 2) {
+		showusage(argv[0]);	
+		exit(EXIT_ERR);
+	}
+	
+	/* check for login mode */
+	if(argc == 2 && isalpha(*argv[1])) {
+		user = argv[1];
+		do_author = do_authen = do_account = 1;
+		command = DEFAULT_COMMAND;
+		login_mode = 1;
+	} else {
+		int c;
+		int opt_index;
+		
+		while((c=getopt_long(argc, argv, opt_string, 
+				long_options, &opt_index)) != EOF) {
+			switch(c) {
+				case 'T':
+					do_authen = 1;
+					break;
+				case 'R':
+					do_author = 1;
+					break;
+				case 'A':
+					do_account = 1;
+					break;
+				case 'V':
+					showversion(argv[0]);
+				case 'h':
+					showusage(argv[0]);
+				case 'u':
+					user = optarg;
+					break;
+				case 'p':
+					pass = optarg;
+					break;
+				case 's': 
+					if(tac_servers >= 2) {
+						/* allow no more that 2 servers */
+						if(!quiet)
+						printf("no more than 2 servers allowed: ignoring %s\n",
+										optarg);
+						break;
+					}
+					tac_servers++;
+					tac_server[tac_servers - 1] = getservername(optarg);
+					break;
+				case 'k':
+					tac_secret = optarg;
+					break;
+				case 'c':
+					command = optarg;
+					break;
+				case 'q':
+					quiet = 1;
+					break;
+				case 'w':
+					log_wtmp = 0;
+					break;
+				case 'n':
+					tac_encryption = 0;
+					break;
+			}
+		}
+	}
+
+	/* check available information and set to defaults if needed */
+	if(do_authen + do_author + do_account == 0) {
+			printf("error: you must specify one of -TRAVh options\n");
+			exit(EXIT_ERR);
+	}
+
+	if(user == NULL) {
+			printf("error: you must specify username.\n");
+			exit(EXIT_ERR);
+	}
+
+	if(!tac_servers) {
+		tac_server[0] = getservername(DEFAULT_SERVER);
+		tac_servers++;
+	}
+
+	if(tac_secret == NULL)
+		tac_secret = DEFAULT_SECRET;
+	
+	if(pass == NULL) {
+		signal(SIGALRM, timeout_handler);
+		alarm(GETPASS_TIMEOUT);
+		pass = getpass(PASSWORD_PROMPT);
+		alarm(0);
+		signal(SIGALRM, SIG_DFL);
+		if(!strlen(pass))
+			exit(EXIT_ERR);
+	}
+
+  	tty=ttyname(0);
+	if(strncmp(tty, "/dev/", 5) == 0)
+		tty += 5;	
+
+	/* open syslog before any TACACS+ calls */
+	openlog("tacc", LOG_CONS|LOG_PID, LOG_AUTHPRIV);
+
+	magic_init();
+	
+	if(do_authen)
+			authenticate(tac_server, tac_servers, user, pass, tty);
+
+	if(do_author) {
+		/* authorize user */
+		struct tac_attrib *attr = NULL;
+		tac_add_attrib(&attr, "service", "ppp");
+		tac_add_attrib(&attr, "protocol", "lcp");
+	
+		tac_fd = tac_connect(tac_server, tac_servers);
+		tac_author_send(tac_fd, user, tty, attr);
+	
+		tac_author_read(tac_fd, &arep);
+		if(arep.status != AUTHOR_STATUS_PASS_ADD &&
+			arep.status != AUTHOR_STATUS_PASS_REPL ) {
+				if(!quiet) printf("Authorization FAILED: %s\n", arep.msg);
+				exit(EXIT_FAIL);
+		} else {
+			if(!quiet) printf("Authorization OK: %s\n", arep.msg);
+		}
+	
+		tac_free_attrib(&attr);
+	}
+
+	/* we no longer need the password in our address space */
+	bzero(pass, strlen(pass));
+	pass = NULL;
+	
+	if(do_account) {
+		/* start accounting */
+		struct tac_attrib *attr = NULL;
+		sprintf(buf, "%lu", time(0));
+		tac_add_attrib(&attr, "start_time", buf);
+		task_id=(short int) magic();
+		sprintf(buf, "%hu", task_id);
+		tac_add_attrib(&attr, "task_id", buf);
+		tac_add_attrib(&attr, "service", "ppp");
+		tac_add_attrib(&attr, "protocol", "lcp");
+		
+		tac_fd=tac_connect(tac_server, tac_servers);
+
+		tac_account_send(tac_fd, TAC_PLUS_ACCT_FLAG_START, user,
+				tty, 0, attr);
+
+		msg = tac_account_read(tac_fd);
+		if(msg != NULL) {
+			if(!quiet) printf("Accounting: START failed: %s\n", msg);
+			syslog(LOG_INFO,"TACACS+ accounting start failed: %s",
+									msg);
+		} else if(!login_mode && !quiet)
+			printf("Accounting: START ok\n");
+
+		close(tac_fd);
+
+		tac_free_attrib(&attr);
+
+	}
+
+	/* log in local utmp */
+	if(log_wtmp)
+        	logwtmp(tty, user, "dialup");
+
+	if(command != NULL) {
+		int ret;
+
+		syslog(LOG_DEBUG, "starting %s for %s", command, user);
+
+		signal(SIGHUP, SIG_IGN);
+		signal(SIGTERM, SIG_IGN);
+		signal(SIGINT, SIG_IGN);
+		signal(SIGCHLD, SIG_IGN);
+
+#ifdef COMMAND_MESSAGE
+		printf(COMMAND_MESSAGE);
+#endif
+
+#if USE_SYSTEM
+		ret = system(command);
+		if(ret < 0)
+				syslog(LOG_WARNING, "command failed: %m");
+		else
+				syslog(LOG_NOTICE, "command exit code %u", ret);
+#else
+		pid=fork();
+		
+		if(pid == 0) {
+		/* child */
+			
+			execl(DEFAULT_COMMAND, DEFAULT_COMMAND, ARGS, NULL);
+			syslog(LOG_ERR, "execl() failed: %m");
+			_exit(EXIT_FAIL);
+		}
+
+		if(pid < 0) {
+		/* error */
+			syslog(LOG_ERR, "fork failed: %m");
+			exit(EXIT_FAIL);
+		}		
+
+		if(pid > 0) {
+		/* parent */
+			int st, r;
+
+			r=wait(&st);
+			/* syslog(LOG_ERR, "wait(): %d", r); */
+		}
+#endif
+	}	
+	
+	if(do_account) {
+		/* stop accounting */
+		struct tac_attrib *attr = NULL;
+		sprintf(buf, "%lu", time(0));
+		tac_add_attrib(&attr, "stop_time", buf);
+		sprintf(buf, "%hu", task_id);
+		tac_add_attrib(&attr, "task_id", buf);
+	
+		tac_fd=tac_connect(tac_server, tac_servers);
+
+		tac_account_send(tac_fd, TAC_PLUS_ACCT_FLAG_STOP, user,
+			tty, 0, attr);
+		msg = tac_account_read(tac_fd);
+		if(msg != NULL) {
+			if(!quiet) printf("Accounting: STOP failed: %s", msg);
+			syslog(LOG_INFO,"TACACS+ accounting stop failed: %s\n",
+									msg);
+		} else if(!login_mode && !quiet)
+			printf("Accounting: STOP ok\n");
+
+		close(tac_fd);
+
+		tac_free_attrib(&attr);
+	}
+
+	/* logout from utmp */
+	if(log_wtmp)
+        	logwtmp(tty, "", "");
+
+	exit(EXIT_OK);	
+}
+
+
+void sighandler(int sig) {
+	TACDEBUG((LOG_DEBUG, "caught signal %d", sig));
+}
+
+void authenticate(unsigned long *tac_server, int tac_servers, char *user,
+				char *pass, char *tty)
+{
+	int tac_fd;
+	char *msg;
+
+
+	tac_fd=tac_connect(tac_server, tac_servers);
+	
+	if(tac_fd < 0) {
+		if(!quiet) printf("Error connecting to TACACS+ server: %m\n");
+		exit(EXIT_ERR);
+	}
+
+	/* start authentication */
+
+	if(tac_authen_pap_send(tac_fd, user, pass, tty) < 0) {
+		if(!quiet) printf("Error sending query to TACACS+ server\n");
+		exit(EXIT_ERR);
+	}
+
+	msg=tac_authen_pap_read(tac_fd);
+	
+	if(msg != NULL) {
+		if(!quiet) printf("Authentication FAILED: %s\n", msg);
+		syslog(LOG_ERR, "authentication failed for %s: %s", user, msg);
+		exit(EXIT_FAIL);
+	}
+
+	if(!quiet) printf("Authentication OK\n");
+	syslog(LOG_INFO, "authentication OK for %s", user);
+
+	close(tac_fd);
+}
+
+void showusage(char *progname) {
+	char *a;
+
+	a = rindex(progname, '/');	
+	progname = (a == NULL) ? progname : ++a; 
+
+	printf("%s -- simple TACACS+ client and login, version %u.%u.%u\n",
+		progname, tac_ver_major, tac_ver_minor, tac_ver_patch);
+	printf("Copyright 1997-98 by Pawel Krawczyk <kravietz@ceti.com.pl>\n");
+	printf("usage: %s option [option, ...]\n", progname);
+	printf("       %s username\n", progname);
+	printf("When started with username as the only parameter, %s will use\n", progname);
+	printf("compiled-in default values for server address and secret. It will\n");
+	printf("also display prompt and read password from standard input.\n");
+	printf("Otherwise, the following options are accepted in command line:\n");
+	printf(" Action:\n");
+	printf("  -T, --authenticate  perform authentication of username and password\n");
+	printf("  -R, --authorize     perform authorization for requested service\n");
+	printf("  -A, --account       account session beginning and end\n");
+	printf("  -h, --help          display this help and exit\n");
+	printf("  -V, --version       display version number and exit\n");
+	printf(" Data:\n");
+	printf("  -u, --username      user's name\n");
+	printf("  -p, --password      user's password\n");
+	printf("  -s, --server        server's address or FQDN (multiple allowed)\n");
+	printf("  -k, --secret        shared secret to encrypt packets\n");
+	printf("  -c, --command       command to execute after success in all of\n");
+	printf("      --exec           specified actions\n");
+	printf(" Modifiers:\n");
+	printf("  -q, --quiet         don't display messages to screen (but still\n");
+	printf("      --silent         report them via syslog(3))\n");
+	printf("  -w, --no-wtmp       don't write records to wtmp(5)\n");
+	printf("  -n, --no-encrypt    don't encrypt AAA packets sent to servers\n");
+
+	exit(EXIT_ERR);
+}
+
+void showversion(char *progname) {
+	char *a;
+		
+	a = rindex(progname, '/');
+	progname = (a == NULL) ? progname : ++a;
+	
+	printf("%s %u.%u.%u\n",
+		       	progname, tac_ver_major, tac_ver_minor, tac_ver_patch);
+	exit(EXIT_OK);
+}
+
+unsigned long getservername(char *serv) {
+	struct in_addr addr;
+	struct hostent *h;
+
+	if(inet_aton(serv, &addr) == 0) {
+		if((h=gethostbyname(serv)) == NULL) {
+			herror("gethostbyname");
+		} else {
+			bcopy(h->h_addr, (char *)&addr, sizeof(struct in_addr));
+			return(addr.s_addr);
+		}
+	} else 
+		return(addr.s_addr);
+
+	return(-1);
+}
+
+/*
+ * This is logwtmp() taken from sys-linux.c, changed a bit for
+ * compatibility with tacc.c
+ */
+
+#if (defined(__linux__) && ! __GLIBC__ >= 2) || defined(__FreeBSD)
+int logwtmp (char *line, char *name, char *host)
+  {
+    int    mode;
+    int    wtmp;
+    struct utmp ut, *utp;
+    pid_t  mypid = getpid();
+/*
+ * Control the 'mesg' function based upon the state of the logon
+ * operation. If the user is being 'logged on' then disable the
+ * mesg function. When the user 'logs off' then re-enable it.
+ */
+    mode = (*name != '\0') ? 0600 : 0622;
+/*    if (chmod (devnam, mode) < 0)
+      {
+	syslog (LOG_ERR, "chmod(\"%s\", 0%o): %m", devnam, mode);
+      }
+*/
+/*
+ * Update the signon database for users.
+ * Christoph Lameter: Copied from poeigl-1.36 Jan 3, 1996
+ */
+    utmpname(_PATH_UTMP);
+    setutent();
+    while ((utp = getutent()) && (utp->ut_pid != mypid))
+        /* nothing */;
+
+    /* Is this call really necessary? There is another one after the 'put' */
+    endutent();
+    
+    if (utp)
+      {
+	memcpy(&ut, utp, sizeof(ut));
+      }
+    else
+      {
+	/* some gettys/telnetds don't initialize utmp... */
+	memset(&ut, 0, sizeof(ut));
+      }
+
+    if (ut.ut_id[0] == 0)
+      {
+	strncpy(ut.ut_id, line + 3, sizeof(ut.ut_id));
+      }
+	
+    strncpy(ut.ut_user, name, sizeof(ut.ut_user));
+    strncpy(ut.ut_line, line, sizeof(ut.ut_line));
+
+    time(&ut.ut_time);
+
+    ut.ut_type = USER_PROCESS;
+    ut.ut_pid  = mypid;
+
+    /* Insert the host name if one is supplied */
+    if (*host)
+      {
+	strncpy (ut.ut_host, host, sizeof(ut.ut_host));
+      }
+
+    /* CL: Makes sure that the logout works */
+    if (*host == 0 && *name==0)
+      {
+	ut.ut_host[0]=0;
+      }
+
+    pututline(&ut);
+    endutent();
+/*
+ * Update the wtmp file.
+ */
+    wtmp = open(_PATH_WTMP, O_APPEND|O_WRONLY);
+    if (wtmp >= 0)
+      {
+	flock(wtmp, LOCK_EX);
+
+    	/* we really should check for error on the write for a full disk! */
+	write (wtmp, (char *)&ut, sizeof(ut));
+	close (wtmp);
+
+	flock(wtmp, LOCK_UN);
+      }
+  }
+#endif
+
+/*
+ * Make a string representation of a network IP address.
+ */
+char *
+ip_ntoa(ipaddr)
+u_int32_t ipaddr;
+{
+    static char b[64];
+
+    ipaddr = ntohl(ipaddr);
+
+    sprintf(b, "%d.%d.%d.%d",
+	    (u_char)(ipaddr >> 24),
+	    (u_char)(ipaddr >> 16),
+	    (u_char)(ipaddr >> 8),
+	    (u_char)(ipaddr));
+    return b;
+}
+
+void timeout_handler(int signum)
+{
+	syslog(LOG_ERR, "timeout reading password from user %s", user);
+
+}
diff --git a/pppd/plugins/winbind.c b/pppd/plugins/winbind.c
index bb05acd..2f92603 100644
--- a/pppd/plugins/winbind.c
+++ b/pppd/plugins/winbind.c
@@ -54,6 +54,11 @@
 #include <errno.h>
 #include <ctype.h>
 
+#ifndef DYNAMIC_PLUGINS
+#define	plugin_init winbind_plugin_init
+#endif
+char winbind_pppd_version[] = VERSION;
+
 #define BUF_LEN 1024
 
 #define NOT_AUTHENTICATED 0
@@ -102,8 +107,6 @@ static int winbind_chap_verify(char *user, char *ourname, int id,
 			       char *message, int message_space);
 static int winbind_allowed_address(u_int32_t addr); 
 
-char pppd_version[] = VERSION;
-
 /**********************************************************************
 * %FUNCTION: plugin_init
 * %ARGUMENTS:
@@ -113,8 +116,8 @@ char pppd_version[] = VERSION;
 * %DESCRIPTION:
 *  Initializes WINBIND plugin.
 ***********************************************************************/
-void
-plugin_init(void)
+
+void plugin_init(void)
 {
     pap_check_hook = winbind_secret_check;
     pap_auth_hook = winbind_pap_auth;
diff --git a/pppd/pppd.h b/pppd/pppd.h
index 247fa15..40bdb9b 100644
--- a/pppd/pppd.h
+++ b/pppd/pppd.h
@@ -81,6 +81,7 @@
 #define MAXNAMELEN	256	/* max length of hostname or name for auth */
 #define MAXSECRETLEN	256	/* max length of password or secret */
 
+
 /*
  * Option descriptor structure.
  */
@@ -228,7 +229,7 @@ extern int	privileged;	/* We were run by real-uid root */
 extern int	need_holdoff;	/* Need holdoff period after link terminates */
 extern char	**script_env;	/* Environment variables for scripts */
 extern int	detached;	/* Have detached from controlling tty */
-extern GIDSET_TYPE groups[NGROUPS_MAX];	/* groups the user is in */
+extern GIDSET_TYPE groups[];	/* groups the user is in */
 extern int	ngroups;	/* How many groups valid in groups */
 extern struct pppd_stats link_stats; /* byte/packet counts etc. for link */
 extern int	link_stats_valid; /* set if link_stats is valid */
@@ -253,6 +254,8 @@ extern bool	doing_multilink;
 extern bool	multilink_master;
 extern bool	bundle_eof;
 extern bool	bundle_terminating;
+extern bool external_auth; /* Set if we're using an external authenticator 
+				  			(radius, tacas etc) */
 
 extern struct notifier *pidchange;   /* for notifications of pid changing */
 extern struct notifier *phasechange; /* for notifications of phase changes */
@@ -302,7 +305,10 @@ extern bool	session_mgmt;	/* Do session management (login records) */
 extern char	our_name[MAXNAMELEN];/* Our name for authentication purposes */
 extern char	remote_name[MAXNAMELEN]; /* Peer's name for authentication */
 extern bool	explicit_remote;/* remote_name specified with remotename opt */
+extern const char *auth_group;	/* group provided by authenticator */
 extern bool	demand;		/* Do dial-on-demand */
+extern char	*ip_up;		/* user defined ip-up script */
+extern char	*ip_down;	/* user defined ip-down script */
 extern char	*ipparam;	/* Extra parameter for ip up/down scripts */
 extern bool	cryptpap;	/* Others' PAP passwords are encrypted */
 extern int	idle_time_limit;/* Shut down link if idle for this long */
@@ -325,6 +331,10 @@ extern bool	dump_options;	/* print out option values */
 extern bool	dryrun;		/* check everything, print options, exit */
 extern int	child_wait;	/* # seconds to wait for children at end */
 
+extern u_int32_t	metric;	/* the metric to set the host route to */
+extern u_int32_t	drmetric;	/* the default route metric to set */
+extern char	pid_file[MAXNAMELEN];	/* name of our pid file */
+
 #ifdef MAXOCTETS
 extern unsigned int maxoctets;	     /* Maximum octetes per session (in bytes) */
 extern int       maxoctets_dir;      /* Direction :
@@ -577,6 +587,14 @@ int  auth_ip_addr __P((int, u_int32_t));
 int  auth_number __P((void));	/* check if remote number is authorized */
 int  bad_ip_adrs __P((u_int32_t));
 				/* check if IP address is unreasonable */
+#ifdef USE_PAM
+int check_pam_account_restrictions __P((const char *));
+				/* check PAM for user account restrictions */
+#endif
+#ifdef USE_EXTERNAL_STATS_PROG
+void notify_login_failure __P((const char *));
+                                /* Notify statsd of any failures */
+#endif
 
 /* Procedures exported from demand.c */
 void demand_conf __P((void));	/* config interface(s) for demand-dial */
@@ -665,10 +683,11 @@ int  sif6addr __P((int, eui64_t, eui64_t));
 int  cif6addr __P((int, eui64_t, eui64_t));
 				/* Remove an IPv6 address from i/f */
 #endif
-int  sifdefaultroute __P((int, u_int32_t, u_int32_t));
+int  sifdefaultroute __P((int, u_int32_t, u_int32_t, u_int32_t, bool));
 				/* Create default route through i/f */
 int  cifdefaultroute __P((int, u_int32_t, u_int32_t));
 				/* Delete default route through i/f */
+int  rtmetricfixup __P((int, u_int32_t, u_int32_t));
 int  sifproxyarp __P((int, u_int32_t));
 				/* Add proxy ARP entry for peer */
 int  cifproxyarp __P((int, u_int32_t));
diff --git a/pppd/sha1.c b/pppd/sha1.c
index f4f975c..cdf9d7c 100644
--- a/pppd/sha1.c
+++ b/pppd/sha1.c
@@ -16,6 +16,7 @@
 
 /* #define SHA1HANDSOFF * Copies data before messing with it. */
 
+#include <time.h>
 #include <string.h>
 #include <netinet/in.h>	/* htonl() */
 #include <net/ppp_defs.h>
diff --git a/pppd/sys-linux.c b/pppd/sys-linux.c
index e5e9baf..813d045 100644
--- a/pppd/sys-linux.c
+++ b/pppd/sys-linux.c
@@ -127,12 +127,7 @@
 
 #ifdef IPX_CHANGE
 #include "ipxcp.h"
-#if __GLIBC__ >= 2 && \
-    !(defined(__powerpc__) && __GLIBC__ == 2 && __GLIBC_MINOR__ == 0)
-#include <netipx/ipx.h>
-#else
 #include <linux/ipx.h>
-#endif
 #endif /* IPX_CHANGE */
 
 #ifdef PPP_FILTER
@@ -1616,11 +1611,11 @@ int have_route_to(u_int32_t addr)
  * sifdefaultroute - assign a default route through the address given.
  */
 
-int sifdefaultroute (int unit, u_int32_t ouraddr, u_int32_t gateway)
+int sifdefaultroute (int unit, u_int32_t ouraddr, u_int32_t gateway, u_int32_t metric, bool force)
 {
     struct rtentry rt;
 
-    if (defaultroute_exists(&rt) && strcmp(rt.rt_dev, ifname) != 0) {
+    if (!force && defaultroute_exists(&rt) && strcmp(rt.rt_dev, ifname) != 0) {
 	if (rt.rt_flags & RTF_GATEWAY)
 	    error("not replacing existing default route via %I",
 		  SIN_ADDR(rt.rt_gateway));
@@ -1634,6 +1629,7 @@ int sifdefaultroute (int unit, u_int32_t ouraddr, u_int32_t gateway)
     SET_SA_FAMILY (rt.rt_dst, AF_INET);
 
     rt.rt_dev = ifname;
+    rt.rt_metric = metric + 1;
 
     if (kernel_version > KVERSION(2,1,0)) {
 	SET_SA_FAMILY (rt.rt_genmask, AF_INET);
@@ -1685,6 +1681,31 @@ int cifdefaultroute (int unit, u_int32_t ouraddr, u_int32_t gateway)
     return 1;
 }
 
+int rtmetricfixup(int unit, u_int32_t hisaddr, u_int32_t metric)
+{
+    struct rtentry rt;
+
+    memset(&rt, '\0', sizeof(rt));
+    SET_SA_FAMILY (rt.rt_dst,     AF_INET);
+    SET_SA_FAMILY (rt.rt_gateway, AF_INET);
+    if (kernel_version > KVERSION(2,1,0)) {
+	SET_SA_FAMILY (rt.rt_genmask, AF_INET);
+	((struct sockaddr_in *) &rt.rt_genmask)->sin_addr.s_addr = ~0L;
+    }
+    rt.rt_dev = ifname;
+    ((struct sockaddr_in *) &rt.rt_gateway)->sin_addr.s_addr = 0L;
+    ((struct sockaddr_in *) &rt.rt_dst)->sin_addr.s_addr     = hisaddr;
+    rt.rt_flags = RTF_UP | RTF_HOST;
+    if (ioctl(sock_fd, SIOCDELRT, &rt) < 0) {
+	error("ioctl(SIOCDELRT): %m(%d)", errno);
+    }
+    rt.rt_metric = metric + 1;
+    if (ioctl(sock_fd, SIOCADDRT, &rt) < 0) {
+	warn("ioctl(SIOCADDRT): %m(%d)", errno);
+    }
+    return 1;
+}
+
 /********************************************************************
  *
  * sifproxyarp - Make a proxy ARP entry for the peer.
diff --git a/pppd/tty.c b/pppd/tty.c
index c9a0b33..538fa38 100644
--- a/pppd/tty.c
+++ b/pppd/tty.c
@@ -112,12 +112,14 @@ static int setxonxoff __P((char **));
 static int setescape __P((char **));
 static void printescape __P((option_t *, void (*)(void *, char *,...),void *));
 static void finish_tty __P((void));
+#ifndef __uClinux__
 static int start_charshunt __P((int, int));
 static void stop_charshunt __P((void *, int));
 static void charshunt_done __P((void *));
 static void charshunt __P((int, int, char *));
 static int record_write __P((FILE *, int code, u_char *buf, int nb,
 			     struct timeval *));
+#endif
 static int open_socket __P((char *));
 static void maybe_relock __P((void *, int));
 
@@ -627,6 +629,7 @@ int connect_tty()
 	 */
 	status = EXIT_PTYCMD_FAILED;
 	if (ptycommand != NULL) {
+#ifndef __uClinux__
 		if (record_file != NULL) {
 			int ipipe[2], opipe[2], ok;
 
@@ -646,8 +649,10 @@ int connect_tty()
 			if (!ok)
 				goto errret;
 		} else {
+#endif /* !__uClinux__ */
 			if (device_script(ptycommand, pty_master, pty_master, 1) < 0)
 				goto errret;
+#ifndef __uClinux__
 		}
 	} else if (pty_socket != NULL) {
 		int fd = open_socket(pty_socket);
@@ -669,6 +674,7 @@ int connect_tty()
 		int fd = dup(ttyfd);
 		if (!start_charshunt(fd, fd))
 			goto errret;
+#endif /* !__uClinux__ */
 	}
 
 	if (using_pty || record_file != NULL) {
@@ -784,7 +790,9 @@ void disconnect_tty()
 	} else {
 		info("Serial link disconnected.");
 	}
+#ifndef __uClinux__
 	stop_charshunt(NULL, 0);
+#endif
 }
 
 void tty_close_fds()
@@ -918,6 +926,7 @@ open_socket(dest)
     return sock;
 }
 
+#ifndef __uClinux__
 
 /*
  * start_charshunt - create a child process to run the character shunt.
@@ -1264,3 +1273,5 @@ record_write(f, code, buf, nb, tp)
     }
     return 1;
 }
+
+#endif /* !__uClinux__ */
diff --git a/pppd/upap.c b/pppd/upap.c
index 8a73621..40dbbfb 100644
--- a/pppd/upap.c
+++ b/pppd/upap.c
@@ -446,7 +446,15 @@ upap_rauthreq(u, inp, id, len)
 
     /* Null terminate and clean remote name. */
     slprintf(rhostname, sizeof(rhostname), "%.*v", ruserlen, ruser);
-
+#ifdef USE_PAM
+    if (retcode == UPAP_AUTHACK) {
+		/* Check the pam account settings */
+		if (check_pam_account_restrictions(ruser)) {
+			warn("User %q failed PAM account check", ruser);
+			retcode - UPAP_AUTHNAK;
+		}
+    }
+#endif 
     if (retcode == UPAP_AUTHACK) {
 	u->us_serverstate = UPAPSS_OPEN;
 	notice("PAP peer authentication succeeded for %q", rhostname);
@@ -455,6 +463,9 @@ upap_rauthreq(u, inp, id, len)
 	u->us_serverstate = UPAPSS_BADAUTH;
 	warn("PAP peer authentication failed for %q", rhostname);
 	auth_peer_fail(u->us_unit, PPP_PAP);
+#ifdef USE_EXTERNAL_STATS_PROG
+	notify_login_failure(ruser);
+#endif
     }
 
     if (u->us_reqtimeout > 0)
diff --git a/pppdump/Makefile.linux b/pppdump/Makefile.linux
index ac028f6..3d73710 100644
--- a/pppdump/Makefile.linux
+++ b/pppdump/Makefile.linux
@@ -2,7 +2,8 @@ DESTDIR = $(INSTROOT)@DESTDIR@
 BINDIR = $(DESTDIR)/sbin
 MANDIR = $(DESTDIR)/share/man/man8
 
-CFLAGS= -O -I../include/net
+#CFLAGS= -O -I../include/net
+CFLAGS += -I../include/net
 OBJS = pppdump.o bsd-comp.o deflate.o zlib.o
 
 INSTALL= install
@@ -10,7 +11,7 @@ INSTALL= install
 all:	pppdump
 
 pppdump: $(OBJS)
-	$(CC) -o pppdump $(OBJS)
+	$(CC) $(CFLAGS) $(LDFLAGS) -o pppdump $(OBJS) $(LDLIBS$(LDLIBS_$@))
 
 clean:
 	rm -f pppdump $(OBJS) *~
diff --git a/pppstats/Makefile.linux b/pppstats/Makefile.linux
index cca6f0f..f7d1156 100644
--- a/pppstats/Makefile.linux
+++ b/pppstats/Makefile.linux
@@ -10,13 +10,14 @@ PPPSTATSRCS = pppstats.c
 PPPSTATOBJS = pppstats.o
 
 #CC = gcc
-COPTS = -O
+#COPTS = -O
 COMPILE_FLAGS = -I../include
-LIBS =
+#LIBS =
 
 INSTALL= install
 
-CFLAGS = $(COPTS) $(COMPILE_FLAGS)
+#CFLAGS = $(COPTS) $(COMPILE_FLAGS)
+CFLAGS += $(COPTS) $(COMPILE_FLAGS)
 
 all: pppstats
 
@@ -26,7 +27,7 @@ install: pppstats
 	$(INSTALL) -c -m 444 pppstats.8 $(MANDIR)
 
 pppstats: $(PPPSTATSRCS)
-	$(CC) $(CFLAGS) -o pppstats pppstats.c $(LIBS)
+	$(CC) $(CFLAGS) $(LDFLAGS) -o pppstats pppstats.c $(LIBS) $(LDLIBS$(LDLIBS_$@))
 
 clean:
 	rm -f pppstats *~ #* core
diff --git a/scripts/radiusclient/dictionary b/scripts/radiusclient/dictionary
new file mode 100644
index 0000000..8172890
--- /dev/null
+++ b/scripts/radiusclient/dictionary
@@ -0,0 +1,242 @@
+#
+# Updated 97/06/13 to livingston-radius-2.01 miquels@cistron.nl
+#
+#	This file contains dictionary translations for parsing
+#	requests and generating responses.  All transactions are
+#	composed of Attribute/Value Pairs.  The value of each attribute
+#	is specified as one of 4 data types.  Valid data types are:
+#
+#	string - 0-253 octets
+#	ipaddr - 4 octets in network byte order
+#	integer - 32 bit value in big endian order (high byte first)
+#	date - 32 bit value in big endian order - seconds since
+#					00:00:00 GMT,  Jan.  1,  1970
+#
+#	Enumerated values are stored in the user file with dictionary
+#	VALUE translations for easy administration.
+#
+#	Example:
+#
+#	ATTRIBUTE	  VALUE
+#	---------------   -----
+#	Framed-Protocol = PPP
+#	7		= 1	(integer encoding)
+#
+
+INCLUDE /etc/radiusclient/dictionary.ms
+INCLUDE /etc/radiusclient/dictionary.sg
+#
+#	Following are the proper new names. Use these.
+#
+ATTRIBUTE	User-Name		1	string
+ATTRIBUTE	Password		2	string
+ATTRIBUTE	CHAP-Password		3	string
+ATTRIBUTE	NAS-IP-Address		4	ipaddr
+ATTRIBUTE	NAS-Port-Id		5	integer
+ATTRIBUTE	Service-Type		6	integer
+ATTRIBUTE	Framed-Protocol		7	integer
+ATTRIBUTE	Framed-IP-Address	8	ipaddr
+ATTRIBUTE	Framed-IP-Netmask	9	ipaddr
+ATTRIBUTE	Framed-Routing		10	integer
+ATTRIBUTE	Filter-Id		11	string
+ATTRIBUTE	Framed-MTU		12	integer
+ATTRIBUTE	Framed-Compression	13	integer
+ATTRIBUTE	Login-IP-Host		14	ipaddr
+ATTRIBUTE	Login-Service		15	integer
+ATTRIBUTE	Login-TCP-Port		16	integer
+ATTRIBUTE	Reply-Message		18	string
+ATTRIBUTE	Callback-Number		19	string
+ATTRIBUTE	Callback-Id		20	string
+ATTRIBUTE	Framed-Route		22	string
+ATTRIBUTE	Framed-IPX-Network	23	ipaddr
+ATTRIBUTE	State			24	string
+ATTRIBUTE	Class			25	string
+ATTRIBUTE	Vendor-Specific		26	string
+ATTRIBUTE	Session-Timeout		27	integer
+ATTRIBUTE	Idle-Timeout		28	integer
+ATTRIBUTE	Termination-Action	29	integer
+ATTRIBUTE	Called-Station-Id	30	string
+ATTRIBUTE	Calling-Station-Id	31	string
+ATTRIBUTE	NAS-Identifier		32	string
+ATTRIBUTE	Proxy-State		33	string
+ATTRIBUTE	Login-LAT-Service	34	string
+ATTRIBUTE	Login-LAT-Node		35	string
+ATTRIBUTE	Login-LAT-Group		36	string
+ATTRIBUTE	Framed-AppleTalk-Link	37	integer
+ATTRIBUTE	Framed-AppleTalk-Network	38	integer
+ATTRIBUTE	Framed-AppleTalk-Zone	39	string
+ATTRIBUTE	Acct-Status-Type	40	integer
+ATTRIBUTE	Acct-Delay-Time		41	integer
+ATTRIBUTE	Acct-Input-Octets	42	integer
+ATTRIBUTE	Acct-Output-Octets	43	integer
+ATTRIBUTE	Acct-Session-Id		44	string
+ATTRIBUTE	Acct-Authentic		45	integer
+ATTRIBUTE	Acct-Session-Time	46	integer
+ATTRIBUTE	Acct-Input-Packets	47	integer
+ATTRIBUTE	Acct-Output-Packets	48	integer
+ATTRIBUTE	Acct-Terminate-Cause	49	integer
+ATTRIBUTE	Acct-Multi-Session-Id	50	string
+ATTRIBUTE	Acct-Link-Count		51	integer
+ATTRIBUTE	Event-Timestamp		55	integer
+ATTRIBUTE	CHAP-Challenge		60	string
+ATTRIBUTE	NAS-Port-Type		61	integer
+ATTRIBUTE	Port-Limit		62	integer
+ATTRIBUTE	Login-LAT-Port		63	integer
+ATTRIBUTE	Connect-Info		77	string
+
+#
+#	RFC3162 IPv6 attributes
+#
+ATTRIBUTE	NAS-IPv6-Address	95	string
+ATTRIBUTE	Framed-Interface-Id	96	string
+ATTRIBUTE	Framed-IPv6-Prefix	97	string
+ATTRIBUTE	Login-IPv6-Host		98	string
+ATTRIBUTE	Framed-IPv6-Route	99	string
+ATTRIBUTE	Framed-IPv6-Pool	100	string
+
+#
+#	Experimental Non Protocol Attributes used by Cistron-Radiusd
+#
+ATTRIBUTE	Huntgroup-Name		221	string
+ATTRIBUTE	User-Category		1029	string
+ATTRIBUTE	Group-Name		1030	string
+ATTRIBUTE	Simultaneous-Use	1034	integer
+ATTRIBUTE	Strip-User-Name		1035	integer
+ATTRIBUTE	Fall-Through		1036	integer
+ATTRIBUTE	Add-Port-To-IP-Address	1037	integer
+ATTRIBUTE	Exec-Program		1038	string
+ATTRIBUTE	Exec-Program-Wait	1039	string
+ATTRIBUTE	Hint			1040	string
+
+#
+#	Non-Protocol Attributes
+#	These attributes are used internally by the server
+#
+ATTRIBUTE	Expiration		  21	date
+ATTRIBUTE	Auth-Type		1000	integer
+ATTRIBUTE	Menu			1001	string
+ATTRIBUTE	Termination-Menu	1002	string
+ATTRIBUTE	Prefix			1003	string
+ATTRIBUTE	Suffix			1004	string
+ATTRIBUTE	Group			1005	string
+ATTRIBUTE	Crypt-Password		1006	string
+ATTRIBUTE	Connect-Rate		1007	integer
+
+#
+#	Integer Translations
+#
+
+#	User Types
+
+VALUE		Service-Type		Login-User		1
+VALUE		Service-Type		Framed-User		2
+VALUE		Service-Type		Callback-Login-User	3
+VALUE		Service-Type		Callback-Framed-User	4
+VALUE		Service-Type		Outbound-User		5
+VALUE		Service-Type		Administrative-User	6
+VALUE		Service-Type		NAS-Prompt-User		7
+
+#	Framed Protocols
+
+VALUE		Framed-Protocol		PPP			1
+VALUE		Framed-Protocol		SLIP			2
+
+#	Framed Routing Values
+
+VALUE		Framed-Routing		None			0
+VALUE		Framed-Routing		Broadcast		1
+VALUE		Framed-Routing		Listen			2
+VALUE		Framed-Routing		Broadcast-Listen	3
+
+#	Framed Compression Types
+
+VALUE		Framed-Compression	None			0
+VALUE		Framed-Compression	Van-Jacobson-TCP-IP	1
+
+#	Login Services
+
+VALUE		Login-Service		Telnet			0
+VALUE		Login-Service		Rlogin			1
+VALUE		Login-Service		TCP-Clear		2
+VALUE		Login-Service		PortMaster		3
+
+#	Status Types
+
+VALUE		Acct-Status-Type	Start			1
+VALUE		Acct-Status-Type	Stop			2
+VALUE		Acct-Status-Type	Alive			3
+VALUE		Acct-Status-Type	Accounting-On		7
+VALUE		Acct-Status-Type	Accounting-Off		8
+
+#	Authentication Types
+
+VALUE		Acct-Authentic		RADIUS			1
+VALUE		Acct-Authentic		Local			2
+VALUE		Acct-Authentic		PowerLink128		100
+
+#	Termination Options
+
+VALUE		Termination-Action	Default			0
+VALUE		Termination-Action	RADIUS-Request		1
+
+#	NAS Port Types, available in 3.3.1 and later
+
+VALUE		NAS-Port-Type		Async			0
+VALUE		NAS-Port-Type		Sync			1
+VALUE		NAS-Port-Type		ISDN			2
+VALUE		NAS-Port-Type		ISDN-V120		3
+VALUE		NAS-Port-Type		ISDN-V110		4
+
+#	Acct Terminate Causes, available in 3.3.2 and later
+
+VALUE           Acct-Terminate-Cause    User-Request            1
+VALUE           Acct-Terminate-Cause    Lost-Carrier            2
+VALUE           Acct-Terminate-Cause    Lost-Service            3
+VALUE           Acct-Terminate-Cause    Idle-Timeout            4
+VALUE           Acct-Terminate-Cause    Session-Timeout         5
+VALUE           Acct-Terminate-Cause    Admin-Reset             6
+VALUE           Acct-Terminate-Cause    Admin-Reboot            7
+VALUE           Acct-Terminate-Cause    Port-Error              8
+VALUE           Acct-Terminate-Cause    NAS-Error               9
+VALUE           Acct-Terminate-Cause    NAS-Request             10
+VALUE           Acct-Terminate-Cause    NAS-Reboot              11
+VALUE           Acct-Terminate-Cause    Port-Unneeded           12
+VALUE           Acct-Terminate-Cause    Port-Preempted          13
+VALUE           Acct-Terminate-Cause    Port-Suspended          14
+VALUE           Acct-Terminate-Cause    Service-Unavailable     15
+VALUE           Acct-Terminate-Cause    Callback                16
+VALUE           Acct-Terminate-Cause    User-Error              17
+VALUE           Acct-Terminate-Cause    Host-Request            18
+
+#
+#	Non-Protocol Integer Translations
+#
+
+VALUE		Auth-Type		Local			0
+VALUE		Auth-Type		System			1
+VALUE		Auth-Type		SecurID			2
+VALUE		Auth-Type		Crypt-Local		3
+VALUE		Auth-Type		Reject			4
+
+#
+#	Cistron extensions
+#
+VALUE		Auth-Type		Pam			253
+VALUE		Auth-Type		Accept			254
+
+#
+#	Experimental Non-Protocol Integer Translations for Cistron-Radiusd
+#
+VALUE		Fall-Through		No			0
+VALUE		Fall-Through		Yes			1
+VALUE		Add-Port-To-IP-Address	No			0
+VALUE		Add-Port-To-IP-Address	Yes			1
+
+#
+#	Configuration Values
+#	uncomment these two lines to turn account expiration on
+#
+
+#VALUE		Server-Config		Password-Expiration	30
+#VALUE		Server-Config		Password-Warning	5
+
diff --git a/scripts/radiusclient/dictionary.ms b/scripts/radiusclient/dictionary.ms
new file mode 100644
index 0000000..c8b0832
--- /dev/null
+++ b/scripts/radiusclient/dictionary.ms
@@ -0,0 +1,81 @@
+#
+#       Microsoft's VSA's, from RFC 2548
+#
+#       $Id: dictionary.ms,v 1.1 2008-01-29 04:10:56 kwilson Exp $
+#
+
+VENDOR          Microsoft       311     Microsoft
+
+ATTRIBUTE       MS-CHAP-Response        1       string  Microsoft
+ATTRIBUTE       MS-CHAP-Error           2       string  Microsoft
+ATTRIBUTE       MS-CHAP-CPW-1           3       string  Microsoft
+ATTRIBUTE       MS-CHAP-CPW-2           4       string  Microsoft
+ATTRIBUTE       MS-CHAP-LM-Enc-PW       5       string  Microsoft
+ATTRIBUTE       MS-CHAP-NT-Enc-PW       6       string  Microsoft
+ATTRIBUTE       MS-MPPE-Encryption-Policy 7     string  Microsoft
+# This is referred to as both singular and plural in the RFC.
+# Plural seems to make more sense.
+ATTRIBUTE       MS-MPPE-Encryption-Type 8       string  Microsoft
+ATTRIBUTE       MS-MPPE-Encryption-Types  8     string  Microsoft
+ATTRIBUTE       MS-RAS-Vendor           9       integer Microsoft
+ATTRIBUTE       MS-CHAP-Domain          10      string  Microsoft
+ATTRIBUTE       MS-CHAP-Challenge       11      string  Microsoft
+ATTRIBUTE       MS-CHAP-MPPE-Keys       12      string  Microsoft encrypt=1
+ATTRIBUTE       MS-BAP-Usage            13      integer Microsoft
+ATTRIBUTE       MS-Link-Utilization-Threshold 14 integer        Microsoft
+ATTRIBUTE       MS-Link-Drop-Time-Limit 15      integer Microsoft
+ATTRIBUTE       MS-MPPE-Send-Key        16      string  Microsoft
+ATTRIBUTE       MS-MPPE-Recv-Key        17      string  Microsoft
+ATTRIBUTE       MS-RAS-Version          18      string  Microsoft
+ATTRIBUTE       MS-Old-ARAP-Password    19      string  Microsoft
+ATTRIBUTE       MS-New-ARAP-Password    20      string  Microsoft
+ATTRIBUTE       MS-ARAP-PW-Change-Reason 21     integer Microsoft
+
+ATTRIBUTE       MS-Filter               22      string  Microsoft
+ATTRIBUTE       MS-Acct-Auth-Type       23      integer Microsoft
+ATTRIBUTE       MS-Acct-EAP-Type        24      integer Microsoft
+
+ATTRIBUTE       MS-CHAP2-Response       25      string  Microsoft
+ATTRIBUTE       MS-CHAP2-Success        26      string  Microsoft
+ATTRIBUTE       MS-CHAP2-CPW            27      string  Microsoft
+
+ATTRIBUTE       MS-Primary-DNS-Server   28      ipaddr
+ATTRIBUTE       MS-Secondary-DNS-Server 29      ipaddr
+ATTRIBUTE       MS-Primary-NBNS-Server  30      ipaddr
+ATTRIBUTE       MS-Secondary-NBNS-Server 31     ipaddr
+
+#ATTRIBUTE      MS-ARAP-Challenge       33      string  Microsoft
+
+#
+#       Integer Translations
+#
+
+#       MS-BAP-Usage Values
+
+VALUE           MS-BAP-Usage            Not-Allowed     0
+VALUE           MS-BAP-Usage            Allowed         1
+VALUE           MS-BAP-Usage            Required        2
+
+#       MS-ARAP-Password-Change-Reason Values
+
+VALUE   MS-ARAP-PW-Change-Reason        Just-Change-Password            1
+VALUE   MS-ARAP-PW-Change-Reason        Expired-Password                2
+VALUE   MS-ARAP-PW-Change-Reason        Admin-Requires-Password-Change  3
+VALUE   MS-ARAP-PW-Change-Reason        Password-Too-Short              4
+
+#       MS-Acct-Auth-Type Values
+
+VALUE           MS-Acct-Auth-Type       PAP             1
+VALUE           MS-Acct-Auth-Type       CHAP            2
+VALUE           MS-Acct-Auth-Type       MS-CHAP-1       3
+VALUE           MS-Acct-Auth-Type       MS-CHAP-2       4
+VALUE           MS-Acct-Auth-Type       EAP             5
+
+#       MS-Acct-EAP-Type Values
+
+VALUE           MS-Acct-EAP-Type        MD5             4
+VALUE           MS-Acct-EAP-Type        OTP             5
+VALUE           MS-Acct-EAP-Type        Generic-Token-Card      6
+VALUE           MS-Acct-EAP-Type        TLS             13
+
+END-VENDOR Microsoft
diff --git a/scripts/radiusclient/dictionary.sg b/scripts/radiusclient/dictionary.sg
new file mode 100644
index 0000000..bdb74f6
--- /dev/null
+++ b/scripts/radiusclient/dictionary.sg
@@ -0,0 +1,11 @@
+#
+#       Secure VSAs
+#
+#       $I$
+#
+
+VENDOR          Secure                  1573     Secure
+
+ATTRIBUTE       SG-GroupName            1        string  Secure
+
+END-VENDOR Secure
-- 
2.17.1

