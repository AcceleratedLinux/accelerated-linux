Date: 2008/04/03 00:33:15
#13399

Add option to resolve all DNS queries as the server IP address.

Index: dnsmasq2/src/forward.c
===================================================================
--- dnsmasq2.orig/src/forward.c	2009-03-12 13:23:19.000000000 +1000
+++ dnsmasq2/src/forward.c	2009-03-12 13:23:29.000000000 +1000
@@ -706,6 +706,28 @@ void receive_query(struct listener *list
 #endif
     }
 
+#ifdef DO_RESOLVE_AS_SERVER
+    if (daemon->custom_options & OPT_REPLY_DST) {
+      /* 
+       * If 'wildcard reply with destination' option is set, don't lookup the 
+       * list of servers, just send a reply with the destination address of the 
+       * request (i.e. the server, us) as the resolved IP. Also set TTL to zero
+       * to avoid caching.
+       */
+      struct all_addr addr;
+      size_t plen;
+      unsigned short gotname = extract_request(header, (size_t)n, daemon->namebuff, NULL);
+
+      /*syslog(LOG_DEBUG, _("bypassing nameserver search - returning IP that req came in on (%s)"), inet_ntoa(dst_addr.addr.addr4));*/
+      if (gotname) {
+        addr = dst_addr;
+        plen = setup_reply(header, (size_t)n, &addr, gotname, 0);
+        send_from(listen->fd, daemon->options & OPT_NOWILD, (char *)header, plen, &source_addr, &dst_addr, if_index);
+      }
+      return;
+    }
+#endif
+
 #ifdef DO_PRELOAD
   /* If the request was generated by ourselves for preloading, just forward it on. */
   if (type == T_A && source_addr.in.sin_addr.s_addr == htonl(0x7f000001) && source_addr.in.sin_port == preload_lookup_sin_port)
Index: dnsmasq2/src/option.c
===================================================================
--- dnsmasq2.orig/src/option.c	2009-03-12 13:23:09.000000000 +1000
+++ dnsmasq2/src/option.c	2009-03-12 13:23:45.000000000 +1000
@@ -96,6 +96,7 @@ struct myoption {
 #define LOPT_LOCAL     286
 #define LOPT_NAPTR     287
 #define LOPT_MINPORT   288
+#define LOPT_REPLY_DST 289
 
 #ifdef HAVE_GETOPT_LONG
 static const struct option opts[] =  
@@ -196,6 +197,9 @@ static const struct myoption opts[] = 
 #ifdef DO_PRELOAD
     {"preload-file", 1, 0, '_'},
 #endif
+#ifdef DO_RESOLVE_AS_SERVER
+    {"reply-with-dest", 1, 0, LOPT_REPLY_DST },
+#endif
 #ifdef DO_DHCP
     {"dhcp-ignore-names", 2, 0, LOPT_NO_NAMES },
 #endif
@@ -2357,6 +2361,14 @@ static char *one_opt(int option, char *a
 	new->weight = weight;
 	break;
       }
+
+#ifdef DO_RESOLVE_AS_SERVER
+    case LOPT_REPLY_DST: /* --reply-with-dest */
+      {
+	daemon->custom_options |= OPT_REPLY_DST;
+	break;
+      }
+#endif
     }
 
   if (problem)
Index: dnsmasq2/src/dnsmasq.h
===================================================================
--- dnsmasq2.orig/src/dnsmasq.h	2009-03-12 13:22:43.000000000 +1000
+++ dnsmasq2/src/dnsmasq.h	2009-03-12 13:23:29.000000000 +1000
@@ -190,6 +190,8 @@ struct event_desc {
 #define OPT_TFTP_APREF     (1u<<29)
 #define OPT_NO_OVERRIDE    (1u<<30)
 #define OPT_NO_REBIND      (1u<<31)
+/* Custom options (we've run out of space for more standard options) */
+#define OPT_REPLY_DST      (1u<<0)
 
 struct all_addr {
   union {
@@ -583,6 +585,7 @@ extern struct daemon {
      in option.c */
 
   unsigned int options;
+  unsigned int custom_options;
   struct resolvc default_resolv, *resolv_files;
   struct mx_srv_record *mxnames;
   struct naptr *naptr;
Index: dnsmasq2/makefile
===================================================================
--- dnsmasq2.orig/makefile	2009-03-12 13:23:19.000000000 +1000
+++ dnsmasq2/makefile	2009-03-12 13:23:29.000000000 +1000
@@ -11,6 +11,9 @@ endif
 ifdef CONFIG_PROP_STATSD_STATSD
 CFLAGS += -DDO_STATS
 endif
+ifdef CONFIG_USER_DNSMASQ2_RESOLVE_AS_SERVER
+CFLAGS += -DDO_RESOLVE_AS_SERVER
+endif
 
 EXTRA_OBJS = preload.o
 export EXTRA_OBJS
