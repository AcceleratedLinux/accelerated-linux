From 9b477a371314e2bab1489e500146cc502845624b Mon Sep 17 00:00:00 2001
From: Ayman Ghanem <ayman.ghanem@digi.com>
Date: Tue, 11 Apr 2023 11:43:13 -0500
Subject: [PATCH] Added DHCP option error ignore

Added a patch to allow DNSMASQ to send erroneous values to their
dhcp-options when the '--ignore-conf-error' is set.  For example,
network broadcast address has an option of 28, and the payload is
expected to be an address, any other types of payload value will trigger
an alert and exit DNSMASQ.

This is not a desirable behaviour, instead, when DNSMASQ detects an
issue, it needs to be able to handle it, send it regardless, but at the
same time syslog it.

This commit allows that to happen by adding the flag
'--ignore-conf-error' when dnsmasq is called.

(Original author: Brendan Chen <brendan.chen@digi.com>)
---
 src/dnsmasq.h |   3 +-
 src/option.c  | 104 ++++++++++++++++++++++++++++++++++++++++++--------
 2 files changed, 90 insertions(+), 17 deletions(-)

diff --git a/src/dnsmasq.h b/src/dnsmasq.h
index 08d5e61..24aa134 100644
--- a/src/dnsmasq.h
+++ b/src/dnsmasq.h
@@ -282,7 +282,8 @@ struct event_desc {
 #define OPT_NO_IDENT       70
 #define OPT_CACHE_RR       71
 #define OPT_LOCALHOST_SERVICE  72
-#define OPT_LAST           73
+#define OPT_IGN_CONF_ERR   73
+#define OPT_LAST           74
 
 #define OPTION_BITS (sizeof(unsigned int)*8)
 #define OPTION_SIZE ( (OPT_LAST/OPTION_BITS)+((OPT_LAST%OPTION_BITS)!=0) )
diff --git a/src/option.c b/src/option.c
index f4ff7c0..59a3f98 100644
--- a/src/option.c
+++ b/src/option.c
@@ -192,6 +192,7 @@ struct myoption {
 #define LOPT_NO_DHCP4      383
 #define LOPT_MAX_PROCS     384
 #define LOPT_DNSSEC_LIMITS 385
+#define LOPT_IGNORE_CONF_ERR 386
 
 #ifdef HAVE_GETOPT_LONG
 static const struct option opts[] =  
@@ -388,6 +389,7 @@ static const struct myoption opts[] =
     { "use-stale-cache", 2, 0 , LOPT_STALE_CACHE },
     { "no-ident", 0, 0, LOPT_NO_IDENT },
     { "max-tcp-connections", 1, 0, LOPT_MAX_PROCS },
+    { "ignore-conf-error", 0, 0, LOPT_IGNORE_CONF_ERR},
     { NULL, 0, 0, 0 }
   };
 
@@ -591,6 +593,7 @@ static struct {
   { LOPT_NO_IDENT, OPT_NO_IDENT, NULL, gettext_noop("Do not add CHAOS TXT records."), NULL },
   { LOPT_CACHE_RR, ARG_DUP, "<RR-type>", gettext_noop("Cache this DNS resource record type."), NULL },
   { LOPT_MAX_PROCS, ARG_ONE, "<integer>", gettext_noop("Maximum number of concurrent tcp connections."), NULL },
+  { LOPT_IGNORE_CONF_ERR, OPT_IGN_CONF_ERR, NULL, gettext_noop("Log dnsmasq conf errors to syslog but continue to run DNSMASQ."), NULL },
   { 0, 0, NULL, NULL, NULL }
 }; 
 
@@ -862,7 +865,6 @@ static void do_usage(void)
 
 #define ret_err(x) do { strcpy(errstr, (x)); return 0; } while (0)
 #define ret_err_free(x,m) do { strcpy(errstr, (x)); free((m)); return 0; } while (0)
-#define goto_err(x) do { strcpy(errstr, (x)); goto on_error; } while (0)
 
 static char *parse_mysockaddr(char *arg, union mysockaddr *addr) 
 {
@@ -1501,14 +1503,24 @@ static int parse_dhcp_opt(char *errstr, char *arg, int flags)
 	  new->u.vendor_class = (unsigned char *)opt_string_alloc(arg+7);
 	  new->flags |= DHOPT_VENDOR;
 	  if ((new->flags & DHOPT_ENCAPSULATE) || flags == DHOPT_MATCH)
-	    goto_err(_("inappropriate vendor:"));
+	    {
+	      if (option_bool(OPT_IGN_CONF_ERR))
+		my_syslog(LOG_CRIT, "DHCP-option %d - inappropriate vendor:", new->opt);
+	      else
+		ret_err(_("inappropriate vendor:"));
+	    }
 	}
       else if (strstr(arg, "encap:") == arg)
 	{
 	  new->u.encap = atoi(arg+6);
 	  new->flags |= DHOPT_ENCAPSULATE;
 	  if ((new->flags & DHOPT_VENDOR) || flags == DHOPT_MATCH)
-	    goto_err(_("inappropriate encap:"));
+	    {
+	      if (option_bool(OPT_IGN_CONF_ERR))
+		my_syslog(LOG_CRIT, "DHCP-option %d - inappropriate encap:", new->opt);
+	      else
+		ret_err(_("inappropriate encap:"));
+	    }
 	}
       else if (strstr(arg, "vi-encap:") == arg)
 	{
@@ -1534,7 +1546,12 @@ static int parse_dhcp_opt(char *errstr, char *arg, int flags)
   if (is6)
     {
       if (new->flags & (DHOPT_VENDOR | DHOPT_ENCAPSULATE))
-	goto_err(_("unsupported encapsulation for IPv6 option"));
+	{
+	  if (option_bool(OPT_IGN_CONF_ERR))
+	    my_syslog(LOG_CRIT, "DHCP-option %d - unsupported encapsulation for IPv6 option", new->opt);
+	  else
+	    ret_err(_("unsupported encapsulation for IPv6 option"));
+	}
       
       if (opt_len == 0 &&
 	  !(new->flags & DHOPT_RFC3925))
@@ -1548,7 +1565,12 @@ static int parse_dhcp_opt(char *errstr, char *arg, int flags)
   
   /* option may be missing with rfc3925 match */
   if (!option_ok)
-    goto_err(_("bad dhcp-option"));
+    {
+      if (option_bool(OPT_IGN_CONF_ERR))
+	my_syslog(LOG_CRIT, "DHCP-option %d - bad dhcp-option", new->opt);
+      else
+	ret_err(_("bad dhcp-option"));
+    }
   
   if (comma)
     {
@@ -1626,10 +1648,30 @@ static int parse_dhcp_opt(char *errstr, char *arg, int flags)
 	  is_string = is_dec = is_hex = 0;
 	  
 	  if (!is6 && (!is_addr || dots == 0))
-	    goto_err(_("bad IP address"));
+	    {
+	      if (option_bool(OPT_IGN_CONF_ERR))
+		{
+		  my_syslog(LOG_CRIT, "DHCP-option %d - bad IP address", new->opt);
+		  is_string = 1; /* defaulting all erroneous values to value type strings */
+		}
+	      else
+		{
+		  ret_err(_("bad IP address"));
+		}
+	    }
 
-	   if (is6 && !is_addr6)
-	     goto_err(_("bad IPv6 address"));
+	  if (is6 && !is_addr6)
+	    {
+	      if (option_bool(OPT_IGN_CONF_ERR))
+		{
+		  my_syslog(LOG_CRIT, "DHCP-option %d - bad IPv6 address", new->opt);
+		  is_string = 1; /* defaulting all erroneous values to value type strings */
+		}
+	      else
+		{
+		  ret_err(_("bad IPv6 address"));
+		}
+	    }
 	}
       /* or names */
       else if (opt_len & (OT_NAME | OT_RFC1035_NAME | OT_CSTRING))
@@ -1722,7 +1764,12 @@ static int parse_dhcp_opt(char *errstr, char *arg, int flags)
 	      comma = split(cp);
 	      slash = split_chr(cp, '/');
 	      if (!inet_pton(AF_INET, cp, &in))
-		goto_err(_("bad IPv4 address"));
+		{
+		  if (option_bool(OPT_IGN_CONF_ERR))
+		    my_syslog(LOG_CRIT, "DHCP-option %d - bad IPv4 address", new->opt);
+		  else
+		    ret_err(_("bad IPv4 address"));
+		}
 	      if (!slash)
 		{
 		  memcpy(op, &in, INADDRSZ);
@@ -1768,7 +1815,10 @@ static int parse_dhcp_opt(char *errstr, char *arg, int flags)
 		  continue;
 		}
 
-	      goto_err(_("bad IPv6 address"));
+	      if (option_bool(OPT_IGN_CONF_ERR))
+		my_syslog(LOG_CRIT, "DHCP-option %d - bad IPv6 address", new->opt);
+	      else
+		ret_err(_("bad IPv6 address"));
 	    } 
 	  new->len = op - new->val;
 	}
@@ -1795,7 +1845,12 @@ static int parse_dhcp_opt(char *errstr, char *arg, int flags)
 		  if (strcmp (arg, ".") != 0)
 		    {
 		      if (!(dom = canonicalise_opt(arg)))
-			goto_err(_("bad domain in dhcp-option"));
+			{
+			  if (option_bool(OPT_IGN_CONF_ERR))
+			    my_syslog(LOG_CRIT, "DHCP-option %d - bad domain in dhcp-option", new->opt);
+			  else
+			    ret_err(_("bad domain in dhcp-option"));
+			}
 			
 		      domlen = strlen(dom) + 2;
 		    }
@@ -1890,7 +1945,12 @@ static int parse_dhcp_opt(char *errstr, char *arg, int flags)
 		{
 		  char *dom = canonicalise_opt(arg);
 		  if (!dom)
-		    goto_err(_("bad domain in dhcp-option"));
+		    {
+		      if (option_bool(OPT_IGN_CONF_ERR))
+			my_syslog(LOG_CRIT, "DHCP-option %d - bad domain in dhcp-option", new->opt);
+		      else
+			ret_err(_("bad domain in dhcp-option"));
+		    }
 		    		  
 		  newp = opt_malloc(len + header_size + strlen(dom) + 2);
 		  
@@ -1934,14 +1994,24 @@ static int parse_dhcp_opt(char *errstr, char *arg, int flags)
       ((new->len > 255) || 
       (new->len > 253 && (new->flags & (DHOPT_VENDOR | DHOPT_ENCAPSULATE))) ||
        (new->len > 250 && (new->flags & DHOPT_RFC3925))))
-    goto_err(_("dhcp-option too long"));
+    {
+      if (option_bool(OPT_IGN_CONF_ERR))
+	my_syslog(LOG_CRIT, "DHCP-option %d - dhcp-option too long", new->opt);
+      else
+	ret_err(_("bad dhcp-option too long"));
+    }
   
   if (flags == DHOPT_MATCH)
     {
       if ((new->flags & (DHOPT_ENCAPSULATE | DHOPT_VENDOR)) ||
 	  !new->netid ||
 	  new->netid->next)
-	goto_err(_("illegal dhcp-match"));
+	{
+	  if (option_bool(OPT_IGN_CONF_ERR))
+	    my_syslog(LOG_CRIT, "DHCP-option %d - illegal dhcp-match", new->opt);
+	  else
+	    ret_err(_("illegal dhcp-match"));
+	}
        
       if (is6)
 	{
@@ -1966,7 +2036,6 @@ static int parse_dhcp_opt(char *errstr, char *arg, int flags)
     }
     
   return 1;
-on_error:
   dhcp_opt_free(new);
   return 0;
 }
@@ -2024,6 +2093,9 @@ static int one_opt(int option, char *arg, char *errstr, char *gen_err, int comma
   
   switch (option)
     { 
+    case LOPT_IGNORE_CONF_ERR:
+      set_option_bool(OPT_IGN_CONF_ERR);
+      break;
     case 'C': /* --conf-file */
       {
 	char *file = opt_string_alloc(arg);
@@ -5494,7 +5566,7 @@ static void read_file(char *file, FILE *f, int hard_opt, int from_script)
       if (errmess)
 	strcpy(daemon->namebuff, errmess);
 	  
-      if (errmess || !one_opt(option, arg, daemon->namebuff, _("error"), 0, hard_opt == LOPT_REV_SERV))
+      if ((errmess || !one_opt(option, arg, daemon->namebuff, _("error"), 0, hard_opt == LOPT_REV_SERV)) && (!option && !option_bool(OPT_IGN_CONF_ERR)))
 	{
 	  if (from_script)
 	    sprintf(daemon->namebuff + strlen(daemon->namebuff), _(" in output from %s"), file);
-- 
2.39.2

