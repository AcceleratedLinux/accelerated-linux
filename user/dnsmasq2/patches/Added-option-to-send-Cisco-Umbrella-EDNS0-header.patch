diff -Nurd dnsmasq-2.80/src/dnsmasq.h modified/dnsmasq-2.80/src/dnsmasq.h
--- dnsmasq-2.80/src/dnsmasq.h	2019-09-03 13:34:26.295523635 -0400
+++ modified/dnsmasq-2.80/src/dnsmasq.h	2019-09-03 13:40:35.986328901 -0400
@@ -1031,6 +1031,7 @@
   int port, query_port, min_port, max_port;
   unsigned long local_ttl, neg_ttl, max_ttl, min_cache_ttl, max_cache_ttl, auth_ttl, dhcp_ttl, use_dhcp_ttl;
   char *dns_client_id;
+  char *dns_umbrella_device_id;
   struct hostsfile *addn_hosts;
   struct dhcp_context *dhcp, *dhcp6;
   struct ra_interface *ra_interfaces;
diff -Nurd dnsmasq-2.80/src/dns-protocol.h modified/dnsmasq-2.80/src/dns-protocol.h
--- dnsmasq-2.80/src/dns-protocol.h	2018-10-18 14:21:55.000000000 -0400
+++ modified/dnsmasq-2.80/src/dns-protocol.h	2019-09-03 13:39:20.226573507 -0400
@@ -82,6 +82,7 @@
 #define EDNS0_OPTION_CLIENT_SUBNET  8     /* IANA */
 #define EDNS0_OPTION_NOMDEVICEID    65073 /* Nominum temporary assignment */
 #define EDNS0_OPTION_NOMCPEID       65074 /* Nominum temporary assignment */
+#define EDNS0_OPTION_UMBDEVICEID    26946 /* Cisco Umbrella experimental (self-assigned) */
 
 struct dns_header {
   u16 id;
diff -Nurd dnsmasq-2.80/src/edns0.c modified/dnsmasq-2.80/src/edns0.c
--- dnsmasq-2.80/src/edns0.c	2018-10-18 14:21:55.000000000 -0400
+++ modified/dnsmasq-2.80/src/edns0.c	2019-09-03 13:41:35.258110589 -0400
@@ -424,6 +424,35 @@
    return 1;
 }
 
+size_t add_umbrella_device_id(struct dns_header *header, size_t plen, unsigned char *limit,
+    char * umbrella_device_id)
+{
+  int i;
+
+  // Header data is 15 bytes (“OpenDNS” + 8 octets of Device ID)
+  char header_bytes[15] = "OpenDNS";
+
+  // Convert hex string to raw bytes and append to data
+  for(i = strlen(header_bytes); i < sizeof(header_bytes); i++)
+  {
+    // Should never happen because the options code already checked that
+    // the length of umbrella_device_id was 16.
+    if (umbrella_device_id[0] == '\0' || umbrella_device_id[1] == '\0')
+        break;
+
+    // Note: Invalid chars will be replaced with a byte with a value of 0.
+    sscanf(umbrella_device_id, "%2hhx", &header_bytes[i]);
+    umbrella_device_id += 2;
+  }
+  
+  plen = add_pseudoheader(header, plen, limit, PACKETSZ, EDNS0_OPTION_UMBDEVICEID,
+    (unsigned char *)header_bytes, sizeof(header_bytes), 0, 1);
+
+  return plen;
+}
+
+
+
 size_t add_edns0_config(struct dns_header *header, size_t plen, unsigned char *limit, 
 			union mysockaddr *source, time_t now, int *check_subnet)    
 {
@@ -439,6 +468,10 @@
     plen = add_pseudoheader(header, plen, limit, PACKETSZ, EDNS0_OPTION_NOMCPEID, 
 			    (unsigned char *)daemon->dns_client_id, strlen(daemon->dns_client_id), 0, 1);
   
+  if (daemon->dns_umbrella_device_id)
+    plen = add_umbrella_device_id(header, plen, limit, daemon->dns_umbrella_device_id);
+
+
   if (option_bool(OPT_CLIENT_SUBNET))
     {
       plen = add_source_addr(header, plen, limit, source); 
diff -Nurd dnsmasq-2.80/src/option.c modified/dnsmasq-2.80/src/option.c
--- dnsmasq-2.80/src/option.c	2019-09-03 13:34:26.295523635 -0400
+++ modified/dnsmasq-2.80/src/option.c	2019-09-03 13:43:04.961515828 -0400
@@ -167,6 +167,7 @@
 #define LOPT_NAME_MATCH    355
 #define LOPT_CAA           356
 #define LOPT_IGNORE_CONF_ERR 357
+#define LOPT_UMBDEVICEID   450
  
 #ifdef HAVE_GETOPT_LONG
 static const struct option opts[] =  
@@ -299,6 +300,7 @@
     { "rebind-localhost-ok", 0, 0,  LOPT_LOC_REBND },
     { "add-mac", 2, 0, LOPT_ADD_MAC },
     { "add-subnet", 2, 0, LOPT_ADD_SBNET },
+    { "add-umbrella-device-id", 1, 0, LOPT_UMBDEVICEID },
     { "add-cpe-id", 1, 0 , LOPT_CPE_ID },
     { "proxy-dnssec", 0, 0, LOPT_DNSSEC },
     { "dhcp-sequential-ip", 0, 0,  LOPT_INCR_ADDR },
@@ -477,6 +479,7 @@
   { LOPT_TEST, 0, NULL, gettext_noop("Check configuration syntax."), NULL },
   { LOPT_ADD_MAC, ARG_DUP, "[=base64|text]", gettext_noop("Add requestor's MAC address to forwarded DNS queries."), NULL },
   { LOPT_ADD_SBNET, ARG_ONE, "<v4 pref>[,<v6 pref>]", gettext_noop("Add specified IP subnet to forwarded DNS queries."), NULL },
+  { LOPT_UMBDEVICEID, ARG_ONE, "<deviceid>", gettext_noop("Add Cisco Umbrella device ID to forwarded DNS queries (16 hex digits)."), NULL },
   { LOPT_CPE_ID, ARG_ONE, "<text>", gettext_noop("Add client identification to forwarded DNS queries."), NULL },
   { LOPT_DNSSEC, OPT_DNSSEC_PROXY, NULL, gettext_noop("Proxy DNSSEC validation results from upstream nameservers."), NULL },
   { LOPT_INCR_ADDR, OPT_CONSEC_ADDR, NULL, gettext_noop("Attempt to allocate sequential IP addresses to DHCP clients."), NULL },
@@ -2297,7 +2300,16 @@
 	    }
 	}
       break;
-      
+
+    case LOPT_UMBDEVICEID:
+      if (arg) {
+        if (strlen(arg) == 16)
+          daemon->dns_umbrella_device_id = opt_string_alloc(arg);
+        else
+          ret_err(gen_err);
+      }
+      break;
+    
     case LOPT_CPE_ID: /* --add-dns-client */
       if (arg)
 	daemon->dns_client_id = opt_string_alloc(arg);
