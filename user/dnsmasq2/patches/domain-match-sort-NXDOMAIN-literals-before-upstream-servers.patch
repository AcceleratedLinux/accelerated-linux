From a16c4c656e105aaf01dbd1d7aaa818b1c6c58849 Mon Sep 17 00:00:00 2001
From: "Sreeves, Francis" <francis.sreeves@digi.com>
Date: Thu, 6 Jul 2023 18:02:10 +0100
Subject: [PATCH] domain-match: sort NXDOMAIN literals before upstream
servers

Swap the order of NXDOMAIN literals and upstream servers so that
NXDOMAIN literals are now matched first. This is required so that a
simple whitelist configuration such as:

server=/example.com/#
server=/example.net/#
address=/#/

works as expected, forwarding 'example.com' and 'example.net' to the
upstream servers in resolv.conf, while blocking all other domains.

Previously, since NXDOMAIN literals were ordered *after* upstream
servers, the blocking component of this configuration ('address=/#/')
did not work, allowing all domains to be queried.
---
 src/domain-match.c | 34 +++++++++++++++-------------------
 1 file changed, 15 insertions(+), 19 deletions(-)

diff --git a/src/domain-match.c b/src/domain-match.c
index cf2da77..f0dc2fb 100644
--- a/src/domain-match.c
+++ b/src/domain-match.c
@@ -298,8 +298,8 @@ int filter_servers(int seed, int flags, int *lowout, int *highout)
   else
     {
       /* Now the servers are on order between low and high, in the order
-	 IPv6 addr, IPv4 addr, return zero for both, resolvconf servers, send upstream, no-data return.
-	 
+	 IPv6 addr, IPv4 addr, return zero for both, resolvconf servers, no-data return, send upstream.
+
 	 See which of those match our query in that priority order and narrow (low, high) */
       
       for (i = nlow; i < nhigh && (daemon->serverarray[i]->flags & SERV_6ADDR); i++);
@@ -334,25 +334,22 @@ int filter_servers(int seed, int flags, int *lowout, int *highout)
 		  else
 		    {
 		      /* now look for a server */
-		      for (i = nlow; i < nhigh && !(daemon->serverarray[i]->flags & SERV_LITERAL_ADDRESS); i++);
-		      
-		      if (i != nlow)
+		      for (i = nlow; i < nhigh && (daemon->serverarray[i]->flags & SERV_LITERAL_ADDRESS); i++);
+
+		      /* --local=/domain/, only return if we don't need a server. */
+		      if (!(flags & (F_DNSSECOK | F_DOMAINSRV | F_SERVER)) && i != nlow)
+		        nhigh = i;
+		      else
 			{
-			  /* If we want a server that can do DNSSEC, and this one can't, 
+			  nlow = i;
+
+			  /* If we want a server that can do DNSSEC, and this one can't,
 			     return nothing, similarly if were looking only for a server
 			     for a particular domain. */
 			  if ((flags & F_DNSSECOK) && !(daemon->serverarray[nlow]->flags & SERV_DO_DNSSEC))
 			    nlow = nhigh;
 			  else if ((flags & F_DOMAINSRV) && daemon->serverarray[nlow]->domain_len == 0)
 			    nlow = nhigh;
-			  else
-			    nhigh = i;
-			}
-		      else
-			{
-			  /* --local=/domain/, only return if we don't need a server. */
-			  if (flags & (F_DNSSECOK | F_DOMAINSRV | F_SERVER))
-			    nhigh = i;
 			}
 		    }
 		}
@@ -532,12 +529,11 @@ static int order_qsort(const void *a, const void *b)
   rc = order_servers(s1, s2);
 
   /* Sort all literal NODATA and local IPV4 or IPV6 responses together,
-     in a very specific order. We flip the SERV_LITERAL_ADDRESS bit
-     so the order is IPv6 literal, IPv4 literal, all-zero literal, 
-     unqualified servers, upstream server, NXDOMAIN literal. */
+     in a very specific order: IPv6 literal, IPv4 literal, all-zero literal,
+     unqualified servers, NXDOMAIN literal, upstream server. */
   if (rc == 0)
-    rc = ((s2->flags & (SERV_LITERAL_ADDRESS | SERV_4ADDR | SERV_6ADDR | SERV_USE_RESOLV | SERV_ALL_ZEROS)) ^ SERV_LITERAL_ADDRESS) -
-      ((s1->flags & (SERV_LITERAL_ADDRESS | SERV_4ADDR | SERV_6ADDR | SERV_USE_RESOLV | SERV_ALL_ZEROS)) ^ SERV_LITERAL_ADDRESS);
+    rc = (s2->flags & (SERV_LITERAL_ADDRESS | SERV_4ADDR | SERV_6ADDR | SERV_USE_RESOLV | SERV_ALL_ZEROS)) -
+      (s1->flags & (SERV_LITERAL_ADDRESS | SERV_4ADDR | SERV_6ADDR | SERV_USE_RESOLV | SERV_ALL_ZEROS));
 
   /* Finally, order by appearance in /etc/resolv.conf etc, for --strict-order */
   if (rc == 0)
-- 
2.39.2

