From 3e965d5dba39939c2f704ec53fe01d57c3b7054f Mon Sep 17 00:00:00 2001
From: Robert Hodaszi <robert.hodaszi@digi.com>
Date: Fri, 18 Jan 2019 14:25:49 +0100
Subject: [PATCH 1/7] Add DesignWare I2C bus support, and add driver for the
 ATECC508 chip

Signed-off-by: Robert Hodaszi <robert.hodaszi@digi.com>
---
 grub-core/Makefile.core.def       |  30 ++
 grub-core/bus/i2c/busses/i2c_dw.c | 630 ++++++++++++++++++++++++++++
 grub-core/bus/i2c/devices/atecc.c | 662 ++++++++++++++++++++++++++++++
 grub-core/bus/i2c/i2c.c           | 246 +++++++++++
 grub-core/commands/atecc_cmd.c    | 242 +++++++++++
 grub-core/commands/i2c_cmd.c      | 188 +++++++++
 include/grub/atecc.h              |  56 +++
 include/grub/i2c.h                |  98 +++++
 8 files changed, 2152 insertions(+)
 create mode 100644 grub-core/bus/i2c/busses/i2c_dw.c
 create mode 100644 grub-core/bus/i2c/devices/atecc.c
 create mode 100644 grub-core/bus/i2c/i2c.c
 create mode 100644 grub-core/commands/atecc_cmd.c
 create mode 100644 grub-core/commands/i2c_cmd.c
 create mode 100644 include/grub/atecc.h
 create mode 100644 include/grub/i2c.h

diff --git a/grub-core/Makefile.core.def b/grub-core/Makefile.core.def
index 2dfa22a..eb3a188 100644
--- a/grub-core/Makefile.core.def
+++ b/grub-core/Makefile.core.def
@@ -2355,3 +2355,33 @@ module = {
   common = loader/i386/xen_file64.c;
   extra_dist = loader/i386/xen_fileXX.c;
 };
+
+module = {
+  name = i2c;
+  common = bus/i2c/i2c.c;
+  enable = pci;
+};
+
+module = {
+  name = i2c_dw;
+  common = bus/i2c/busses/i2c_dw.c;
+  enable = pci;
+};
+
+module = {
+  name = i2c_cmd;
+  common = commands/i2c_cmd.c;
+  enable = efi;
+};
+
+module = {
+  name = atecc;
+  common = bus/i2c/devices/atecc.c;
+  enable = efi;
+};
+
+module = {
+  name = atecc_cmd;
+  common = commands/atecc_cmd.c;
+  enable = efi;
+};
diff --git a/grub-core/bus/i2c/busses/i2c_dw.c b/grub-core/bus/i2c/busses/i2c_dw.c
new file mode 100644
index 0000000..c46f937
--- /dev/null
+++ b/grub-core/bus/i2c/busses/i2c_dw.c
@@ -0,0 +1,630 @@
+/* i2c_dw.c - Designware I2C adapter.  */
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2013  Free Software Foundation, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/pci.h>
+#include <grub/dl.h>
+#include <grub/mm.h>
+#include <grub/time.h>
+#include <grub/i2c.h>
+
+GRUB_MOD_LICENSE ("GPLv3+");
+
+#define DRIVER_NAME	"i2c_dw"
+
+struct grub_i2c_dw_scl_sda_cfg
+{
+  grub_uint32_t ss_hcnt;
+  grub_uint32_t fs_hcnt;
+  grub_uint32_t ss_lcnt;
+  grub_uint32_t fs_lcnt;
+  grub_uint32_t sda_hold;
+};
+
+/* BayTrail HCNT/LCNT/SDA hold time */
+static struct grub_i2c_dw_scl_sda_cfg grub_i2c_dw_baytrail_config =
+{
+  .ss_hcnt = 0x200,
+  .fs_hcnt = 0x55,
+  .ss_lcnt = 0x200,
+  .fs_lcnt = 0x99,
+  .sda_hold = 0x6,
+};
+
+struct grub_i2c_dw_priv
+{
+  volatile grub_uint32_t		*base;
+  struct grub_i2c_dw_scl_sda_cfg	*scl_sda_cfg;
+};
+
+#if !defined(I2C_DW_IC_CLK)
+# define I2C_DW_IC_CLK			166
+#endif
+#define NANO_TO_MICRO			1000
+
+/* Worst case timeout for 1 byte is kept as 5ms */
+#define I2C_DW_BYTE_TO			5
+#define I2C_DW_STOPDET_TO		5
+#define I2C_DW_BYTE_TO_BB		(I2C_DW_BYTE_TO * 16)
+
+/* High and low times in different speed modes (in ns) */
+#define MIN_SS_SCL_HIGHTIME		4000
+#define MIN_SS_SCL_LOWTIME		4700
+#define MIN_FS_SCL_HIGHTIME		600
+#define MIN_FS_SCL_LOWTIME		1300
+#define MIN_HS_SCL_HIGHTIME		60
+#define MIN_HS_SCL_LOWTIME		160
+
+#define I2C_DW_MAX_SPEED		3400000
+#define I2C_DW_FAST_SPEED		400000
+#define I2C_DW_STANDARD_SPEED		100000
+
+/* CON register */
+#define I2C_DW_CON_MASTER_MODE		(1 << 0)
+#define I2C_DW_CON_SPEED_MASK		(3 << 1)
+#define I2C_DW_CON_SPEED_SHIFT		1
+#define I2C_DW_CON_SPEED_STANDARD	(1 << I2C_DW_CON_SPEED_SHIFT)
+#define I2C_DW_CON_SPEED_FAST		(2 << I2C_DW_CON_SPEED_SHIFT)
+#define I2C_DW_CON_SPEED_HIGH		(3 << I2C_DW_CON_SPEED_SHIFT)
+#define I2C_DW_CON_10BITADDR_SLAVE	(1 << 3)
+#define I2C_DW_CON_10BITADDR_MASTER	(1 << 4)
+#define I2C_DW_CON_RESTART_EN		(1 << 5)
+#define I2C_DW_CON_SLAVE_DISABLE	(1 << 6)
+
+/* Data buffer and command register */
+#define I2C_DW_DATA_CMD_CMD		(1 << 8)
+#define I2C_DW_DATA_CMD_STOP		(1 << 9)
+#define I2C_DW_DATA_CMD_RESTART		(1 << 10)
+
+/* Interrupt status register */
+#define I2C_DW_INTR_STAT_STOP_DET	(1 << 9)
+
+/* FIFO threshold register */
+#define I2C_DW_FIFO_TL0			0x00
+#define I2C_DW_FIFO_TL1			0x01
+#define I2C_DW_FIFO_TL2			0x02
+#define I2C_DW_FIFO_TL3			0x03
+#define I2C_DW_FIFO_TL4			0x04
+#define I2C_DW_FIFO_TL5			0x05
+#define I2C_DW_FIFO_TL6			0x06
+#define I2C_DW_FIFO_TL7			0x07
+#define I2C_DW_RX_TL			I2C_DW_FIFO_TL0
+#define I2C_DW_TX_TL			I2C_DW_FIFO_TL0
+
+/* ENABLE register */
+#define I2C_DW_ENABLE_ENABLE		(1 << 0)
+
+/* STATUS register */
+#define I2C_DW_STATUS_ACTIVITY		(1 << 0)
+#define I2C_DW_STATUS_TFNF		(1 << 1)
+#define I2C_DW_STATUS_TFE		(1 << 2)
+#define I2C_DW_STATUS_RFNE		(1 << 3)
+#define I2C_DW_STATUS_RFF		(1 << 4)
+#define I2C_DW_STATUS_MST_ACTIVITY	(1 << 5)
+#define I2C_DW_STATUS_SLV_ACTIVITY	(1 << 6)
+
+/* ENABLE_STATUS register */
+#define I2C_DW_ENABLE_STATUS_IC_EN	(1 << 0)
+
+typedef enum
+{
+  I2C_DW_REG_IC_CON = 0,
+  I2C_DW_REG_IC_TAR,
+  I2C_DW_REG_IC_SAR,
+  I2C_DW_REG_IC_HS_MADDR,
+  I2C_DW_REG_IC_DATA_CMD,
+  I2C_DW_REG_IC_SS_SCL_HCNT,
+  I2C_DW_REG_IC_SS_SCL_LCNT,
+  I2C_DW_REG_IC_FS_SCL_HCNT,
+  I2C_DW_REG_IC_FS_SCL_LCNT,
+  I2C_DW_REG_IC_HS_SCL_HCNT,
+  I2C_DW_REG_IC_HS_SCL_LCNT,
+  I2C_DW_REG_IC_INTR_STAT,
+  I2C_DW_REG_IC_INTR_MASK,
+  I2C_DW_REG_IC_RAW_INTR_STAT,
+  I2C_DW_REG_IC_RX_TL,
+  I2C_DW_REG_IC_TX_TL,
+  I2C_DW_REG_IC_CLR_INTR,
+  I2C_DW_REG_IC_CLR_RX_UNDER,
+  I2C_DW_REG_IC_CLR_RX_OVER,
+  I2C_DW_REG_IC_CLR_TX_OVER,
+  I2C_DW_REG_IC_CLR_RD_REQ,
+  I2C_DW_REG_IC_CLR_TX_ABRT,
+  I2C_DW_REG_IC_CLR_RX_DONE,
+  I2C_DW_REG_IC_CLR_ACTIVITY,
+  I2C_DW_REG_IC_CLR_STOP_DET,
+  I2C_DW_REG_IC_CLR_START_DET,
+  I2C_DW_REG_IC_CLR_GEN_CALL,
+  I2C_DW_REG_IC_ENABLE,
+  I2C_DW_REG_IC_STATUS,
+  I2C_DW_REG_IC_TXFLR,
+  I2C_DW_REG_IC_RXFLR,
+  I2C_DW_REG_IC_SDA_HOLD,
+  I2C_DW_REG_IC_TX_ABRT_SOURCE,
+  I2C_DW_REG_IC_SLV_DATA_NACK_ONLY,
+  I2C_DW_REG_IC_DMA_CR,
+  I2C_DW_REG_IC_DMA_TDLR,
+  I2C_DW_REG_IC_DMA_RDLR,
+  I2C_DW_REG_IC_SDA_SETUP,
+  I2C_DW_REG_IC_ACK_GENERAL_CALL,
+  I2C_DW_REG_IC_ENABLE_STATUS,
+  I2C_DW_REG_IC_FS_SPKLEN,
+  I2C_DW_REG_IC_HS_SPKLEN,
+  I2C_DW_REG_IC_COMP_PARAM_1 = 0x3D,
+  I2C_DW_REG_IC_COMP_VERSION,
+  I2C_DW_REG_IC_COMP_TYPE,
+  I2C_DW_REG_CLOCK_PARAMS = 0x200,
+  I2C_DW_REG_RESETS,
+  I2C_DW_REG_GENERAL,
+  I2C_DW_REG_I2C_ACK_COUNT = 0x206,
+  I2C_DW_REG_I2C_TX_COMPLETE_INTR_STAT,
+  I2C_DW_REG_I2C_TX_COMPLETE_INTR_CLR,
+} grub_i2c_dw_reg_t;
+
+
+
+static inline grub_uint32_t
+grub_i2c_dw_readl (struct grub_i2c_dw_priv *priv, grub_i2c_dw_reg_t reg)
+{
+  return grub_le_to_cpu32 (*(priv->base + reg));
+}
+
+static inline void
+grub_i2c_dw_writel (struct grub_i2c_dw_priv *priv, grub_i2c_dw_reg_t reg,
+		    grub_uint32_t val)
+{
+  *(priv->base + reg) = grub_cpu_to_le32 (val);
+}
+
+
+
+static grub_err_t
+grub_i2c_dw_enable (struct grub_i2c_adapter *adap, int enable)
+{
+  struct grub_i2c_dw_priv *priv = adap->priv;
+  grub_uint32_t ena = enable ? I2C_DW_ENABLE_STATUS_IC_EN : 0;
+  int timeout = 10;
+
+  do
+    {
+      grub_i2c_dw_writel (priv, I2C_DW_REG_IC_ENABLE, ena);
+      if ((grub_i2c_dw_readl (priv, I2C_DW_REG_IC_ENABLE_STATUS) &
+	  I2C_DW_ENABLE_STATUS_IC_EN) == ena)
+	{
+	  return GRUB_ERR_NONE;
+	}
+
+      grub_millisleep (1);
+    } while (timeout--);
+
+  grub_printf ("timeout in %sabling I2C adapter\n", enable ? "en" : "dis");
+
+  return GRUB_ERR_TIMEOUT;
+}
+
+static grub_err_t
+grub_i2c_dw_set_bus_speed (struct grub_i2c_adapter *adap,
+			   grub_uint32_t speed)
+{
+  struct grub_i2c_dw_priv *priv = adap->priv;
+  grub_uint32_t cntl;
+  grub_uint32_t hcnt, lcnt;
+  grub_uint32_t i2c_spd;
+  struct grub_i2c_dw_scl_sda_cfg *scl_sda_cfg = priv->scl_sda_cfg;
+
+  if (speed >= I2C_DW_MAX_SPEED)
+    i2c_spd = I2C_DW_CON_SPEED_HIGH;
+  else if (speed >= I2C_DW_FAST_SPEED)
+    i2c_spd = I2C_DW_CON_SPEED_FAST;
+  else
+    i2c_spd = I2C_DW_CON_SPEED_STANDARD;
+
+  /* To set speed cltr must be disabled */
+  grub_i2c_dw_enable (adap, 0);
+
+  cntl = (grub_i2c_dw_readl (priv, I2C_DW_REG_IC_CON) & (~I2C_DW_CON_SPEED_MASK));
+
+  switch (i2c_spd)
+    {
+      /* No High-speed for BayTrail yet */
+#if 0
+      case I2C_DW_CON_SPEED_HIGH:
+	break;
+#endif
+
+      case I2C_DW_CON_SPEED_STANDARD:
+	cntl |= I2C_DW_CON_SPEED_STANDARD;
+	if (scl_sda_cfg)
+	  {
+	    hcnt = scl_sda_cfg->ss_hcnt;
+	    lcnt = scl_sda_cfg->ss_lcnt;
+          }
+	else
+	  {
+	    hcnt = (I2C_DW_IC_CLK * MIN_SS_SCL_HIGHTIME) / NANO_TO_MICRO;
+	    lcnt = (I2C_DW_IC_CLK * MIN_SS_SCL_LOWTIME) / NANO_TO_MICRO;
+	  }
+	grub_i2c_dw_writel (priv, I2C_DW_REG_IC_SS_SCL_HCNT, hcnt);
+	grub_i2c_dw_writel (priv, I2C_DW_REG_IC_SS_SCL_LCNT, lcnt);
+
+	break;
+
+      case I2C_DW_CON_SPEED_FAST:
+      default:
+	cntl |= I2C_DW_CON_SPEED_FAST;
+	if (scl_sda_cfg)
+	  {
+	    hcnt = scl_sda_cfg->fs_hcnt;
+	    lcnt = scl_sda_cfg->fs_lcnt;
+	  }
+	else
+	  {
+	    hcnt = (I2C_DW_IC_CLK * MIN_FS_SCL_HIGHTIME) / NANO_TO_MICRO;
+	    lcnt = (I2C_DW_IC_CLK * MIN_FS_SCL_LOWTIME) / NANO_TO_MICRO;
+	  }
+	grub_i2c_dw_writel (priv, I2C_DW_REG_IC_FS_SCL_HCNT, hcnt);
+	grub_i2c_dw_writel (priv, I2C_DW_REG_IC_FS_SCL_LCNT, lcnt);
+
+	break;
+    }
+
+  grub_i2c_dw_writel (priv, I2C_DW_REG_IC_CON, cntl);
+
+  /* Configure SDA Hold Time if required */
+  if (scl_sda_cfg)
+    grub_i2c_dw_writel (priv, I2C_DW_REG_IC_SDA_HOLD, scl_sda_cfg->sda_hold);
+
+  /* Enable back i2c now speed set */
+  grub_i2c_dw_enable (adap, 1);
+
+  return GRUB_ERR_NONE;
+}
+
+/*
+ * grub_i2c_dw_setaddress - Sets the target slave address
+ * @i2c_addr:	target i2c address
+ *
+ * Sets the target slave address.
+ */
+static void
+grub_i2c_dw_setaddress (struct grub_i2c_adapter *adap, grub_uint32_t addr)
+{
+  struct grub_i2c_dw_priv *priv = adap->priv;
+
+  /* Disable i2c */
+  grub_i2c_dw_enable (adap, 0);
+
+  grub_i2c_dw_writel (priv, I2C_DW_REG_IC_TAR, addr);
+
+  /* Enable i2c */
+  grub_i2c_dw_enable (adap, 1);
+}
+
+/*
+ * grub_i2c_dw_flush_rxfifo - Flushes the i2c RX FIFO
+ *
+ * Flushes the i2c RX FIFO
+ */
+static void
+grub_i2c_dw_flush_rxfifo (struct grub_i2c_adapter *adap)
+{
+  struct grub_i2c_dw_priv *priv = adap->priv;
+
+  while (grub_i2c_dw_readl (priv, I2C_DW_REG_IC_STATUS) & I2C_DW_STATUS_RFNE)
+    grub_i2c_dw_readl (priv, I2C_DW_REG_IC_DATA_CMD);
+}
+
+/*
+ * grub_i2c_dw_wait_for_bb - Waits for bus busy
+ *
+ * Waits for bus busy
+ */
+static grub_err_t
+grub_i2c_dw_wait_for_bb (struct grub_i2c_adapter *adap)
+{
+  struct grub_i2c_dw_priv *priv = adap->priv;
+
+  /* Worst case timeout for 1 byte is kept as 2ms */
+  grub_uint64_t end_time_bb = grub_get_time_ms () + I2C_DW_BYTE_TO_BB;
+
+  while ((grub_i2c_dw_readl (priv, I2C_DW_REG_IC_STATUS) & I2C_DW_STATUS_MST_ACTIVITY) ||
+	 !(grub_i2c_dw_readl (priv,I2C_DW_REG_IC_STATUS) & I2C_DW_STATUS_TFE))
+    {
+      /* Evaluate timeout */
+      if (grub_get_time_ms () > end_time_bb)
+	return GRUB_ERR_TIMEOUT;
+    }
+
+  return GRUB_ERR_NONE;
+}
+
+static grub_err_t
+grub_i2c_dw_xfer_init (struct grub_i2c_adapter *adap,
+		       grub_uint8_t chip, grub_uint32_t addr, int alen)
+{
+  struct grub_i2c_dw_priv *priv = adap->priv;
+
+  if (grub_i2c_dw_wait_for_bb (adap))
+    return GRUB_ERR_TIMEOUT;
+
+  grub_i2c_dw_setaddress (adap, chip);
+  while (alen)
+    {
+      alen--;
+      /* high byte address going out first */
+      grub_i2c_dw_writel (priv, I2C_DW_REG_IC_DATA_CMD,
+			  (addr >> (alen * 8)) & 0xff);
+    }
+
+  return GRUB_ERR_NONE;
+}
+
+static grub_err_t
+grub_i2c_dw_init (struct grub_i2c_adapter *adap, grub_uint32_t speed)
+{
+  struct grub_i2c_dw_priv *priv = adap->priv;
+
+  /* Disable I2C controller */
+  grub_i2c_dw_enable (adap, 0);
+
+  grub_i2c_dw_writel (priv, I2C_DW_REG_IC_CON, (I2C_DW_CON_SLAVE_DISABLE |
+			    I2C_DW_CON_RESTART_EN | I2C_DW_CON_SPEED_FAST |
+			    I2C_DW_CON_MASTER_MODE));
+
+  grub_i2c_dw_writel (priv, I2C_DW_REG_IC_RX_TL, I2C_DW_RX_TL);
+  grub_i2c_dw_writel (priv, I2C_DW_REG_IC_TX_TL, I2C_DW_TX_TL);
+  grub_i2c_dw_writel (priv, I2C_DW_REG_IC_INTR_MASK, I2C_DW_INTR_STAT_STOP_DET);
+
+  /* Set bus speed */
+  grub_i2c_dw_set_bus_speed (adap, speed);
+
+  /* Enable i2c */
+  grub_i2c_dw_enable (adap, 1);
+
+  return GRUB_ERR_NONE;
+}
+
+static grub_err_t
+grub_i2c_dw_xfer_finish (struct grub_i2c_adapter *adap)
+{
+  struct grub_i2c_dw_priv *priv = adap->priv;
+  grub_uint64_t end_time_rx = grub_get_time_ms () + I2C_DW_STOPDET_TO;
+
+  while (1)
+    {
+      if (grub_i2c_dw_readl (priv, I2C_DW_REG_IC_INTR_STAT) &
+	  I2C_DW_INTR_STAT_STOP_DET)
+	{
+	  grub_i2c_dw_readl (priv, I2C_DW_REG_IC_CLR_STOP_DET);
+	  break;
+	}
+	else if (grub_get_time_ms () > end_time_rx)
+	  break;
+    }
+
+  if (grub_i2c_dw_wait_for_bb (adap))
+    {
+      grub_printf("Timed out waiting for I2C bus\n");
+
+      return GRUB_ERR_TIMEOUT;
+    }
+
+  grub_i2c_dw_flush_rxfifo (adap);
+
+  return GRUB_ERR_NONE;
+}
+
+static grub_err_t
+grub_i2c_dw_read (struct grub_i2c_adapter *adap, grub_uint8_t dev,
+		  grub_uint32_t addr, int alen, grub_uint8_t *buffer, int len)
+{
+  struct grub_i2c_dw_priv *priv = adap->priv;
+  grub_err_t ret;
+  grub_uint64_t end_time_rx;
+  int active = 0;
+
+  ret = grub_i2c_dw_xfer_init (adap, dev, addr, alen);
+  if (ret)
+    return ret;
+
+  end_time_rx = grub_get_time_ms () + I2C_DW_BYTE_TO;
+  while (len)
+    {
+      if (!active)
+	{
+	  /* Avoid writing to ic_cmd_data multiple times in case this loop spins
+	   * too quickly and the ic_status RFNE bit isn't set after the first write.
+	   * Subsequent writes to ic_cmd_data len trigger spurious i2c transfer. */
+	  if (len == 1)
+	    grub_i2c_dw_writel (priv, I2C_DW_REG_IC_DATA_CMD,
+				I2C_DW_DATA_CMD_CMD | I2C_DW_DATA_CMD_STOP);
+	  else
+	    grub_i2c_dw_writel (priv, I2C_DW_REG_IC_DATA_CMD,
+				I2C_DW_DATA_CMD_CMD);
+
+	  active = 1;
+	}
+
+      if (grub_i2c_dw_readl (priv, I2C_DW_REG_IC_STATUS) & I2C_DW_STATUS_RFNE)
+	{
+	  *buffer++ =
+		(grub_uint8_t)grub_i2c_dw_readl (priv, I2C_DW_REG_IC_DATA_CMD);
+	  len--;
+	  end_time_rx = grub_get_time_ms () + I2C_DW_BYTE_TO;
+
+	  active = 0;
+	}
+      else if (grub_get_time_ms () > end_time_rx)
+	return GRUB_ERR_TIMEOUT;
+    }
+
+  return grub_i2c_dw_xfer_finish (adap);
+}
+
+static grub_err_t
+grub_i2c_dw_write (struct grub_i2c_adapter *adap, grub_uint8_t dev,
+		   grub_uint32_t addr, int alen, grub_uint8_t *buffer, int len)
+{
+  struct grub_i2c_dw_priv *priv = adap->priv;
+  grub_uint32_t to_delta = len * I2C_DW_BYTE_TO;
+  grub_err_t ret;
+  grub_uint64_t end_time_rx;
+
+  ret = grub_i2c_dw_xfer_init (adap, dev, addr, alen);
+  if (ret)
+    return ret;
+
+  end_time_rx = grub_get_time_ms () + to_delta;
+  while (len)
+    {
+      if (grub_i2c_dw_readl (priv, I2C_DW_REG_IC_STATUS) & I2C_DW_STATUS_TFNF)
+        {
+	  if (--len == 0)
+	    grub_i2c_dw_writel (priv, I2C_DW_REG_IC_DATA_CMD,
+				*buffer | I2C_DW_DATA_CMD_STOP);
+	  else
+	    grub_i2c_dw_writel (priv, I2C_DW_REG_IC_DATA_CMD, *buffer);
+
+	  buffer++;
+	  end_time_rx = grub_get_time_ms () + to_delta;
+	}
+      else if (grub_get_time_ms () > end_time_rx)
+	{
+	  grub_dprintf (DRIVER_NAME, "timed out. i2c write Failed\n");
+	  return GRUB_ERR_TIMEOUT;
+	}
+    }
+
+  return grub_i2c_dw_xfer_finish (adap);
+}
+
+static void
+grub_i2c_dw_fini_hw (struct grub_i2c_adapter *adap)
+{
+  if (!adap)
+    return;
+
+  /* Disable adapter */
+  grub_i2c_dw_enable (adap, 0);
+
+  /* Free up memory */
+  grub_free (adap->priv);
+  grub_free (adap);
+}
+
+static const struct grub_i2c_driver grub_i2c_dw_driver =
+{
+  .name			= DRIVER_NAME,
+  .set_bus_speed	= grub_i2c_dw_set_bus_speed,
+  .read			= grub_i2c_dw_read,
+  .write		= grub_i2c_dw_write,
+  .fini			= grub_i2c_dw_fini_hw,
+};
+
+static int
+grub_i2c_dw_pci_iterate (grub_pci_device_t dev,
+			 grub_pci_id_t pciid,
+			 void *data __attribute__ ((unused)))
+{
+  grub_pci_address_t addr;
+  grub_uint32_t class;
+  grub_uint32_t bar;
+  struct grub_i2c_adapter *adap;
+  struct grub_i2c_dw_priv *priv;
+
+  /* Read class. */
+  addr = grub_pci_make_address (dev, GRUB_PCI_REG_CLASS);
+  class = grub_pci_read (addr);
+
+  /* Currently, we are supporting only Baytrail's I2C0 bus */
+  /* TODO: should create a device support list, and check against that */
+  if ((class >> 16) != 0x0c80 || (pciid & 0xFFFF) != 0x8086 ||
+      (pciid >> 16) != 0x0f41)
+    return 0;
+
+  grub_dprintf (DRIVER_NAME, "found\n");
+
+  /* Initialize device */
+
+  /* Allocate memory for the adapter */
+  adap = grub_zalloc (sizeof (*adap));
+  if (!adap)
+    {
+      grub_dprintf (DRIVER_NAME, "no mem\n");
+      return 0;
+    }
+
+  /* And allocate memory for the private data */
+  adap->priv = priv = grub_zalloc (sizeof (struct grub_i2c_dw_priv));
+  if (!priv)
+    {
+      grub_dprintf (DRIVER_NAME, "no mem\n");
+      goto fail;
+    }
+
+  /* Read address */
+  addr = grub_pci_make_address (dev, GRUB_PCI_REG_ADDRESSES);
+  bar = grub_pci_read (addr);
+
+  /* Enable device */
+  addr = grub_pci_make_address (dev, GRUB_PCI_REG_COMMAND);
+  grub_pci_write_word (addr, grub_pci_read_word (addr) |
+		       GRUB_PCI_COMMAND_MEM_ENABLED);
+
+  /* Map base address */
+  priv->base = grub_pci_device_map_range (dev, bar & GRUB_PCI_ADDR_MEM_MASK,
+					  0x830);
+
+  grub_dprintf (DRIVER_NAME, "base=%p\n", priv->base);
+
+  /* TODO: should verify, if it is a baytrail config instead */
+  priv->scl_sda_cfg = &grub_i2c_dw_baytrail_config;
+
+  /* Initialize adapter */
+  if (grub_i2c_dw_init (adap, 100000))
+    {
+      grub_dprintf (DRIVER_NAME, "couldn't initialize I2C adapter\n");
+      goto fail;
+    }
+
+  adap->driver = (struct grub_i2c_driver *)&grub_i2c_dw_driver;
+
+  /* Register in I2C layer */
+  grub_i2c_adapter_register (adap);
+
+  return 0;
+
+fail:
+  if (adap->priv)
+    grub_free (adap->priv);
+
+  grub_free (adap);
+
+  return 0;
+}
+
+GRUB_MOD_INIT(i2c_dw)
+{
+  /* Iterate through devices, search for DW I2C adapter */
+  grub_pci_iterate (grub_i2c_dw_pci_iterate, NULL);
+}
+
+GRUB_MOD_FINI(i2c_dw)
+{
+  grub_i2c_driver_unregister ((struct grub_i2c_driver *)&grub_i2c_dw_driver);
+}
diff --git a/grub-core/bus/i2c/devices/atecc.c b/grub-core/bus/i2c/devices/atecc.c
new file mode 100644
index 0000000..54b63e7
--- /dev/null
+++ b/grub-core/bus/i2c/devices/atecc.c
@@ -0,0 +1,662 @@
+/* atecc.c - ATECC508 driver.  */
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2013  Free Software Foundation, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/dl.h>
+#include <grub/env.h>
+#include <grub/mm.h>
+#include <grub/time.h>
+#include <grub/i2c.h>
+#include <grub/atecc.h>
+
+GRUB_MOD_LICENSE ("GPLv3+");
+
+#define GRUB_ATECC_ADDR			0x60
+
+/* Wakeup delay for ATECC108/508 in msec */
+#define ATECC_ATECC_W_HI		1
+/* Wakeup delay for ATSHA204 in msec */
+#define ATECC_ATSHA_W_HI		3
+
+/* ATECC OP codes */
+#define ATECC_OP_CHECKMAC		0x28
+#define ATECC_OP_COUNTER		0x24
+#define ATECC_OP_DERIVEKEY		0x1C
+#define ATECC_OP_ECDH			0x43
+#define ATECC_OP_GENDIG			0x15
+#define ATECC_OP_GENKEY			0x40
+#define ATECC_OP_HMAC			0x11
+#define ATECC_OP_INFO			0x30
+#define ATECC_OP_LOCK			0x17
+#define ATECC_OP_MAC			0x08
+#define ATECC_OP_NONCE			0x16
+#define ATECC_OP_PAUSE			0x01
+#define ATECC_OP_PRIVWRITE		0x46
+#define ATECC_OP_RANDOM			0x1B
+#define ATECC_OP_READ			0x02
+#define ATECC_OP_SIGN			0x41
+#define ATECC_OP_SHA			0x47
+#define ATECC_OP_UPDATEEXTRA		0x20
+#define ATECC_OP_VERIFY			0x45
+#define ATECC_OP_WRITE			0x12
+
+struct grub_atecc_buffer
+{
+  grub_uint8_t	*ptr;
+  unsigned int	len;
+};
+
+static void
+grub_atecc_i2c_crc_command (grub_uint8_t *cmd, unsigned int len);
+static grub_err_t
+grub_atecc_i2c_transaction (grub_uint8_t *tx_buf, unsigned int tx_len,
+			    struct grub_atecc_buffer *rx_buf);
+static int
+grub_atecc_check_rsp_crc16 (const grub_uint8_t *buf, const grub_uint8_t len);
+static grub_err_t
+grub_atecc_parse_status (grub_uint8_t status);
+
+grub_err_t
+grub_atecc_get_serialnum (grub_atecc_serial_num_t sn)
+{
+  struct grub_atecc_buffer recv = {0, 0};
+  grub_err_t err;
+
+  grub_uint8_t cmd[] =
+    {
+      0x03,
+      0x07,
+      ATECC_OP_READ,
+      0x80,
+      0x00,
+      0x00,
+      0x00,
+      0x00,
+    };
+
+  if (!sn)
+    return grub_error (GRUB_ERR_BAD_ARGUMENT, N_("invalid argument"));
+
+  grub_atecc_i2c_crc_command (cmd, sizeof (cmd));
+
+  err = grub_atecc_i2c_transaction (cmd, sizeof (cmd), &recv);
+  if (err)
+    return err;
+
+  /* Verify response length */
+  if (recv.len != (32 + 3))
+    {
+      err = grub_error (GRUB_ERR_READ_ERROR, N_("invalid rsp length"));
+      goto fail;
+    }
+
+  if (!grub_atecc_check_rsp_crc16 (recv.ptr, recv.len))
+    {
+      err = grub_error (GRUB_ERR_READ_ERROR, N_("bad crc"));
+      goto fail;
+    }
+
+  grub_memcpy(&sn[0], &recv.ptr[1], 4);
+  grub_memcpy(&sn[4], &recv.ptr[9], 5);
+
+  err = GRUB_ERR_NONE;
+
+fail:
+  grub_free (recv.ptr);
+
+  return err;
+}
+
+grub_err_t
+grub_atecc_get_random (grub_atecc_random_num_t random)
+{
+  struct grub_atecc_buffer recv = {0, 0};
+  grub_err_t err;
+
+  grub_uint8_t cmd[] =
+    {
+      0x03,
+      0x07,
+      ATECC_OP_RANDOM,
+      0x00,
+      0x00,
+      0x00,
+      0x00,
+      0x00,
+    };
+
+  if (!random)
+    return grub_error (GRUB_ERR_BAD_ARGUMENT, N_("invalid argument"));
+
+  grub_atecc_i2c_crc_command (cmd, sizeof (cmd));
+
+  err = grub_atecc_i2c_transaction (cmd, sizeof (cmd), &recv);
+  if (err)
+    return err;
+
+  /* Verify response length */
+  if (recv.len != (32 + 3))
+    {
+      err = grub_error (GRUB_ERR_READ_ERROR, N_("invalid rsp length"));
+      goto fail;
+    }
+
+  if (!grub_atecc_check_rsp_crc16 (recv.ptr, recv.len))
+    {
+      err = grub_error (GRUB_ERR_READ_ERROR, N_("bad crc"));
+      goto fail;
+    }
+
+  grub_memcpy (random, &recv.ptr[1], sizeof (grub_atecc_random_num_t));
+
+  err = GRUB_ERR_NONE;
+
+fail:
+  grub_free (recv.ptr);
+
+  return err;
+}
+
+grub_err_t
+grub_atecc_checkmac (grub_uint8_t slot, grub_atecc_digest_t digest,
+		     grub_atecc_signature_t signature)
+{
+  struct grub_atecc_buffer recv = {0, 0};
+  grub_err_t err;
+  /* Message format:
+   * 0:		Word address (0x03)
+   * 1:		Packet length
+   * 2:		CHECKMAC command
+   * 3:		Mode
+   * 4-5:	SlotID
+   * 6-37:	ClientChal
+   * 38-69:	ClientResp
+   * 70-82:	OtherData
+   * 83-84:	CRC
+   */
+  grub_uint8_t cmd[85], *ptr = cmd;
+  unsigned int i;
+
+  /* Verify slot index */
+  if (slot >= GRUB_ATECC_SLOT_NUM)
+      return grub_error (GRUB_ERR_BAD_ARGUMENT, N_("invalid slot"));
+
+  /* Verify digest and signature */
+  if (!digest)
+      return grub_error (GRUB_ERR_BAD_ARGUMENT, N_("invalid digest"));
+  if (!signature)
+      return grub_error (GRUB_ERR_BAD_ARGUMENT, N_("invalid signature"));
+
+  /* Set word address */
+  *ptr++ = 0x03;
+  /* Set length */
+  *ptr++ = sizeof (cmd) - 1;
+  /* Set command */
+  *ptr++ = ATECC_OP_CHECKMAC;
+  /* Set mode: sources: ClientChal and Slot[SlotID] */
+  *ptr++ = 0x00;
+  /* SlotID */
+  *ptr++ = slot;
+  /* SlotID (not used */
+  *ptr++ = 0;
+
+  /* Copy digest */
+  for (i = 0; i < sizeof (grub_atecc_digest_t); i++)
+    *ptr++ = *digest++;
+
+  /* Copy signature */
+  for (i = 0; i < sizeof (grub_atecc_signature_t); i++)
+    *ptr++ = *signature++;
+
+  /* Other data is 0 */
+  for (i = 0; i < 13; i++)
+    *ptr++ = 0;
+
+  grub_atecc_i2c_crc_command (cmd, sizeof (cmd));
+
+  err = grub_atecc_i2c_transaction (cmd, sizeof (cmd), &recv);
+  if (err)
+    return err;
+
+  /* Verify response length - we expect a simple status message */
+  if (recv.len != (1 + 3))
+    {
+      err = grub_error (GRUB_ERR_READ_ERROR, N_("invalid rsp length"));
+      goto fail;
+    }
+
+  if (!grub_atecc_check_rsp_crc16 (recv.ptr, recv.len))
+    {
+      err = grub_error (GRUB_ERR_READ_ERROR, N_("bad crc"));
+      goto fail;
+    }
+
+  err = grub_atecc_parse_status (recv.ptr[1]);
+
+fail:
+  grub_free (recv.ptr);
+
+  return err;
+}
+
+grub_err_t
+grub_atecc_nonce (grub_atecc_digest_t digest)
+{
+  struct grub_atecc_buffer recv = {0, 0};
+  grub_err_t err;
+
+  grub_uint8_t cmd[40] =
+    {
+      0x03,			/* word address */
+      0x27,			/* length */
+      ATECC_OP_NONCE,		/* command */
+      0x03,			/* pass-thru mode */
+      0x00,			/* no TempKey usage (2 bytes) */
+      0x00,
+      /* 32 bytes for digest */
+      /* 2 bytes for crc */
+    };
+
+  /* Verify digest */
+  if (!digest)
+      return grub_error (GRUB_ERR_BAD_ARGUMENT, N_("invalid digest"));
+
+  /* Copy digest */
+  grub_memcpy(&cmd[6], digest, sizeof(grub_atecc_digest_t));
+
+  grub_atecc_i2c_crc_command (cmd, sizeof (cmd));
+
+  err = grub_atecc_i2c_transaction (cmd, sizeof (cmd), &recv);
+  if (err)
+    return err;
+
+  /* Verify response length - we expect a simple status message */
+  if (recv.len != (1 + 3))
+    {
+      err = grub_error (GRUB_ERR_READ_ERROR, N_("invalid rsp length"));
+      goto fail;
+    }
+
+  if (!grub_atecc_check_rsp_crc16 (recv.ptr, recv.len))
+    {
+      err = grub_error (GRUB_ERR_READ_ERROR, N_("bad crc"));
+      goto fail;
+    }
+
+  err = grub_atecc_parse_status (recv.ptr[1]);
+
+fail:
+  grub_free (recv.ptr);
+
+  return err;
+}
+
+grub_err_t
+grub_atecc_verify (grub_uint8_t slot, grub_atecc_signature_t r,
+		   grub_atecc_signature_t s)
+{
+  struct grub_atecc_buffer recv = {0, 0};
+  grub_err_t err;
+
+  grub_uint8_t cmd[72] =
+    {
+      0x03,			/* word address */
+      0x47,			/* length */
+      ATECC_OP_VERIFY,		/* command */
+      0x00,			/* stored mode */
+      slot,			/* key slot (2 bytes) */
+      0x00,
+      /* 32 bytes for R signature */
+      /* 32 bytes for S signature */
+      /* 2 bytes for crc */
+    };
+
+  /* Verify slot index */
+  if (slot >= GRUB_ATECC_SLOT_NUM)
+      return grub_error (GRUB_ERR_BAD_ARGUMENT, N_("invalid slot"));
+
+  /* Verify signature pair */
+  if (!r)
+      return grub_error (GRUB_ERR_BAD_ARGUMENT, N_("invalid R-signature"));
+  if (!s)
+      return grub_error (GRUB_ERR_BAD_ARGUMENT, N_("invalid S-signature"));
+
+  /* Copy digest */
+  grub_memcpy(&cmd[6], r, sizeof(grub_atecc_signature_t));
+
+  /* Copy signature */
+  grub_memcpy(&cmd[38], s, sizeof(grub_atecc_signature_t));
+
+  grub_atecc_i2c_crc_command (cmd, sizeof (cmd));
+
+  err = grub_atecc_i2c_transaction (cmd, sizeof (cmd), &recv);
+  if (err)
+    return err;
+
+  /* Verify response length - we expect a simple status message */
+  if (recv.len != (1 + 3))
+    {
+      err = grub_error (GRUB_ERR_READ_ERROR, N_("invalid rsp length"));
+      goto fail;
+    }
+
+  if (!grub_atecc_check_rsp_crc16 (recv.ptr, recv.len))
+    {
+      err = grub_error (GRUB_ERR_READ_ERROR, N_("bad crc"));
+      goto fail;
+    }
+
+  err = grub_atecc_parse_status (recv.ptr[1]);
+
+fail:
+  grub_free (recv.ptr);
+
+  return err;
+}
+
+static grub_err_t
+grub_atecc_parse_status (grub_uint8_t status)
+{
+  grub_err_t ret;
+
+  switch (status)
+    {
+      case 0x00:
+	ret = GRUB_ERR_NONE;
+	break;
+
+      case 0x01:
+	ret = grub_error (GRUB_ERR_TEST_FAILURE, N_("invalid signature"));
+	break;
+
+      case 0x03:
+	ret = grub_error (GRUB_ERR_IO, N_("parse err response\n"));
+	break;
+
+      case 0x05:
+	ret = grub_error (GRUB_ERR_IO, N_("ECC fault response\n"));
+	break;
+
+      case 0x0F:
+	ret = grub_error (GRUB_ERR_IO, N_("execution err response\n"));
+	break;
+
+      case 0x11:
+	ret = grub_error (GRUB_ERR_IO, N_("rx wakeup token response\n"));
+	break;
+
+      case 0xEE:
+	ret = grub_error (GRUB_ERR_IO, N_("watchdog expired response\n"));
+	break;
+
+      case 0xFF:
+	ret = grub_error (GRUB_ERR_IO, N_("CRC err response\n"));
+	break;
+
+      default:
+	ret = grub_error (GRUB_ERR_IO, N_("unknonwn err from device (0x%x)\n"),
+					  status);
+	break;
+    }
+
+  return ret;
+}
+
+static void
+grub_atecc_dump_buffer (grub_uint8_t *buffer, unsigned int len)
+{
+  const char *debug = grub_env_get ("debug");
+
+  if (!debug)
+    return;
+
+  if (grub_strword (debug, "all") || grub_strword (debug, "atecc"))
+    {
+      unsigned int i;
+
+      grub_printf ("%s:%d: data: ", GRUB_FILE, __LINE__);
+
+      for (i = 0; i < len; i++)
+	grub_printf ("0x%02x ", buffer[i]);
+
+      grub_printf ("\n");
+    }
+}
+
+static grub_uint16_t
+grub_atecc_crc16 (const grub_uint8_t *buf, const grub_uint8_t len)
+{
+  grub_uint8_t i;
+  grub_uint16_t crc16 = 0;
+
+  for (i = 0; i < len; i++)
+    {
+      grub_uint8_t shift;
+
+      for (shift = 0x01; shift > 0x00; shift <<= 1)
+	{
+	  grub_uint8_t data_bit = (buf[i] & shift) ? 1 : 0;
+	  grub_uint8_t crc_bit = crc16 >> 15;
+
+	  crc16 <<= 1;
+
+	  if ((data_bit ^ crc_bit) != 0)
+	    crc16 ^= 0x8005;
+	}
+    }
+
+  return crc16;
+}
+
+static void
+grub_atecc_i2c_crc_command (grub_uint8_t *cmd, unsigned int len)
+{
+  /* The command packet is:
+   * [0x03] [Length=1 + command + CRC] [cmd] [crc]
+   *
+   * The CRC is calculate over:
+   * CRC([Len] [cmd])
+   */
+  int crc_data_len = len - 2 - 1;
+  grub_uint16_t crc = grub_atecc_crc16 (&cmd[1], crc_data_len);
+
+  cmd[len - 2] = grub_cpu_to_le16 (crc) & 0xFF;
+  cmd[len - 1] = grub_cpu_to_le16 (crc) >> 8;
+}
+
+static int
+grub_atecc_crc16_matches (const grub_uint8_t *buf, const grub_uint8_t len,
+			  const grub_uint16_t crc)
+{
+  grub_uint16_t crc_calc = grub_atecc_crc16 (buf, len);
+
+  return (crc == crc_calc);
+}
+
+static int
+grub_atecc_check_rsp_crc16 (const grub_uint8_t *buf, const grub_uint8_t len)
+{
+  const grub_uint16_t *rec_crc = (const grub_uint16_t *)&buf[len - 2];
+
+  return grub_atecc_crc16_matches (buf, len - 2, grub_cpu_to_le16 (*rec_crc));
+}
+
+static grub_err_t
+grub_atecc_i2c_wakeup (void)
+{
+  grub_err_t success;
+  int is_awake = 0;
+  int try_con = 0;
+  grub_uint8_t buf[4] = {0};
+  grub_err_t err;
+
+  /* Set wake-up token message */
+
+  while (!is_awake && try_con++ < 5)
+    {
+      int retry_resp = 4;
+
+      grub_dprintf ("atecc", "send wakeup (%u)\n", try_con);
+
+      /* To wake up the device, you need to hold SDA low for at least 60us
+       * (tWLO).
+       * To achieve this, send 0 to address 0. This will hold SDA low for 8
+       * clock cycles (sending the address), which will work, as long as the I2C
+       * speed is less than 133kHz. */
+      buf[0] = 0;
+
+      err = grub_i2c_write (GRUB_ATECC_ADDR, 0, 0, buf, 1);
+      if (err)
+        {
+	  success = grub_error (GRUB_ERR_IO, N_("IO error"));
+	  continue;
+	}
+
+      /* Delay for tWHI before reading the response */
+      grub_millisleep (ATECC_ATECC_W_HI);
+
+      /* Read response */
+      while (grub_i2c_read (GRUB_ATECC_ADDR, 0, 0, buf, sizeof (buf)) ||
+	     buf[0] == 0xFF)
+	{
+	  if (--retry_resp < 0)
+	    break;
+
+	  grub_dprintf ("atecc", "no valid wake rsp, retry\n");
+	}
+
+      if (retry_resp < 0)
+	{
+	  grub_dprintf ("atecc", "Wakeup failed, no device\n");
+	  success = grub_error (GRUB_ERR_BAD_DEVICE, N_("no device"));
+	  continue;
+	}
+
+      grub_dprintf ("atecc", "chip is awake\n");
+
+      if (grub_atecc_check_rsp_crc16 (buf, sizeof (buf)))
+	{
+	  if (buf[1] == 0x11)
+	    {
+	      grub_dprintf ("atecc", "wakeup rsp OK\n");
+	      success = GRUB_ERR_NONE;
+	      is_awake = 1;
+	    }
+	  else
+	    {
+	      grub_dprintf ("atecc", "wakeup rsp incorrect\n");
+	      success = grub_error (GRUB_ERR_IO, N_("wakeup rsp incorrect"));
+	    }
+	}
+      else
+	{
+	  grub_dprintf ("atecc", "wakeup CRC failure\n");
+	  success = grub_error (GRUB_ERR_IO, N_("wakeup CRC failure"));
+	}
+    }
+
+  return success;
+}
+
+static grub_err_t
+grub_atecc_i2c_idle (void)
+{
+  grub_uint8_t buf[1] = {0x02};
+
+  grub_dprintf ("atecc", "send idle\n");
+
+  return grub_i2c_write (GRUB_ATECC_ADDR, 0, 0, buf, 1);
+}
+
+static grub_err_t
+grub_atecc_i2c_transaction (grub_uint8_t *tx_buf, unsigned int tx_len,
+			    struct grub_atecc_buffer *rx_buf)
+{
+  grub_err_t err;
+  grub_uint8_t status_packet[4];
+  int total_sleep = 120;	/* Max exec time is GenKey (115msec) */
+  int packet_len;
+  grub_uint8_t *recv_buf;
+
+  err = grub_atecc_i2c_wakeup ();
+  if (err)
+    return err;
+
+#if 0
+  grub_dprintf ("atecc", "TX buffer\n");
+  grub_atecc_dump_buffer (tx_buf, tx_len);
+#endif
+
+  /* Send cmd */
+  err = grub_i2c_write (GRUB_ATECC_ADDR, 0, 0, tx_buf, tx_len);
+  if (err)
+    return grub_error (GRUB_ERR_IO, N_("tx error"));
+
+  /* Poll for the response - if 1st byte of the response is 0xFF, chip is still
+   * working */
+  while (grub_i2c_read (GRUB_ATECC_ADDR, 0, 0, status_packet,
+			sizeof (status_packet)) ||
+	 status_packet[0] == 0xFF)
+    {
+      total_sleep -= 4;
+      if (total_sleep < 0)
+        return grub_error (GRUB_ERR_TIMEOUT, N_("couldn't read rsp hdr"));
+
+      grub_millisleep (4);
+    }
+
+  packet_len = status_packet[0];
+
+  recv_buf = grub_malloc (packet_len);
+  if (!recv_buf)
+    return GRUB_ERR_OUT_OF_MEMORY;
+
+  grub_memcpy (recv_buf, status_packet, sizeof (status_packet));
+
+  /* The min. response length is 4. Check message length here, and if we
+   * received a full packet, we're done. */
+  if (packet_len > 4)
+    {
+      err = grub_i2c_read (GRUB_ATECC_ADDR, 0, 0, recv_buf + 4, packet_len - 4);
+      if (err)
+	{
+	  grub_free (recv_buf);
+	  return grub_error (GRUB_ERR_IO, N_("couldn't read rsp"));
+	}
+    }
+
+  /* Store the entire packet. Other functions must check the CRC and strip off
+   * the length byte */
+  rx_buf->ptr = recv_buf;
+  rx_buf->len = packet_len;
+
+  grub_dprintf ("atecc", "Got data from device\n");
+  grub_atecc_dump_buffer (recv_buf, packet_len);
+
+  grub_atecc_i2c_idle ();
+
+  return GRUB_ERR_NONE;
+}
+
+GRUB_MOD_INIT(atecc)
+{
+}
+
+GRUB_MOD_FINI(atecc)
+{
+}
diff --git a/grub-core/bus/i2c/i2c.c b/grub-core/bus/i2c/i2c.c
new file mode 100644
index 0000000..e8abdd3
--- /dev/null
+++ b/grub-core/bus/i2c/i2c.c
@@ -0,0 +1,246 @@
+/* i2c.c - I2C bus.  */
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2013  Free Software Foundation, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/dl.h>
+#include <grub/env.h>
+#include <grub/mm.h>
+#include <grub/i2c.h>
+
+GRUB_MOD_LICENSE ("GPLv3+");
+
+
+static struct grub_i2c_adapter *grub_i2c_adapter_current;
+
+static struct grub_i2c_adapter *grub_i2c_adapters;
+
+struct grub_i2c_adapter *
+grub_i2c_get_adapter (int index)
+{
+  struct grub_i2c_adapter *adap;
+
+  for (adap = grub_i2c_adapters; index > 0 && adap != NULL; index--)
+    adap = adap->next;
+
+  if (!adap)
+    grub_dprintf ("i2c", "adapter not found");
+
+  return adap;
+}
+
+struct grub_i2c_adapter *
+grub_i2c_get_adapter_by_name (const char *name)
+{
+  struct grub_i2c_adapter *adap = grub_i2c_adapters;
+
+  while (adap)
+    {
+      if (grub_strcmp (adap->name, name) == 0)
+	return adap;
+
+      adap = adap->next;
+    }
+
+  grub_dprintf ("i2c", "adapter not found");
+
+  return NULL;
+}
+
+const char *
+grub_i2c_get_adapter_name (int index)
+{
+  struct grub_i2c_adapter *adap;
+
+  adap = grub_i2c_get_adapter (index);
+
+  if (!adap)
+    return NULL;
+
+  return adap->name;
+}
+
+grub_err_t
+grub_i2c_set_adapter (int index)
+{
+  struct grub_i2c_adapter *adap;
+
+  adap = grub_i2c_get_adapter (index);
+  if (!adap)
+    {
+      grub_dprintf ("i2c", "adapter not found");
+
+      return grub_error (GRUB_ERR_UNKNOWN_DEVICE, N_("adapter not found"));
+    }
+
+  grub_i2c_adapter_current = adap;
+
+  return GRUB_ERR_NONE;
+}
+
+grub_err_t
+grub_i2c_set_adapter_by_name (const char *name)
+{
+  struct grub_i2c_adapter *adap;
+
+  adap = grub_i2c_get_adapter_by_name (name);
+  if (!adap)
+    {
+      grub_dprintf ("i2c", "adapter not found");
+
+      return grub_error (GRUB_ERR_UNKNOWN_DEVICE, N_("adapter not found"));
+    }
+
+  grub_i2c_adapter_current = adap;
+
+  return GRUB_ERR_NONE;
+}
+
+grub_err_t
+grub_i2c_read (grub_uint8_t dev, grub_uint32_t addr, int alen,
+	       grub_uint8_t *buffer, int len)
+{
+  struct grub_i2c_adapter *adap = grub_i2c_adapter_current;
+
+  if (!adap)
+    return grub_error (GRUB_ERR_UNKNOWN_DEVICE, N_("adapter not found"));
+
+  return adap->driver->read (adap, dev, addr, alen, buffer, len);
+}
+
+grub_err_t
+grub_i2c_write (grub_uint8_t dev, grub_uint32_t addr, int alen,
+		grub_uint8_t *buffer, int len)
+{
+  struct grub_i2c_adapter *adap = grub_i2c_adapter_current;
+
+  if (!adap)
+    return grub_error (GRUB_ERR_BAD_DEVICE, N_("adapter not found"));
+
+  return adap->driver->write (adap, dev, addr, alen, buffer, len);
+}
+
+void
+grub_i2c_adapter_register (struct grub_i2c_adapter *adap)
+{
+  int found;
+  unsigned int index;
+
+  if (!adap)
+    return;
+
+  /* Go through on adapter list, and search for adapter index */
+  index = 0;
+  do
+    {
+      struct grub_i2c_adapter *a = grub_i2c_adapters;
+
+      found = 1;
+
+      while (a)
+	{
+	  const char *name = adap->driver->name;
+	  unsigned int len = grub_strlen (name);
+
+	  if (grub_strncmp (a->name, name, len) == 0)
+	    {
+	      if (grub_strtoul (&a->name[len], 0, 10) == index)
+		{
+		  /* Index already exists */
+		  ++index;
+		  found = 0;
+		  break;
+		}
+	    }
+	  a = a->next;
+	}
+    } while (!found);
+
+  adap->name = grub_xasprintf ("%s%d", adap->driver->name, index);
+
+  grub_dprintf ("i2c", "registering i2c adapter %s\n", adap->name);
+
+  grub_list_push (GRUB_AS_LIST_P (&grub_i2c_adapters), GRUB_AS_LIST (adap));
+
+  /* If this is the first adapter we found, make it as currently used one */
+  if (grub_i2c_adapter_current == NULL)
+    grub_i2c_adapter_current = adap;
+}
+
+void
+grub_i2c_adapter_unregister (struct grub_i2c_adapter *adap)
+{
+  struct grub_i2c_driver *driver = adap->driver;
+
+  if (!adap)
+    return;
+
+  grub_dprintf ("i2c", "unregistering i2c adapter %s\n", adap->name);
+
+  grub_free (adap->name);
+
+  driver->fini (adap);
+
+  grub_list_remove (GRUB_AS_LIST (adap));
+
+  /* If the current adapter is the removed one, set current to null */
+  if (grub_i2c_adapter_current == adap)
+    grub_i2c_adapter_current = NULL;
+}
+
+void
+grub_i2c_driver_unregister (struct grub_i2c_driver *driver)
+{
+  struct grub_i2c_adapter *adap = grub_i2c_adapters;
+
+  if (!driver)
+    return;
+
+  grub_dprintf ("i2c", "unregistering i2c driver %s\n", driver->name);
+
+  /* Go through on adapters, and deregister the ones, using this driver */
+  while (adap)
+    {
+      struct grub_i2c_adapter *next = adap->next;
+
+      if (adap->driver == driver)
+	grub_i2c_adapter_unregister (adap);
+
+      adap = next;
+    }
+}
+
+GRUB_MOD_INIT(i2c)
+{
+  grub_i2c_adapters = NULL;
+  grub_i2c_adapter_current = NULL;
+}
+
+GRUB_MOD_FINI(i2c)
+{
+  struct grub_i2c_adapter *adap = grub_i2c_adapters;
+
+  /* Deregister all adapters */
+  while (adap)
+    {
+      struct grub_i2c_adapter *next = adap->next;
+
+      grub_i2c_adapter_unregister (adap);
+
+      adap = next;
+    }
+}
diff --git a/grub-core/commands/atecc_cmd.c b/grub-core/commands/atecc_cmd.c
new file mode 100644
index 0000000..6f0430e
--- /dev/null
+++ b/grub-core/commands/atecc_cmd.c
@@ -0,0 +1,242 @@
+/* atecc_cmd.c - ATECC508 commands.  */
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2013  Free Software Foundation, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/dl.h>
+#include <grub/command.h>
+#include <grub/env.h>
+#include <grub/mm.h>
+#include <grub/atecc.h>
+
+GRUB_MOD_LICENSE ("GPLv3+");
+
+static grub_err_t
+grub_hexstr2array (const char *s, grub_uint8_t *buffer);
+
+static grub_err_t
+grub_cmd_atecc (grub_command_t cmd __attribute__ ((unused)),
+		int argc, char **argv)
+{
+  grub_err_t err;
+
+  if (argc < 1)
+    return grub_error (GRUB_ERR_BAD_ARGUMENT,
+		       N_("expect at least a cmd argument"));
+
+  /* Get serial number */
+  if (grub_strcmp (argv[0], "serial") == 0)
+    {
+      unsigned int i;
+
+      grub_atecc_serial_num_t sn;
+
+      err = grub_atecc_get_serialnum (sn);
+
+      if (!err)
+	{
+	  grub_printf ("Serial number: ");
+	  for (i = 0; i < sizeof (grub_atecc_serial_num_t); i++)
+	    grub_printf ("%02x", sn[i]);
+	  grub_printf ("\n");
+	}
+    }
+  /* Get random number */
+  else if (grub_strcmp (argv[0], "random") == 0)
+    {
+      unsigned int i;
+
+      grub_atecc_random_num_t random;
+
+      err = grub_atecc_get_random (random);
+
+      if (!err)
+	{
+	  grub_printf ("Random number: ");
+	  for (i = 0; i < sizeof (grub_atecc_random_num_t); i++)
+	    grub_printf ("%02x", random[i]);
+	  grub_printf ("\n");
+	}
+    }
+  /* HMAC verification */
+  else if (grub_strcmp (argv[0], "checkmac") == 0)
+    {
+      unsigned int slot;
+      char *digestStr = argv[2];
+      char *sigStr = argv[3];
+      grub_atecc_digest_t digest;
+      grub_atecc_signature_t signature;
+
+      if (argc != 4)
+	return grub_error (GRUB_ERR_BAD_ARGUMENT, N_("4 arguments expected"));
+
+      /* Verify digest and signature, they should be a 32-byte (64-chars) long
+       * hex string */
+      if (grub_strlen (digestStr) != 64)
+	return grub_error (GRUB_ERR_BAD_ARGUMENT, N_("invalid digest string"));
+      if (grub_strlen (sigStr) != 64)
+	return grub_error (GRUB_ERR_BAD_ARGUMENT,
+			   N_("invalid signature string"));
+
+      slot = grub_strtoul (argv[1], 0, 0);
+      if (slot >= GRUB_ATECC_SLOT_NUM)
+	return grub_error (GRUB_ERR_BAD_ARGUMENT, N_("invalid key slot index"));
+
+      /* Convert hex strings to char arrays */
+      err = grub_hexstr2array (digestStr, digest);
+      if (err)
+	return err;
+      err = grub_hexstr2array (sigStr, signature);
+      if (err)
+	return err;
+
+      err = grub_atecc_checkmac (slot, digest, signature);
+      if (!err)
+	grub_printf ("Signature is OK\n");
+    }
+  /* Nonce */
+  else if (grub_strcmp (argv[0], "nonce") == 0)
+    {
+      char *digestStr = argv[1];
+      grub_atecc_digest_t digest;
+
+      if (argc != 2)
+	return grub_error (GRUB_ERR_BAD_ARGUMENT, N_("2 arguments expected"));
+
+      /* Verify diest string is 32 byte (64-chars) long hex string */
+      if (grub_strlen (digestStr) != 64)
+	return grub_error (GRUB_ERR_BAD_ARGUMENT, N_("invalid digest string"));
+
+      /* Convert hex strings to char arrays */
+      err = grub_hexstr2array (digestStr, digest);
+      if (err)
+	return err;
+
+      err = grub_atecc_nonce (digest);
+      if (!err)
+	grub_printf ("Nonce successful\n");
+    }
+  /* ECDSA verification */
+  else if (grub_strcmp (argv[0], "verify") == 0)
+    {
+      unsigned int slot;
+      char *rStr = argv[2];
+      char *sStr = argv[3];
+      grub_atecc_signature_t rsignature;
+      grub_atecc_signature_t ssignature;
+
+      if (argc != 4)
+	return grub_error (GRUB_ERR_BAD_ARGUMENT, N_("4 arguments expected"));
+
+      /* Verify R and S ECDSA signature pair, they should be a 32-byte
+       * (64-chars) long hex string */
+      if (grub_strlen (rStr) != 64)
+	return grub_error (GRUB_ERR_BAD_ARGUMENT,
+			   N_("invalid r-signature string"));
+      if (grub_strlen (sStr) != 64)
+	return grub_error (GRUB_ERR_BAD_ARGUMENT,
+			   N_("invalid s-signature string"));
+
+      slot = grub_strtoul (argv[1], 0, 0);
+      if (slot >= GRUB_ATECC_SLOT_NUM)
+	return grub_error (GRUB_ERR_BAD_ARGUMENT, N_("invalid key slot index"));
+
+      /* Convert hex strings to char arrays */
+      err = grub_hexstr2array (rStr, rsignature);
+      if (err)
+	return err;
+      err = grub_hexstr2array (sStr, ssignature);
+      if (err)
+	return err;
+
+      err = grub_atecc_verify (slot, rsignature, ssignature);
+      if (!err)
+	grub_printf ("Signature is OK\n");
+    }
+  else
+    return grub_error (GRUB_ERR_BAD_ARGUMENT, N_("invalid argument"));
+
+  return err;
+}
+
+static int
+grub_hex2bin (const char *s)
+{
+  int ret = 0;
+  int i;
+
+  for (i = 0; i < 2; i++ )
+    {
+      char c = *s++;
+
+      ret <<= 4;
+
+      if (c >= '0' && c <= '9')
+	ret |= c - '0';
+      else if (c >= 'a' && c <= 'f')
+	ret |= c - 'a' + 10;
+      else if (c >= 'A' && c <= 'F')
+	ret |= c - 'A' + 10;
+      else
+	return -1;
+    }
+
+  return ret;
+}
+
+static grub_err_t
+grub_hexstr2array (const char *s, grub_uint8_t *buffer)
+{
+  int len;
+
+  len = grub_strlen (s);
+
+  while (len >= 2)
+    {
+      int c;
+
+      c = grub_hex2bin (s);
+      if (c < 0)
+	return grub_error (GRUB_ERR_BAD_ARGUMENT, N_("invalid hex string"));
+
+      *buffer++ = c;
+      s += 2;
+      len -= 2;
+    }
+
+  return GRUB_ERR_NONE;
+}
+
+static grub_command_t cmd;
+
+GRUB_MOD_INIT(atecc_cmd)
+{
+  cmd = grub_register_command ("atecc", grub_cmd_atecc,
+			       N_("CMD [CMD_ARGS]"),
+			       N_("ATECC508 communication\n" \
+				  "CMD:\n" \
+				  "  serial:                         Get serial number\n" \
+				  "  random:                         Get random number\n" \
+				  "  checkmac <slot> <digest> <sig>: HMAC verification\n" \
+				  "  nonce <digest>:                 nonce generation\n" \
+				  "  verify <slot> <r-sig> <s-sig>:  ECDSA verification\n"));
+}
+
+GRUB_MOD_FINI(atecc_cmd)
+{
+  grub_unregister_command (cmd);
+}
diff --git a/grub-core/commands/i2c_cmd.c b/grub-core/commands/i2c_cmd.c
new file mode 100644
index 0000000..4041979
--- /dev/null
+++ b/grub-core/commands/i2c_cmd.c
@@ -0,0 +1,188 @@
+/* i2ccmd.c - I2C commands.  */
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2013  Free Software Foundation, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/pci.h>
+#include <grub/dl.h>
+#include <grub/misc.h>
+#include <grub/extcmd.h>
+#include <grub/env.h>
+#include <grub/mm.h>
+#include <grub/i18n.h>
+#include <grub/time.h>
+#include <grub/i2c.h>
+
+GRUB_MOD_LICENSE ("GPLv3+");
+
+static grub_err_t
+grub_cmd_i2c (grub_command_t cmd, int argc, char **argv)
+{
+  grub_uint32_t dev_addr, reg_addr, reg_len, data_len;
+
+  if (argc < 4)
+    return grub_error (GRUB_ERR_BAD_ARGUMENT, N_("not enough arguments"));
+
+  dev_addr = grub_strtoul (argv[0], 0, 0);
+  reg_addr = grub_strtoul (argv[1], 0, 0);
+  reg_len = grub_strtoul (argv[2], 0, 0);
+  data_len = grub_strtoul (argv[3], 0, 0);
+
+  if (grub_strcmp (&cmd->name[sizeof ("i2c_") - 1], "read") == 0)
+    {
+      grub_uint8_t *buffer;
+      grub_err_t err;
+
+      buffer = grub_malloc (data_len);
+      if (!buffer)
+	return grub_error (GRUB_ERR_OUT_OF_MEMORY, N_("no mem"));
+
+      err = grub_i2c_read (dev_addr, reg_addr, reg_len, buffer, data_len);
+
+      if (err)
+	err = grub_error (GRUB_ERR_READ_ERROR, N_("couldn't read chip"));
+      else
+	{
+	  grub_uint32_t i;
+
+	  for (i = 0; i < data_len; i++)
+	    {
+	      if ((i % 8) == 0)
+		grub_printf ("\n0x%04x: ", i);
+
+	      grub_printf ("0x%02x ",buffer[i]);
+	    }
+	  grub_printf ("\n");
+	}
+
+      grub_free (buffer);
+
+      return err;
+    }
+  else if (grub_strcmp (&cmd->name[sizeof ("i2c_") - 1], "write") == 0)
+    {
+      grub_uint8_t *buffer;
+      grub_err_t err;
+      grub_uint32_t i;
+
+      if (argc != (int)(4 + data_len))
+	return grub_error (GRUB_ERR_BAD_ARGUMENT,
+			   N_("data buffer not match with data length"));
+
+      buffer = grub_malloc (data_len);
+      if (!buffer)
+	return grub_error (GRUB_ERR_OUT_OF_MEMORY, N_("no mem"));
+
+      /* Parse data */
+      for (i = 0; i < data_len; i++)
+	buffer[i] = (grub_uint8_t)grub_strtoul (argv[4 + i], 0, 0);
+
+      grub_printf ("\n");
+      for (i = 0; i < data_len; i++)
+	grub_printf ("0x%x ", buffer[i]);
+      grub_printf ("\n");
+
+      err = grub_i2c_write (dev_addr, reg_addr, reg_len, buffer, data_len);
+
+      if (err)
+	err = grub_error (GRUB_ERR_WRITE_ERROR, N_("couldn't write chip"));
+
+      grub_free (buffer);
+
+      return err;
+    }
+  else
+    return grub_error (GRUB_ERR_BAD_ARGUMENT,
+		       N_("invalid operation, should be 'read' or 'write'"));
+}
+
+static grub_err_t
+grub_cmd_i2c_list (grub_command_t cmd __attribute__((unused)),
+		   int argc __attribute__((unused)),
+		   char **argv __attribute__((unused)))
+{
+  const char *name;
+  int i;
+
+  i = 0;
+  while (1)
+    {
+      name = grub_i2c_get_adapter_name (i);
+
+      if (!name)
+	return GRUB_ERR_NONE;
+
+      grub_printf ("Bus %d: %s\n", i, name);
+
+      i++;
+    }
+}
+
+static grub_err_t
+grub_cmd_i2c_setbus (grub_command_t cmd __attribute__((unused)),
+		     int argc, char **argv)
+{
+  grub_err_t err;
+
+  if (argc != 1)
+    return grub_error (GRUB_ERR_BAD_ARGUMENT, N_("not enough arguments"));
+
+  /* Check if it's a bus index or name */
+  if (argv[0][0] >= '0' && argv[0][0] <= '9')
+    {
+      grub_uint32_t bus;
+
+      bus = grub_strtoul (argv[0], 0, 0);
+
+      err = grub_i2c_set_adapter (bus);
+    }
+  else
+    err = grub_i2c_set_adapter_by_name (argv[0]);
+
+  if (err)
+    return grub_error (GRUB_ERR_BAD_ARGUMENT, N_("bus not found"));
+
+  return GRUB_ERR_NONE;
+}
+
+static grub_command_t cmd_i2c_setbus;
+static grub_command_t cmd_i2c_read;
+static grub_command_t cmd_i2c_write;
+static grub_command_t cmd_i2c_list;
+
+GRUB_MOD_INIT(i2c)
+{
+  cmd_i2c_setbus = grub_register_command ("i2c_setbus", grub_cmd_i2c_setbus,
+					  N_("<BUS_INDEX or BUS_NAME>"),
+					  N_("Set used I2C bus."));
+  cmd_i2c_read = grub_register_command ("i2c_read", grub_cmd_i2c,
+					N_("DEV_ADDR REG_ADDR REG_LEN DATA_LEN"),
+					N_("Read from I2C bus."));
+  cmd_i2c_write = grub_register_command ("i2c_write", grub_cmd_i2c,
+					 N_("DEV_ADDR REG_ADDR REG_LEN DATA_LEN DATA..."),
+					 N_("Write to I2C bus."));
+  cmd_i2c_list = grub_register_command ("i2c_list", grub_cmd_i2c_list,
+					0, N_("List I2C adapters"));
+}
+
+GRUB_MOD_FINI(i2c)
+{
+  grub_unregister_command (cmd_i2c_setbus);
+  grub_unregister_command (cmd_i2c_read);
+  grub_unregister_command (cmd_i2c_write);
+  grub_unregister_command (cmd_i2c_list);
+}
diff --git a/include/grub/atecc.h b/include/grub/atecc.h
new file mode 100644
index 0000000..d622e0f
--- /dev/null
+++ b/include/grub/atecc.h
@@ -0,0 +1,56 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2008  Free Software Foundation, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef GRUB_ATECC_H
+#define GRUB_ATECC_H	1
+
+#define GRUB_ATECC_SERIAL_NUM_LEN	9
+typedef grub_uint8_t grub_atecc_serial_num_t[GRUB_ATECC_SERIAL_NUM_LEN];
+
+grub_err_t
+grub_atecc_get_serialnum(grub_atecc_serial_num_t sn);
+
+
+/* Random number length */
+#define GRUB_ATECC_RANDOM_NUM_LEN	32
+typedef grub_uint8_t grub_atecc_random_num_t[GRUB_ATECC_RANDOM_NUM_LEN];
+
+grub_err_t
+grub_atecc_get_random (grub_atecc_random_num_t random);
+
+
+/* Number of data zone slots */
+#define GRUB_ATECC_SLOT_NUM		16
+/* Digest length */
+#define GRUB_ATECC_DIGEST_LEN		32
+/* Signature length */
+#define GRUB_ATECC_SIGNATURE_LEN	32
+
+typedef grub_uint8_t grub_atecc_digest_t[GRUB_ATECC_DIGEST_LEN];
+typedef grub_uint8_t grub_atecc_signature_t[GRUB_ATECC_SIGNATURE_LEN];
+
+grub_err_t
+grub_atecc_checkmac(grub_uint8_t slot, grub_atecc_digest_t digest,
+		    grub_atecc_signature_t signature);
+grub_err_t
+grub_atecc_nonce(grub_atecc_digest_t digest);
+grub_err_t
+grub_atecc_verify(grub_uint8_t slot, grub_atecc_signature_t r,
+		  grub_atecc_signature_t s);
+
+#endif /* GRUB_ATECC_H */
diff --git a/include/grub/i2c.h b/include/grub/i2c.h
new file mode 100644
index 0000000..f9d1dde
--- /dev/null
+++ b/include/grub/i2c.h
@@ -0,0 +1,98 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2008  Free Software Foundation, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef GRUB_I2C_H
+#define GRUB_I2C_H	1
+
+#include <grub/err.h>
+
+struct grub_i2c_adapter;
+
+/* I2C driver */
+struct grub_i2c_driver
+{
+  /* Driver name */
+  const char *name;
+
+  /* Set bus speed */
+  grub_err_t (*set_bus_speed) (struct grub_i2c_adapter *adap,
+                               grub_uint32_t speed);
+
+  /* Read from bus */
+  grub_err_t (*read) (struct grub_i2c_adapter *adap, grub_uint8_t dev,
+		      grub_uint32_t addr, int alen, grub_uint8_t *buffer,
+		      int len);
+
+  /* Write to bus */
+  grub_err_t (*write) (struct grub_i2c_adapter *adap, grub_uint8_t dev,
+		       grub_uint32_t addr, int alen, grub_uint8_t *buffer,
+		       int len);
+
+  void (*fini) (struct grub_i2c_adapter *adap);
+};
+
+
+/* I2C adapter */
+struct grub_i2c_adapter
+{
+  struct grub_i2c_adapter *next;
+  struct grub_i2c_adapter **prev;
+
+  /* Adapter name */
+  char *name;
+
+  /* Driver */
+  struct grub_i2c_driver *driver;
+
+  /* Adapter-specific data */
+  void *priv;
+};
+
+struct grub_i2c_adapter *
+grub_i2c_get_adapter(int index);
+
+struct grub_i2c_adapter *
+grub_i2c_get_adapter_by_name(const char *name);
+
+const char *
+grub_i2c_get_adapter_name(int index);
+
+grub_err_t
+grub_i2c_set_adapter(int index);
+
+grub_err_t
+grub_i2c_set_adapter_by_name(const char *name);
+
+grub_err_t
+grub_i2c_read(grub_uint8_t dev, grub_uint32_t addr, int alen,
+	      grub_uint8_t *buffer, int len);
+
+grub_err_t
+grub_i2c_write(grub_uint8_t dev, grub_uint32_t addr, int alen,
+	       grub_uint8_t *buffer, int len);
+
+void
+grub_i2c_adapter_register (struct grub_i2c_adapter *adap);
+
+void
+grub_i2c_adapter_unregister (struct grub_i2c_adapter *adap);
+
+void
+grub_i2c_driver_unregister (struct grub_i2c_driver *driver);
+
+#endif /* GRUB_I2C_H */
-- 
2.17.1

