From b31f8ec0c2a5caf9d660db4ea4b51f23f9894245 Mon Sep 17 00:00:00 2001
From: Robert Hodaszi <robert.hodaszi@digi.com>
Date: Tue, 7 Dec 2021 18:26:55 +0100
Subject: [PATCH 07/11] Add ConnectIT LED and dev-mode

---
 grub-core/commands/mcu.c | 495 ++++++++++++++++++++++++++++++++++++---
 1 file changed, 468 insertions(+), 27 deletions(-)

diff --git a/grub-core/commands/mcu.c b/grub-core/commands/mcu.c
index 294ccfd..69d80cc 100644
--- a/grub-core/commands/mcu.c
+++ b/grub-core/commands/mcu.c
@@ -29,6 +29,12 @@
 
 GRUB_MOD_LICENSE ("GPLv3+");
 
+#if 0
+#undef grub_dprintf
+#define grub_dprintf(a, b...) grub_printf(a " " b)
+#define MCU_DEBUG 1
+#endif
+
 /* MCU communication port */
 struct grub_serial_port *grub_mcu_port = NULL;
 
@@ -60,6 +66,15 @@ struct grub_serial_port *grub_mcu_port = NULL;
 #define GRUB_MCU_PKT_ADDR_LED_PWR_CTRL	0x0E
 #define GRUB_MCU_PKT_ADDR_LED_PWR_TIME	0x0F
 
+/* Connect IT DIGI command addresses */
+#define GRUB_MCU_DIGI_FACTORY_DEFAULT  0x01
+#define GRUB_MCU_DIGI_LED_CTRL         0x02
+#define GRUB_MCU_DIGI_LED_FLASH        0x03
+#define GRUB_MCU_DIGI_LED_INTERVAL     0x04
+#define GRUB_MCU_DIGI_COM_CTRL         0x0a
+
+/* ConnectIT addresses - system mode */
+#define GRUB_MCU_PKT_SYSTEM_MODE	0x2a
 
 /* Offsets not counting START and END bytes */
 #define GRUB_MCU_PKT_DEVID_OFFSET	0
@@ -109,7 +124,7 @@ grub_mcu_tx (grub_uint8_t *buffer, unsigned int size)
   /* Calculate CRC8 */
   buffer[size - 1] = grub_mcu_crc8 (buffer, size - 1);
 
-#if 0
+#ifdef MCU_DEBUG
   {
     unsigned int i;
     grub_printf("TX:\n");
@@ -119,6 +134,12 @@ grub_mcu_tx (grub_uint8_t *buffer, unsigned int size)
   }
 #endif
 
+#ifdef DIGI_CONNECTITXX
+  /* HACK: Don't TX too soon after the last RX otherwise the MCU does
+   * not reply. */
+  grub_millisleep(100);
+#endif
+
   /* Escape special characters on sending */
 
   /* Send START delimiter without escaping */
@@ -257,7 +278,7 @@ retry:
 	    break;
 	}
     }
-#if 0
+#ifdef MCU_DEBUG
   {
     unsigned int i;
     grub_printf("RX:\n");
@@ -313,6 +334,7 @@ grub_mcu_txrx (grub_uint8_t *tx_buffer, unsigned int tx_len,
 }
 
 
+#ifndef DIGI_CONNECTITXX
 
 /*******************************************************************************
  *				LEDs
@@ -742,6 +764,7 @@ grub_mcu_set_all_leds (int is_on)
 /*******************************************************************************
  *				Power type
  ******************************************************************************/
+
 enum grub_mcu_pwr_type
 {
   GRUB_MCU_PWR_TYPE_9_36V = 0,	/* 9-36V */
@@ -780,6 +803,395 @@ grub_mcu_get_pwr_type (enum grub_mcu_pwr_type *pwr_type)
   return GRUB_ERR_NONE;
 }
 
+#else /* DIGI_CONNECTITXX */
+
+/*******************************************************************************
+ * Connect IT 16 / 48 ledcmd (ported from user mode code)
+ ******************************************************************************/
+
+#define CMD_QUERY        0x00 /* query the state of the LEDs */
+#define CMD_ON           0x01 /* turn LED on permanently */
+#define CMD_OFF          0x02 /* turn LED off permanently */
+#define CMD_FLASH        0x03 /* flash this LED */
+#define CMD_FLASH_FAST   0x04 /* flash this LED quickly */
+
+#define LED_LEN_MAIN     2
+
+/* Maximum length of LED state sent or received, used to size buffers only.
+ * LED flash is twice this. */
+#define LED_MCU_LEN_MAX  2
+
+#define	SET_BIT(p,n)	((p) |= (1 << (n)))
+#define	CLR_BIT(p,n)	((p) &= (~(1 << (n))))
+#define	BIT_SET(p,n)	((p) & (1 << (n)))
+
+#define FALSE 0
+#define TRUE 1
+
+static int led_state_valid = FALSE;
+static grub_uint8_t led_state[LED_MCU_LEN_MAX];
+static grub_uint8_t led_flash[2*LED_MCU_LEN_MAX];
+static int led_changed = FALSE;
+
+struct led {
+	const char *name;
+	int index;
+	int bit;
+	int altbit; /* altbit gets turned off when bit turns on */
+};
+
+static struct led led_name[] = {
+	{ "POWER_BLUE",      0, 0, 1 },
+	{ "POWER_RED",       0, 1, 0 },
+	{ "STATUS_BLUE",     0, 2, 3 },
+	{ "STATUS_RED",      0, 3, 2 },
+	{ "WWAN_SIG_BLUE",   0, 4, 5 },
+	{ "WWAN_SIG_RED",    0, 5, 4 },
+	{ "WWAN_SERV_BLUE",  0, 6, 7 },
+	{ "WWAN_SERV_RED",   0, 7, 6 },
+	{ "PSU1_BLUE",       1, 0, 1 },
+	{ "PSU1_RED",        1, 1, 0 },
+	{ "PSU2_BLUE",       1, 2, 3 },
+	{ "PSU2_RED",        1, 3, 2 },
+	{ "STATUS_REAR_BLUE",1, 4, 5 },
+	{ "STATUS_REAR_RED", 1, 5, 4 },
+	{ "CONSOLE_DATA",    1, 6, -1 },
+	{ "CONSOLE_BUSY",    1, 7, -1 },
+	{ "ALL",             -1, -1, -1 },
+	{ NULL,              -1, -1, -1 }
+};
+
+static void ledcmd_usage(void)
+{
+  int i;
+
+  grub_printf("usage: ledcmd [-h?] ((-s|-o|-O|-f|-F|-q) <led#|name>) ...\n\n"
+      "\t-h?\thelp    - what you see below\n"
+      "\t-o\ton      - turn LED on\n"
+      "\t-O\toff     - turn LED off\n"
+      "\t-f\tflash   - make LED flash\n"
+      "\t-F\tflash   - make LED flash fast\n"
+      "\t-q\tquery   - print LED state\n"
+      "\n");
+  for (i = 0; led_name[i].name; i++)
+    grub_printf("%s%s", led_name[i].name, i % 6 == 5 ? "\n" : " ");
+  grub_printf("\n");
+}
+
+static void set_state_bit(const struct led *l, int on)
+{
+	if (on) SET_BIT(led_state[l->index], l->bit);
+	else    CLR_BIT(led_state[l->index], l->bit);
+}
+
+static void set_state_altbit(const struct led *l, int on)
+{
+	if (l->altbit == -1)
+		return;
+	if (on) SET_BIT(led_state[l->index], l->altbit);
+	else    CLR_BIT(led_state[l->index], l->altbit);
+}
+
+static int is_state_bit_set(const struct led *l)
+{
+	return BIT_SET(led_state[l->index], l->bit);
+}
+
+static void flash_bits(const struct led *l, int speed, int *index, int *bit)
+{
+	/* The flash buffer is twice the size of the state buffer as each LED
+	 * has two bits: flash enable and flash speed (slow/fast).
+	 * The order of LEDs is also different to the state buffer: it is
+	 * BLUE/YELLOW LEDs followed by RED/GREEN LEDs rather than alternating
+	 * BLUE/RED or YELLOW/GREEN. */
+	if (l->bit % 2 == 0) {
+		/* BLUE or YELLOW */
+		*index = l->index;
+		*bit = l->bit + (speed ? 0 : 1);
+	} else {
+		/* RED or GREEN */
+		*index = l->index + LED_LEN_MAIN;
+		*bit = l->bit - (speed ? 1 : 0);
+	}
+}
+
+static void set_flash_bit(const struct led *l, int on)
+{
+	int index;
+	int bit;
+	flash_bits(l, FALSE, &index, &bit);
+	if (on) SET_BIT(led_flash[index], bit);
+	else    CLR_BIT(led_flash[index], bit);
+}
+
+static int is_flash_bit_set(const struct led *l)
+{
+	int index;
+	int bit;
+	flash_bits(l, FALSE, &index, &bit);
+	return BIT_SET(led_flash[index], bit);
+}
+
+static void set_fastflash_bit(const struct led *l, int on)
+{
+	int index;
+	int bit;
+	flash_bits(l, TRUE, &index, &bit);
+	if (on) SET_BIT(led_flash[index], bit);
+	else    CLR_BIT(led_flash[index], bit);
+}
+
+static int is_fastflash_bit_set(const struct led *l)
+{
+	int index;
+	int bit;
+	flash_bits(l, TRUE, &index, &bit);
+	return BIT_SET(led_flash[index], bit);
+}
+
+/*****************************************************************************/
+
+static void ledcmd_update(void)
+{
+  grub_uint8_t ctrl[] =
+    {
+      GRUB_MCU_PKT_DEVID_DIGI,
+      GRUB_MCU_PKT_CMD_SET,
+      GRUB_MCU_DIGI_LED_CTRL,
+      led_state[0],
+      led_state[1],
+      0			/* CRC */
+    };
+  grub_uint8_t flash[] =
+    {
+      GRUB_MCU_PKT_DEVID_DIGI,
+      GRUB_MCU_PKT_CMD_SET,
+      GRUB_MCU_DIGI_LED_FLASH,
+      led_flash[0],
+      led_flash[1],
+      led_flash[2],
+      led_flash[3],
+      0			/* CRC */
+    };
+  grub_uint8_t resp[5];
+
+  if (!led_changed)
+    return;
+
+  /* Send to MCU */
+  if (grub_mcu_txrx (ctrl, sizeof (ctrl), resp, sizeof (resp))) {
+    grub_printf("couldn't set LED\n");
+    return;
+  }
+
+  /* Send to MCU */
+  if (grub_mcu_txrx (flash, sizeof (flash), resp, sizeof (resp))) {
+    grub_printf("couldn't set LED flash\n");
+    return;
+  }
+
+  return;
+}
+
+static grub_err_t
+ledcmd_fetch_status(struct led *l __attribute__ ((unused)))
+{
+  grub_uint8_t ctrl[] =
+    {
+      GRUB_MCU_PKT_DEVID_DIGI,
+      GRUB_MCU_PKT_CMD_GET,
+      GRUB_MCU_DIGI_LED_CTRL,
+      0			/* CRC */
+    };
+  grub_uint8_t flash[] =
+    {
+      GRUB_MCU_PKT_DEVID_DIGI,
+      GRUB_MCU_PKT_CMD_GET,
+      GRUB_MCU_DIGI_LED_FLASH,
+      0			/* CRC */
+    };
+  grub_uint8_t rctrl[6];
+  grub_uint8_t rflash[8];
+
+  /* Get current state of the LED buffer so we can update it */
+  if (led_state_valid)
+    return GRUB_ERR_NONE;
+
+  /* Send to MCU */
+  if (grub_mcu_txrx (ctrl, sizeof (ctrl), rctrl, sizeof (rctrl)))
+    return grub_error (GRUB_ERR_IO, "couldn't get LED");
+
+  grub_memcpy(led_state, &rctrl[GRUB_MCU_PKT_DATA_OFFSET], 2);
+
+  /* Send to MCU */
+  if (grub_mcu_txrx (flash, sizeof (flash), rflash, sizeof (rflash)))
+    return grub_error (GRUB_ERR_IO, "couldn't get LED flash");
+
+  grub_memcpy(led_flash, &rflash[GRUB_MCU_PKT_DATA_OFFSET], 4);
+
+  led_state_valid = TRUE;
+  return GRUB_ERR_NONE;
+}
+
+static void ledcmd_set(int cmd, struct led *l)
+{
+	if (ledcmd_fetch_status(l) != GRUB_ERR_NONE)
+		return;
+
+	if (cmd == CMD_ON) {
+		set_state_bit(l, TRUE);
+		set_state_altbit(l, FALSE);
+		set_flash_bit(l, FALSE);
+		set_fastflash_bit(l, FALSE);
+		led_changed = TRUE; /* TODO: this can be smarter */
+
+	} else if (cmd == CMD_OFF) {
+		set_state_bit(l, FALSE);
+		set_state_altbit(l, FALSE);
+		led_changed = TRUE; /* TODO: this can be smarter */
+
+	} else if (cmd == CMD_FLASH) {
+		set_state_bit(l, TRUE);
+		set_state_altbit(l, FALSE);
+		set_flash_bit(l, TRUE);
+		set_fastflash_bit(l, FALSE);
+		led_changed = TRUE; /* TODO: this can be smarter */
+
+	} else if (cmd == CMD_FLASH_FAST) {
+		set_state_bit(l, TRUE);
+		set_state_altbit(l, FALSE);
+		set_flash_bit(l, TRUE);
+		set_fastflash_bit(l, TRUE);
+		led_changed = TRUE; /* TODO: this can be smarter */
+
+	} else if (cmd == CMD_QUERY) {
+		grub_printf("%s ", l->name);
+		if (!is_state_bit_set(l)) {
+			grub_printf("off");
+		} else if (is_flash_bit_set(l)) {
+			if (is_fastflash_bit_set(l))
+				grub_printf("fast-flash");
+			else
+				grub_printf("flash");
+		} else {
+			grub_printf("on");
+		}
+		grub_printf("\n");
+	}
+}
+
+static void set_led(int cmd, char *led)
+{
+	int i, _led = -1;
+
+	for (i = 0; led_name[i].name; i++)
+		if (grub_strcasecmp(led, led_name[i].name) == 0) {
+			_led = i;
+			break;
+		}
+
+	if (_led == -1) {
+		grub_printf("Invalid LED %s", led);
+		ledcmd_usage();
+		return;
+	}
+
+	if (grub_strcmp(led_name[_led].name, "ALL") == 0) {
+		/* Must set individually rather than filling buffer to
+		 * ensure RED/BLUE combo LEDs are not both on at the same
+		 * time (otherwise the set fails) */
+		for (i = 0; led_name[i].name; i++) {
+			if (i == _led)
+				continue;
+
+			/* Don't touch the PSU1_RED/PSU1_BLUE/PSU2_RED/PSU2_BLUE LEDs
+			 * because the MCU has logic to control these. */
+			if (cmd != CMD_QUERY
+					&& grub_strncmp(led_name[i].name, "PSU", sizeof("PSU") - 1) == 0)
+				continue;
+
+			ledcmd_set(cmd, &led_name[i]);
+		}
+		return;
+	}
+
+	ledcmd_set(cmd, &led_name[_led]);
+}
+
+static grub_err_t
+grub_mcu_ledcmd (int argc, char **argv)
+{
+  int n;
+
+  led_changed = FALSE;
+
+  for (n = 0; n < argc - 1; n += 2) {
+    /* check for '-* arg' */
+    if (*argv[n] != '-' || argc - n < 2)
+      break;
+    switch (*(argv[n]+1)) {
+    case 'o': set_led(CMD_ON,         argv[n+1]); break;
+    case 'O': set_led(CMD_OFF,        argv[n+1]); break;
+    case 'f': set_led(CMD_FLASH,      argv[n+1]); break;
+    case 'F': set_led(CMD_FLASH_FAST, argv[n+1]); break;
+    case 'q': set_led(CMD_QUERY,      argv[n+1]); break;
+    case '?':
+    case 'h':
+    default:
+      break;
+    }
+  }
+
+  if (n == 0 || n < argc) {
+    ledcmd_usage();
+    return grub_error (GRUB_ERR_BAD_ARGUMENT, "Incorrect arguments");
+  }
+
+  ledcmd_update();
+
+  return GRUB_ERR_NONE;
+}
+
+/*******************************************************************************
+ *				System Mode
+ ******************************************************************************/
+
+enum grub_mcu_system_mode
+{
+  GRUB_MCU_SYSTEM_MODE_USER = 0,	/* Production mode (user) */
+  GRUB_MCU_SYSTEM_MODE_ENGINEERING = 1,	/* Dev mode (engineering) */
+};
+
+/*
+ * Get system mode
+ */
+static grub_err_t
+grub_mcu_system_mode (enum grub_mcu_system_mode *system_mode)
+{
+  grub_uint8_t cmd[] =
+    {
+      GRUB_MCU_PKT_DEVID_SYSTEM,
+      GRUB_MCU_PKT_CMD_GET,
+      GRUB_MCU_PKT_SYSTEM_MODE,
+      0			/* CRC */
+    };
+  grub_uint8_t resp[5];
+
+  /* Send to MCU */
+  if (grub_mcu_txrx (cmd, sizeof (cmd), &resp[0], sizeof (resp)))
+    return grub_errno;
+
+  /* Check answer */
+  if (resp[GRUB_MCU_PKT_DATA_OFFSET] != GRUB_MCU_SYSTEM_MODE_USER &&
+  	resp[GRUB_MCU_PKT_DATA_OFFSET] != GRUB_MCU_SYSTEM_MODE_ENGINEERING)
+    return grub_error (GRUB_ERR_IO, "couldn't get system mode");
+
+  *system_mode = resp[GRUB_MCU_PKT_DATA_OFFSET];
+
+  return GRUB_ERR_NONE;
+}
+
+#endif /* DIGI_CONNECTITXX */
 /*******************************************************************************
  *				Watchdog
  ******************************************************************************/
@@ -883,6 +1295,8 @@ grub_mcu_init (int argc, char **argv)
   return GRUB_ERR_NONE;
 }
 
+#ifndef DIGI_CONNECTITXX
+
 static grub_err_t
 grub_mcu_list_led_names (int argc __attribute__ ((unused)),
 			 char **argv __attribute__ ((unused)))
@@ -966,16 +1380,30 @@ grub_mcu_led_set_all (int argc, char **argv)
 
   return grub_mcu_set_all_leds (state);
 }
+#endif /* DIGI_CONNECTITXX */
 
 static grub_err_t
 grub_mcu_is_dev_mode (int argc, char **argv)
 {
   grub_err_t err;
-  enum grub_mcu_pwr_type pwr_type = 0xFF;
   unsigned int is_dev_mode;
+#ifdef DIGI_CONNECTITXX
+  enum grub_mcu_system_mode system_mode = 0xFF;
+#else
+  enum grub_mcu_pwr_type pwr_type = 0xFF;
+#endif
 
   VERIFY_MCU_PORT();
 
+#ifdef DIGI_CONNECTITXX
+  err = grub_mcu_system_mode (&system_mode);
+  if (err)
+    return err;
+
+  grub_dprintf ("mcu", "system mode = %d\n", system_mode);
+
+  is_dev_mode = (system_mode == GRUB_MCU_SYSTEM_MODE_ENGINEERING) ? 1 : 0;
+#else
   err = grub_mcu_get_pwr_type (&pwr_type);
   if (err)
     return err;
@@ -983,6 +1411,7 @@ grub_mcu_is_dev_mode (int argc, char **argv)
   grub_dprintf ("mcu", "power type = %d\n", pwr_type);
 
   is_dev_mode = (pwr_type == GRUB_MCU_PWR_TYPE_9_36V_DEV) ? 1 : 0;
+#endif
 
   if (argc > 0)
     {
@@ -1033,9 +1462,13 @@ typedef struct
 static const grub_mcu_cmd_t grub_mcu_cmds[] =
 {
   { "init",		grub_mcu_init },
+#ifndef DIGI_CONNECTITXX
   { "led_names",	grub_mcu_list_led_names },
   { "set_led",		grub_mcu_led_set },
   { "set_all_leds",	grub_mcu_led_set_all },
+#else
+  { "ledcmd",		grub_mcu_ledcmd },
+#endif
   { "is_dev_mode",	grub_mcu_is_dev_mode },
   { "set_wdog",		grub_mcu_set_wdog },
   { NULL, NULL },
@@ -1065,30 +1498,38 @@ GRUB_MOD_INIT(mcu)
 {
   cmd_mcu = grub_register_command ("mcu", grub_cmd_mcu,
 				   N_("CMD [ARGS]"),
-				   N_("Commands:\n" \
-				      "  init SERIAL_PORT:               initialize MCU communication on SERIAL_PORT\n" \
-				      "\n" \
-			              "  led_names:                      list LED names\n" \
-			              "\n" \
-				      "  set_led LED COLOR BLINK_TIME:   set LED\n" \
-				      "    LED:                          see command 'led_names'\n" \
-				      "    COLOR:\n" \
-				      "      off:                        OFF\n" \
-				      "      green:                      green\n" \
-				      "      yellow:                     yellow\n" \
-				      "    BLINK_TIME:\n" \
-				      "      0:                          solid\n" \
-				      "      1-10:                       100msec - 1sec\n" \
-				      "\n" \
-				      "  set_all_leds STATE:             set all LEDs on or off\n" \
-				      "    STATE:\n" \
-				      "      off:                        OFF\n" \
-				      "      on:                         ON\n" \
-				      "\n" \
-				      "  is_dev_mode [ENVVAR]:           check if development mode is enabled\n" \
-				      "    ENVVAR:                       [OPTIONAL] store result in this env var\n" \
-				      "\n" \
-				      "  set_wdog [TIMEOUT]:             set watchdog\n" \
+				   N_("Commands:\n"
+				      "  init SERIAL_PORT:               initialize MCU communication on SERIAL_PORT\n"
+				      "\n"
+#ifndef DIGI_CONNECTITXX
+			              "  led_names:                      list LED names\n"
+			              "\n"
+				      "  set_led LED COLOR BLINK_TIME:   set LED\n"
+				      "    LED:                          see command 'led_names'\n"
+				      "    COLOR:\n"
+				      "      off:                        OFF\n"
+				      "      green:                      green\n"
+				      "      yellow:                     yellow\n"
+				      "    BLINK_TIME:\n"
+				      "      0:                          solid\n"
+				      "      1-10:                       100msec - 1sec\n"
+				      "\n"
+				      "  set_all_leds STATE:             set all LEDs on or off\n"
+				      "    STATE:\n"
+				      "      off:                        OFF\n"
+				      "      on:                         ON\n"
+				      "\n"
+#else
+				      "  ledcmd [args]:                  control leds,  run with not args for help\n"
+				      "\n"
+#endif
+				      "  is_dev_mode [ENVVAR]:           check if development mode is enabled\n"
+				      "    ENVVAR:                       [OPTIONAL] store result in this env var\n"
+				      "\n"
+				      "  is_user_mode [ENVVAR]:          check if user mode is enabled\n"
+				      "    ENVVAR:                       [OPTIONAL] store result in this env var\n"
+				      "\n"
+				      "  set_wdog [TIMEOUT]:             set watchdog\n"
 				      "    TIMEOUT:                      watchdog timeout in seconds (3-255), or 0 to disable\n"));
 }
 
-- 
2.27.0

