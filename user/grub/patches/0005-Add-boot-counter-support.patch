From 2c3f332257dc91fdf03e7fea927b0117f8cc0100 Mon Sep 17 00:00:00 2001
From: Robert Hodaszi <robert.hodaszi@digi.com>
Date: Tue, 7 Dec 2021 18:25:48 +0100
Subject: [PATCH 05/11] Add boot counter support

It using using the CMOS alarm seconds and minutes bytes

Signed-off-by: Robert Hodaszi <robert.hodaszi@digi.com>
---
 grub-core/Makefile.core.def   |   5 +
 grub-core/commands/bootcntr.c | 214 ++++++++++++++++++++++++++++++++++
 2 files changed, 219 insertions(+)
 create mode 100644 grub-core/commands/bootcntr.c

diff --git a/grub-core/Makefile.core.def b/grub-core/Makefile.core.def
index b85a3e3..cd20a2d 100644
--- a/grub-core/Makefile.core.def
+++ b/grub-core/Makefile.core.def
@@ -2570,3 +2570,8 @@ module = {
   name = mcu;
   common = commands/mcu.c;
 };
+
+module = {
+  name = bootcntr;
+  common = commands/bootcntr.c;
+};
diff --git a/grub-core/commands/bootcntr.c b/grub-core/commands/bootcntr.c
new file mode 100644
index 0000000..e667612
--- /dev/null
+++ b/grub-core/commands/bootcntr.c
@@ -0,0 +1,214 @@
+/* bootcntr.c - command to list files and devices */
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2003,2005,2007,2008,2009  Free Software Foundation, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/types.h>
+#include <grub/err.h>
+#include <grub/dl.h>
+#include <grub/env.h>
+#include <grub/command.h>
+#include <grub/cpu/io.h>
+
+GRUB_MOD_LICENSE ("GPLv3+");
+
+/* Boot counter's NVRAM bank and address */
+#define BOOTCNTR_BANK		0x00
+#define BOOTCNTR_ADDR		0x01
+#define BOOTCNTR_CHECK_ADDR	0x03
+
+#define RTC_PORT(x)	(0x70 + (x))
+
+#define BIN2BCD(v)	(((v) % 10) | ((((v) / 10) % 10) << 4))
+#define BCD2BIN(v)	(((v) & 0xf) + (((v) >> 4) * 10))
+
+/*
+ * Chip has two 128-byte banks.
+ */
+
+/*
+ * Read RTC NVRAM at address
+ *
+ * Input:
+ *   bank:	0 (standard bank) or 1 (extended bank)
+ *   addr:	address in bank
+ */
+static grub_uint8_t
+rtc_cmos_read (grub_uint8_t bank, grub_uint8_t addr)
+{
+  grub_uint8_t value;
+
+  grub_outb (addr, RTC_PORT (0 + (2 * bank)));
+  value = grub_inb (RTC_PORT (1 + (2 * bank)));
+
+  return value;
+}
+
+/*
+ * Write RTC NVRAM at address
+ *
+ * Input:
+ *   bank:	0 (standard bank) or 1 (extended bank)
+ *   addr:	address in bank
+ */
+static void
+rtc_cmos_write (grub_uint8_t value, grub_uint8_t bank, grub_uint8_t addr)
+{
+	grub_outb (addr, RTC_PORT (0 + (2 * bank)));
+	grub_outb (value, RTC_PORT (1 + (2 * bank)));
+}
+
+static grub_err_t
+grub_bootcntr_get (grub_uint8_t *val)
+{
+  grub_uint8_t value;
+  grub_uint8_t value_check;
+
+  value = rtc_cmos_read (BOOTCNTR_BANK, BOOTCNTR_ADDR);
+  value_check = rtc_cmos_read (BOOTCNTR_BANK, BOOTCNTR_CHECK_ADDR);
+
+  value = BCD2BIN(value);
+  value_check = BCD2BIN(value_check);
+
+  /* Verify if value is correct */
+  if (value_check != (59 - value))
+    return grub_error (GRUB_ERR_READ_ERROR, N_("boot counter value is invalid"));
+
+  *val = value;
+
+  return GRUB_ERR_NONE;
+}
+
+static grub_err_t
+grub_cmd_bootcntr_get (struct grub_command *cmd __attribute__ ((unused)),
+		       int argc, char *argv[])
+{
+  grub_err_t err;
+  grub_uint8_t value;
+
+  err = grub_bootcntr_get (&value);
+  if (err)
+    return err;
+
+  if (argc > 0)
+    {
+      char buf[sizeof ("XXX")];
+      grub_snprintf (buf, sizeof (buf), "%u", value);
+      grub_env_set (argv[0], buf);
+    }
+  else
+    grub_printf ("%u\n", value);
+
+  return GRUB_ERR_NONE;
+}
+
+static grub_err_t
+grub_bootcntr_set (grub_uint8_t val)
+{
+  grub_uint8_t value_check;
+
+  value_check = 59 - val;
+
+  rtc_cmos_write (BIN2BCD(val), BOOTCNTR_BANK, BOOTCNTR_ADDR);
+  rtc_cmos_write (BIN2BCD(value_check), BOOTCNTR_BANK, BOOTCNTR_CHECK_ADDR);
+
+  return GRUB_ERR_NONE;
+}
+
+static grub_err_t
+grub_cmd_bootcntr_set (struct grub_command *cmd __attribute__ ((unused)),
+		       int argc, char *argv[])
+{
+  grub_uint32_t value;
+
+  if (argc != 1)
+    return grub_error (GRUB_ERR_BAD_ARGUMENT, N_("value required"));
+
+  value = grub_strtoul (argv[0], 0, 0);
+  if (value > 0xFF)
+    return grub_error (GRUB_ERR_BAD_ARGUMENT, N_("value should be [0 - 255]"));
+
+  return grub_bootcntr_set (value);
+}
+
+static grub_err_t
+grub_cmd_bootcntr_inc (struct grub_command *cmd __attribute__ ((unused)),
+		       int argc, char *argv[])
+{
+  grub_uint8_t value;
+  grub_err_t err;
+
+  err = grub_bootcntr_get (&value);
+  if (err)
+    return err;
+
+  value++;
+
+  return grub_bootcntr_set (value);
+}
+
+static grub_err_t
+grub_cmd_bootcntr_dec (struct grub_command *cmd __attribute__ ((unused)),
+		       int argc, char *argv[])
+{
+  grub_uint8_t value;
+  grub_err_t err;
+
+  err = grub_bootcntr_get (&value);
+  if (err)
+    return err;
+
+  value--;
+
+  return grub_bootcntr_set (value);
+}
+
+static grub_command_t cmd_bootcntr_get;
+static grub_command_t cmd_bootcntr_set;
+static grub_command_t cmd_bootcntr_inc;
+static grub_command_t cmd_bootcntr_dec;
+
+GRUB_MOD_INIT(bootcntr)
+{
+  cmd_bootcntr_get = grub_register_command ("bootcntr_get",
+					    grub_cmd_bootcntr_get,
+					    N_("[ENVVAR]"),
+					    N_("Get current value of the boot counter."));
+
+  cmd_bootcntr_set = grub_register_command ("bootcntr_set",
+					    grub_cmd_bootcntr_set,
+					    N_("VALUE"),
+					    N_("Set current value of the boot counter."));
+
+  cmd_bootcntr_inc = grub_register_command ("bootcntr_inc",
+					    grub_cmd_bootcntr_inc,
+					    N_(""),
+					    N_("Increment the boot counter."));
+
+  cmd_bootcntr_dec = grub_register_command ("bootcntr_dec",
+					    grub_cmd_bootcntr_dec,
+					    N_(""),
+					    N_("Decrement the boot counter."));
+}
+
+GRUB_MOD_FINI(bootcntr)
+{
+  grub_unregister_command (cmd_bootcntr_get);
+  grub_unregister_command (cmd_bootcntr_set);
+  grub_unregister_command (cmd_bootcntr_inc);
+  grub_unregister_command (cmd_bootcntr_dec);
+}
-- 
2.27.0

