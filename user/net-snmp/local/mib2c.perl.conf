## ########################################################################
##
## Config for generating modules for use in the embedded perl environmentg
##
## Copyright Tripleplay Services Limited 2005
## All rights reserved.
##
## Use is subject to license terms specified in the COPYING file
## distributed with the Net-SNMP package.
##
## ########################################################################
##
## Gotchas.
## Any $ signs in the output will be snaffled and disappear. For this reason
## lines that need to output perl variables use a printf line instead
##
## Comments that are for the use of documenting this config file
## need to be double hashes
##
## Operation
## 1. Creates a file called output.tmp which contains the main data structures
## and a call to the agent startup function.
## 2. Creates a file called skel.tmp with skeleton accessor functions. 
## This should be copied to functions.pl and edited to actually
## do the work required for each leaf.
## 3. Creates an output file with the OID name. This contains the bolierplate
## and the data structures
## This is the file to reference in the snmpd.conf file
## 
## The user must fill in the functions.pl code as requried. This file is then
## included at run time at the top of the generated perl code 
## (do 'functions.pl)
## 
## The generated file needs the NetSNMP::agent::Support.pm module in the
## system. This module contains the run-time support for the agent.
##
## The oidtable is a hash of hashes with the top level key an OID
## There are two types of entry
## 1. Scalars have the full OID plus the .0 index string
## 2. Columnar data has the index fields set to 0. The NetSNMP::agent::Support
##    code will use zeros to locate the table specific handlers.
##
## #########################################################################


## #########################################################################
## Define the 'macros' used later in this config file
## #########################################################################
@define EMIT_INDEX_VARS@
  ##
  ## Calculate the number of index identifiers and then
  ## for each identifier work out the offset in the oid
  ##
  @eval $numindex=0@
  @eval $idxoffset = $c.oidlength@
  # The values of the oid elements for the indexes
  @foreach $i index@
##  my $$idx_$i = getOidElement($$idx, $idxoffset);
  @printf "  my %sidx_$vars{'i'} = getOidElement(%soid, $vars{'idxoffset'});\n",$,$@
     @eval $idxoffset = $idxoffset + 1@
  @end@
@enddefine@

@define EMIT_GETARGS@
  ##
  ## Output the code the get the args for a function
  ##
  # The OID is passed as a NetSNMP::OID object
  @printf "  my (%soid) = shift;\n",$@
@enddefine@

@define EMIT_LOAD_DATA@
  ## 
  ## Emit the code to load a data table
  ##
  # Load the $t table data
  load_$t();
@enddefine@

@define EMIT_INDEX_INFO@
##
## Emit a list of indexes for a table as perl comments
## To be used when generating the comment fields for a handler
##
# In Table: $t
@foreach $i index@
# Index: $i
@end@
@enddefine@

@define EMIT_INDEX_WALKER@
##
## Output a skeleton index walker and index checker
## for the table if it has not been done already
##
@if $needwalker@
## Output skeleton index validator for table
# -------------------------------------------------------
# Index validation for table $t
# Checks the supplied OID is in range
# Returns 1 if it is and 0 if out of range
@calldefine EMIT_INDEX_INFO@
# -------------------------------------------------------
sub check_$t {
  @calldefine EMIT_GETARGS@

  @calldefine EMIT_INDEX_VARS@

  @calldefine EMIT_LOAD_DATA@

  # Check the index is in range and valid
  return 1;
}

# -------------------------------------------------------
# Index walker for table $t
# Given an OID for a table, returns the next OID in range, 
# or if no more OIDs it returns 0.
@calldefine EMIT_INDEX_INFO@
# -------------------------------------------------------
sub next_$t {
  @calldefine EMIT_GETARGS@

  @calldefine EMIT_INDEX_VARS@

  @calldefine EMIT_LOAD_DATA@

  # Return the next OID if there is one
  # or return 0 if no more OIDs in this table
  return 0;
}
@eval $needwalker = 0@    ## Dont need this again for the current table
@end@
@enddefine@

@define EMIT_TABLE_LOAD@
# -------------------------------------------------------
# Loader for table $t
# Edit this function to load the data needed for $t
# This function gets called for every request to columnar
# data in the $t table
# -------------------------------------------------------
sub load_$t { 
  
}  
@enddefine@

@eval $date=scalar localtime; @

## Open the output file and emit the perl startup bolierplate
@open output.tmp@
#!/usr/bin/perl -w
#
#
# WARNING: DO NOT EDIT THIS FILE BY HAND.
#
# This file has been generated by mib2c using the mib2c.perl.conf file
# This is intended to be used by the net-snmp agent with embedded perl
# support. See perldoc NetSNMP::agent
#
# Created on $date
#
# To load this into a running agent with embedded perl support turned
# on, simply put the following line (without the leading # mark) your
# snmpd.conf file:
#
@printf "# perl do 'path/to/agent_%s.pl'\n",$oid@
#
# You will need a copy of NetSNMP installed. This has been developed using
# NetSNMP version 5.2.2
#



##use strict;
use NetSNMP::agent::Support;
use NetSNMP::ASN (':all');

# Include the functions to handle the nodes
do 'functions.pl';

## Create the skeleton file ready for the skeleton handlers later on
@push@
@open skel.tmp@
# Skeleton accessor functions.
# DO NOT EDIT 
# This file will be overwritten next time mib2c is run.
# Copy this file to functions.pl and then edit it.
@close skel.tmp@
@pop@

## Generate the hash of hashes with the oids and handlers for the tables
# Hash for all OIDs
@printf "my %soidtable={\n", $@
# Table objects
@foreach $t table@
 @print Processing table $t@
 @push@
 @append skel.tmp@
## Output skeleton loader for this table
  @calldefine EMIT_TABLE_LOAD@
  @close skel.tmp@
  @pop@
  ## 
  @eval $needwalker = 1@   ## Need the walker and checker once this table
  @foreach $c nonindex@    
   @if $c.accessible @
    ##
    ## Generate the entry for the hash table
    ## We first calculate the number of index items for this table
    @eval $numindex = 0@
    @eval $idxelem = ""@
    @foreach $i index@
      @perleval $vars{'idxelem'} .= '.0'; 0; @
      @eval $numindex = $numindex+1@
    @end@
    "$c.objectID$idxelem"=>{func=>\&get_$c,type=>$c.type, check=>\&check_$t, nextoid=>\&next_$t, istable=>'1', next=>"", numindex=>$numindex},
    ## Output skeleton handlers for this column object
    @push@
    @append skel.tmp@
@calldefine EMIT_INDEX_WALKER@
# -------------------------------------------------------
# Handler for columnar object '$c' 
# OID: $c.objectID
# Syntax: $c.type
# From: $c.module
@calldefine EMIT_INDEX_INFO@
# -------------------------------------------------------
sub get_$c { 
  @calldefine EMIT_GETARGS@

  @calldefine EMIT_INDEX_VARS@

  @calldefine EMIT_LOAD_DATA@

  # Code here to read the required variable from the loaded table
  # using whatever indexing you need.
  # The index has already been checked and found to be valid

  ## Add further types as required. 
  @if $c.type eq "ASN_INTEGER"@
  return 32;
  @end@
  @if $c.type eq "ASN_OCTET_STR"@
  return "STR";
  @end@
  @if $c.type eq "ASN_COUNTER64"@
  return 64;
  @end@
}
  @close skel.tmp@
    @pop@
  @end@
 @end@
@end@
@print Processing scalars@
## output the hash with the OIDs and handlers
## Scalars have a single index element
# Scalars
@foreach $s scalar@
 @if $s.accessible@
	'$s.objectID.0'=>{func=>\&get_$s,type=>$s.type,next=>"", numindex=>1},	
 @end@
@end@
##End of the OID hash
};

## Emit code to register the top level oid with the agent
## The $oid variable comes from mib2c as the last non option arg
# Register the top oid with the agent
@printf "registerAgent(%sagent, '$oid', %soidtable);",$,$@

## Output skeleton handlers for the scalars
@push@
@append skel.tmp@
@foreach $s scalar@
 @if $s.accessible@
# -------------------------------------------------------
# Handler for scalar object $s
# OID: $s.objectID
# Syntax: $s.type
# From: $s.module
# -------------------------------------------------------
sub get_$s { 

  # Add code here to read the value required and return it

  ## Add further types as required. 
  @if $s.type eq "ASN_INTEGER"@
  return 32;
  @end@
  @if $s.type eq "ASN_OCTET_STR"@
  return "STR";
  @end@
  @if $s.type eq "ASN_COUNTER64"@
  return 64;
  @end@
}
 @end@
@end@
@close skel.tmp@
@pop@

@close output.tmp@
##
## Now create the code file from the outputfile
##
@startperl@
my $oidname = $vars{'oid'};
my $out = "agent_" . $oidname .".pl";
system("cat output.tmp > $out");
@endperl@
@print Output code generated.@

