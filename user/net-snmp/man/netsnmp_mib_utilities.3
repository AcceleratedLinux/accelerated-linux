.TH "mib parsing and datatype manipulation routines." 3 "23 Sep 2009" "Version 5.5" "net-snmp" \" -*- nroff -*-
.ad l
.nh
.SH NAME
mib parsing and datatype manipulation routines. \- 
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fB_PrefixList\fP"
.br
.ti -1c
.RI "struct \fBparse_hints\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fB_PrefixList\fP * \fBPrefixListPtr\fP"
.br
.ti -1c
.RI "typedef struct \fB_PrefixList\fP \fBPrefixList\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBinet_address_type\fP { \fBIPV4\fP =  1, \fBIPV6\fP =  2, \fBIPV4Z\fP =  3, \fBIPV6Z\fP =  4, \fBDNS\fP =  16 }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fB_sprint_hexstring_line\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, const u_char *cp, size_t line_len)"
.br
.RI "\fIPrints a hexadecimal string into a buffer. \fP"
.ti -1c
.RI "int \fBsprint_realloc_hexstring\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, const u_char *cp, size_t len)"
.br
.ti -1c
.RI "int \fBsprint_realloc_asciistring\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, const u_char *cp, size_t len)"
.br
.RI "\fIPrints an ascii string into a buffer. \fP"
.ti -1c
.RI "int \fBsprint_realloc_octet_string\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, const \fBnetsnmp_variable_list\fP *var, const struct \fBenum_list\fP *enums, const char *hint, const char *units)"
.br
.RI "\fIPrints an octet string into a buffer. \fP"
.ti -1c
.RI "int \fBsprint_realloc_counter64\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, const \fBnetsnmp_variable_list\fP *var, const struct \fBenum_list\fP *enums, const char *hint, const char *units)"
.br
.RI "\fIPrints a counter into a buffer. \fP"
.ti -1c
.RI "int \fBsprint_realloc_opaque\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, const \fBnetsnmp_variable_list\fP *var, const struct \fBenum_list\fP *enums, const char *hint, const char *units)"
.br
.RI "\fIPrints an object identifier into a buffer. \fP"
.ti -1c
.RI "int \fBsprint_realloc_object_identifier\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, const \fBnetsnmp_variable_list\fP *var, const struct \fBenum_list\fP *enums, const char *hint, const char *units)"
.br
.RI "\fIPrints an object identifier into a buffer. \fP"
.ti -1c
.RI "int \fBsprint_realloc_timeticks\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, const \fBnetsnmp_variable_list\fP *var, const struct \fBenum_list\fP *enums, const char *hint, const char *units)"
.br
.RI "\fIPrints a timetick \fBvariable\fP into a buffer. \fP"
.ti -1c
.RI "int \fBsprint_realloc_hinted_integer\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, long val, const char decimaltype, const char *hint, const char *units)"
.br
.RI "\fIPrints an integer according to the hint into a buffer. \fP"
.ti -1c
.RI "int \fBsprint_realloc_integer\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, const \fBnetsnmp_variable_list\fP *var, const struct \fBenum_list\fP *enums, const char *hint, const char *units)"
.br
.RI "\fIPrints an integer into a buffer. \fP"
.ti -1c
.RI "int \fBsprint_realloc_uinteger\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, const \fBnetsnmp_variable_list\fP *var, const struct \fBenum_list\fP *enums, const char *hint, const char *units)"
.br
.RI "\fIPrints an unsigned integer into a buffer. \fP"
.ti -1c
.RI "int \fBsprint_realloc_gauge\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, const \fBnetsnmp_variable_list\fP *var, const struct \fBenum_list\fP *enums, const char *hint, const char *units)"
.br
.RI "\fIPrints a gauge value into a buffer. \fP"
.ti -1c
.RI "int \fBsprint_realloc_counter\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, const \fBnetsnmp_variable_list\fP *var, const struct \fBenum_list\fP *enums, const char *hint, const char *units)"
.br
.RI "\fIPrints a counter value into a buffer. \fP"
.ti -1c
.RI "int \fBsprint_realloc_networkaddress\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, const \fBnetsnmp_variable_list\fP *var, const struct \fBenum_list\fP *enums, const char *hint, const char *units)"
.br
.RI "\fIPrints a network address into a buffer. \fP"
.ti -1c
.RI "int \fBsprint_realloc_ipaddress\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, const \fBnetsnmp_variable_list\fP *var, const struct \fBenum_list\fP *enums, const char *hint, const char *units)"
.br
.RI "\fIPrints an ip-address into a buffer. \fP"
.ti -1c
.RI "int \fBsprint_realloc_null\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, const \fBnetsnmp_variable_list\fP *var, const struct \fBenum_list\fP *enums, const char *hint, const char *units)"
.br
.RI "\fIPrints a null value into a buffer. \fP"
.ti -1c
.RI "int \fBsprint_realloc_bitstring\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, const \fBnetsnmp_variable_list\fP *var, const struct \fBenum_list\fP *enums, const char *hint, const char *units)"
.br
.RI "\fIPrints a bit string into a buffer. \fP"
.ti -1c
.RI "int \fBsprint_realloc_nsapaddress\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, const \fBnetsnmp_variable_list\fP *var, const struct \fBenum_list\fP *enums, const char *hint, const char *units)"
.br
.ti -1c
.RI "int \fBsprint_realloc_badtype\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, const \fBnetsnmp_variable_list\fP *var, const struct \fBenum_list\fP *enums, const char *hint, const char *units)"
.br
.RI "\fIFallback routine for a bad type, prints 'Variable has bad type' into a buffer. \fP"
.ti -1c
.RI "int \fBsprint_realloc_by_type\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, const \fBnetsnmp_variable_list\fP *var, const struct \fBenum_list\fP *enums, const char *hint, const char *units)"
.br
.RI "\fIUniversal print routine, prints a \fBvariable\fP into a buffer according to the \fBvariable\fP type. \fP"
.ti -1c
.RI "struct \fBtree\fP * \fBget_tree_head\fP (void)"
.br
.RI "\fIRetrieves the \fBtree\fP head. \fP"
.ti -1c
.RI "char * \fBsnmp_out_toggle_options\fP (char *options)"
.br
.ti -1c
.RI "void \fBsnmp_out_toggle_options_usage\fP (const char *lead, FILE *outf)"
.br
.ti -1c
.RI "char * \fBsnmp_in_options\fP (char *optarg, int argc, char *const *argv)"
.br
.ti -1c
.RI "char * \fBsnmp_in_toggle_options\fP (char *options)"
.br
.ti -1c
.RI "void \fBsnmp_in_toggle_options_usage\fP (const char *lead, FILE *outf)"
.br
.RI "\fIPrints out a help usage for the in* toggle options. \fP"
.ti -1c
.RI "void \fBregister_mib_handlers\fP (void)"
.br
.ti -1c
.RI "void \fBnetsnmp_set_mib_directory\fP (const char *dir)"
.br
.ti -1c
.RI "char * \fBnetsnmp_get_mib_directory\fP (void)"
.br
.ti -1c
.RI "void \fBnetsnmp_fixup_mib_directory\fP (void)"
.br
.ti -1c
.RI "void \fBnetsnmp_init_mib\fP (void)"
.br
.RI "\fIInitialises the mib reader. \fP"
.ti -1c
.RI "void \fBinit_mib\fP (void)"
.br
.ti -1c
.RI "int \fB_mibindex_add\fP (const char *dirname, int i)"
.br
.ti -1c
.RI "void \fBnetsnmp_mibindex_load\fP (void)"
.br
.ti -1c
.RI "char * \fBnetsnmp_mibindex_lookup\fP (const char *dirname)"
.br
.ti -1c
.RI "FILE * \fBnetsnmp_mibindex_new\fP (const char *dirname)"
.br
.ti -1c
.RI "void \fBshutdown_mib\fP (void)"
.br
.RI "\fIUnloads all mibs. \fP"
.ti -1c
.RI "void \fBprint_mib\fP (FILE *fp)"
.br
.RI "\fIPrints the MIBs to the file fp. \fP"
.ti -1c
.RI "void \fBprint_ascii_dump\fP (FILE *fp)"
.br
.ti -1c
.RI "void \fBset_function\fP (struct \fBtree\fP *subtree)"
.br
.RI "\fISet's the printing function printomat in a subtree according it's type. \fP"
.ti -1c
.RI "int \fBread_objid\fP (const char *input, oid *output, size_t *out_len)"
.br
.RI "\fIReads an object identifier from an input string into internal OID form. \fP"
.ti -1c
.RI "void \fBnetsnmp_sprint_realloc_objid\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, int *buf_overflow, const oid *objid, size_t objidlen)"
.br
.ti -1c
.RI "struct \fBtree\fP * \fBnetsnmp_sprint_realloc_objid_tree\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, int *buf_overflow, const oid *objid, size_t objidlen)"
.br
.ti -1c
.RI "int \fBsprint_realloc_objid\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, const oid *objid, size_t objidlen)"
.br
.ti -1c
.RI "int \fBsnprint_objid\fP (char *buf, size_t buf_len, const oid *objid, size_t objidlen)"
.br
.ti -1c
.RI "void \fBprint_objid\fP (const oid *objid, size_t objidlen)"
.br
.RI "\fIPrints an oid to stdout. \fP"
.ti -1c
.RI "void \fBfprint_objid\fP (FILE *f, const oid *objid, size_t objidlen)"
.br
.RI "\fIPrints an oid to a file descriptor. \fP"
.ti -1c
.RI "int \fBsprint_realloc_variable\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, const oid *objid, size_t objidlen, const \fBnetsnmp_variable_list\fP *\fBvariable\fP)"
.br
.ti -1c
.RI "int \fBsnprint_variable\fP (char *buf, size_t buf_len, const oid *objid, size_t objidlen, const \fBnetsnmp_variable_list\fP *\fBvariable\fP)"
.br
.ti -1c
.RI "void \fBprint_variable\fP (const oid *objid, size_t objidlen, const \fBnetsnmp_variable_list\fP *\fBvariable\fP)"
.br
.RI "\fIPrints a \fBvariable\fP to stdout. \fP"
.ti -1c
.RI "void \fBfprint_variable\fP (FILE *f, const oid *objid, size_t objidlen, const \fBnetsnmp_variable_list\fP *\fBvariable\fP)"
.br
.RI "\fIPrints a \fBvariable\fP to a file descriptor. \fP"
.ti -1c
.RI "int \fBsprint_realloc_value\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, const oid *objid, size_t objidlen, const \fBnetsnmp_variable_list\fP *\fBvariable\fP)"
.br
.ti -1c
.RI "int \fBsnprint_value\fP (char *buf, size_t buf_len, const oid *objid, size_t objidlen, const \fBnetsnmp_variable_list\fP *\fBvariable\fP)"
.br
.ti -1c
.RI "void \fBprint_value\fP (const oid *objid, size_t objidlen, const \fBnetsnmp_variable_list\fP *\fBvariable\fP)"
.br
.ti -1c
.RI "void \fBfprint_value\fP (FILE *f, const oid *objid, size_t objidlen, const \fBnetsnmp_variable_list\fP *\fBvariable\fP)"
.br
.ti -1c
.RI "int \fBbuild_oid_segment\fP (\fBnetsnmp_variable_list\fP *var)"
.br
.RI "\fITakes the value in VAR and turns it into an OID segment in var->name. \fP"
.ti -1c
.RI "int \fBbuild_oid_noalloc\fP (oid *in, size_t in_len, size_t *out_len, oid *prefix, size_t prefix_len, \fBnetsnmp_variable_list\fP *indexes)"
.br
.ti -1c
.RI "int \fBbuild_oid\fP (oid **out, size_t *out_len, oid *prefix, size_t prefix_len, \fBnetsnmp_variable_list\fP *indexes)"
.br
.ti -1c
.RI "int \fBparse_oid_indexes\fP (oid *oidIndex, size_t oidLen, \fBnetsnmp_variable_list\fP *data)"
.br
.ti -1c
.RI "int \fBparse_one_oid_index\fP (oid **oidStart, size_t *oidLen, \fBnetsnmp_variable_list\fP *data, int complete)"
.br
.ti -1c
.RI "int \fBdump_realloc_oid_to_inetaddress\fP (const int addr_type, const oid *objid, size_t objidlen, u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, char quotechar)"
.br
.ti -1c
.RI "int \fBdump_realloc_oid_to_string\fP (const oid *objid, size_t objidlen, u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, char quotechar)"
.br
.ti -1c
.RI "struct \fBtree\fP * \fBget_tree\fP (const oid *objid, size_t objidlen, struct \fBtree\fP *subtree)"
.br
.ti -1c
.RI "void \fBprint_description\fP (oid *objid, size_t objidlen, int width)"
.br
.RI "\fIPrints on oid description on stdout. \fP"
.ti -1c
.RI "void \fBfprint_description\fP (FILE *f, oid *objid, size_t objidlen, int width)"
.br
.RI "\fIPrints on oid description into a file descriptor. \fP"
.ti -1c
.RI "int \fBsnprint_description\fP (char *buf, size_t buf_len, oid *objid, size_t objidlen, int width)"
.br
.ti -1c
.RI "int \fBsprint_realloc_description\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, oid *objid, size_t objidlen, int width)"
.br
.ti -1c
.RI "int \fBget_module_node\fP (const char *fname, const char *\fBmodule\fP, oid *objid, size_t *objidlen)"
.br
.ti -1c
.RI "int \fBget_wild_node\fP (const char *name, oid *objid, size_t *objidlen)"
.br
.ti -1c
.RI "int \fBget_node\fP (const char *name, oid *objid, size_t *objidlen)"
.br
.ti -1c
.RI "void \fBclear_tree_flags\fP (register struct \fBtree\fP *tp)"
.br
.ti -1c
.RI "void \fBprint_oid_report\fP (FILE *fp)"
.br
.ti -1c
.RI "void \fBprint_oid_report_enable_labeledoid\fP (void)"
.br
.ti -1c
.RI "void \fBprint_oid_report_enable_oid\fP (void)"
.br
.ti -1c
.RI "void \fBprint_oid_report_enable_suffix\fP (void)"
.br
.ti -1c
.RI "void \fBprint_oid_report_enable_symbolic\fP (void)"
.br
.ti -1c
.RI "void \fBprint_oid_report_enable_mibchildoid\fP (void)"
.br
.ti -1c
.RI "char * \fBuptime_string\fP (u_long timeticks, char *buf)"
.br
.RI "\fIConverts timeticks to hours, minutes, seconds string. \fP"
.ti -1c
.RI "char * \fBuptime_string_n\fP (u_long timeticks, char *buf, size_t buflen)"
.br
.ti -1c
.RI "oid * \fBsnmp_parse_oid\fP (const char *argv, oid *root, size_t *rootlen)"
.br
.RI "\fIGiven a string, parses an oid out of it (if possible). \fP"
.ti -1c
.RI "const char * \fBparse_octet_hint\fP (const char *hint, const char *value, unsigned char **new_val, int *new_val_len)"
.br
.ti -1c
.RI "u_char \fBmib_to_asn_type\fP (int mib_type)"
.br
.ti -1c
.RI "int \fBnetsnmp_str2oid\fP (const char *S, oid *O, int L)"
.br
.RI "\fIConverts a string to its OID form. \fP"
.ti -1c
.RI "int \fBnetsnmp_oid2chars\fP (char *C, int L, const oid *O)"
.br
.RI "\fIConverts an OID to its character form. \fP"
.ti -1c
.RI "int \fBnetsnmp_oid2str\fP (char *S, int L, oid *O)"
.br
.RI "\fIConverts an OID to its string form. \fP"
.ti -1c
.RI "int \fBsnprint_by_type\fP (char *buf, size_t buf_len, \fBnetsnmp_variable_list\fP *var, const struct \fBenum_list\fP *enums, const char *hint, const char *units)"
.br
.ti -1c
.RI "int \fBsnprint_hexstring\fP (char *buf, size_t buf_len, const u_char *cp, size_t len)"
.br
.ti -1c
.RI "int \fBsnprint_asciistring\fP (char *buf, size_t buf_len, const u_char *cp, size_t len)"
.br
.ti -1c
.RI "int \fBsnprint_octet_string\fP (char *buf, size_t buf_len, const \fBnetsnmp_variable_list\fP *var, const struct \fBenum_list\fP *enums, const char *hint, const char *units)"
.br
.ti -1c
.RI "int \fBsnprint_opaque\fP (char *buf, size_t buf_len, const \fBnetsnmp_variable_list\fP *var, const struct \fBenum_list\fP *enums, const char *hint, const char *units)"
.br
.ti -1c
.RI "int \fBsnprint_object_identifier\fP (char *buf, size_t buf_len, const \fBnetsnmp_variable_list\fP *var, const struct \fBenum_list\fP *enums, const char *hint, const char *units)"
.br
.ti -1c
.RI "int \fBsnprint_timeticks\fP (char *buf, size_t buf_len, const \fBnetsnmp_variable_list\fP *var, const struct \fBenum_list\fP *enums, const char *hint, const char *units)"
.br
.ti -1c
.RI "int \fBsnprint_hinted_integer\fP (char *buf, size_t buf_len, long val, const char *hint, const char *units)"
.br
.ti -1c
.RI "int \fBsnprint_integer\fP (char *buf, size_t buf_len, const \fBnetsnmp_variable_list\fP *var, const struct \fBenum_list\fP *enums, const char *hint, const char *units)"
.br
.ti -1c
.RI "int \fBsnprint_uinteger\fP (char *buf, size_t buf_len, const \fBnetsnmp_variable_list\fP *var, const struct \fBenum_list\fP *enums, const char *hint, const char *units)"
.br
.ti -1c
.RI "int \fBsnprint_gauge\fP (char *buf, size_t buf_len, const \fBnetsnmp_variable_list\fP *var, const struct \fBenum_list\fP *enums, const char *hint, const char *units)"
.br
.ti -1c
.RI "int \fBsnprint_counter\fP (char *buf, size_t buf_len, const \fBnetsnmp_variable_list\fP *var, const struct \fBenum_list\fP *enums, const char *hint, const char *units)"
.br
.ti -1c
.RI "int \fBsnprint_networkaddress\fP (char *buf, size_t buf_len, const \fBnetsnmp_variable_list\fP *var, const struct \fBenum_list\fP *enums, const char *hint, const char *units)"
.br
.ti -1c
.RI "int \fBsnprint_ipaddress\fP (char *buf, size_t buf_len, const \fBnetsnmp_variable_list\fP *var, const struct \fBenum_list\fP *enums, const char *hint, const char *units)"
.br
.ti -1c
.RI "int \fBsnprint_null\fP (char *buf, size_t buf_len, const \fBnetsnmp_variable_list\fP *var, const struct \fBenum_list\fP *enums, const char *hint, const char *units)"
.br
.ti -1c
.RI "int \fBsnprint_bitstring\fP (char *buf, size_t buf_len, const \fBnetsnmp_variable_list\fP *var, const struct \fBenum_list\fP *enums, const char *hint, const char *units)"
.br
.ti -1c
.RI "int \fBsnprint_nsapaddress\fP (char *buf, size_t buf_len, const \fBnetsnmp_variable_list\fP *var, const struct \fBenum_list\fP *enums, const char *hint, const char *units)"
.br
.ti -1c
.RI "int \fBsnprint_counter64\fP (char *buf, size_t buf_len, const \fBnetsnmp_variable_list\fP *var, const struct \fBenum_list\fP *enums, const char *hint, const char *units)"
.br
.ti -1c
.RI "int \fBsnprint_badtype\fP (char *buf, size_t buf_len, const \fBnetsnmp_variable_list\fP *var, const struct \fBenum_list\fP *enums, const char *hint, const char *units)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "struct \fBtree\fP * \fBtree_head\fP"
.br
.ti -1c
.RI "struct \fBtree\fP * \fBMib\fP"
.br
.ti -1c
.RI "oid \fBRFC1213_MIB\fP [] = { 1, 3, 6, 1, 2, 1 }"
.br
.ti -1c
.RI "\fBPrefixList\fP \fBmib_prefixes\fP []"
.br
.ti -1c
.RI "char ** \fB_mibindexes\fP = NULL"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "int _sprint_hexstring_line (u_char ** buf, size_t * buf_len, size_t * out_len, int allow_realloc, const u_char * cp, size_t line_len)"
.PP
Prints a hexadecimal string into a buffer. The characters pointed by *cp are encoded as hexadecimal string.
.PP
If allow_realloc is true the buffer will be (re)allocated to fit in the needed size. (Note: *buf may change due to this.)
.PP
\fBParameters:\fP
.RS 4
\fIbuf\fP address of the buffer to print to. 
.br
\fIbuf_len\fP address to an integer containing the size of buf. 
.br
\fIout_len\fP incremented by the number of characters printed. 
.br
\fIallow_realloc\fP if not zero reallocate the buffer to fit the needed size. 
.br
\fIcp\fP the array of characters to encode. 
.br
\fIline_len\fP the array length of cp.
.RE
.PP
\fBReturns:\fP
.RS 4
1 on success, or 0 on failure (out of memory, or buffer to small when not allowed to realloc.) 
.RE
.PP

.PP
Definition at line 289 of file mib.c.
.SS "int build_oid (oid ** out, size_t * out_len, oid * prefix, size_t prefix_len, \fBnetsnmp_variable_list\fP * indexes)"
.PP
xxx-rks: should free previous value? 
.PP
Definition at line 3739 of file mib.c.
.SS "int build_oid_segment (\fBnetsnmp_variable_list\fP * var)"
.PP
Takes the value in VAR and turns it into an OID segment in var->name. \fBParameters:\fP
.RS 4
\fIvar\fP The \fBvariable\fP.
.RE
.PP
\fBReturns:\fP
.RS 4
SNMPERR_SUCCESS or SNMPERR_GENERR 
.RE
.PP

.PP
Definition at line 3603 of file mib.c.
.SS "void fprint_description (FILE * f, oid * objid, size_t objidlen, int width)"
.PP
Prints on oid description into a file descriptor. \fBParameters:\fP
.RS 4
\fIf\fP The file descriptor to print to. 
.br
\fIobjid\fP The object identifier. 
.br
\fIobjidlen\fP The object id length. 
.br
\fIwidth\fP Number of subidentifiers. 
.RE
.PP

.PP
Definition at line 4609 of file mib.c.
.SS "void fprint_objid (FILE * f, const oid * objid, size_t objidlen)"
.PP
Prints an oid to a file descriptor. \fBParameters:\fP
.RS 4
\fIf\fP The file descriptor to print to. 
.br
\fIobjid\fP The oid to print 
.br
\fIobjidlen\fP The length of oidid. 
.RE
.PP

.PP
Definition at line 3326 of file mib.c.
.SS "void fprint_variable (FILE * f, const oid * objid, size_t objidlen, const \fBnetsnmp_variable_list\fP * variable)"
.PP
Prints a \fBvariable\fP to a file descriptor. \fBParameters:\fP
.RS 4
\fIf\fP The file descriptor to print to. 
.br
\fIobjid\fP The object id. 
.br
\fIobjidlen\fP The length of teh object id. 
.br
\fI\fBvariable\fP\fP The \fBvariable\fP to print. 
.RE
.PP

.PP
Definition at line 3480 of file mib.c.
.SS "struct \fBtree\fP* get_tree_head (void)\fC [read]\fP"
.PP
Retrieves the \fBtree\fP head. \fBReturns:\fP
.RS 4
the \fBtree\fP head. 
.RE
.PP

.PP
Definition at line 2035 of file mib.c.
.SS "int get_wild_node (const char * name, oid * objid, size_t * objidlen)"\fBSee also:\fP
.RS 4
comments on find_best_tree_node for usage after first time. 
.RE
.PP

.PP
Definition at line 5629 of file mib.c.
.SS "void netsnmp_fixup_mib_directory (void)"
.PP
swap in the new value and repeat 
.PP
Definition at line 2500 of file mib.c.
.SS "char* netsnmp_get_mib_directory (void)"
.PP
Check if the environment \fBvariable\fP is set
.PP
Not set use hard coded path 
.PP
Definition at line 2453 of file mib.c.
.SS "void netsnmp_init_mib (void)"
.PP
Initialises the mib reader. Library API routines concerned with MIB files and objects, and OIDs.
.PP
Reads in all settings from the environment. 
.PP
Definition at line 2547 of file mib.c.
.SS "int netsnmp_oid2chars (char * C, int L, const oid * O)"
.PP
Converts an OID to its character form. in example 5 . 1 . 2 . 3 . 4 . 5 = 12345
.PP
\fBParameters:\fP
.RS 4
\fIC\fP The character buffer. 
.br
\fIL\fP The length of the buffer. 
.br
\fIO\fP The oid.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on Sucess, 1 on failure. 
.RE
.PP

.PP
length 
.PP
Definition at line 6416 of file mib.c.
.SS "int netsnmp_oid2str (char * S, int L, oid * O)"
.PP
Converts an OID to its string form. in example 5 . 'h' . 'e' . 'l' . 'l' . 'o' = 'hello\\0' (null terminated)
.PP
\fBParameters:\fP
.RS 4
\fIS\fP The character string buffer. 
.br
\fIL\fP The length of the string buffer. 
.br
\fIO\fP The oid.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on Sucess, 1 on failure. 
.RE
.PP

.PP
Definition at line 6444 of file mib.c.
.SS "void netsnmp_set_mib_directory (const char * dir)"
.PP
New dir starts with '+', thus we add it.
.PP
If dir starts with '+' skip '+' it.
.PP
set_string calls strdup, so if we allocated memory, free it 
.PP
Definition at line 2398 of file mib.c.
.SS "int netsnmp_str2oid (const char * S, oid * O, int L)"
.PP
Converts a string to its OID form. in example 'hello' = 5 . 'h' . 'e' . 'l' . 'l' . 'o'
.PP
\fBParameters:\fP
.RS 4
\fIS\fP The string. 
.br
\fIO\fP The oid. 
.br
\fIL\fP The length of the oid.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on Sucess, 1 on failure. 
.RE
.PP

.PP
Definition at line 6381 of file mib.c.
.SS "void print_description (oid * objid, size_t objidlen, int width)"
.PP
Prints on oid description on stdout. \fBSee also:\fP
.RS 4
\fBfprint_description\fP 
.RE
.PP

.PP
Definition at line 4593 of file mib.c.
.SS "void print_mib (FILE * fp)"
.PP
Prints the MIBs to the file fp. \fBParameters:\fP
.RS 4
\fIfp\fP The file descriptor to print to. 
.RE
.PP

.PP
Definition at line 2904 of file mib.c.
.SS "void print_objid (const oid * objid, size_t objidlen)"
.PP
Prints an oid to stdout. \fBParameters:\fP
.RS 4
\fIobjid\fP The oid to print 
.br
\fIobjidlen\fP The length of oidid. 
.RE
.PP

.PP
Definition at line 3312 of file mib.c.
.SS "void print_variable (const oid * objid, size_t objidlen, const \fBnetsnmp_variable_list\fP * variable)"
.PP
Prints a \fBvariable\fP to stdout. \fBParameters:\fP
.RS 4
\fIobjid\fP The object id. 
.br
\fIobjidlen\fP The length of teh object id. 
.br
\fI\fBvariable\fP\fP The \fBvariable\fP to print. 
.RE
.PP

.PP
Definition at line 3464 of file mib.c.
.SS "int read_objid (const char * input, oid * output, size_t * out_len)"
.PP
Reads an object identifier from an input string into internal OID form. When called, out_len must hold the maximum length of the output array.
.PP
\fBParameters:\fP
.RS 4
\fIinput\fP the input string. 
.br
\fIoutput\fP the oid wirte. 
.br
\fIout_len\fP number of subid's in output.
.RE
.PP
\fBReturns:\fP
.RS 4
1 if successful.
.RE
.PP
If an error occurs, this function returns 0 and MAY set snmp_errno. snmp_errno is NOT set if SET_SNMP_ERROR evaluates to nothing. This can make multi-threaded use a tiny bit more robust. 
.PP
Definition at line 3002 of file mib.c.
.SS "void set_function (struct \fBtree\fP * subtree)"
.PP
Set's the printing function printomat in a subtree according it's type. \fBParameters:\fP
.RS 4
\fIsubtree\fP The subtree to set. 
.RE
.PP

.PP
Definition at line 2925 of file mib.c.
.SS "void shutdown_mib (void)"
.PP
Unloads all mibs. 
.PP
Definition at line 2870 of file mib.c.
.SS "void snmp_in_toggle_options_usage (const char * lead, FILE * outf)"
.PP
Prints out a help usage for the in* toggle options. \fBParameters:\fP
.RS 4
\fIlead\fP The lead to print for every line. 
.br
\fIoutf\fP The file descriptor to write to. 
.RE
.PP

.PP
Definition at line 2308 of file mib.c.
.SS "oid* snmp_parse_oid (const char * argv, oid * root, size_t * rootlen)"
.PP
Given a string, parses an oid out of it (if possible). It will try to parse it based on predetermined configuration if present or by every method possible otherwise. If a suffix has been registered using NETSNMP_DS_LIB_OIDSUFFIX, it will be appended to the input string before processing.
.PP
\fBParameters:\fP
.RS 4
\fIargv\fP The OID to string parse 
.br
\fIroot\fP An OID array where the results are stored. 
.br
\fIrootlen\fP The max length of the array going in and the data length coming out.
.RE
.PP
\fBReturns:\fP
.RS 4
The root oid pointer if successful, or NULL otherwise. 
.RE
.PP

.PP
Definition at line 5987 of file mib.c.
.SS "int sprint_realloc_asciistring (u_char ** buf, size_t * buf_len, size_t * out_len, int allow_realloc, const u_char * cp, size_t len)"
.PP
Prints an ascii string into a buffer. The characters pointed by *cp are encoded as an ascii string.
.PP
If allow_realloc is true the buffer will be (re)allocated to fit in the needed size. (Note: *buf may change due to this.)
.PP
\fBParameters:\fP
.RS 4
\fIbuf\fP address of the buffer to print to. 
.br
\fIbuf_len\fP address to an integer containing the size of buf. 
.br
\fIout_len\fP incremented by the number of characters printed. 
.br
\fIallow_realloc\fP if not zero reallocate the buffer to fit the needed size. 
.br
\fIcp\fP the array of characters to encode. 
.br
\fIlen\fP the array length of cp.
.RE
.PP
\fBReturns:\fP
.RS 4
1 on success, or 0 on failure (out of memory, or buffer to small when not allowed to realloc.) 
.RE
.PP

.PP
Definition at line 385 of file mib.c.
.SS "int sprint_realloc_badtype (u_char ** buf, size_t * buf_len, size_t * out_len, int allow_realloc, const \fBnetsnmp_variable_list\fP * var, const struct \fBenum_list\fP * enums, const char * hint, const char * units)"
.PP
Fallback routine for a bad type, prints 'Variable has bad type' into a buffer. If allow_realloc is true the buffer will be (re)allocated to fit in the needed size. (Note: *buf may change due to this.)
.PP
\fBParameters:\fP
.RS 4
\fIbuf\fP Address of the buffer to print to. 
.br
\fIbuf_len\fP Address to an integer containing the size of buf. 
.br
\fIout_len\fP Incremented by the number of characters printed. 
.br
\fIallow_realloc\fP if not zero reallocate the buffer to fit the needed size. 
.br
\fIvar\fP The \fBvariable\fP to encode. 
.br
\fIenums\fP The enumeration ff this \fBvariable\fP is enumerated. may be NULL. 
.br
\fIhint\fP Contents of the DISPLAY-HINT clause of the MIB. See RFC 1903 Section 3.1 for details. may be NULL. 
.br
\fIunits\fP Contents of the UNITS clause of the MIB. may be NULL.
.RE
.PP
\fBReturns:\fP
.RS 4
1 on success, or 0 on failure (out of memory, or buffer to small when not allowed to realloc.) 
.RE
.PP

.PP
Definition at line 1920 of file mib.c.
.SS "int sprint_realloc_bitstring (u_char ** buf, size_t * buf_len, size_t * out_len, int allow_realloc, const \fBnetsnmp_variable_list\fP * var, const struct \fBenum_list\fP * enums, const char * hint, const char * units)"
.PP
Prints a bit string into a buffer. If allow_realloc is true the buffer will be (re)allocated to fit in the needed size. (Note: *buf may change due to this.)
.PP
\fBParameters:\fP
.RS 4
\fIbuf\fP Address of the buffer to print to. 
.br
\fIbuf_len\fP Address to an integer containing the size of buf. 
.br
\fIout_len\fP Incremented by the number of characters printed. 
.br
\fIallow_realloc\fP if not zero reallocate the buffer to fit the needed size. 
.br
\fIvar\fP The \fBvariable\fP to encode. 
.br
\fIenums\fP The enumeration ff this \fBvariable\fP is enumerated. may be NULL. 
.br
\fIhint\fP Contents of the DISPLAY-HINT clause of the MIB. See RFC 1903 Section 3.1 for details. may be NULL. 
.br
\fIunits\fP Contents of the UNITS clause of the MIB. may be NULL.
.RE
.PP
\fBReturns:\fP
.RS 4
1 on success, or 0 on failure (out of memory, or buffer to small when not allowed to realloc.) 
.RE
.PP

.PP
Definition at line 1781 of file mib.c.
.SS "int sprint_realloc_by_type (u_char ** buf, size_t * buf_len, size_t * out_len, int allow_realloc, const \fBnetsnmp_variable_list\fP * var, const struct \fBenum_list\fP * enums, const char * hint, const char * units)"
.PP
Universal print routine, prints a \fBvariable\fP into a buffer according to the \fBvariable\fP type. If allow_realloc is true the buffer will be (re)allocated to fit in the needed size. (Note: *buf may change due to this.)
.PP
\fBParameters:\fP
.RS 4
\fIbuf\fP Address of the buffer to print to. 
.br
\fIbuf_len\fP Address to an integer containing the size of buf. 
.br
\fIout_len\fP Incremented by the number of characters printed. 
.br
\fIallow_realloc\fP if not zero reallocate the buffer to fit the needed size. 
.br
\fIvar\fP The \fBvariable\fP to encode. 
.br
\fIenums\fP The enumeration ff this \fBvariable\fP is enumerated. may be NULL. 
.br
\fIhint\fP Contents of the DISPLAY-HINT clause of the MIB. See RFC 1903 Section 3.1 for details. may be NULL. 
.br
\fIunits\fP Contents of the UNITS clause of the MIB. may be NULL.
.RE
.PP
\fBReturns:\fP
.RS 4
1 on success, or 0 on failure (out of memory, or buffer to small when not allowed to realloc.) 
.RE
.PP

.PP
Definition at line 1955 of file mib.c.
.SS "int sprint_realloc_counter (u_char ** buf, size_t * buf_len, size_t * out_len, int allow_realloc, const \fBnetsnmp_variable_list\fP * var, const struct \fBenum_list\fP * enums, const char * hint, const char * units)"
.PP
Prints a counter value into a buffer. If allow_realloc is true the buffer will be (re)allocated to fit in the needed size. (Note: *buf may change due to this.)
.PP
\fBParameters:\fP
.RS 4
\fIbuf\fP Address of the buffer to print to. 
.br
\fIbuf_len\fP Address to an integer containing the size of buf. 
.br
\fIout_len\fP Incremented by the number of characters printed. 
.br
\fIallow_realloc\fP if not zero reallocate the buffer to fit the needed size. 
.br
\fIvar\fP The \fBvariable\fP to encode. 
.br
\fIenums\fP The enumeration ff this \fBvariable\fP is enumerated. may be NULL. 
.br
\fIhint\fP Contents of the DISPLAY-HINT clause of the MIB. See RFC 1903 Section 3.1 for details. may be NULL. 
.br
\fIunits\fP Contents of the UNITS clause of the MIB. may be NULL.
.RE
.PP
\fBReturns:\fP
.RS 4
1 on success, or 0 on failure (out of memory, or buffer to small when not allowed to realloc.) 
.RE
.PP

.PP
Definition at line 1548 of file mib.c.
.SS "int sprint_realloc_counter64 (u_char ** buf, size_t * buf_len, size_t * out_len, int allow_realloc, const \fBnetsnmp_variable_list\fP * var, const struct \fBenum_list\fP * enums, const char * hint, const char * units)"
.PP
Prints a counter into a buffer. The \fBvariable\fP var is encoded as a counter value.
.PP
If allow_realloc is true the buffer will be (re)allocated to fit in the needed size. (Note: *buf may change due to this.)
.PP
\fBParameters:\fP
.RS 4
\fIbuf\fP Address of the buffer to print to. 
.br
\fIbuf_len\fP Address to an integer containing the size of buf. 
.br
\fIout_len\fP Incremented by the number of characters printed. 
.br
\fIallow_realloc\fP if not zero reallocate the buffer to fit the needed size. 
.br
\fIvar\fP The \fBvariable\fP to encode. 
.br
\fIenums\fP The enumeration ff this \fBvariable\fP is enumerated. may be NULL. 
.br
\fIhint\fP Contents of the DISPLAY-HINT clause of the MIB. See RFC 1903 Section 3.1 for details. may be NULL. 
.br
\fIunits\fP Contents of the UNITS clause of the MIB. may be NULL.
.RE
.PP
\fBReturns:\fP
.RS 4
1 on success, or 0 on failure (out of memory, or buffer to small when not allowed to realloc.) 
.RE
.PP

.PP
Definition at line 864 of file mib.c.
.SS "int sprint_realloc_gauge (u_char ** buf, size_t * buf_len, size_t * out_len, int allow_realloc, const \fBnetsnmp_variable_list\fP * var, const struct \fBenum_list\fP * enums, const char * hint, const char * units)"
.PP
Prints a gauge value into a buffer. If allow_realloc is true the buffer will be (re)allocated to fit in the needed size. (Note: *buf may change due to this.)
.PP
\fBParameters:\fP
.RS 4
\fIbuf\fP Address of the buffer to print to. 
.br
\fIbuf_len\fP Address to an integer containing the size of buf. 
.br
\fIout_len\fP Incremented by the number of characters printed. 
.br
\fIallow_realloc\fP if not zero reallocate the buffer to fit the needed size. 
.br
\fIvar\fP The \fBvariable\fP to encode. 
.br
\fIenums\fP The enumeration ff this \fBvariable\fP is enumerated. may be NULL. 
.br
\fIhint\fP Contents of the DISPLAY-HINT clause of the MIB. See RFC 1903 Section 3.1 for details. may be NULL. 
.br
\fIunits\fP Contents of the UNITS clause of the MIB. may be NULL.
.RE
.PP
\fBReturns:\fP
.RS 4
1 on success, or 0 on failure (out of memory, or buffer to small when not allowed to realloc.) 
.RE
.PP

.PP
Definition at line 1475 of file mib.c.
.SS "int sprint_realloc_hinted_integer (u_char ** buf, size_t * buf_len, size_t * out_len, int allow_realloc, long val, const char decimaltype, const char * hint, const char * units)"
.PP
Prints an integer according to the hint into a buffer. If allow_realloc is true the buffer will be (re)allocated to fit in the needed size. (Note: *buf may change due to this.)
.PP
\fBParameters:\fP
.RS 4
\fIbuf\fP Address of the buffer to print to. 
.br
\fIbuf_len\fP Address to an integer containing the size of buf. 
.br
\fIout_len\fP Incremented by the number of characters printed. 
.br
\fIallow_realloc\fP if not zero reallocate the buffer to fit the needed size. 
.br
\fIval\fP The \fBvariable\fP to encode. 
.br
\fIdecimaltype\fP The enumeration ff this \fBvariable\fP is enumerated. may be NULL. 
.br
\fIhint\fP Contents of the DISPLAY-HINT clause of the MIB. See RFC 1903 Section 3.1 for details. may _NOT_ be NULL. 
.br
\fIunits\fP Contents of the UNITS clause of the MIB. may be NULL.
.RE
.PP
\fBReturns:\fP
.RS 4
1 on success, or 0 on failure (out of memory, or buffer to small when not allowed to realloc.) 
.RE
.PP

.PP
Definition at line 1201 of file mib.c.
.SS "int sprint_realloc_integer (u_char ** buf, size_t * buf_len, size_t * out_len, int allow_realloc, const \fBnetsnmp_variable_list\fP * var, const struct \fBenum_list\fP * enums, const char * hint, const char * units)"
.PP
Prints an integer into a buffer. If allow_realloc is true the buffer will be (re)allocated to fit in the needed size. (Note: *buf may change due to this.)
.PP
\fBParameters:\fP
.RS 4
\fIbuf\fP Address of the buffer to print to. 
.br
\fIbuf_len\fP Address to an integer containing the size of buf. 
.br
\fIout_len\fP Incremented by the number of characters printed. 
.br
\fIallow_realloc\fP if not zero reallocate the buffer to fit the needed size. 
.br
\fIvar\fP The \fBvariable\fP to encode. 
.br
\fIenums\fP The enumeration ff this \fBvariable\fP is enumerated. may be NULL. 
.br
\fIhint\fP Contents of the DISPLAY-HINT clause of the MIB. See RFC 1903 Section 3.1 for details. may be NULL. 
.br
\fIunits\fP Contents of the UNITS clause of the MIB. may be NULL.
.RE
.PP
\fBReturns:\fP
.RS 4
1 on success, or 0 on failure (out of memory, or buffer to small when not allowed to realloc.) 
.RE
.PP

.PP
Definition at line 1275 of file mib.c.
.SS "int sprint_realloc_ipaddress (u_char ** buf, size_t * buf_len, size_t * out_len, int allow_realloc, const \fBnetsnmp_variable_list\fP * var, const struct \fBenum_list\fP * enums, const char * hint, const char * units)"
.PP
Prints an ip-address into a buffer. If allow_realloc is true the buffer will be (re)allocated to fit in the needed size. (Note: *buf may change due to this.)
.PP
\fBParameters:\fP
.RS 4
\fIbuf\fP Address of the buffer to print to. 
.br
\fIbuf_len\fP Address to an integer containing the size of buf. 
.br
\fIout_len\fP Incremented by the number of characters printed. 
.br
\fIallow_realloc\fP if not zero reallocate the buffer to fit the needed size. 
.br
\fIvar\fP The \fBvariable\fP to encode. 
.br
\fIenums\fP The enumeration ff this \fBvariable\fP is enumerated. may be NULL. 
.br
\fIhint\fP Contents of the DISPLAY-HINT clause of the MIB. See RFC 1903 Section 3.1 for details. may be NULL. 
.br
\fIunits\fP Contents of the UNITS clause of the MIB. may be NULL.
.RE
.PP
\fBReturns:\fP
.RS 4
1 on success, or 0 on failure (out of memory, or buffer to small when not allowed to realloc.) 
.RE
.PP

.PP
Definition at line 1677 of file mib.c.
.SS "int sprint_realloc_networkaddress (u_char ** buf, size_t * buf_len, size_t * out_len, int allow_realloc, const \fBnetsnmp_variable_list\fP * var, const struct \fBenum_list\fP * enums, const char * hint, const char * units)"
.PP
Prints a network address into a buffer. If allow_realloc is true the buffer will be (re)allocated to fit in the needed size. (Note: *buf may change due to this.)
.PP
\fBParameters:\fP
.RS 4
\fIbuf\fP Address of the buffer to print to. 
.br
\fIbuf_len\fP Address to an integer containing the size of buf. 
.br
\fIout_len\fP Incremented by the number of characters printed. 
.br
\fIallow_realloc\fP if not zero reallocate the buffer to fit the needed size. 
.br
\fIvar\fP The \fBvariable\fP to encode. 
.br
\fIenums\fP The enumeration ff this \fBvariable\fP is enumerated. may be NULL. 
.br
\fIhint\fP Contents of the DISPLAY-HINT clause of the MIB. See RFC 1903 Section 3.1 for details. may be NULL. 
.br
\fIunits\fP Contents of the UNITS clause of the MIB. may be NULL.
.RE
.PP
\fBReturns:\fP
.RS 4
1 on success, or 0 on failure (out of memory, or buffer to small when not allowed to realloc.) 
.RE
.PP

.PP
Definition at line 1611 of file mib.c.
.SS "int sprint_realloc_null (u_char ** buf, size_t * buf_len, size_t * out_len, int allow_realloc, const \fBnetsnmp_variable_list\fP * var, const struct \fBenum_list\fP * enums, const char * hint, const char * units)"
.PP
Prints a null value into a buffer. If allow_realloc is true the buffer will be (re)allocated to fit in the needed size. (Note: *buf may change due to this.)
.PP
\fBParameters:\fP
.RS 4
\fIbuf\fP Address of the buffer to print to. 
.br
\fIbuf_len\fP Address to an integer containing the size of buf. 
.br
\fIout_len\fP Incremented by the number of characters printed. 
.br
\fIallow_realloc\fP if not zero reallocate the buffer to fit the needed size. 
.br
\fIvar\fP The \fBvariable\fP to encode. 
.br
\fIenums\fP The enumeration ff this \fBvariable\fP is enumerated. may be NULL. 
.br
\fIhint\fP Contents of the DISPLAY-HINT clause of the MIB. See RFC 1903 Section 3.1 for details. may be NULL. 
.br
\fIunits\fP Contents of the UNITS clause of the MIB. may be NULL.
.RE
.PP
\fBReturns:\fP
.RS 4
1 on success, or 0 on failure (out of memory, or buffer to small when not allowed to realloc.) 
.RE
.PP

.PP
Definition at line 1737 of file mib.c.
.SS "int sprint_realloc_object_identifier (u_char ** buf, size_t * buf_len, size_t * out_len, int allow_realloc, const \fBnetsnmp_variable_list\fP * var, const struct \fBenum_list\fP * enums, const char * hint, const char * units)"
.PP
Prints an object identifier into a buffer. If allow_realloc is true the buffer will be (re)allocated to fit in the needed size. (Note: *buf may change due to this.)
.PP
\fBParameters:\fP
.RS 4
\fIbuf\fP Address of the buffer to print to. 
.br
\fIbuf_len\fP Address to an integer containing the size of buf. 
.br
\fIout_len\fP Incremented by the number of characters printed. 
.br
\fIallow_realloc\fP if not zero reallocate the buffer to fit the needed size. 
.br
\fIvar\fP The \fBvariable\fP to encode. 
.br
\fIenums\fP The enumeration ff this \fBvariable\fP is enumerated. may be NULL. 
.br
\fIhint\fP Contents of the DISPLAY-HINT clause of the MIB. See RFC 1903 Section 3.1 for details. may be NULL. 
.br
\fIunits\fP Contents of the UNITS clause of the MIB. may be NULL.
.RE
.PP
\fBReturns:\fP
.RS 4
1 on success, or 0 on failure (out of memory, or buffer to small when not allowed to realloc.) 
.RE
.PP

.PP
Definition at line 1057 of file mib.c.
.SS "int sprint_realloc_octet_string (u_char ** buf, size_t * buf_len, size_t * out_len, int allow_realloc, const \fBnetsnmp_variable_list\fP * var, const struct \fBenum_list\fP * enums, const char * hint, const char * units)"
.PP
Prints an octet string into a buffer. The \fBvariable\fP var is encoded as octet string.
.PP
If allow_realloc is true the buffer will be (re)allocated to fit in the needed size. (Note: *buf may change due to this.)
.PP
\fBParameters:\fP
.RS 4
\fIbuf\fP Address of the buffer to print to. 
.br
\fIbuf_len\fP Address to an integer containing the size of buf. 
.br
\fIout_len\fP Incremented by the number of characters printed. 
.br
\fIallow_realloc\fP if not zero reallocate the buffer to fit the needed size. 
.br
\fIvar\fP The \fBvariable\fP to encode. 
.br
\fIenums\fP The enumeration ff this \fBvariable\fP is enumerated. may be NULL. 
.br
\fIhint\fP Contents of the DISPLAY-HINT clause of the MIB. See RFC 1903 Section 3.1 for details. may be NULL. 
.br
\fIunits\fP Contents of the UNITS clause of the MIB. may be NULL.
.RE
.PP
\fBReturns:\fP
.RS 4
1 on success, or 0 on failure (out of memory, or buffer to small when not allowed to realloc.) 
.RE
.PP

.PP
Definition at line 445 of file mib.c.
.SS "int sprint_realloc_opaque (u_char ** buf, size_t * buf_len, size_t * out_len, int allow_realloc, const \fBnetsnmp_variable_list\fP * var, const struct \fBenum_list\fP * enums, const char * hint, const char * units)"
.PP
Prints an object identifier into a buffer. If allow_realloc is true the buffer will be (re)allocated to fit in the needed size. (Note: *buf may change due to this.)
.PP
\fBParameters:\fP
.RS 4
\fIbuf\fP Address of the buffer to print to. 
.br
\fIbuf_len\fP Address to an integer containing the size of buf. 
.br
\fIout_len\fP Incremented by the number of characters printed. 
.br
\fIallow_realloc\fP if not zero reallocate the buffer to fit the needed size. 
.br
\fIvar\fP The \fBvariable\fP to encode. 
.br
\fIenums\fP The enumeration ff this \fBvariable\fP is enumerated. may be NULL. 
.br
\fIhint\fP Contents of the DISPLAY-HINT clause of the MIB. See RFC 1903 Section 3.1 for details. may be NULL. 
.br
\fIunits\fP Contents of the UNITS clause of the MIB. may be NULL.
.RE
.PP
\fBReturns:\fP
.RS 4
1 on success, or 0 on failure (out of memory, or buffer to small when not allowed to realloc.) 
.RE
.PP

.PP
Definition at line 967 of file mib.c.
.SS "int sprint_realloc_timeticks (u_char ** buf, size_t * buf_len, size_t * out_len, int allow_realloc, const \fBnetsnmp_variable_list\fP * var, const struct \fBenum_list\fP * enums, const char * hint, const char * units)"
.PP
Prints a timetick \fBvariable\fP into a buffer. If allow_realloc is true the buffer will be (re)allocated to fit in the needed size. (Note: *buf may change due to this.)
.PP
\fBParameters:\fP
.RS 4
\fIbuf\fP Address of the buffer to print to. 
.br
\fIbuf_len\fP Address to an integer containing the size of buf. 
.br
\fIout_len\fP Incremented by the number of characters printed. 
.br
\fIallow_realloc\fP if not zero reallocate the buffer to fit the needed size. 
.br
\fIvar\fP The \fBvariable\fP to encode. 
.br
\fIenums\fP The enumeration ff this \fBvariable\fP is enumerated. may be NULL. 
.br
\fIhint\fP Contents of the DISPLAY-HINT clause of the MIB. See RFC 1903 Section 3.1 for details. may be NULL. 
.br
\fIunits\fP Contents of the UNITS clause of the MIB. may be NULL.
.RE
.PP
\fBReturns:\fP
.RS 4
1 on success, or 0 on failure (out of memory, or buffer to small when not allowed to realloc.) 
.RE
.PP

.PP
Definition at line 1127 of file mib.c.
.SS "int sprint_realloc_uinteger (u_char ** buf, size_t * buf_len, size_t * out_len, int allow_realloc, const \fBnetsnmp_variable_list\fP * var, const struct \fBenum_list\fP * enums, const char * hint, const char * units)"
.PP
Prints an unsigned integer into a buffer. If allow_realloc is true the buffer will be (re)allocated to fit in the needed size. (Note: *buf may change due to this.)
.PP
\fBParameters:\fP
.RS 4
\fIbuf\fP Address of the buffer to print to. 
.br
\fIbuf_len\fP Address to an integer containing the size of buf. 
.br
\fIout_len\fP Incremented by the number of characters printed. 
.br
\fIallow_realloc\fP if not zero reallocate the buffer to fit the needed size. 
.br
\fIvar\fP The \fBvariable\fP to encode. 
.br
\fIenums\fP The enumeration ff this \fBvariable\fP is enumerated. may be NULL. 
.br
\fIhint\fP Contents of the DISPLAY-HINT clause of the MIB. See RFC 1903 Section 3.1 for details. may be NULL. 
.br
\fIunits\fP Contents of the UNITS clause of the MIB. may be NULL.
.RE
.PP
\fBReturns:\fP
.RS 4
1 on success, or 0 on failure (out of memory, or buffer to small when not allowed to realloc.) 
.RE
.PP

.PP
Definition at line 1378 of file mib.c.
.SS "char* uptime_string (u_long timeticks, char * buf)"
.PP
Converts timeticks to hours, minutes, seconds string. CMU compatible does not show centiseconds.
.PP
\fBParameters:\fP
.RS 4
\fItimeticks\fP The timeticks to convert. 
.br
\fIbuf\fP Buffer to write to, has to be at least 40 Bytes large.
.RE
.PP
\fBReturns:\fP
.RS 4
The buffer
.RE
.PP
\fBSee also:\fP
.RS 4
uptimeString 
.RE
.PP

.PP
Definition at line 5952 of file mib.c.
.SH "Variable Documentation"
.PP 
.SS "\fBPrefixList\fP mib_prefixes[]"\fBInitial value:\fP
.PP
.nf
 {
    {&Standard_Prefix[0]},      
    {'.iso.org.dod.internet.mgmt.mib-2'},
    {'.iso.org.dod.internet.experimental'},
    {'.iso.org.dod.internet.private'},
    {'.iso.org.dod.internet.snmpParties'},
    {'.iso.org.dod.internet.snmpSecrets'},
    {NULL, 0}                   
}
.fi
.PP
Definition at line 178 of file mib.c.
.SH "Author"
.PP 
Generated automatically by Doxygen for net-snmp from the source code.
