From fa0427c5c0cfa0d10d23f85844cda21524c7b0e7 Mon Sep 17 00:00:00 2001
From: Ming Liu-Chan <ming.liu-chan@digi.com>
Date: Fri, 21 Oct 2022 00:01:55 -0400
Subject: [PATCH] ModemManager plugin: update cinterion plugin

Update MV31-W udev rules and retry AT port probing
---
 plugins/Makefile.am                           |   6 +
 .../77-mm-cinterion-port-types.rules          |  16 +
 .../mm-broadband-modem-mbim-cinterion.c       | 283 ++++++++++++++++++
 .../mm-broadband-modem-mbim-cinterion.h       |  47 +++
 plugins/cinterion/mm-plugin-cinterion.c       |  91 ++++--
 5 files changed, 422 insertions(+), 21 deletions(-)
 create mode 100644 plugins/cinterion/mm-broadband-modem-mbim-cinterion.c
 create mode 100644 plugins/cinterion/mm-broadband-modem-mbim-cinterion.h

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 5bbd8697..f71ada3d 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -616,6 +616,12 @@ libmm_plugin_cinterion_la_SOURCES += \
 	cinterion/mm-broadband-modem-qmi-cinterion.h \
 	$(NULL)
 endif
+if WITH_MBIM
+libmm_plugin_cinterion_la_SOURCES += \
+	cinterion/mm-broadband-modem-mbim-cinterion.c \
+	cinterion/mm-broadband-modem-mbim-cinterion.h \
+	$(NULL)
+endif
 libmm_plugin_cinterion_la_CPPFLAGS = \
 	$(PLUGIN_COMMON_COMPILER_FLAGS) \
 	-DMM_MODULE_NAME=\"cinterion\" \
diff --git a/plugins/cinterion/77-mm-cinterion-port-types.rules b/plugins/cinterion/77-mm-cinterion-port-types.rules
index f5ceee3a..af613872 100644
--- a/plugins/cinterion/77-mm-cinterion-port-types.rules
+++ b/plugins/cinterion/77-mm-cinterion-port-types.rules
@@ -44,4 +44,20 @@ ATTRS{idVendor}=="1e2d", ATTRS{idProduct}=="005d", ENV{.MM_USBIFNUM}=="04", ENV{
 ATTRS{idVendor}=="1e2d", ATTRS{idProduct}=="005d", ENV{.MM_USBIFNUM}=="06", ENV{ID_MM_PORT_IGNORE}="1"
 ATTRS{idVendor}=="1e2d", ATTRS{idProduct}=="005d", ENV{.MM_USBIFNUM}=="08", ENV{ID_MM_PORT_IGNORE}="1"
 
+# MV31-W mbim enumeration
+#  ttyACM1 (if #2): AT port
+#  ttyACM3 (if #4): NMEA/GPS port
+#  ttyACM4 (if #5): Diag port
+ATTRS{idVendor}=="1e2d", ATTRS{idProduct}=="00b3", ENV{.MM_USBIFNUM}=="02", ENV{ID_MM_PORT_TYPE_AT_PRIMARY}="1"
+ATTRS{idVendor}=="1e2d", ATTRS{idProduct}=="00b3", ENV{.MM_USBIFNUM}=="04", ENV{ID_MM_PORT_TYPE_GPS}="1"
+ATTRS{idVendor}=="1e2d", ATTRS{idProduct}=="00b3", ENV{.MM_USBIFNUM}=="05", ENV{ID_MM_PORT_IGNORE}="1"
+
+# MV31-W QMI enumeration
+#  ttyACM1 (if #1): AT port
+#  ttyACM3 (if #2): NMEA/GPS port
+#  ttyACM4 (if #3): Diag port
+ATTRS{idVendor}=="1e2d", ATTRS{idProduct}=="00b7", ENV{.MM_USBIFNUM}=="01", ENV{ID_MM_PORT_TYPE_AT_PRIMARY}="1"
+ATTRS{idVendor}=="1e2d", ATTRS{idProduct}=="00b7", ENV{.MM_USBIFNUM}=="02", ENV{ID_MM_PORT_TYPE_GPS}="1"
+ATTRS{idVendor}=="1e2d", ATTRS{idProduct}=="00b7", ENV{.MM_USBIFNUM}=="03", ENV{ID_MM_PORT_TYPE_QCDM}="1"
+
 LABEL="mm_cinterion_port_types_end"
diff --git a/plugins/cinterion/mm-broadband-modem-mbim-cinterion.c b/plugins/cinterion/mm-broadband-modem-mbim-cinterion.c
new file mode 100644
index 00000000..17ff8471
--- /dev/null
+++ b/plugins/cinterion/mm-broadband-modem-mbim-cinterion.c
@@ -0,0 +1,283 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details:
+ *
+ * Copyright (C) 2021 Aleksander Morgado <aleksander@aleksander.es>
+ */
+
+#include <config.h>
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <ctype.h>
+
+#include "ModemManager.h"
+#include "mm-log.h"
+#include "mm-errors-types.h"
+#include "mm-iface-modem-location.h"
+#include "mm-iface-modem-voice.h"
+#include "mm-iface-modem.h"
+#include "mm-modem-helpers.h"
+#include "mm-base-modem-at.h"
+#include "mm-broadband-modem-mbim-cinterion.h"
+#include "mm-shared-cinterion.h"
+
+static void iface_modem_init          (MMIfaceModem         *iface);
+static void iface_modem_location_init (MMIfaceModemLocation *iface);
+static void iface_modem_voice_init    (MMIfaceModemVoice    *iface);
+static void iface_modem_time_init     (MMIfaceModemTime     *iface);
+static void shared_cinterion_init     (MMSharedCinterion    *iface);
+
+static MMIfaceModem         *iface_modem_parent;
+static MMIfaceModemLocation *iface_modem_location_parent;
+static MMIfaceModemVoice    *iface_modem_voice_parent;
+static MMIfaceModemTime     *iface_modem_time_parent;
+
+G_DEFINE_TYPE_EXTENDED (MMBroadbandModemMbimCinterion, mm_broadband_modem_mbim_cinterion, MM_TYPE_BROADBAND_MODEM_MBIM, 0,
+                        G_IMPLEMENT_INTERFACE (MM_TYPE_IFACE_MODEM, iface_modem_init)
+                        G_IMPLEMENT_INTERFACE (MM_TYPE_IFACE_MODEM_LOCATION, iface_modem_location_init)
+                        G_IMPLEMENT_INTERFACE (MM_TYPE_IFACE_MODEM_VOICE, iface_modem_voice_init)
+                        G_IMPLEMENT_INTERFACE (MM_TYPE_IFACE_MODEM_TIME, iface_modem_time_init)
+                        G_IMPLEMENT_INTERFACE (MM_TYPE_SHARED_CINTERION, shared_cinterion_init))
+/*****************************************************************************/
+
+/* Manufacturer loading (Modem interface) */
+static gboolean
+response_processor_string_ignore_at_errors (MMBaseModem *self,
+                                            gpointer none,
+                                            const gchar *command,
+                                            const gchar *response,
+                                            gboolean last_command,
+                                            const GError *error,
+                                            GVariant **result,
+                                            GError **result_error)
+{
+    if (error) {
+        /* Ignore AT errors (ie, ERROR or CMx ERROR) */
+        if (error->domain != MM_MOBILE_EQUIPMENT_ERROR || last_command)
+            *result_error = g_error_copy (error);
+
+        return FALSE;
+    }
+
+    *result = g_variant_new_string (response);
+    return TRUE;
+}
+
+static gchar *
+sanitize_info_reply (GVariant *v, const char *prefix)
+{
+    const gchar *reply, *p;
+    gchar *sanitized;
+
+    /* Strip any leading command reply */
+    reply = g_variant_get_string (v, NULL);
+    p = strstr (reply, prefix);
+    if (p)
+        reply = p + strlen (prefix);
+    sanitized = g_strdup (reply);
+    return mm_strip_quotes (g_strstrip (sanitized));
+}
+
+/*****************************************************************************/
+/* Model loading (Modem interface) */
+
+static gchar *
+modem_load_model_finish (MMIfaceModem *self,
+                         GAsyncResult *res,
+                         GError **error)
+{
+    GVariant *result;
+    gchar *model = NULL;
+
+    result = mm_base_modem_at_sequence_finish (MM_BASE_MODEM (self), res, NULL, error);
+    if (result) {
+        model = sanitize_info_reply (result, "GMM:");
+        mm_obj_dbg (self, "loaded model: %s", model);
+    }
+    return model;
+}
+
+static const MMBaseModemAtCommand models[] = {
+        { "+GMM", 3, TRUE, response_processor_string_ignore_at_errors },
+        { "+GMM", 3, TRUE, response_processor_string_ignore_at_errors },
+        { NULL }
+};
+
+static void
+modem_load_model (MMIfaceModem *self,
+                  GAsyncReadyCallback callback,
+                  gpointer user_data)
+{
+    mm_obj_dbg (self, "loading model...");
+    mm_base_modem_at_sequence (
+            MM_BASE_MODEM (self),
+            models,
+            NULL, /* response_processor_context */
+            NULL, /* response_processor_context_free */
+            callback,
+            user_data);
+}
+
+/*****************************************************************************/
+/* Revision loading */
+
+static gchar *
+modem_load_revision_finish (MMIfaceModem *self,
+                            GAsyncResult *res,
+                            GError **error)
+{
+    GVariant *result;
+    gchar *revision = NULL;
+
+    result = mm_base_modem_at_sequence_finish (MM_BASE_MODEM (self), res, NULL, error);
+    if (result) {
+        revision = sanitize_info_reply (result, "VERSION:");
+        mm_obj_dbg (self, "loaded revision: %s", revision);
+    }
+    return revision;
+}
+
+static const MMBaseModemAtCommand revisions[] = {
+        { "^VERSION?",  3, TRUE, response_processor_string_ignore_at_errors },
+        { NULL }
+};
+
+static void
+modem_load_revision (MMIfaceModem *self,
+                     GAsyncReadyCallback callback,
+                     gpointer user_data)
+{
+    mm_obj_dbg (self, "loading revision...");
+    mm_base_modem_at_sequence (
+            MM_BASE_MODEM (self),
+            revisions,
+            NULL, /* response_processor_context */
+            NULL, /* response_processor_context_free */
+            callback,
+            user_data);
+}
+
+/*****************************************************************************/
+
+MMBroadbandModemMbimCinterion *
+mm_broadband_modem_mbim_cinterion_new (const gchar *device,
+                                       const gchar **drivers,
+                                       const gchar *plugin,
+                                       guint16 vendor_id,
+                                       guint16 product_id)
+{
+    return g_object_new (MM_TYPE_BROADBAND_MODEM_MBIM_CINTERION,
+                         MM_BASE_MODEM_DEVICE, device,
+                         MM_BASE_MODEM_DRIVERS, drivers,
+                         MM_BASE_MODEM_PLUGIN, plugin,
+                         MM_BASE_MODEM_VENDOR_ID, vendor_id,
+                         MM_BASE_MODEM_PRODUCT_ID, product_id,
+                         NULL);
+}
+
+static void
+mm_broadband_modem_mbim_cinterion_init (MMBroadbandModemMbimCinterion *self)
+{
+}
+
+static void
+iface_modem_init (MMIfaceModem *iface)
+{
+    iface_modem_parent = g_type_interface_peek_parent (iface);
+
+    iface->load_model = modem_load_model;
+    iface->load_model_finish = modem_load_model_finish;
+    iface->load_revision = modem_load_revision;
+    iface->load_revision_finish = modem_load_revision_finish;
+}
+
+static MMIfaceModem *
+peek_parent_interface (MMSharedCinterion *self)
+{
+    return iface_modem_parent;
+}
+
+static void
+iface_modem_location_init (MMIfaceModemLocation *iface)
+{
+    iface_modem_location_parent = g_type_interface_peek_parent (iface);
+
+    iface->load_capabilities                 = mm_shared_cinterion_location_load_capabilities;
+    iface->load_capabilities_finish          = mm_shared_cinterion_location_load_capabilities_finish;
+    iface->enable_location_gathering         = mm_shared_cinterion_enable_location_gathering;
+    iface->enable_location_gathering_finish  = mm_shared_cinterion_enable_location_gathering_finish;
+    iface->disable_location_gathering        = mm_shared_cinterion_disable_location_gathering;
+    iface->disable_location_gathering_finish = mm_shared_cinterion_disable_location_gathering_finish;
+}
+
+static MMIfaceModemLocation *
+peek_parent_location_interface (MMSharedCinterion *self)
+{
+    return iface_modem_location_parent;
+}
+
+static void
+iface_modem_voice_init (MMIfaceModemVoice *iface)
+{
+    iface_modem_voice_parent = g_type_interface_peek_parent (iface);
+
+    iface->create_call = mm_shared_cinterion_create_call;
+
+    iface->check_support                     = mm_shared_cinterion_voice_check_support;
+    iface->check_support_finish              = mm_shared_cinterion_voice_check_support_finish;
+    iface->enable_unsolicited_events         = mm_shared_cinterion_voice_enable_unsolicited_events;
+    iface->enable_unsolicited_events_finish  = mm_shared_cinterion_voice_enable_unsolicited_events_finish;
+    iface->disable_unsolicited_events        = mm_shared_cinterion_voice_disable_unsolicited_events;
+    iface->disable_unsolicited_events_finish = mm_shared_cinterion_voice_disable_unsolicited_events_finish;
+    iface->setup_unsolicited_events          = mm_shared_cinterion_voice_setup_unsolicited_events;
+    iface->setup_unsolicited_events_finish   = mm_shared_cinterion_voice_setup_unsolicited_events_finish;
+    iface->cleanup_unsolicited_events        = mm_shared_cinterion_voice_cleanup_unsolicited_events;
+    iface->cleanup_unsolicited_events_finish = mm_shared_cinterion_voice_cleanup_unsolicited_events_finish;
+}
+
+static MMIfaceModemVoice *
+peek_parent_voice_interface (MMSharedCinterion *self)
+{
+    return iface_modem_voice_parent;
+}
+
+static void
+iface_modem_time_init (MMIfaceModemTime *iface)
+{
+    iface_modem_time_parent = g_type_interface_peek_parent (iface);
+
+    iface->setup_unsolicited_events          = mm_shared_cinterion_time_setup_unsolicited_events;
+    iface->setup_unsolicited_events_finish   = mm_shared_cinterion_time_setup_unsolicited_events_finish;
+    iface->cleanup_unsolicited_events        = mm_shared_cinterion_time_cleanup_unsolicited_events;
+    iface->cleanup_unsolicited_events_finish = mm_shared_cinterion_time_cleanup_unsolicited_events_finish;
+}
+
+static MMIfaceModemTime *
+peek_parent_time_interface (MMSharedCinterion *self)
+{
+    return iface_modem_time_parent;
+}
+
+static void
+shared_cinterion_init (MMSharedCinterion *iface)
+{
+    iface->peek_parent_location_interface = peek_parent_location_interface;
+    iface->peek_parent_voice_interface    = peek_parent_voice_interface;
+    iface->peek_parent_time_interface     = peek_parent_time_interface;
+}
+
+static void
+mm_broadband_modem_mbim_cinterion_class_init (MMBroadbandModemMbimCinterionClass *klass)
+{
+}
diff --git a/plugins/cinterion/mm-broadband-modem-mbim-cinterion.h b/plugins/cinterion/mm-broadband-modem-mbim-cinterion.h
new file mode 100644
index 00000000..a2f2ef68
--- /dev/null
+++ b/plugins/cinterion/mm-broadband-modem-mbim-cinterion.h
@@ -0,0 +1,47 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details:
+ *
+ * Copyright (C) 2021 Aleksander Morgado <aleksander@aleksander.es>
+ */
+
+#ifndef MM_BROADBAND_MODEM_MBIM_CINTERION_MBIM_H
+#define MM_BROADBAND_MODEM_MBIM_CINTERION_MBIM_H
+
+#include "mm-broadband-modem-mbim.h"
+
+#define MM_TYPE_BROADBAND_MODEM_MBIM_CINTERION            (mm_broadband_modem_mbim_cinterion_get_type ())
+#define MM_BROADBAND_MODEM_MBIM_CINTERION(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), MM_TYPE_BROADBAND_MODEM_MBIM_CINTERION, MMBroadbandModemMbimCinterion))
+#define MM_BROADBAND_MODEM_MBIM_CINTERION_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass),  MM_TYPE_BROADBAND_MODEM_MBIM_CINTERION, MMBroadbandModemMbimCinterionClass))
+#define MM_IS_BROADBAND_MODEM_MBIM_CINTERION(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MM_TYPE_BROADBAND_MODEM_MBIM_CINTERION))
+#define MM_IS_BROADBAND_MODEM_MBIM_CINTERION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass),  MM_TYPE_BROADBAND_MODEM_MBIM_CINTERION))
+#define MM_BROADBAND_MODEM_MBIM_CINTERION_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj),  MM_TYPE_BROADBAND_MODEM_MBIM_CINTERION, MMBroadbandModemMbimCinterionClass))
+
+typedef struct _MMBroadbandModemMbimCinterion MMBroadbandModemMbimCinterion;
+typedef struct _MMBroadbandModemMbimCinterionClass MMBroadbandModemMbimCinterionClass;
+
+struct _MMBroadbandModemMbimCinterion {
+    MMBroadbandModemMbim parent;
+};
+
+struct _MMBroadbandModemMbimCinterionClass{
+    MMBroadbandModemMbimClass parent;
+};
+
+GType mm_broadband_modem_mbim_cinterion_get_type (void);
+
+MMBroadbandModemMbimCinterion *mm_broadband_modem_mbim_cinterion_new (const gchar  *device,
+                                                                      const gchar **drivers,
+                                                                      const gchar  *plugin,
+                                                                      guint16       vendor_id,
+                                                                      guint16       product_id);
+
+#endif /* MM_BROADBAND_MODEM_MBIM_CINTERION_H */
diff --git a/plugins/cinterion/mm-plugin-cinterion.c b/plugins/cinterion/mm-plugin-cinterion.c
index f2eb5d73..9d4b52ed 100644
--- a/plugins/cinterion/mm-plugin-cinterion.c
+++ b/plugins/cinterion/mm-plugin-cinterion.c
@@ -36,7 +36,7 @@
 #endif
 
 #if defined WITH_MBIM
-#include "mm-broadband-modem-mbim.h"
+#include "mm-broadband-modem-mbim-cinterion.h"
 #endif
 
 G_DEFINE_TYPE (MMPluginCinterion, mm_plugin_cinterion, MM_TYPE_PLUGIN)
@@ -50,6 +50,19 @@ MM_PLUGIN_DEFINE_MINOR_VERSION
 #define TAG_CINTERION_APP_PORT   "cinterion-app-port"
 #define TAG_CINTERION_MODEM_PORT "cinterion-modem-port"
 
+typedef struct {
+    MMPortSerialAt *port;
+    guint port_responsive_retries;
+} CinterionCustomInitContext;
+
+static void
+cinterion_custom_init_context_free (CinterionCustomInitContext *ctx)
+{
+    g_object_unref (ctx->port);
+    g_slice_free (CinterionCustomInitContext, ctx);
+
+}
+
 static gboolean
 cinterion_custom_init_finish (MMPortProbe   *probe,
                               GAsyncResult  *result,
@@ -58,6 +71,9 @@ cinterion_custom_init_finish (MMPortProbe   *probe,
     return g_task_propagate_boolean (G_TASK (result), error);
 }
 
+static void
+wait_for_sqport (GTask *task);
+
 static void
 sqport_ready (MMPortSerialAt *port,
               GAsyncResult   *res,
@@ -65,12 +81,22 @@ sqport_ready (MMPortSerialAt *port,
 {
     MMPortProbe *probe;
     const gchar *response;
+    GError *error = NULL;
 
     probe = g_task_get_source_object (task);
 
-    /* Ignore errors, just avoid tagging */
-    response = mm_port_serial_at_command_finish (port, res, NULL);
-    if (response) {
+    response = mm_port_serial_at_command_finish (port, res, &error);
+    if (error) {
+        /* On a timeout or send error, wait */
+        if (g_error_matches (error, MM_SERIAL_ERROR, MM_SERIAL_ERROR_RESPONSE_TIMEOUT) ||
+            g_error_matches (error, MM_SERIAL_ERROR, MM_SERIAL_ERROR_SEND_FAILED)) {
+            wait_for_sqport (task);
+            return;
+        }
+
+        mm_obj_warn (probe, "port initialization logic failed: %s", error->message);
+    }
+    else if (response) {
         /* A valid reply to AT^SQPORT tells us this is an AT port already */
         mm_port_probe_set_result_at (probe, TRUE);
 
@@ -84,6 +110,31 @@ sqport_ready (MMPortSerialAt *port,
     g_object_unref (task);
 }
 
+static void
+wait_for_sqport (GTask *task)
+{
+    CinterionCustomInitContext *ctx;
+
+    ctx = g_task_get_task_data (task);
+
+    if (ctx->port_responsive_retries == 0) {
+        g_task_return_boolean (task, TRUE);
+        g_object_unref (task);
+        return;
+    }
+    ctx->port_responsive_retries--;
+
+    mm_port_serial_at_command (
+        ctx->port,
+        "AT^SQPORT?",
+        5,
+        FALSE, /* raw */
+        FALSE, /* allow_cached */
+        g_task_get_cancellable (task),
+        (GAsyncReadyCallback) sqport_ready,
+        task);
+}
+
 static void
 cinterion_custom_init (MMPortProbe         *probe,
                        MMPortSerialAt      *port,
@@ -91,23 +142,21 @@ cinterion_custom_init (MMPortProbe         *probe,
                        GAsyncReadyCallback  callback,
                        gpointer             user_data)
 {
+    CinterionCustomInitContext *ctx;
     GTask *task;
 
+    ctx = g_slice_new (CinterionCustomInitContext);
+    ctx->port = g_object_ref (port);
+    ctx->port_responsive_retries = 5;
     task = g_task_new (probe, cancellable, callback, user_data);
+    g_task_set_check_cancellable (task, FALSE);
+    g_task_set_task_data (task, ctx, (GDestroyNotify)cinterion_custom_init_context_free);
 
-    mm_port_serial_at_command (
-        port,
-        "AT^SQPORT?",
-        3,
-        FALSE, /* raw */
-        FALSE, /* allow cached */
-        cancellable,
-        (GAsyncReadyCallback) sqport_ready,
-        task);
+    mm_obj_dbg (probe, "Start polling for port type....");
+    wait_for_sqport (task);
 }
 
 /*****************************************************************************/
-
 static MMBaseModem *
 create_modem (MMPlugin *self,
               const gchar *uid,
@@ -131,11 +180,11 @@ create_modem (MMPlugin *self,
 #if defined WITH_MBIM
     if (mm_port_probe_list_has_mbim_port (probes)) {
         mm_obj_dbg (self, "MBIM-powered Cinterion modem found...");
-        return MM_BASE_MODEM (mm_broadband_modem_mbim_new (uid,
-                                                           drivers,
-                                                           mm_plugin_get_name (self),
-                                                           vendor,
-                                                           product));
+        return MM_BASE_MODEM (mm_broadband_modem_mbim_cinterion_new (uid,
+                                                                     drivers,
+                                                                     mm_plugin_get_name (self),
+                                                                     vendor,
+                                                                     product));
     }
 #endif
 
@@ -181,8 +230,8 @@ grab_port (MMPlugin *self,
 G_MODULE_EXPORT MMPlugin *
 mm_plugin_create (void)
 {
-    static const gchar *subsystems[] = { "tty", "net", "usb", NULL };
-    static const gchar *vendor_strings[] = { "cinterion", "siemens", NULL };
+    static const gchar *subsystems[] = { "tty", "net", "usbmisc", NULL };
+    static const gchar *vendor_strings[] = { "cinterion", "siemens", "thales", NULL };
     static const guint16 vendor_ids[] = { 0x1e2d, 0x0681, 0 };
     static const MMAsyncMethod custom_init = {
         .async  = G_CALLBACK (cinterion_custom_init),
-- 
2.25.1

