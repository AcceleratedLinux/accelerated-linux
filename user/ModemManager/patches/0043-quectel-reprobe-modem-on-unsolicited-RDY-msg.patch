From 63daff92e0cee67feb7bd950a107cc0096ca672c Mon Sep 17 00:00:00 2001
From: Samuel Brian <samuel.brian@digi.com>
Date: Thu, 6 May 2021 10:17:14 +1000
Subject: quectel: reprobe modem on unsolicited RDY msg

There are reports of the Quectel EG25G performing an internal reset for
unknown reasons, which causes the modem to reset without dropping off
the USB bus. ModemManager does not notice that the modem has reset,
and continues with stale QMI sessions that no longer work.

ModemManager debug logs from when this occur look like this:

    <debug> [000253.216561] [modem1/ttyUSB3/at] <-- '<CR><LF>RDY<CR><LF>'
    <debug> [000253.217746] [modem1/ttyUSB2/at] <-- '<CR><LF>RDY<CR><LF>'
    <debug> [000253.244104] [modem1/ttyUSB2/at] <-- '<CR><LF>+CPIN: READY<CR><LF>'
    <debug> [000253.266475] [modem1/ttyUSB2/at] <-- '<CR><LF>+QUSIM: 1<CR><LF>'
    <debug> [000253.266664] [modem1] (quectel) checking SIM swap
    <debug> [000253.266745] [modem1] checking if SIM was swapped...
    <debug> [000253.266909] [modem1/sim1] loading SIM identifier...
    ...
    transaction 0x405 aborted, but message is not abortable
    <warn>  [000261.008737] [modem1/bearer1] reloading stats failed: QMI operation failed: Transaction timed out

It can be detected by handling the unsolicited "RDY" message on the AT
ports that is sent when the modem starts up. Making ModemManager reprobe
the modem gets it working again.

This patch hijacks the Quectel SIM hot swap setup which already sets an
unsolicited message handler, for lack of a more appropriate place
currently.
Adding the message handler happens late enough after the initial probe
(after e.g. a hardware reset), so that any first RDY does not trigger the
reprobe.
---
 plugins/quectel/mm-shared-quectel.c | 35 +++++++++++++++++++++++++++++
 1 file changed, 35 insertions(+)

diff --git a/plugins/quectel/mm-shared-quectel.c b/plugins/quectel/mm-shared-quectel.c
index 76107e79..7188b773 100644
--- a/plugins/quectel/mm-shared-quectel.c
+++ b/plugins/quectel/mm-shared-quectel.c
@@ -112,6 +112,18 @@ quectel_qusim_unsolicited_handler (MMPortSerialAt *port,
     }
 }
 
+static void
+quectel_rdy_unsolicited_handler (MMPortSerialAt *port,
+                                 GMatchInfo *match_info,
+                                 MMIfaceModem* self)
+{
+    mm_obj_info (self,
+                "internal modem reset detected by unsolicited RDY, reprobing");
+
+    mm_base_modem_set_reprobe (MM_BASE_MODEM (self), TRUE);
+    mm_base_modem_set_valid (MM_BASE_MODEM (self), FALSE);
+}
+
 gboolean
 mm_shared_quectel_setup_sim_hot_swap_finish (MMIfaceModem *self,
                                              GAsyncResult *res,
@@ -156,6 +168,29 @@ mm_shared_quectel_setup_sim_hot_swap (MMIfaceModem *self,
 
     g_regex_unref (pattern);
     mm_obj_dbg (self, "+QUSIM detection set up");
+
+    pattern = g_regex_new ("RDY\\r\\n", G_REGEX_RAW, 0, NULL);
+    g_assert (pattern);
+
+    if (port_primary)
+        mm_port_serial_at_add_unsolicited_msg_handler (
+            port_primary,
+            pattern,
+            (MMPortSerialAtUnsolicitedMsgFn)quectel_rdy_unsolicited_handler,
+            self,
+            NULL);
+
+    if (port_secondary)
+        mm_port_serial_at_add_unsolicited_msg_handler (
+            port_secondary,
+            pattern,
+            (MMPortSerialAtUnsolicitedMsgFn)quectel_rdy_unsolicited_handler,
+            self,
+            NULL);
+
+    g_regex_unref (pattern);
+    mm_obj_dbg (self, "RDY detection set up");
+
     g_task_return_boolean (task, TRUE);
     g_object_unref (task);
 }
