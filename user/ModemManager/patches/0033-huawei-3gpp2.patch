Add Huawei 3GPP2 SMS support

The Huawei ME209u-526 is a band 4 and 13 LTE modem that does not use
the GSM 07.05 standard AT commands for SMS operations.  Instead, it uses
the "Huawei Proprietary Interface IMS Short Message (3GPP2)" command set
(see "HUAWEI ME209u-526 LTE Module AT Command Interface Specification").

The proprietary messages turn out to be mostly compatible with GSM 07.05
commands, except that they begin with "^H".

commit 1a56757e0387e92189d4232da68b3020cc60e999
Author: Peter Hunt <peter.hunt@opengear.com>
Date:   Thu May 28 07:47:51 2015 +1000

    OG-1230 Add Huawei 3GPP2 SMS support

Index: ModemManager/src/mm-modem-helpers.h
===================================================================
--- ModemManager.orig/src/mm-modem-helpers.h
+++ ModemManager/src/mm-modem-helpers.h
@@ -347,6 +347,7 @@ typedef struct {
     gint index;
     gint status;
     gchar *pdu;
+    gboolean is_huawei_sms; /* AT^HCMGR */
 } MM3gppPduInfo;
 void   mm_3gpp_pdu_info_free           (MM3gppPduInfo *info);
 void   mm_3gpp_pdu_info_list_free      (GList *info_list);
Index: ModemManager/src/mm-modem-helpers.c
===================================================================
--- ModemManager.orig/src/mm-modem-helpers.c
+++ ModemManager/src/mm-modem-helpers.c
@@ -919,7 +919,7 @@ mm_3gpp_cusd_regex_get (void)
 GRegex *
 mm_3gpp_cmti_regex_get (void)
 {
-    return g_regex_new ("\\r\\n\\+CMTI:\\s*\"(\\S+)\",\\s*(\\d+)\\r\\n",
+    return g_regex_new ("\\r\\n(?:\\+CMTI|\\^HCMTI):\\s*\"([^\"]*)\",\\s*(\\d+)\\r\\n",
                         G_REGEX_RAW | G_REGEX_OPTIMIZE,
                         0,
                         NULL);
@@ -931,7 +931,7 @@ mm_3gpp_cds_regex_get (void)
     /* Example:
      * <CR><LF>+CDS: 24<CR><LF>07914356060013F10659098136395339F6219011707193802190117071938030<CR><LF>
      */
-    return g_regex_new ("\\r\\n\\+CDS:\\s*(\\d+)\\r\\n(.*)\\r\\n",
+    return g_regex_new ("\\r\\n(?:\\+CDS|\\^HCDS):\\s*(\\d+)\\r\\n(.*)\\r\\n",
                         G_REGEX_RAW | G_REGEX_OPTIMIZE,
                         0,
                         NULL);
@@ -2098,7 +2098,7 @@ mm_3gpp_parse_cmgr_read_response (const
 
     /* +CMGR: <stat>,<alpha>,<length>(whitespace)<pdu> */
     /* The <alpha> and <length> fields are matched, but not currently used */
-    r = g_regex_new ("\\+CMGR:\\s*(\\d+)\\s*,([^,]*),\\s*(\\d+)\\s*([^\\r\\n]*)", 0, 0, NULL);
+    r = g_regex_new ("(?:\\+CMGR|\\^HCMGR):\\s*(\\d+)\\s*,([^,]*),\\s*(\\d+)\\s*([^\\r\\n]*)", 0, 0, NULL);
     g_assert (r);
 
     if (!g_regex_match (r, reply, 0, &match_info)) {
@@ -2145,6 +2145,7 @@ mm_3gpp_parse_cmgr_read_response (const
     info->index = index;
     info->status = status;
     info->pdu = pdu;
+    info->is_huawei_sms = (*g_match_info_fetch (match_info, 0) == '^');
 
 done:
     g_match_info_free (match_info);
Index: ModemManager/src/mm-base-sms.c
===================================================================
--- ModemManager.orig/src/mm-base-sms.c
+++ ModemManager/src/mm-base-sms.c
@@ -26,10 +26,12 @@
 #define _LIBMM_INSIDE_MM
 #include <libmm-glib.h>
 
+#define MM_LOG_NO_OBJECT        /* for mm_dbg() */
 #include "mm-base-sms.h"
 #include "mm-broadband-modem.h"
 #include "mm-iface-modem.h"
 #include "mm-iface-modem-messaging.h"
+#include "mm-sms-part-cdma.h"
 #include "mm-sms-part-3gpp.h"
 #include "mm-base-modem-at.h"
 #include "mm-base-modem.h"
@@ -297,6 +299,7 @@ generate_submit_pdus (MMBaseSms *self,
 {
     MMBaseModem *modem;
     gboolean is_3gpp;
+    gboolean is_huawei_sms;
 
     /* First; decide which kind of PDU we'll generate, based on the current modem caps */
 
@@ -306,10 +309,12 @@ generate_submit_pdus (MMBaseSms *self,
     g_assert (modem != NULL);
 
     is_3gpp = mm_iface_modem_is_3gpp (MM_IFACE_MODEM (modem));
+    is_huawei_sms = mm_iface_modem_is_huawei_sms (MM_IFACE_MODEM (modem));
     g_object_unref (modem);
 
     /* On a 3GPP-capable modem, create always a 3GPP SMS (even if the modem is 3GPP+3GPP2) */
     if (is_3gpp)
+      if (!is_huawei_sms)       /* Unless device forces 3GPP2/CDMA messaging */
         return generate_3gpp_submit_pdus (self, error);
 
     /* Otherwise, create a 3GPP2 SMS */
@@ -775,6 +780,7 @@ sms_get_store_or_send_command (MMBaseSms
                                MMSmsPart  *part,
                                gboolean    text_or_pdu,   /* TRUE for PDU */
                                gboolean    store_or_send, /* TRUE for send */
+                               gboolean    is_huawei_sms,
                                gchar     **out_cmd,
                                gchar     **out_msg_data,
                                GError    **error)
@@ -784,9 +790,15 @@ sms_get_store_or_send_command (MMBaseSms
 
     if (!text_or_pdu) {
         /* Text mode */
+      if (is_huawei_sms) {
+        *out_cmd = g_strdup_printf ("^HCMG%c=\"%s\"",
+                                    store_or_send ? 'S' : 'W',
+                                    mm_sms_part_get_number (part));
+      } else {
         *out_cmd = g_strdup_printf ("+CMG%c=\"%s\"",
                                     store_or_send ? 'S' : 'W',
                                     mm_sms_part_get_number (part));
+      }
         *out_msg_data = g_strdup_printf ("%s\x1a", mm_sms_part_get_text (part));
     } else {
         guint8 *pdu;
@@ -814,9 +826,15 @@ sms_get_store_or_send_command (MMBaseSms
         }
 
         /* CMGW/S length is the size of the PDU without SMSC information */
+      if (is_huawei_sms) {
+        *out_cmd = g_strdup_printf ("^HCMG%c=%d",
+                                     store_or_send ? 'S' : 'W',
+                                     pdulen - msgstart);
+      } else {
         *out_cmd = g_strdup_printf ("+CMG%c=%d",
                                     store_or_send ? 'S' : 'W',
                                     pdulen - msgstart);
+      }
         *out_msg_data = g_strdup_printf ("%s\x1a", hex);
         g_free (hex);
     }
@@ -947,10 +965,12 @@ sms_store_next_part (GTask *task)
 
     g_clear_pointer (&ctx->msg_data, g_free);
 
+    gboolean is_huawei_sms = mm_iface_modem_is_huawei_sms (MM_IFACE_MODEM (ctx->modem));
     if (!sms_get_store_or_send_command (self,
                                         (MMSmsPart *)ctx->current->data,
                                         ctx->use_pdu_mode,
                                         FALSE,
+                                        is_huawei_sms,
                                         &cmd,
                                         &ctx->msg_data,
                                         &error)) {
@@ -1074,6 +1094,19 @@ read_message_reference_from_reply (const
         rv = sscanf (strstr (response, "+CMGS"), "+CMGS: %d", &idx);
     else if (strstr (response, "+CMSS"))
         rv = sscanf (strstr (response, "+CMSS"), "+CMSS: %d", &idx);
+    else if (strstr (response, "^HCMGS"))
+        rv = sscanf (strstr (response, "^HCMGS"), "^HCMGS:%d", &idx);
+    else if (strlen(response) == 0) {
+        /*
+         * read_message_reference_from_reply(): response: ''
+         * _close_internal(): (ttyUSB0) device open count is 1 (close)
+         * debug_log(): (ttyUSB2): <-- '<CR><LF>^HCMGS:0<CR><LF>'
+         * debug_log(): (ttyUSB0): <-- '<CR><LF>^HCMGS:0<CR><LF>'
+         */
+        mm_dbg("No response read from modem, this needs investigation");
+        idx = 0;
+        rv = 1;
+    }
 
     if (rv != 1 || idx < 0) {
         g_set_error (error,
@@ -1231,10 +1264,12 @@ sms_send_next_part (GTask *task)
 
     g_clear_pointer (&ctx->msg_data, g_free);
 
+    gboolean is_huawei_sms = mm_iface_modem_is_huawei_sms (MM_IFACE_MODEM (ctx->modem));
     if (!sms_get_store_or_send_command (self,
                                         (MMSmsPart *)ctx->current->data,
                                         ctx->use_pdu_mode,
                                         TRUE,
+                                        is_huawei_sms,
                                         &cmd,
                                         &ctx->msg_data,
                                         &error)) {
@@ -1403,8 +1438,14 @@ delete_next_part (GTask *task)
         return;
     }
 
+  gboolean is_huawei_sms = mm_iface_modem_is_huawei_sms (MM_IFACE_MODEM (ctx->modem));
+  if (is_huawei_sms) {
+    cmd = g_strdup_printf ("^HCMGD=%d",
+                           mm_sms_part_get_index ((MMSmsPart *)ctx->current->data));
+  } else {
     cmd = g_strdup_printf ("+CMGD=%d",
                            mm_sms_part_get_index ((MMSmsPart *)ctx->current->data));
+  }
     mm_base_modem_at_command (ctx->modem,
                               cmd,
                               10,
@@ -1463,6 +1504,7 @@ sms_delete (MMBaseSms *self,
     }
 
     /* Select specific storage to delete from */
+    mm_obj_dbg (self, "storage type for sms is: %d", mm_base_sms_get_storage(self));
     mm_broadband_modem_lock_sms_storages (
         MM_BROADBAND_MODEM (self->priv->modem),
         mm_base_sms_get_storage (self),
Index: ModemManager/src/mm-broadband-modem.c
===================================================================
--- ModemManager.orig/src/mm-broadband-modem.c
+++ ModemManager/src/mm-broadband-modem.c
@@ -6365,11 +6365,13 @@ modem_messaging_load_supported_storages
                                          gpointer user_data)
 {
     GTask *task;
+    gboolean is_huawei_sms = mm_iface_modem_is_huawei_sms (MM_IFACE_MODEM(self));
 
     task = g_task_new (self, NULL, callback, user_data);
 
     /* Check support storages */
     mm_base_modem_at_command (MM_BASE_MODEM (self),
+              is_huawei_sms ? "^HCPMS=?" :
                               "+CPMS=?",
                               3,
                               TRUE,
@@ -6611,10 +6613,20 @@ mm_broadband_modem_lock_sms_storages (MM
     mm_obj_dbg (self, "locking SMS storages to: mem1 (%s), mem2 (%s)...",
                 mem1_str, mem2_str ? mem2_str : "none");
 
+    gboolean is_huawei_sms = mm_iface_modem_is_huawei_sms (MM_IFACE_MODEM(self));
+
     if (mem2_str)
+      if (is_huawei_sms) {
+        cmd = g_strdup_printf ("^HCPMS=\"%s\",\"%s\"", mem1_str, mem2_str);
+      } else {
         cmd = g_strdup_printf ("+CPMS=\"%s\",\"%s\"", mem1_str, mem2_str);
+      }
     else
+      if (is_huawei_sms) {
+        cmd = g_strdup_printf ("^HCPMS=\"%s\"", mem1_str);
+      } else {
         cmd = g_strdup_printf ("+CPMS=\"%s\"", mem1_str);
+      }
 
     mm_base_modem_at_command (MM_BASE_MODEM (self),
                               cmd,
@@ -6683,7 +6695,12 @@ modem_messaging_set_default_storage (MMI
     mem1_str = g_ascii_strup (mm_sms_storage_get_string (self->priv->current_sms_mem1_storage), -1);
     mem_str = g_ascii_strup (mm_sms_storage_get_string (storage), -1);
 
+  gboolean is_huawei_sms = mm_iface_modem_is_huawei_sms (MM_IFACE_MODEM(self));
+  if (is_huawei_sms) {
+    cmd = g_strdup_printf ("^HCPMS=\"\",\"%s\",\"%s\"", mem_str, mem_str);
+  } else {
     cmd = g_strdup_printf ("+CPMS=\"%s\",\"%s\",\"%s\"", mem1_str, mem_str, mem_str);
+  }
 
     task = g_task_new (self, NULL, callback, user_data);
 
@@ -6820,6 +6837,7 @@ modem_messaging_setup_cleanup_unsolicite
 
 typedef struct {
     guint idx;
+    MMSmsStorage storage;
 } SmsPartContext;
 
 static void
@@ -6856,13 +6874,19 @@ sms_part_ready (MMBroadbandModem *self,
         return;
     }
 
+  if (info->is_huawei_sms) {
+    part = mm_sms_part_cdma_new_from_pdu (info->index, info->pdu, self, &error);
+  } else {
     part = mm_sms_part_3gpp_new_from_pdu (info->index, info->pdu, self, &error);
+  }
     if (part) {
         mm_obj_dbg (self, "correctly parsed PDU (%d)", ctx->idx);
+        mm_obj_dbg (self, "with storage type (%d) default is (%d)",
+                ctx->storage, self->priv->modem_messaging_sms_default_storage);
         mm_iface_modem_messaging_take_part (MM_IFACE_MODEM_MESSAGING (self),
                                             part,
                                             MM_SMS_STATE_RECEIVED,
-                                            self->priv->modem_messaging_sms_default_storage);
+                                            ctx->storage);
     } else {
         /* Don't treat the error as critical */
         mm_obj_dbg (self, "error parsing PDU (%d): %s", ctx->idx, error->message);
@@ -6893,10 +6917,16 @@ indication_lock_storages_ready (MMBroadb
     }
 
     /* Storage now set and locked */
+    mm_obj_dbg(self, "Reading message %d from storage: %d", ctx->idx, ctx->storage);
 
     /* Retrieve the message */
     ctx = g_task_get_task_data (task);
+  gboolean is_huawei_sms = mm_iface_modem_is_huawei_sms (MM_IFACE_MODEM(self));
+  if (is_huawei_sms) {
+    command = g_strdup_printf ("^HCMGR=%d", ctx->idx);
+  } else {
     command = g_strdup_printf ("+CMGR=%d", ctx->idx);
+  }
     mm_base_modem_at_command (MM_BASE_MODEM (self),
                               command,
                               10,
@@ -6938,8 +6968,10 @@ cmti_received (MMPortSerialAt *port,
         return;
     }
 
+    mm_obj_dbg (self, "Remeber PDU (%d) storage type (%d)", idx, storage);
     ctx = g_new (SmsPartContext, 1);
     ctx->idx = idx;
+    ctx->storage = storage;
 
     task = g_task_new (self, NULL, NULL, NULL);
     g_task_set_task_data (task, ctx, g_free);
@@ -6971,7 +7003,12 @@ cds_received (MMPortSerialAt *port,
     if (!pdu)
         return;
 
+  gboolean is_huawei_sms = mm_iface_modem_is_huawei_sms (MM_IFACE_MODEM(self));
+  if (is_huawei_sms) {
+    part = mm_sms_part_cdma_new_from_pdu (SMS_PART_INVALID_INDEX, pdu, self, &error);
+  } else {
     part = mm_sms_part_3gpp_new_from_pdu (SMS_PART_INVALID_INDEX, pdu, self, &error);
+  }
     if (part) {
         mm_obj_dbg (self, "correctly parsed non-stored PDU");
         mm_iface_modem_messaging_take_part (MM_IFACE_MODEM_MESSAGING (self),
@@ -6996,6 +7033,9 @@ set_messaging_unsolicited_events_handler
     GRegex *cds_regex;
     guint i;
     GTask *task;
+    const gchar *model;
+
+    model = mm_iface_modem_get_model (MM_IFACE_MODEM (self));
 
     cmti_regex = mm_3gpp_cmti_regex_get ();
     cds_regex = mm_3gpp_cds_regex_get ();
@@ -7396,12 +7436,17 @@ sms_pdu_part_list_ready (MMBroadbandMode
     }
 
     ctx = g_task_get_task_data (task);
+    gboolean is_huawei_sms = mm_iface_modem_is_huawei_sms (MM_IFACE_MODEM(self));
 
     for (l = info_list; l; l = g_list_next (l)) {
         MM3gppPduInfo *info = l->data;
         MMSmsPart *part;
 
+      if (is_huawei_sms) {
+        part = mm_sms_part_cdma_new_from_pdu (info->index, info->pdu, self, &error);
+      } else {
         part = mm_sms_part_3gpp_new_from_pdu (info->index, info->pdu, self, &error);
+      }
         if (part) {
             mm_obj_dbg (self, "correctly parsed PDU (%d)", info->index);
             mm_iface_modem_messaging_take_part (MM_IFACE_MODEM_MESSAGING (self),
@@ -10463,8 +10508,7 @@ disabling_context_free (DisablingContext
         mm_iface_modem_update_state (MM_IFACE_MODEM (ctx->self),
                                      MM_MODEM_STATE_DISABLED,
                                      MM_MODEM_STATE_CHANGE_REASON_USER_REQUESTED);
-    else if (ctx->previous_state != MM_MODEM_STATE_DISABLED &&
-             ctx->previous_state != MM_MODEM_STATE_UNKNOWN) {
+    else if (ctx->previous_state != MM_MODEM_STATE_DISABLED) {
         /* Fallback to previous state */
         mm_iface_modem_update_state (MM_IFACE_MODEM (ctx->self),
                                      ctx->previous_state,
@@ -10831,8 +10875,7 @@ enabling_context_free (EnablingContext *
         mm_iface_modem_update_state (MM_IFACE_MODEM (ctx->self),
                                      MM_MODEM_STATE_ENABLED,
                                      MM_MODEM_STATE_CHANGE_REASON_USER_REQUESTED);
-    else if (ctx->previous_state != MM_MODEM_STATE_ENABLED &&
-             ctx->previous_state != MM_MODEM_STATE_UNKNOWN) {
+    else if (ctx->previous_state != MM_MODEM_STATE_ENABLED) {
         /* Fallback to previous state */
         mm_iface_modem_update_state (MM_IFACE_MODEM (ctx->self),
                                      ctx->previous_state,
Index: ModemManager/src/mm-sms-part-cdma.c
===================================================================
--- ModemManager.orig/src/mm-sms-part-cdma.c
+++ ModemManager/src/mm-sms-part-cdma.c
@@ -861,6 +861,7 @@ read_bearer_data_user_data (MMSmsPart
     }
 
     case ENCODING_LATIN: {
+        GError *error = NULL;
         gchar *latin;
         gchar *text;
         guint i;
Index: ModemManager/src/mm-iface-modem.c
===================================================================
--- ModemManager.orig/src/mm-iface-modem.c
+++ ModemManager/src/mm-iface-modem.c
@@ -5599,6 +5599,15 @@ mm_iface_modem_is_3gpp_only (MMIfaceMode
 }
 
 gboolean
+mm_iface_modem_is_huawei_sms (MMIfaceModem *self)
+{
+    /* Some Huawei modems only implement a reduced and renamed subset of
+     * GSM 07.05 commands for 3GPP2 SMS */
+    const gchar *model = mm_iface_modem_get_model (self);
+    return g_ascii_strcasecmp(model, "ME209u-526") == 0;
+}
+
+gboolean
 mm_iface_modem_is_cdma_only (MMIfaceModem *self)
 {
     return (mm_iface_modem_get_current_capabilities (self) == MM_MODEM_CAPABILITY_CDMA_EVDO);
Index: ModemManager/src/mm-iface-modem.h
===================================================================
--- ModemManager.orig/src/mm-iface-modem.h
+++ ModemManager/src/mm-iface-modem.h
@@ -393,6 +393,7 @@ gboolean          mm_iface_modem_is_3gpp
 gboolean          mm_iface_modem_is_3gpp_lte              (MMIfaceModem *self);
 gboolean          mm_iface_modem_is_cdma                  (MMIfaceModem *self);
 gboolean          mm_iface_modem_is_cdma_only             (MMIfaceModem *self);
+gboolean          mm_iface_modem_is_huawei_sms            (MMIfaceModem *self);
 
 /* Helpers to query supported modes */
 gboolean mm_iface_modem_is_2g      (MMIfaceModem *self);
