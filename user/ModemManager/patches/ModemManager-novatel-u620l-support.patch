--- ModemManager/plugins/Makefile.am	2018-11-26 16:08:43.992943750 +1000
+++ ModemManager/plugins/Makefile.am.new	2018-11-26 16:17:02.360943710 +1000
@@ -760,6 +760,8 @@
 	novatel/mm-broadband-modem-novatel-lte.h \
 	novatel/mm-broadband-bearer-novatel-lte.c \
 	novatel/mm-broadband-bearer-novatel-lte.h \
+	novatel/mm-broadband-bearer-novatel-lte-ccm.c \
+	novatel/mm-broadband-bearer-novatel-lte-ccm.h \
 	novatel/mm-sim-novatel-lte.c \
 	novatel/mm-sim-novatel-lte.h \
 	$(NULL)
diff --git a/plugins/novatel/mm-broadband-bearer-novatel-lte-ccm.c b/plugins/novatel/mm-broadband-bearer-novatel-lte-ccm.c
new file mode 100644
index 0000000..8c0ecc9
--- /dev/null
+++ b/plugins/novatel/mm-broadband-bearer-novatel-lte-ccm.c
@@ -0,0 +1,865 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details:
+ *
+ * http://www.verizonwireless.com/dam/support/pdf/user_guide/u620-at-command-reference-guide-7-17-15.pdf
+ *
+ * based on mm-broadband-bearer-novatel-lte-qmi.c
+ *
+ * Copyright (C) 2015 Accelerated Concepts, Inc.
+ */
+
+#include <config.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <ctype.h>
+
+#include <ModemManager.h>
+#define _LIBMM_INSIDE_MM
+#include <libmm-glib.h>
+
+#include "mm-base-modem-at.h"
+#include "mm-broadband-bearer-novatel-lte-ccm.h"
+#include "mm-log.h"
+#include "mm-modem-helpers.h"
+
+#define CONNECTION_CHECK_TIMEOUT_SEC 5
+
+G_DEFINE_TYPE (MMBroadbandBearerNovatelLteCcm, mm_broadband_bearer_novatel_lte_ccm, MM_TYPE_BROADBAND_BEARER);
+
+struct _MMBroadbandBearerNovatelLteCcmPrivate {
+    /* timeout id for checking whether we're still connected */
+    guint connection_poller;
+};
+
+static gchar *
+normalize_dynamic_status (const gchar *status)
+{
+    gchar *normalized_status, *iter;
+
+    if (!status)
+        return NULL;
+
+    normalized_status = g_strdup (status);
+    for (iter = normalized_status; *iter; iter++)
+        if (g_ascii_isspace (*iter))
+            *iter = ' ';
+
+    return normalized_status;
+}
+
+/*****************************************************************************/
+/* 3GPP Connection sequence */
+
+typedef struct {
+    MMBroadbandBearerNovatelLteCcm *self;
+    MMBaseModem *modem;
+    MMPortSerialAt *primary;
+    MMPort *data;
+    GCancellable *cancellable;
+    GSimpleAsyncResult *result;
+    gint retries;
+
+    guint *cid_list;
+    guint cid_cnt;
+    guint cid_idx;
+
+    MMBearerIpFamily ip_family;
+} DetailedConnectContext;
+
+static void
+detailed_connect_context_complete_and_free (DetailedConnectContext *ctx)
+{
+    mm_dbg("CTX=%p", ctx);
+    g_simple_async_result_complete_in_idle (ctx->result);
+    g_object_unref (ctx->result);
+    g_object_unref (ctx->cancellable);
+    if (ctx->data)
+        g_object_unref (ctx->data);
+    g_object_unref (ctx->primary);
+    g_object_unref (ctx->modem);
+    g_object_unref (ctx->self);
+    g_slice_free (DetailedConnectContext, ctx);
+}
+
+static gboolean
+detailed_connect_context_set_error_if_cancelled (DetailedConnectContext *ctx,
+                                                 GError **error)
+{
+    if (!g_cancellable_is_cancelled (ctx->cancellable))
+        return FALSE;
+
+    g_set_error (error,
+                 MM_CORE_ERROR,
+                 MM_CORE_ERROR_CANCELLED,
+                 "Connection setup operation has been cancelled");
+    return TRUE;
+}
+
+static gboolean
+detailed_connect_context_complete_and_free_if_cancelled (DetailedConnectContext *ctx)
+{
+    GError *error = NULL;
+
+    if (!detailed_connect_context_set_error_if_cancelled (ctx, &error))
+        return FALSE;
+
+    g_simple_async_result_take_error (ctx->result, error);
+    detailed_connect_context_complete_and_free (ctx);
+    return TRUE;
+}
+
+static MMBearerConnectResult *
+connect_3gpp_finish (MMBroadbandBearer *self,
+                     GAsyncResult *res,
+                     GError **error)
+{
+    if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
+        return NULL;
+
+    return mm_bearer_connect_result_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
+}
+
+static gboolean connect_3gpp_dynamic_status (DetailedConnectContext *ctx);
+
+#define CONNSTATE_TAG "connstate:"
+
+/* returns connstate or -1 on error */
+static int
+connstate(const gchar *str)
+{
+    const gchar *cp = g_strrstr (str, CONNSTATE_TAG);
+
+    if (!cp || !cp[sizeof(CONNSTATE_TAG) - 1])
+        return -1;
+
+    return atoi(cp + (sizeof(CONNSTATE_TAG) - 1));
+}
+
+static gboolean
+is_dynamic_status_connected (const gchar *str)
+{
+    switch (connstate(str)) {
+    case 5:
+        return 1;
+    default:
+        return 0;
+    }
+}
+
+static gboolean
+is_dynamic_status_disconnected (const gchar *str)
+{
+    switch (connstate(str)) {
+    case 3:
+        return 1;
+    default:
+        return 0;
+    }
+}
+
+static void
+poll_connection_ready (MMBaseModem *modem,
+                       GAsyncResult *res,
+                       MMBroadbandBearerNovatelLteCcm *bearer)
+{
+    const gchar *result;
+    GError *error = NULL;
+
+    result = mm_base_modem_at_command_finish (modem, res, &error);
+    if (!result) {
+        mm_warn ("DYNAMIC connection status failed: %s", error->message);
+        g_error_free (error);
+        return;
+    }
+
+    if (is_dynamic_status_disconnected (result)) {
+        mm_base_bearer_report_connection_status (MM_BASE_BEARER (bearer), MM_BEARER_CONNECTION_STATUS_DISCONNECTED);
+        g_source_remove (bearer->priv->connection_poller);
+        bearer->priv->connection_poller = 0;
+    }
+}
+
+static gboolean
+poll_connection (MMBroadbandBearerNovatelLteCcm *bearer)
+{
+    MMBaseModem *modem = NULL;
+
+    g_object_get (MM_BASE_BEARER (bearer),
+                  MM_BASE_BEARER_MODEM, &modem,
+                  NULL);
+    mm_base_modem_at_command (
+        modem,
+        "$NWDYNAMICSTATUS?",
+        3,
+        FALSE,
+        (GAsyncReadyCallback)poll_connection_ready,
+        bearer);
+    g_object_unref (modem);
+
+    return TRUE;
+}
+
+static void
+connect_3gpp_dynamic_status_ready (MMBaseModem *modem,
+                              GAsyncResult *res,
+                              DetailedConnectContext *ctx)
+{
+    const gchar *result;
+    gchar *normalized_result;
+    GError *error = NULL;
+
+    if (detailed_connect_context_complete_and_free_if_cancelled (ctx))
+        return;
+
+    result = mm_base_modem_at_command_full_finish (modem, res, &error);
+    if (!result) {
+        mm_warn ("DYNAMIC connection status failed: %s", error->message);
+        if (!g_error_matches (error, MM_MOBILE_EQUIPMENT_ERROR, MM_MOBILE_EQUIPMENT_ERROR_UNKNOWN)) {
+            g_simple_async_result_take_error (ctx->result, error);
+            detailed_connect_context_complete_and_free (ctx);
+            return;
+        }
+        g_error_free (error);
+        result = "Unknown error";
+    } else if (is_dynamic_status_connected (result)) {
+        MMBearerIpConfig *ipv4_config = NULL;
+        MMBearerIpConfig *ipv6_config = NULL;
+
+        mm_dbg("Connected");
+        ctx->self->priv->connection_poller = g_timeout_add_seconds (CONNECTION_CHECK_TIMEOUT_SEC,
+                                                                    (GSourceFunc)poll_connection,
+                                                                    ctx->self);
+
+	if (ctx->ip_family & MM_BEARER_IP_FAMILY_IPV4 ||
+		ctx->ip_family & MM_BEARER_IP_FAMILY_IPV4V6) {
+	    ipv4_config = mm_bearer_ip_config_new ();
+	    mm_bearer_ip_config_set_method (ipv4_config, MM_BEARER_IP_METHOD_DHCP);
+	}
+	if (ctx->ip_family & MM_BEARER_IP_FAMILY_IPV6 ||
+		ctx->ip_family & MM_BEARER_IP_FAMILY_IPV4V6) {
+	    ipv6_config = mm_bearer_ip_config_new ();
+	    mm_bearer_ip_config_set_method (ipv6_config, MM_BEARER_IP_METHOD_DHCP);
+	}
+	g_assert (ipv4_config || ipv6_config);
+
+	g_simple_async_result_set_op_res_gpointer (
+	    ctx->result,
+	    mm_bearer_connect_result_new (ctx->data, ipv4_config, ipv6_config),
+	    (GDestroyNotify)mm_bearer_connect_result_unref);
+	detailed_connect_context_complete_and_free (ctx);
+
+	g_clear_object (&ipv4_config);
+	g_clear_object (&ipv6_config);
+	return;
+    }
+
+    if (ctx->retries > 0) {
+        ctx->retries--;
+        mm_dbg ("Retrying status check in a second. %d retries left.",
+                ctx->retries);
+        g_timeout_add_seconds (1, (GSourceFunc)connect_3gpp_dynamic_status, ctx);
+        return;
+    }
+
+    /* Already exhausted all retries */
+    normalized_result = normalize_dynamic_status (result);
+    g_simple_async_result_set_error (ctx->result,
+                                     MM_CORE_ERROR,
+                                     MM_CORE_ERROR_FAILED,
+                                     "DYNAMIC connect failed: %s",
+                                     normalized_result);
+    g_free (normalized_result);
+    detailed_connect_context_complete_and_free (ctx);
+}
+
+static gboolean
+connect_3gpp_dynamic_status (DetailedConnectContext *ctx)
+{
+    mm_base_modem_at_command_full (
+        ctx->modem,
+        ctx->primary,
+        "$NWDYNAMICSTATUS?",
+        3, /* timeout */
+        FALSE, /* allow_cached */
+        FALSE, /* is_raw */
+        ctx->cancellable, /* DAVIDM */
+        (GAsyncReadyCallback)connect_3gpp_dynamic_status_ready, /* callback */
+        ctx); /* user_data */
+
+    return FALSE;
+}
+
+static void
+connect_3gpp_dynamic_connect_ready (MMBaseModem *modem,
+                               GAsyncResult *res,
+                               DetailedConnectContext *ctx)
+{
+    const gchar *result;
+    GError *error = NULL;
+
+    result = mm_base_modem_at_command_full_finish (modem, res, &error);
+    if (!result) {
+        mm_warn ("DYNAMIC connection failed: %s", error->message);
+        g_simple_async_result_take_error (ctx->result, error);
+        detailed_connect_context_complete_and_free (ctx);
+        return;
+    }
+
+    /*
+     * The connection is most likely done, but there's no
+     * notification from the modem when we connect, so check it and poll
+     * for a bit to see if it comes good
+     */
+    g_timeout_add_seconds (1, (GSourceFunc)connect_3gpp_dynamic_status, ctx);
+}
+
+static void
+connect_3gpp_authenticate (DetailedConnectContext *ctx)
+{
+    int ip_family_num;
+    gchar *command;
+
+    switch (ctx->ip_family) {
+    case MM_BEARER_IP_FAMILY_IPV4:   ip_family_num = 0; break;
+    case MM_BEARER_IP_FAMILY_IPV6:   ip_family_num = 1; break;
+    case MM_BEARER_IP_FAMILY_IPV4V6: ip_family_num = 2; break;
+    default:
+        g_simple_async_result_set_error (ctx->result,
+                                         MM_CORE_ERROR,
+                                         MM_CORE_ERROR_UNSUPPORTED,
+                                         "Only IPv4/IPv6/IPv4v6 are supported by this modem");
+        detailed_connect_context_complete_and_free (ctx);
+        return;
+    }
+
+    command = g_strdup_printf ("$NWCCMCONNECT=0,%d", ip_family_num);
+
+    mm_base_modem_at_command_full (
+        ctx->modem,
+        ctx->primary,
+        command,
+        10, /* timeout */
+        FALSE, /* allow_cached */
+        FALSE, /* is_raw */
+        ctx->cancellable, /* DAVIDM */
+        (GAsyncReadyCallback)connect_3gpp_dynamic_connect_ready,
+        ctx); /* user_data */
+    g_free (command);
+}
+
+
+static void
+initialize_pdp_context_ready (MMBaseModem *modem,
+                              GAsyncResult *res,
+                              DetailedConnectContext *ctx)
+{
+    GError *error = NULL;
+
+    /* If cancelled, complete */
+    if (detailed_connect_context_complete_and_free_if_cancelled (ctx))
+        return;
+    mm_base_modem_at_command_full_finish (modem, res, &error);
+    if (error) {
+        mm_warn ("Couldn't initialize PDP context with our APN: '%s'",
+                 error->message);
+        g_simple_async_result_take_error (ctx->result, error);
+        detailed_connect_context_complete_and_free (ctx);
+        return;
+    }
+    connect_3gpp_authenticate (ctx);
+}
+
+static void
+setup_pdp_context_1 (DetailedConnectContext *ctx)
+{
+    gchar *apn, *command;
+    const gchar *pdp_type;
+
+    pdp_type = mm_3gpp_get_pdp_type_from_ip_family (ctx->ip_family);
+    if (!pdp_type) {
+        gchar * str;
+
+        str = mm_bearer_ip_family_build_string_from_mask (ctx->ip_family);
+        g_simple_async_result_set_error (ctx->result,
+                                         MM_CORE_ERROR,
+                                         MM_CORE_ERROR_INVALID_ARGS,
+                                         "Unsupported IP type requested: '%s'",
+                                         str);
+        g_free (str);
+        detailed_connect_context_complete_and_free (ctx);
+        return;
+    }
+
+    /* initialize a PDP context 1 with our APN */
+    apn = (gchar *)mm_bearer_properties_get_apn (mm_base_bearer_peek_config (MM_BASE_BEARER (ctx->self)));
+    apn = mm_port_serial_at_quote_string (apn);
+    command = g_strdup_printf ("+CGDCONT=1,\"%s\",%s", pdp_type,
+                               apn);
+    g_free (apn);
+    mm_base_modem_at_command_full (ctx->modem,
+                                   ctx->primary,
+                                   command,
+                                   3,
+                                   FALSE,
+                                   FALSE, /* raw */
+                                   NULL, /* cancellable */
+                                   (GAsyncReadyCallback)initialize_pdp_context_ready,
+                                   ctx);
+    g_free (command);
+}
+
+
+static void
+disable_next_cid (MMBaseModem *modem,
+                  GAsyncResult *res,
+                  DetailedConnectContext *ctx)
+{
+    GError *error = NULL;
+
+    /* If cancelled, complete */
+    if (detailed_connect_context_complete_and_free_if_cancelled (ctx))
+        return;
+
+    mm_base_modem_at_command_full_finish (modem, res, &error);
+    if (error)
+        mm_warn ("Couldn't disable PDP context %d: '%s'",
+		 ctx->cid_list[ctx->cid_idx], error->message);
+    if (++ctx->cid_idx < ctx->cid_cnt) {
+    	gchar *command;
+
+	command = g_strdup_printf ("+CGACT=0,%d", ctx->cid_list[ctx->cid_idx]);
+	mm_base_modem_at_command_full (ctx->modem,
+				       ctx->primary,
+				       command,
+				       3,
+				       FALSE,
+				       FALSE, /* raw */
+				       NULL, /* cancellable */
+				       (GAsyncReadyCallback)disable_next_cid,
+				       ctx);
+	g_free (command);
+	return;
+    }
+
+    setup_pdp_context_1 (ctx);
+}
+
+static void
+pdp_list_ready (MMBaseModem *modem,
+                GAsyncResult *res,
+                DetailedConnectContext *ctx)
+{
+    const gchar *result;
+    GError *error = NULL;
+    GError *inner_error;
+    guint cid;
+    GList *pdp_list = NULL;
+    GList *l;
+    gchar *command;
+
+    if (detailed_connect_context_complete_and_free_if_cancelled (ctx))
+        return;
+
+    result = mm_base_modem_at_command_full_finish (modem, res, &error);
+
+    if (error) {
+        mm_dbg ("Continuing after Unexpected +CGDCONT? error: '%s'",
+	        error->message);
+	connect_3gpp_authenticate (ctx);
+	return;
+    }
+
+    pdp_list = mm_3gpp_parse_cgdcont_read_response (result ?: "", &inner_error);
+    if (!pdp_list) {
+        if (inner_error) {
+            mm_dbg ("%s", inner_error->message);
+            g_error_free (inner_error);
+        } else {
+            /* No predefined PDP contexts found */
+            mm_dbg ("No PDP contexts found");
+        }
+	connect_3gpp_authenticate (ctx);
+        return;
+    }
+
+    /* Show all found PDP contexts in debug log */
+    mm_dbg ("Found '%u' PDP contexts", g_list_length (pdp_list));
+    cid = 0;
+    for (l = pdp_list; l; l = g_list_next (l)) {
+        MM3gppPdpContext *pdp = l->data;
+        gchar *ip_family_str;
+
+        ip_family_str = mm_bearer_ip_family_build_string_from_mask (pdp->pdp_type);
+        mm_dbg ("  PDP context [cid=%u] [type='%s'] [apn='%s']",
+                pdp->cid,
+                ip_family_str,
+                pdp->apn ? pdp->apn : "");
+        g_free (ip_family_str);
+	/* CID 1 seems special,  it cannot be disabled */
+	if (pdp->cid != 1)
+	    cid++;
+    }
+
+    /* create a list of PDP CID's to disable */
+    if (cid > 0) {
+    	guint idx = 0;
+    	ctx->cid_list = g_slice_alloc(cid * sizeof(guint));
+	for (l = pdp_list; l; l = g_list_next (l)) {
+	    MM3gppPdpContext *pdp = l->data;
+	    /* CID 1 seems special,  it cannot be disabled */
+	    if (pdp->cid != 1)
+	    	ctx->cid_list[idx++] = pdp->cid;
+	}
+	ctx->cid_cnt = idx;
+    }
+
+    mm_3gpp_pdp_context_list_free (pdp_list);
+
+    if (ctx->cid_list == NULL) {
+        mm_dbg ("No CID's need disabling, continuing with connection...");
+	connect_3gpp_authenticate (ctx);
+    	return;
+    }
+
+    mm_dbg ("Disable all active CIDs...");
+
+    command = g_strdup_printf ("+CGACT=0,%d", ctx->cid_list[ctx->cid_idx]);
+    mm_base_modem_at_command_full (ctx->modem,
+                                   ctx->primary,
+                                   command,
+                                   3,
+                                   FALSE,
+                                   FALSE, /* raw */
+                                   NULL, /* cancellable */
+                                   (GAsyncReadyCallback)disable_next_cid,
+                                   ctx);
+    g_free (command);
+}
+
+static void
+disable_all_cids (DetailedConnectContext *ctx)
+{
+    mm_dbg ("Disable all CIDs...");
+    mm_base_modem_at_command_full (ctx->modem,
+                                   ctx->primary,
+                                   "+CGDCONT?",
+                                   3,
+                                   FALSE,
+                                   FALSE, /* raw */
+                                   NULL, /* cancellable */
+                                   (GAsyncReadyCallback)pdp_list_ready,
+                                   ctx);
+}
+
+
+static void
+connect_3gpp (MMBroadbandBearer *self,
+              MMBroadbandModem *modem,
+              MMPortSerialAt *primary,
+              MMPortSerialAt *secondary,
+              GCancellable *cancellable,
+              GAsyncReadyCallback callback,
+              gpointer user_data)
+{
+    DetailedConnectContext *ctx;
+
+    ctx = g_slice_new0 (DetailedConnectContext);
+    ctx->self = g_object_ref (self);
+    ctx->modem = MM_BASE_MODEM (g_object_ref (modem));
+    ctx->primary = g_object_ref (primary);
+    ctx->cancellable = g_object_ref (cancellable);
+    ctx->result = g_simple_async_result_new (G_OBJECT (self),
+                                             callback,
+                                             user_data,
+                                             connect_3gpp);
+    ctx->retries = 10;
+
+    ctx->ip_family = mm_bearer_properties_get_ip_type (mm_base_bearer_peek_config (MM_BASE_BEARER (ctx->self)));
+    if (ctx->ip_family == MM_BEARER_IP_FAMILY_NONE ||
+            ctx->ip_family == MM_BEARER_IP_FAMILY_ANY) {
+        gchar *ip_family_str;
+
+        ctx->ip_family = mm_base_bearer_get_default_ip_family (MM_BASE_BEARER (ctx->self));
+        ip_family_str = mm_bearer_ip_family_build_string_from_mask (ctx->ip_family);
+        mm_dbg ("No specific IP family requested, defaulting to %s",
+                ip_family_str);
+        g_free (ip_family_str);
+    }
+
+    /* Get a 'net' data port */
+    ctx->data = mm_base_modem_get_best_data_port (ctx->modem, MM_PORT_TYPE_NET);
+    if (!ctx->data) {
+        g_simple_async_result_set_error (
+            ctx->result,
+            MM_CORE_ERROR,
+            MM_CORE_ERROR_CONNECTED,
+            "Couldn't connect: no available net port available");
+        detailed_connect_context_complete_and_free (ctx);
+        return;
+    }
+
+    disable_all_cids (ctx);
+}
+
+/*****************************************************************************/
+/* 3GPP Disonnection sequence */
+
+typedef struct {
+    MMBroadbandBearer *self;
+    MMBaseModem *modem;
+    MMPortSerialAt *primary;
+    MMPort *data;
+    GSimpleAsyncResult *result;
+    gint retries;
+} DetailedDisconnectContext;
+
+static DetailedDisconnectContext *
+detailed_disconnect_context_new (MMBroadbandBearer *self,
+                                 MMBroadbandModem *modem,
+                                 MMPortSerialAt *primary,
+                                 MMPort *data,
+                                 GAsyncReadyCallback callback,
+                                 gpointer user_data)
+{
+    DetailedDisconnectContext *ctx;
+
+    ctx = g_new0 (DetailedDisconnectContext, 1);
+    ctx->self = g_object_ref (self);
+    ctx->modem = MM_BASE_MODEM (g_object_ref (modem));
+    ctx->primary = g_object_ref (primary);
+    ctx->data = g_object_ref (data);
+    ctx->result = g_simple_async_result_new (G_OBJECT (self),
+                                             callback,
+                                             user_data,
+                                             detailed_disconnect_context_new);
+    ctx->retries = 60;
+    return ctx;
+}
+
+static void
+detailed_disconnect_context_complete_and_free (DetailedDisconnectContext *ctx)
+{
+    g_simple_async_result_complete_in_idle (ctx->result);
+    g_object_unref (ctx->result);
+    g_object_unref (ctx->data);
+    g_object_unref (ctx->primary);
+    g_object_unref (ctx->modem);
+    g_object_unref (ctx->self);
+    g_free (ctx);
+}
+
+static gboolean
+disconnect_3gpp_finish (MMBroadbandBearer *self,
+                        GAsyncResult *res,
+                        GError **error)
+{
+    return !g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error);
+}
+
+static gboolean disconnect_3gpp_dynamic_status (DetailedDisconnectContext *ctx);
+
+static void
+disconnect_3gpp_status_ready (MMBaseModem *modem,
+                              GAsyncResult *res,
+                              DetailedDisconnectContext *ctx)
+{
+    const gchar *result;
+    GError *error = NULL;
+    gboolean is_connected = FALSE;
+
+    result = mm_base_modem_at_command_full_finish (modem, res, &error);
+    if (result) {
+        mm_dbg ("DYNAMIC connection status: %s", result);
+        if (is_dynamic_status_disconnected (result)) {
+            g_simple_async_result_set_op_res_gboolean (ctx->result, TRUE);
+            detailed_disconnect_context_complete_and_free (ctx);
+            return;
+        } else if (is_dynamic_status_connected (result)) {
+            is_connected = TRUE;
+        }
+    } else {
+        mm_dbg ("DYNAMIC connection status failed: %s", error->message);
+        g_error_free (error);
+        result = "Unknown error";
+    }
+
+    if (ctx->retries > 0) {
+        ctx->retries--;
+        mm_dbg ("Retrying status check in 1 second. %d retries left.",
+                ctx->retries);
+        g_timeout_add_seconds (1, (GSourceFunc)disconnect_3gpp_dynamic_status, ctx);
+        return;
+    }
+
+    /* If $NWDYNAMICSTATUS reports a CONNECTED state, returns an error such that
+     * the modem state remains 'connected'. Otherwise, assumes the modem is
+     * disconnected from the network successfully. */
+    if (is_connected) {
+        gchar *normalized_result;
+
+        normalized_result = normalize_dynamic_status (result);
+        g_simple_async_result_set_error (ctx->result,
+                                         MM_CORE_ERROR,
+                                         MM_CORE_ERROR_FAILED,
+                                         "DYNAMIC disconnect failed: %s",
+                                         normalized_result);
+        g_free (normalized_result);
+    } else
+        g_simple_async_result_set_op_res_gboolean (ctx->result, TRUE);
+
+    detailed_disconnect_context_complete_and_free (ctx);
+}
+
+static gboolean
+disconnect_3gpp_dynamic_status (DetailedDisconnectContext *ctx)
+{
+    mm_base_modem_at_command_full (
+        ctx->modem,
+        ctx->primary,
+        "$NWDYNAMICSTAUS?",
+        3, /* timeout */
+        FALSE, /* allow_cached */
+        FALSE, /* is_raw */
+        NULL, /* cancellable */
+        (GAsyncReadyCallback)disconnect_3gpp_status_ready,
+        ctx); /* user_data */
+    return FALSE;
+}
+
+
+static void
+disconnect_3gpp_check_status (MMBaseModem *modem,
+                              GAsyncResult *res,
+                              DetailedDisconnectContext *ctx)
+{
+    GError *error = NULL;
+
+    mm_base_modem_at_command_full_finish (modem, res, &error);
+    if (error) {
+        mm_dbg("Disconnection error: %s", error->message);
+        g_error_free (error);
+    }
+
+    disconnect_3gpp_dynamic_status (ctx);
+}
+
+static void
+disconnect_3gpp (MMBroadbandBearer *self,
+                 MMBroadbandModem *modem,
+                 MMPortSerialAt *primary,
+                 MMPortSerialAt *secondary,
+                 MMPort *data,
+                 guint cid,
+                 GAsyncReadyCallback callback,
+                 gpointer user_data)
+{
+    DetailedDisconnectContext *ctx;
+    MMBroadbandBearerNovatelLteCcm *bearer = MM_BROADBAND_BEARER_NOVATEL_LTE_CCM (self);
+
+    if (bearer->priv->connection_poller) {
+        g_source_remove (bearer->priv->connection_poller);
+        bearer->priv->connection_poller = 0;
+    }
+
+    ctx = detailed_disconnect_context_new (self, modem, primary, data, callback, user_data);
+
+    mm_base_modem_at_command_full (
+        ctx->modem,
+        ctx->primary,
+        "$NWCCMCONNECT=1,2",
+        10, /* timeout */
+        FALSE, /* allow_cached */
+        FALSE, /* is_raw */
+        NULL, /* cancellable */
+        (GAsyncReadyCallback)disconnect_3gpp_check_status,
+        ctx); /* user_data */
+}
+
+/*****************************************************************************/
+
+MMBaseBearer *
+mm_broadband_bearer_novatel_lte_ccm_new_finish (GAsyncResult *res,
+                                            GError **error)
+{
+    GObject *bearer;
+    GObject *source;
+
+    source = g_async_result_get_source_object (res);
+    bearer = g_async_initable_new_finish (G_ASYNC_INITABLE (source), res, error);
+    g_object_unref (source);
+
+    if (!bearer)
+        return NULL;
+
+    /* Only export valid bearers */
+    mm_base_bearer_export (MM_BASE_BEARER (bearer));
+
+    return MM_BASE_BEARER (bearer);
+}
+
+void
+mm_broadband_bearer_novatel_lte_ccm_new (MMBroadbandModemNovatelLte *modem,
+                                     MMBearerProperties *config,
+                                     GCancellable *cancellable,
+                                     GAsyncReadyCallback callback,
+                                     gpointer user_data)
+{
+    g_async_initable_new_async (
+        MM_TYPE_BROADBAND_BEARER_NOVATEL_LTE_CCM,
+        G_PRIORITY_DEFAULT,
+        cancellable,
+        callback,
+        user_data,
+        MM_BASE_BEARER_MODEM, modem,
+        MM_BASE_BEARER_CONFIG, config,
+        NULL);
+}
+
+static void
+mm_broadband_bearer_novatel_lte_ccm_init (MMBroadbandBearerNovatelLteCcm *self)
+{
+    self->priv = G_TYPE_INSTANCE_GET_PRIVATE (self,
+                                              MM_TYPE_BROADBAND_BEARER_NOVATEL_LTE_CCM,
+                                              MMBroadbandBearerNovatelLteCcmPrivate);
+
+    self->priv->connection_poller = 0;
+}
+
+static void
+finalize (GObject *object)
+{
+    MMBroadbandBearerNovatelLteCcm *self = MM_BROADBAND_BEARER_NOVATEL_LTE_CCM (object);
+
+    if (self->priv->connection_poller)
+        g_source_remove (self->priv->connection_poller);
+
+    G_OBJECT_CLASS (mm_broadband_bearer_novatel_lte_ccm_parent_class)->finalize (object);
+}
+
+static void
+mm_broadband_bearer_novatel_lte_ccm_class_init (MMBroadbandBearerNovatelLteCcmClass *klass)
+{
+    GObjectClass *object_class = G_OBJECT_CLASS (klass);
+    MMBroadbandBearerClass *broadband_bearer_class = MM_BROADBAND_BEARER_CLASS (klass);
+
+    g_type_class_add_private (object_class, sizeof (MMBroadbandBearerNovatelLteCcmPrivate));
+
+    object_class->finalize = finalize;
+
+    broadband_bearer_class->connect_3gpp = connect_3gpp;
+    broadband_bearer_class->connect_3gpp_finish = connect_3gpp_finish;
+    broadband_bearer_class->disconnect_3gpp = disconnect_3gpp;
+    broadband_bearer_class->disconnect_3gpp_finish = disconnect_3gpp_finish;
+}
diff --git a/plugins/novatel/mm-broadband-bearer-novatel-lte-ccm.h b/plugins/novatel/mm-broadband-bearer-novatel-lte-ccm.h
new file mode 100644
index 0000000..6596bdb
--- /dev/null
+++ b/plugins/novatel/mm-broadband-bearer-novatel-lte-ccm.h
@@ -0,0 +1,61 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details:
+ *
+ * Author: David McCullough <david.mccullough@accelerated.com>
+ * Copyright (C) 2015 Accelerated Concepts, Inc.
+ */
+
+#ifndef MM_BROADBAND_BEARER_NOVATEL_LTE_CCM_H
+#define MM_BROADBAND_BEARER_NOVATEL_LTE_CCM_H
+
+#include <glib.h>
+#include <glib-object.h>
+
+#define _LIBMM_INSIDE_MM
+#include <libmm-glib.h>
+
+#include "mm-broadband-bearer.h"
+#include "mm-broadband-modem-novatel-lte.h"
+
+#define MM_TYPE_BROADBAND_BEARER_NOVATEL_LTE_CCM            (mm_broadband_bearer_novatel_lte_ccm_get_type ())
+#define MM_BROADBAND_BEARER_NOVATEL_LTE_CCM(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), MM_TYPE_BROADBAND_BEARER_NOVATEL_LTE_CCM, MMBroadbandBearerNovatelLteCcm))
+#define MM_BROADBAND_BEARER_NOVATEL_LTE_CCM_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass),  MM_TYPE_BROADBAND_BEARER_NOVATEL_LTE_CCM, MMBroadbandBearerNovatelLteCcmClass))
+#define MM_IS_BROADBAND_BEARER_NOVATEL_LTE_CCM(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MM_TYPE_BROADBAND_BEARER_NOVATEL_LTE_CCM))
+#define MM_IS_BROADBAND_BEARER_NOVATEL_LTE_CCM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass),  MM_TYPE_BROADBAND_BEARER_NOVATEL_LTE_CCM))
+#define MM_BROADBAND_BEARER_NOVATEL_LTE_CCM_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj),  MM_TYPE_BROADBAND_BEARER_NOVATEL_LTE_CCM, MMBroadbandBearerNovatelLteCcmClass))
+
+typedef struct _MMBroadbandBearerNovatelLteCcm MMBroadbandBearerNovatelLteCcm;
+typedef struct _MMBroadbandBearerNovatelLteCcmClass MMBroadbandBearerNovatelLteCcmClass;
+typedef struct _MMBroadbandBearerNovatelLteCcmPrivate MMBroadbandBearerNovatelLteCcmPrivate;
+
+struct _MMBroadbandBearerNovatelLteCcm {
+    MMBroadbandBearer parent;
+    MMBroadbandBearerNovatelLteCcmPrivate *priv;
+};
+
+struct _MMBroadbandBearerNovatelLteCcmClass {
+    MMBroadbandBearerClass parent;
+};
+
+GType mm_broadband_bearer_novatel_lte_ccm_get_type (void);
+
+/* Default 3GPP bearer creation implementation */
+void          mm_broadband_bearer_novatel_lte_ccm_new    (MMBroadbandModemNovatelLte *modem,
+                                                          MMBearerProperties *properties,
+                                                          GCancellable *cancellable,
+                                                          GAsyncReadyCallback callback,
+                                                          gpointer user_data);
+MMBaseBearer *mm_broadband_bearer_novatel_lte_ccm_new_finish (GAsyncResult *res,
+                                                              GError **error);
+
+
+#endif /* MM_BROADBAND_BEARER_NOVATEL_LTE_CCM_H */
--- ModemManager/plugins/novatel/mm-broadband-modem-novatel-lte.c	2018-11-13 15:22:44.886516047 +1000
+++ ModemManager/plugins/novatel/mm-broadband-modem-novatel-lte.c.new	2018-11-27 08:56:22.172938863 +1000
@@ -25,23 +25,40 @@
 #include "ModemManager.h"
 #include "mm-base-modem-at.h"
 #include "mm-broadband-bearer-novatel-lte.h"
+#include "mm-broadband-bearer-novatel-lte-ccm.h"
 #include "mm-broadband-modem-novatel-lte.h"
 #include "mm-sim-novatel-lte.h"
 #include "mm-errors-types.h"
 #include "mm-iface-modem.h"
 #include "mm-iface-modem-3gpp.h"
+#include "mm-iface-modem-cdma.h"
 #include "mm-iface-modem-messaging.h"
+#include "mm-iface-modem-signal.h"
 #include "mm-log.h"
 #include "mm-modem-helpers.h"
 #include "mm-serial-parsers.h"
 
+static MMIfaceModem *iface_modem_parent;
+
 static void iface_modem_init (MMIfaceModem *iface);
+static void iface_modem_ccm_init (MMIfaceModem *iface);
 static void iface_modem_3gpp_init (MMIfaceModem3gpp *iface);
+static void iface_modem_3gpp_ccm_init (MMIfaceModem3gpp *iface);
+static void iface_modem_cdma_ccm_init (MMIfaceModemCdma *iface);
+static void iface_modem_signal_ccm_init (MMIfaceModemSignal *iface);
+
 
 G_DEFINE_TYPE_EXTENDED (MMBroadbandModemNovatelLte, mm_broadband_modem_novatel_lte, MM_TYPE_BROADBAND_MODEM, 0,
                         G_IMPLEMENT_INTERFACE (MM_TYPE_IFACE_MODEM, iface_modem_init)
                         G_IMPLEMENT_INTERFACE (MM_TYPE_IFACE_MODEM_3GPP, iface_modem_3gpp_init));
 
+G_DEFINE_TYPE_EXTENDED (MMBroadbandModemNovatelLteCcm, mm_broadband_modem_novatel_lte_ccm, MM_TYPE_BROADBAND_MODEM, 0,
+                        G_IMPLEMENT_INTERFACE (MM_TYPE_IFACE_MODEM, iface_modem_ccm_init)
+                        G_IMPLEMENT_INTERFACE (MM_TYPE_IFACE_MODEM_CDMA, iface_modem_cdma_ccm_init)
+                        G_IMPLEMENT_INTERFACE (MM_TYPE_IFACE_MODEM_SIGNAL, iface_modem_signal_ccm_init)
+                        G_IMPLEMENT_INTERFACE (MM_TYPE_IFACE_MODEM_3GPP, iface_modem_3gpp_ccm_init));
+
+
 /*****************************************************************************/
 /* Modem power down (Modem interface) */
 
@@ -107,6 +124,28 @@
                                      g_task_new (self, NULL, callback, user_data));
 }
 
+static void
+modem_create_bearer_ccm (MMIfaceModem *self,
+                     MMBearerProperties *properties,
+                     GAsyncReadyCallback callback,
+                     gpointer user_data)
+{
+    GSimpleAsyncResult *result;
+
+    /* Set a new ref to the bearer object as result */
+    result = g_simple_async_result_new (G_OBJECT (self),
+                                        callback,
+                                        user_data,
+                                        modem_create_bearer);
+
+    /* We just create a MMBroadbandBearer */
+    mm_broadband_bearer_novatel_lte_ccm_new (MM_BROADBAND_MODEM_NOVATEL_LTE_CCM (self),
+                                             properties,
+                                             NULL, /* cancellable */
+                                             (GAsyncReadyCallback)broadband_bearer_new_ready,
+                                             result);
+}
+
 /*****************************************************************************/
 /* Create SIM (Modem interface) */
 
@@ -536,6 +575,91 @@
 }
 
 /*****************************************************************************/
+/* Load access technologies (Modem interface) for CCM modem */
+
+typedef struct {
+    MMModemAccessTechnology generic_act;
+    guint mask;
+} AccessTechnologyResult;
+
+static gboolean
+load_access_technologies_ccm_finish (MMIfaceModem *self,
+                                     GAsyncResult *res,
+                                     MMModemAccessTechnology *access_technologies,
+                                     guint *mask,
+                                     GError **error)
+{
+    AccessTechnologyResult *r;
+
+    if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
+        return FALSE;
+
+    r = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res));
+    *access_technologies = r->generic_act;
+    *mask = r->mask;
+    return TRUE;
+}
+
+static void
+cnti_set_ready (MMBaseModem *self,
+                GAsyncResult *res,
+                GSimpleAsyncResult *simple)
+{
+    GError *error = NULL;
+    AccessTechnologyResult *r;
+    const gchar *response;
+    const gchar *p;
+
+    response = mm_base_modem_at_command_finish (MM_BASE_MODEM (self), res, &error);
+    if (!response) {
+        g_simple_async_result_take_error (simple, error);
+        g_simple_async_result_complete (simple);
+        g_object_unref (simple);
+        return;
+    }
+
+    p = mm_strip_tag (response, "$CNTI:");
+    p = strchr (p, ',');
+    if (!p) {
+        error = g_error_new (MM_CORE_ERROR,
+                             MM_CORE_ERROR_FAILED,
+                             "Couldn't parse $CNTI result '%s'",
+                             response);
+        g_simple_async_result_take_error (simple, error);
+        g_simple_async_result_complete (simple);
+        g_object_unref (simple);
+        return;
+    }
+
+    r = g_new0 (AccessTechnologyResult, 1);
+    r->generic_act = mm_string_to_access_tech (p);
+    r->mask = MM_IFACE_MODEM_3GPP_ALL_ACCESS_TECHNOLOGIES_MASK;
+    g_simple_async_result_set_op_res_gpointer (simple, r, g_free);
+    g_simple_async_result_complete (simple);
+    g_object_unref (simple);
+}
+
+static void
+load_access_technologies_ccm (MMIfaceModem *self,
+                              GAsyncReadyCallback callback,
+                              gpointer user_data)
+{
+    GSimpleAsyncResult *result;
+
+    result = g_simple_async_result_new (G_OBJECT (self),
+                                        callback,
+                                        user_data,
+                                        load_access_technologies_ccm);
+    mm_base_modem_at_command (
+        MM_BASE_MODEM (self),
+        "$CNTI=0",
+        3,
+        FALSE,
+        (GAsyncReadyCallback)cnti_set_ready,
+        result);
+}
+
+/*****************************************************************************/
 /* Reset (Modem interface) */
 
 static gboolean
@@ -640,6 +764,867 @@
 }
 
 /*****************************************************************************/
+/* Load supported modes (Modem interface) */
+
+static GArray *
+load_supported_modes_finish (MMIfaceModem *self,
+                             GAsyncResult *res,
+                             GError **error)
+{
+    if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
+        return NULL;
+
+    return g_array_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
+}
+
+static void
+parent_load_supported_modes_ready (MMIfaceModem *self,
+                                   GAsyncResult *res,
+                                   GSimpleAsyncResult *simple)
+{
+    GError *error = NULL;
+    GArray *all;
+    GArray *combinations;
+    GArray *filtered;
+    MMModemModeCombination mode;
+
+    all = iface_modem_parent->load_supported_modes_finish (self, res, &error);
+    if (!all) {
+        g_simple_async_result_take_error (simple, error);
+        g_simple_async_result_complete (simple);
+        g_object_unref (simple);
+        return;
+    }
+
+    /* Build list of combinations */
+    combinations = g_array_sized_new (FALSE, FALSE, sizeof (MMModemModeCombination), 5);
+
+    /* 2G only */
+    mode.allowed = MM_MODEM_MODE_2G;
+    mode.preferred = MM_MODEM_MODE_NONE;
+    g_array_append_val (combinations, mode);
+    /* 3G only */
+    mode.allowed = MM_MODEM_MODE_3G;
+    mode.preferred = MM_MODEM_MODE_NONE;
+    g_array_append_val (combinations, mode);
+    /* 4G only */
+    mode.allowed = MM_MODEM_MODE_4G;
+    mode.preferred = MM_MODEM_MODE_NONE;
+    g_array_append_val (combinations, mode);
+    /* Auto */
+    mode.allowed = (MM_MODEM_MODE_2G | MM_MODEM_MODE_3G | MM_MODEM_MODE_4G);
+    mode.preferred = MM_MODEM_MODE_NONE;
+    g_array_append_val (combinations, mode);
+
+    /* Filter out those unsupported modes */
+    filtered = mm_filter_supported_modes (all, combinations);
+    g_array_unref (all);
+    g_array_unref (combinations);
+
+    g_simple_async_result_set_op_res_gpointer (simple, filtered, (GDestroyNotify) g_array_unref);
+    g_simple_async_result_complete (simple);
+    g_object_unref (simple);
+}
+
+static void
+load_supported_modes (MMIfaceModem *self,
+                      GAsyncReadyCallback callback,
+                      gpointer user_data)
+{
+    /* Run parent's loading */
+    iface_modem_parent->load_supported_modes (
+        MM_IFACE_MODEM (self),
+        (GAsyncReadyCallback)parent_load_supported_modes_ready,
+        g_simple_async_result_new (G_OBJECT (self),
+                                   callback,
+                                   user_data,
+                                   load_supported_modes));
+}
+
+/*****************************************************************************/
+/* Load initial allowed/preferred modes (Modem interface) */
+
+typedef struct {
+    MMModemMode allowed;
+    MMModemMode preferred;
+} LoadCurrentModesResult;
+
+static gboolean
+load_current_modes_finish (MMIfaceModem *self,
+                           GAsyncResult *res,
+                           MMModemMode *allowed,
+                           MMModemMode *preferred,
+                           GError **error)
+{
+    LoadCurrentModesResult *result;
+
+    if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
+        return FALSE;
+
+    /* When a valid result is given, we never complete in idle */
+    result = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res));
+    *allowed = result->allowed;
+    *preferred = result->preferred;
+    return TRUE;
+}
+
+static void
+nwrat_query_ready (MMBaseModem *self,
+                   GAsyncResult *res,
+                   GSimpleAsyncResult *simple)
+{
+    LoadCurrentModesResult result;
+    GError *error = NULL;
+    const gchar *response;
+    GRegex *r;
+    GMatchInfo *match_info = NULL;
+    gint a = -1;
+    gint b = -1;
+
+    response = mm_base_modem_at_command_finish (MM_BASE_MODEM (self), res, &error);
+    if (!response) {
+        g_simple_async_result_take_error (simple, error);
+        g_simple_async_result_complete (simple);
+        g_object_unref (simple);
+        return;
+    }
+
+    /* Parse response */
+    r = g_regex_new ("\\$NWRAT:\\s*(\\d),(\\d),(\\d)", G_REGEX_UNGREEDY, 0, NULL);
+    g_assert (r != NULL);
+
+    if (!g_regex_match_full (r, response, strlen (response), 0, 0, &match_info, &error)) {
+        if (error)
+            g_simple_async_result_take_error (simple, error);
+        else
+            g_simple_async_result_set_error (simple,
+                                             MM_CORE_ERROR,
+                                             MM_CORE_ERROR_FAILED,
+                                             "Couldn't match NWRAT reply: %s",
+                                             response);
+        g_simple_async_result_complete (simple);
+        g_object_unref (simple);
+        g_match_info_free (match_info);
+        g_regex_unref (r);
+        return;
+    }
+
+    if (!mm_get_int_from_match_info (match_info, 1, &a) ||
+        !mm_get_int_from_match_info (match_info, 2, &b) ||
+        a < 0 || a > 4 ||
+        b < 1 || b > 2) {
+        g_simple_async_result_set_error (
+            simple,
+            MM_CORE_ERROR,
+            MM_CORE_ERROR_FAILED,
+            "Failed to parse mode/tech response '%s': invalid modes reported",
+            response);
+        g_match_info_free (match_info);
+        g_regex_unref (r);
+        g_simple_async_result_complete (simple);
+        g_object_unref (simple);
+        return;
+    }
+
+    switch (a) {
+    case 0: /* Automatic */
+        result.allowed = (MM_MODEM_MODE_2G | MM_MODEM_MODE_3G | MM_MODEM_MODE_4G);
+        result.preferred = MM_MODEM_MODE_NONE;
+        break;
+    case 1: /* GSM Only */
+        result.allowed = MM_MODEM_MODE_3G;
+        result.preferred = MM_MODEM_MODE_3G;
+        break;
+    case 2: /* WCDMA Only */
+        result.allowed = MM_MODEM_MODE_3G;
+        result.preferred = MM_MODEM_MODE_3G;
+        break;
+    case 3: /* LTE Only */
+        result.allowed = MM_MODEM_MODE_4G;
+        result.preferred = MM_MODEM_MODE_4G;
+        break;
+    case 4: /* CDMA (1x) Only */
+        result.allowed = MM_MODEM_MODE_2G;
+        result.preferred = MM_MODEM_MODE_2G;
+        break;
+    default:
+        /* We only allow mode 0|1|2|3|4 */
+        g_assert_not_reached ();
+        break;
+    }
+
+    g_match_info_free (match_info);
+    g_regex_unref (r);
+
+    /* When a valid result is given, we never complete in idle */
+    g_simple_async_result_set_op_res_gpointer (simple, &result, NULL);
+    g_simple_async_result_complete (simple);
+    g_object_unref (simple);
+}
+
+static void
+load_current_modes (MMIfaceModem *self,
+                    GAsyncReadyCallback callback,
+                    gpointer user_data)
+{
+    GSimpleAsyncResult *result;
+
+    result = g_simple_async_result_new (G_OBJECT (self),
+                                        callback,
+                                        user_data,
+                                        load_current_modes);
+
+    mm_base_modem_at_command (MM_BASE_MODEM (self),
+                              "$NWRAT?",
+                              3,
+                              FALSE,
+                              (GAsyncReadyCallback)nwrat_query_ready,
+                              result);
+}
+
+/*****************************************************************************/
+/* Set allowed modes (Modem interface) */
+
+static gboolean
+set_current_modes_finish (MMIfaceModem *self,
+                          GAsyncResult *res,
+                          GError **error)
+{
+    return !g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error);
+}
+
+static void
+allowed_mode_update_ready (MMBroadbandModemNovatelLteCcm *self,
+                           GAsyncResult *res,
+                           GSimpleAsyncResult *operation_result)
+{
+    GError *error = NULL;
+
+    mm_base_modem_at_command_finish (MM_BASE_MODEM (self), res, &error);
+    if (error)
+        /* Let the error be critical. */
+        g_simple_async_result_take_error (operation_result, error);
+    else
+        g_simple_async_result_set_op_res_gboolean (operation_result, TRUE);
+    g_simple_async_result_complete (operation_result);
+    g_object_unref (operation_result);
+}
+
+static void
+set_current_modes (MMIfaceModem *self,
+                   MMModemMode allowed,
+                   MMModemMode preferred,
+                   GAsyncReadyCallback callback,
+                   gpointer user_data)
+{
+    GSimpleAsyncResult *result;
+    gchar *command;
+    gint a = -1;
+    gint b = -1;
+
+    result = g_simple_async_result_new (G_OBJECT (self),
+                                        callback,
+                                        user_data,
+                                        set_current_modes);
+
+    if (allowed == MM_MODEM_MODE_2G) {
+        a = 1;
+        b = 1;
+    } else if (allowed == MM_MODEM_MODE_3G) {
+        a = 2;
+        b = 1;
+    } else if (allowed == (MM_MODEM_MODE_2G | MM_MODEM_MODE_3G)) {
+        b = 2;
+        if (preferred == MM_MODEM_MODE_NONE)
+            a = 0;
+        else if (preferred == MM_MODEM_MODE_2G)
+            a = 1;
+        else if (preferred == MM_MODEM_MODE_3G)
+            a = 2;
+    } else if (allowed == MM_MODEM_MODE_ANY &&
+               preferred == MM_MODEM_MODE_NONE) {
+        b = 2;
+        a = 0;
+    }
+
+    if (a < 0 || b < 0) {
+        gchar *allowed_str;
+        gchar *preferred_str;
+
+        allowed_str = mm_modem_mode_build_string_from_mask (allowed);
+        preferred_str = mm_modem_mode_build_string_from_mask (preferred);
+        g_simple_async_result_set_error (result,
+                                         MM_CORE_ERROR,
+                                         MM_CORE_ERROR_FAILED,
+                                         "Requested mode (allowed: '%s', preferred: '%s') not "
+                                         "supported by the modem.",
+                                         allowed_str,
+                                         preferred_str);
+        g_free (allowed_str);
+        g_free (preferred_str);
+
+        g_simple_async_result_complete_in_idle (result);
+        g_object_unref (result);
+        return;
+    }
+
+    command = g_strdup_printf ("AT$NWRAT=%d,%d", a, b);
+    mm_base_modem_at_command (
+        MM_BASE_MODEM (self),
+        command,
+        3,
+        FALSE,
+        (GAsyncReadyCallback)allowed_mode_update_ready,
+        result);
+    g_free (command);
+}
+
+/*****************************************************************************/
+/* Equipment ID loading (Modem interface) */
+
+static gchar *
+sanitize_info_reply (const gchar *reply, const char *prefix)
+{
+    const gchar *p;
+    gchar *sanitized;
+
+    /* Strip any leading command reply */
+    p = strstr (reply, prefix);
+    if (p)
+        reply = p + strlen (prefix);
+    sanitized = g_strdup (reply);
+    return mm_strip_quotes (g_strstrip (sanitized));
+}
+
+static gchar *
+load_equipment_identifier_finish (MMIfaceModem *self,
+                                  GAsyncResult *res,
+                                  GError **error)
+{
+    const gchar *result;
+    gchar *equip_id = NULL, *esn = NULL, *meid = NULL, *imei = NULL;
+
+    result = mm_base_modem_at_command_finish (MM_BASE_MODEM (self), res, error);
+    if (result) {
+        equip_id = sanitize_info_reply (result, "GSN:");
+
+        /* Modems put all sorts of things into the GSN response; sanitize it */
+        if (mm_parse_gsn (equip_id, &imei, &meid, &esn)) {
+            g_free (equip_id);
+
+            if (imei)
+                equip_id = g_strdup (imei);
+            else if (meid)
+                equip_id = g_strdup (meid);
+            else if (esn)
+                equip_id = g_strdup (esn);
+            g_free (esn);
+            g_free (meid);
+            g_free (imei);
+
+            g_assert (equip_id);
+        } else {
+            /* Leave whatever the modem returned alone */
+        }
+        mm_dbg ("loaded equipment identifier: %s", equip_id);
+    }
+    return equip_id;
+}
+
+static void
+load_equipment_identifier (MMIfaceModem *self,
+                           GAsyncReadyCallback callback,
+                           gpointer user_data)
+{
+    mm_dbg ("loading equipment identifier...");
+    mm_base_modem_at_command (
+        MM_BASE_MODEM (self),
+        "+GSN",
+        3,
+        FALSE,
+        callback,
+        user_data);
+}
+
+/*****************************************************************************/
+/* Manufacturer loading (Modem interface) */
+
+static gchar *
+load_manufacturer_finish (MMIfaceModem *self,
+                          GAsyncResult *res,
+                          GError **error)
+{
+    const gchar *result;
+    gchar *manufacturer = NULL;
+
+    result = mm_base_modem_at_command_finish (MM_BASE_MODEM (self), res, error);
+    if (result) {
+        manufacturer = sanitize_info_reply (result, "GMI:");
+        mm_dbg ("loaded manufacturer: %s", manufacturer);
+    }
+    return manufacturer;
+}
+
+static void
+load_manufacturer (MMIfaceModem *self,
+                   GAsyncReadyCallback callback,
+                   gpointer user_data)
+{
+    mm_dbg ("loading manufacturer...");
+    mm_base_modem_at_command (
+        MM_BASE_MODEM (self),
+        "+GMI",
+        3,
+        FALSE,
+        callback,
+        user_data);
+}
+
+/*****************************************************************************/
+/* IMEI loading (3GPP interface) CCM */
+
+static gchar *
+modem_3gpp_load_imei_finish (MMIfaceModem3gpp *self,
+                             GAsyncResult *res,
+                             GError **error)
+{
+    gchar *imei;
+    imei = g_strdup (mm_base_modem_at_command_finish (MM_BASE_MODEM (self), res, error));
+    if (!imei)
+        return NULL;
+    mm_dbg ("loaded IMEI: %s", imei);
+    return imei;
+}
+
+static void
+modem_3gpp_load_imei (MMIfaceModem3gpp *self,
+                      GAsyncReadyCallback callback,
+                      gpointer user_data)
+{
+    mm_dbg ("loading IMEI...");
+    mm_base_modem_at_command (MM_BASE_MODEM (self),
+                              "+GSN",
+                              3,
+                              TRUE,
+                              callback,
+                              user_data);
+}
+
+/*****************************************************************************/
+/* MEID loading (CDMA interface) */
+
+static gchar *
+modem_cdma_load_meid_finish (MMIfaceModemCdma *self,
+                             GAsyncResult *res,
+                             GError **error)
+{
+    gchar *meid, *nwati, *cp;
+    nwati = (gchar *)mm_base_modem_at_command_finish (MM_BASE_MODEM (self), res, error);
+    if (!nwati)
+        return NULL;
+    cp = strstr(nwati, "MEID:0x");
+    if (!cp)
+        return NULL;
+    meid = g_strdup(cp + 7);
+    if (!meid)
+        return NULL;
+    meid = strtok(meid, "\r\n");
+    mm_dbg ("loaded MEID: %s", meid);
+    return meid;
+}
+
+static void
+modem_cdma_load_meid (MMIfaceModemCdma *self,
+                      GAsyncReadyCallback callback,
+                      gpointer user_data)
+{
+    mm_dbg ("loading MEID...");
+    mm_base_modem_at_command (MM_BASE_MODEM (self),
+                              "$NWATI?",
+                              3,
+                              TRUE,
+                              callback,
+                              user_data);
+}
+
+/*****************************************************************************/
+/* ESN loading (CDMA interface) */
+
+static gchar *
+modem_cdma_load_esn_finish (MMIfaceModemCdma *self,
+                            GAsyncResult *res,
+                            GError **error)
+{
+    gchar *esn, *nwati, *cp;
+    nwati = (gchar *)mm_base_modem_at_command_finish (MM_BASE_MODEM (self), res, error);
+    if (!nwati)
+        return NULL;
+    cp = strstr(nwati, "ESN:0x");
+    if (!cp)
+        return NULL;
+    esn = g_strdup(cp + 6);
+    if (!esn)
+        return NULL;
+    esn = strtok(esn, "\r\n");
+    mm_dbg ("loaded ESN: %s", esn);
+    return esn;
+}
+
+static void
+modem_cdma_load_esn (MMIfaceModemCdma *self,
+                     GAsyncReadyCallback callback,
+                     gpointer user_data)
+{
+    mm_dbg ("loading ESN...");
+    mm_base_modem_at_command (MM_BASE_MODEM (self),
+                              "$NWATI?",
+                              3,
+                              TRUE,
+                              callback,
+                              user_data);
+}
+
+/*****************************************************************************/
+/* Check support (Signal interface) */
+
+static gboolean
+signal_check_support_finish (MMIfaceModemSignal *self,
+                             GAsyncResult *res,
+                             GError **error)
+{
+    return g_simple_async_result_get_op_res_gboolean (G_SIMPLE_ASYNC_RESULT (res));
+}
+
+static void
+signal_check_support (MMIfaceModemSignal *self,
+                      GAsyncReadyCallback callback,
+                      gpointer user_data)
+{
+    GSimpleAsyncResult *result;
+    gboolean supported = TRUE;
+
+    result = g_simple_async_result_new (G_OBJECT (self),
+                                        callback,
+                                        user_data,
+                                        signal_check_support);
+
+    mm_dbg ("Extended signal capabilities %ssupported", supported ? "" : "not ");
+    g_simple_async_result_set_op_res_gboolean (result, supported);
+    g_simple_async_result_complete_in_idle (result);
+    g_object_unref (result);
+}
+
+/*****************************************************************************/
+/* Load extended signal information */
+
+typedef enum {
+    SIGNAL_LOAD_VALUES_STEP_SIGNAL_FIRST,
+    SIGNAL_LOAD_VALUES_STEP_SIGNAL_ACCESS_TECH,
+    SIGNAL_LOAD_VALUES_STEP_SIGNAL_RSRQ, /* +VZWRSRQ? */
+    SIGNAL_LOAD_VALUES_STEP_SIGNAL_RSRP, /* +VZWRSRP? */
+    SIGNAL_LOAD_VALUES_STEP_SIGNAL_CSQ,  /* +CSQ? */
+    SIGNAL_LOAD_VALUES_STEP_SIGNAL_LAST
+} SignalLoadValuesStep;
+
+typedef struct {
+    MMModemAccessTechnology tech;
+    MMSignal *value;
+} SignalLoadValuesResult;
+
+typedef struct {
+    MMBroadbandModemNovatelLteCcm *self;
+    GSimpleAsyncResult *result;
+    SignalLoadValuesStep step;
+    SignalLoadValuesResult *values_result;
+} SignalLoadValuesContext;
+
+static void
+signal_load_values_result_free (SignalLoadValuesResult *result)
+{
+    if (result->value)
+        g_object_unref (result->value);
+    g_slice_free (SignalLoadValuesResult, result);
+}
+
+static void
+signal_load_values_context_complete_and_free (SignalLoadValuesContext *ctx)
+{
+    g_simple_async_result_complete (ctx->result);
+    if (ctx->values_result)
+        signal_load_values_result_free (ctx->values_result);
+    g_object_unref (ctx->result);
+    g_object_unref (ctx->self);
+    g_slice_free (SignalLoadValuesContext, ctx);
+}
+
+static gboolean
+signal_load_values_finish (MMIfaceModemSignal *self,
+                           GAsyncResult *res,
+                           MMSignal **cdma,
+                           MMSignal **evdo,
+                           MMSignal **gsm,
+                           MMSignal **umts,
+                           MMSignal **lte,
+                           GError **error)
+{
+    SignalLoadValuesResult *values_result;
+
+    if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
+        return FALSE;
+
+    values_result = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res));
+
+    *cdma = NULL;
+    *evdo = NULL;
+    *gsm  = NULL;
+    *umts = NULL;
+    *lte  = NULL;
+
+    switch (values_result->tech) {
+    case MM_MODEM_ACCESS_TECHNOLOGY_GPRS:
+    case MM_MODEM_ACCESS_TECHNOLOGY_EDGE:
+    case MM_MODEM_ACCESS_TECHNOLOGY_HSDPA:
+    case MM_MODEM_ACCESS_TECHNOLOGY_HSUPA:
+    case MM_MODEM_ACCESS_TECHNOLOGY_HSPA:
+    case MM_MODEM_ACCESS_TECHNOLOGY_HSPA_PLUS:
+    case MM_MODEM_ACCESS_TECHNOLOGY_GSM:
+    case MM_MODEM_ACCESS_TECHNOLOGY_GSM_COMPACT:
+        *gsm  = values_result->value ? g_object_ref (values_result->value) : NULL;
+        break;
+    case MM_MODEM_ACCESS_TECHNOLOGY_UMTS:
+        *umts = values_result->value ? g_object_ref (values_result->value) : NULL;
+        break;
+    case MM_MODEM_ACCESS_TECHNOLOGY_1XRTT:
+        *cdma = values_result->value ? g_object_ref (values_result->value) : NULL;
+        break;
+    case MM_MODEM_ACCESS_TECHNOLOGY_EVDO0:
+    case MM_MODEM_ACCESS_TECHNOLOGY_EVDOA:
+    case MM_MODEM_ACCESS_TECHNOLOGY_EVDOB:
+        *evdo = values_result->value ? g_object_ref (values_result->value) : NULL;
+        break;
+    case MM_MODEM_ACCESS_TECHNOLOGY_LTE:
+        *lte  = values_result->value ? g_object_ref (values_result->value) : NULL;
+        break;
+    default:
+        break;
+    }
+
+    return TRUE;
+}
+
+static void signal_load_values_context_step (SignalLoadValuesContext *ctx);
+
+static void
+signal_load_values_get_signal_info_ready (MMBroadbandModemNovatelLteCcm *self,
+                                          GAsyncResult *res,
+                                          SignalLoadValuesContext *ctx)
+{
+    GError *error = NULL;
+    const gchar *response, *p;
+
+    switch (ctx->step) {
+    case SIGNAL_LOAD_VALUES_STEP_SIGNAL_FIRST:
+        break;
+    case SIGNAL_LOAD_VALUES_STEP_SIGNAL_ACCESS_TECH:
+        response = mm_base_modem_at_command_finish (MM_BASE_MODEM (self),
+	                                            res,
+						    &error);
+        if (!response) {
+	    ctx->step = SIGNAL_LOAD_VALUES_STEP_SIGNAL_LAST - 1;
+            break;
+        }
+        p = mm_strip_tag (response, "$CNTI:");
+        p = strchr (p, ',');
+	if (!p) {
+	    ctx->step = SIGNAL_LOAD_VALUES_STEP_SIGNAL_LAST - 1;
+            break;
+	}
+	/* we have results */
+        ctx->values_result = g_slice_new0 (SignalLoadValuesResult);
+        ctx->values_result->tech = mm_string_to_access_tech (p);
+        break;
+    case SIGNAL_LOAD_VALUES_STEP_SIGNAL_RSRQ:
+        response = mm_base_modem_at_command_finish (MM_BASE_MODEM (self),
+	                                            res,
+						    &error);
+        if (!response)
+            break;
+        p = mm_strip_tag (response, "+VZWRSRQ:");
+	p = strchr(p, '"');
+	if (p) {
+	    if (!ctx->values_result->value)
+	        ctx->values_result->value = mm_signal_new ();
+            mm_signal_set_rsrq (ctx->values_result->value, (gdouble)atof(p+1));
+	}
+        break;
+    case SIGNAL_LOAD_VALUES_STEP_SIGNAL_RSRP:
+        response = mm_base_modem_at_command_finish (MM_BASE_MODEM (self),
+	                                            res,
+						    &error);
+        if (!response)
+	    break;
+        p = mm_strip_tag (response, "+VZWRSRP:");
+	p = strchr(p, '"');
+	if (p) {
+	    if (!ctx->values_result->value)
+	        ctx->values_result->value = mm_signal_new ();
+            mm_signal_set_rsrp (ctx->values_result->value, (gdouble)atof(p+1));
+	}
+        break;
+    case SIGNAL_LOAD_VALUES_STEP_SIGNAL_CSQ:
+        response = mm_base_modem_at_command_finish (MM_BASE_MODEM (self),
+	                                            res,
+						    &error);
+        if (!response)
+	    break;
+        p = mm_strip_tag (response, "+CSQ:");
+	if (p) {
+	    int csq;
+	    if (!ctx->values_result->value)
+	        ctx->values_result->value = mm_signal_new ();
+	    csq = atoi(p);
+	    if (csq >= 0 && csq <= 31)
+                mm_signal_set_rssi (ctx->values_result->value, (gdouble)(-113+(2*csq)));
+	}
+        break;
+    case SIGNAL_LOAD_VALUES_STEP_SIGNAL_LAST:
+        break;
+    }
+    ctx->step++;
+    signal_load_values_context_step (ctx);
+}
+
+static void
+signal_load_values_context_step (SignalLoadValuesContext *ctx)
+{
+    switch (ctx->step) {
+    case SIGNAL_LOAD_VALUES_STEP_SIGNAL_FIRST:
+        ctx->step++;
+        /* Fall through */
+
+    case SIGNAL_LOAD_VALUES_STEP_SIGNAL_ACCESS_TECH:
+        mm_base_modem_at_command (MM_BASE_MODEM (ctx->self),
+                                  "$CNTI=0",
+                                  3,
+                                  FALSE,
+                                  (GAsyncReadyCallback)signal_load_values_get_signal_info_ready,
+                                  ctx);
+	return;
+
+    case SIGNAL_LOAD_VALUES_STEP_SIGNAL_RSRQ: /* +VZWRSRQ? */
+        mm_base_modem_at_command (MM_BASE_MODEM (ctx->self),
+                                  "+VZWRSRQ?",
+                                  3,
+                                  FALSE,
+                                  (GAsyncReadyCallback)signal_load_values_get_signal_info_ready,
+                                  ctx);
+	return;
+
+    case SIGNAL_LOAD_VALUES_STEP_SIGNAL_RSRP: /* +VZWRSRP? */
+        mm_base_modem_at_command (MM_BASE_MODEM (ctx->self),
+                                  "+VZWRSRP?",
+                                  3,
+                                  FALSE,
+                                  (GAsyncReadyCallback)signal_load_values_get_signal_info_ready,
+                                  ctx);
+	return;
+
+    case SIGNAL_LOAD_VALUES_STEP_SIGNAL_CSQ:  /* +CSQ? */
+        mm_base_modem_at_command (MM_BASE_MODEM (ctx->self),
+                                  "+CSQ?",
+                                  3,
+                                  FALSE,
+                                  (GAsyncReadyCallback)signal_load_values_get_signal_info_ready,
+                                  ctx);
+        return;
+
+    case SIGNAL_LOAD_VALUES_STEP_SIGNAL_LAST:
+        /* If any result is set, succeed */
+        if (ctx->values_result && ctx->values_result->value) {
+            g_simple_async_result_set_op_res_gpointer (ctx->result,
+                                                       ctx->values_result,
+                                                       (GDestroyNotify)signal_load_values_result_free);
+            ctx->values_result = NULL;
+        } else {
+            g_simple_async_result_set_error (ctx->result,
+                                             MM_CORE_ERROR,
+                                             MM_CORE_ERROR_FAILED,
+                                             "No way to load extended signal information");
+        }
+        signal_load_values_context_complete_and_free (ctx);
+        return;
+    }
+    g_assert_not_reached ();
+}
+
+static void
+signal_load_values (MMIfaceModemSignal *self,
+                    GCancellable *cancellable,
+                    GAsyncReadyCallback callback,
+                    gpointer user_data)
+{
+    SignalLoadValuesContext *ctx;
+
+    mm_dbg ("loading extended signal information...");
+
+    ctx = g_slice_new0 (SignalLoadValuesContext);
+    ctx->self = g_object_ref (self);
+    ctx->result = g_simple_async_result_new (G_OBJECT (self),
+                                             callback,
+                                             user_data,
+                                             signal_load_values);
+    ctx->step = SIGNAL_LOAD_VALUES_STEP_SIGNAL_FIRST;
+
+    signal_load_values_context_step (ctx);
+}
+
+/*****************************************************************************/
+/* Signal quality loading (Modem interface) - convert indicator to a %age */
+
+static guint
+modem_load_signal_quality_finish (MMIfaceModem *self,
+                                  GAsyncResult *res,
+                                  GError **error)
+{
+    gchar *response, *cp;
+    guint ind, per;
+
+    response = (gchar *)mm_base_modem_at_command_finish (MM_BASE_MODEM (self), res, error);
+    if (!response)
+        return 0;
+    cp = strstr(response, "rssi:");
+    if (!cp)
+        return 0;
+    ind = atoi(cp + 5);
+    switch (ind) {
+    default:
+    case 0: per = 0;  break;
+    case 1: per = 15; break;
+    case 2: per = 33; break;
+    case 3: per = 52; break;
+    case 4: per = 72; break;
+    case 5: per = 90; break;
+    }
+    mm_dbg ("Signal quality %d -> %%%d", ind, per);
+    return per;
+}
+
+static void
+modem_load_signal_quality (MMIfaceModem *self,
+                           GAsyncReadyCallback callback,
+                           gpointer user_data)
+{
+    /* custom signal quality loading */
+    mm_base_modem_at_command (
+        MM_BASE_MODEM (self),
+        "$NWDYNAMICSTATUS?",
+        3,
+        FALSE,
+        (GAsyncReadyCallback)callback,
+        user_data);
+}
+
+/*****************************************************************************/
 
 MMBroadbandModemNovatelLte *
 mm_broadband_modem_novatel_lte_new (const gchar *device,
@@ -657,6 +1642,23 @@
                          NULL);
 }
 
+
+MMBroadbandModemNovatelLteCcm *
+mm_broadband_modem_novatel_lte_ccm_new (const gchar *device,
+                                        const gchar **drivers,
+                                        const gchar *plugin,
+                                        guint16 vendor_id,
+                                        guint16 product_id)
+{
+    return g_object_new (MM_TYPE_BROADBAND_MODEM_NOVATEL_LTE_CCM,
+                         MM_BASE_MODEM_DEVICE, device,
+                         MM_BASE_MODEM_DRIVERS, drivers,
+                         MM_BASE_MODEM_PLUGIN, plugin,
+                         MM_BASE_MODEM_VENDOR_ID, vendor_id,
+                         MM_BASE_MODEM_PRODUCT_ID, product_id,
+                         NULL);
+}
+
 static void
 mm_broadband_modem_novatel_lte_init (MMBroadbandModemNovatelLte *self)
 {
@@ -665,6 +1667,8 @@
 static void
 iface_modem_init (MMIfaceModem *iface)
 {
+	iface_modem_parent = g_type_interface_peek_parent (iface);
+
     iface->modem_power_down = modem_power_down;
     iface->modem_power_down_finish = modem_power_down_finish;
     iface->create_bearer = modem_create_bearer;
@@ -699,3 +1703,79 @@
 mm_broadband_modem_novatel_lte_class_init (MMBroadbandModemNovatelLteClass *klass)
 {
 }
+
+static void
+mm_broadband_modem_novatel_lte_ccm_init (MMBroadbandModemNovatelLteCcm *self)
+{
+}
+
+static void
+iface_modem_ccm_init (MMIfaceModem *iface)
+{
+    iface_modem_parent = g_type_interface_peek_parent (iface);
+
+    iface->modem_power_down = modem_power_down;
+    iface->modem_power_down_finish = modem_power_down_finish;
+    iface->create_bearer = modem_create_bearer_ccm;
+    iface->create_bearer_finish = modem_create_bearer_finish;
+    iface->create_sim = modem_create_sim;
+    iface->create_sim_finish = modem_create_sim_finish;
+    iface->modem_after_sim_unlock = modem_after_sim_unlock;
+    iface->modem_after_sim_unlock_finish = modem_after_sim_unlock_finish;
+    iface->load_own_numbers = load_own_numbers;
+    iface->load_own_numbers_finish = load_own_numbers_finish;
+    iface->load_supported_bands = load_supported_bands;
+    iface->load_supported_bands_finish = load_supported_bands_finish;
+    iface->load_current_bands = load_current_bands;
+    iface->load_current_bands_finish = load_current_bands_finish;
+    /* No support for setting bands, as it destabilizes the modem. */
+    iface->load_supported_modes = load_supported_modes;
+    iface->load_supported_modes_finish = load_supported_modes_finish;
+    iface->load_current_modes = load_current_modes;
+    iface->load_current_modes_finish = load_current_modes_finish;
+    iface->set_current_modes = set_current_modes;
+    iface->set_current_modes_finish = set_current_modes_finish;
+    iface->load_access_technologies = load_access_technologies_ccm;
+    iface->load_access_technologies_finish = load_access_technologies_ccm_finish;
+    iface->load_equipment_identifier = load_equipment_identifier;
+    iface->load_equipment_identifier_finish = load_equipment_identifier_finish;
+    iface->load_manufacturer = load_manufacturer;
+    iface->load_manufacturer_finish = load_manufacturer_finish;
+    iface->reset = reset;
+    iface->reset_finish = reset_finish;
+
+    iface->load_signal_quality = modem_load_signal_quality;
+    iface->load_signal_quality_finish = modem_load_signal_quality_finish;
+}
+
+static void
+iface_modem_3gpp_ccm_init (MMIfaceModem3gpp *iface)
+{
+    iface->scan_networks = scan_networks;
+    iface->scan_networks_finish = scan_networks_finish;
+    iface->load_imei = modem_3gpp_load_imei;
+    iface->load_imei_finish = modem_3gpp_load_imei_finish;
+}
+
+static void
+iface_modem_cdma_ccm_init (MMIfaceModemCdma *iface)
+{
+    iface->load_meid = modem_cdma_load_meid;
+    iface->load_meid_finish = modem_cdma_load_meid_finish;
+    iface->load_esn = modem_cdma_load_esn;
+    iface->load_esn_finish = modem_cdma_load_esn_finish;
+}
+
+static void
+iface_modem_signal_ccm_init (MMIfaceModemSignal *iface)
+{
+    iface->check_support = signal_check_support;
+    iface->check_support_finish = signal_check_support_finish;
+    iface->load_values = signal_load_values;
+    iface->load_values_finish = signal_load_values_finish;
+}
+
+static void
+mm_broadband_modem_novatel_lte_ccm_class_init (MMBroadbandModemNovatelLteCcmClass *klass)
+{
+}
--- ModemManager/plugins/novatel/mm-broadband-modem-novatel-lte.h	2017-10-12 10:42:44.808909401 +1000
+++ ModemManager/plugins/novatel/mm-broadband-modem-novatel-lte.h.new	2018-11-27 08:59:58.124938845 +1000
@@ -32,7 +32,7 @@
 
 struct _MMBroadbandModemNovatelLte {
     MMBroadbandModem parent;
-    MMBroadbandModemNovatelLtePrivate *priv;
+    //MMBroadbandModemNovatelLtePrivate *priv;
 };
 
 struct _MMBroadbandModemNovatelLteClass{
@@ -47,4 +47,23 @@
                                                                 guint16 vendor_id,
                                                                 guint16 product_id);
 
+#define MM_TYPE_BROADBAND_MODEM_NOVATEL_LTE_CCM         (mm_broadband_modem_novatel_lte_ccm_get_type ())
+#define MM_BROADBAND_MODEM_NOVATEL_LTE_CCM(obj)         (G_TYPE_CHECK_INSTANCE_CAST ((obj), MM_TYPE_BROADBAND_MODEM_NOVATEL_LTE_CCM, MMBroadbandModemNovatelLteCcm))
+#define MM_BROADBAND_MODEM_NOVATEL_LTE_CCM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass),  MM_TYPE_BROADBAND_MODEM_NOVATEL_LTE_CCM, MMBroadbandModemNovatelLteCcmClass))
+#define MM_IS_BROADBAND_MODEM_NOVATEL_LTE_CCM(obj)      (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MM_TYPE_BROADBAND_MODEM_NOVATEL_LTE_CCM))
+#define MM_IS_BROADBAND_MODEM_NOVATEL_LTE_CCM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass),  MM_TYPE_BROADBAND_MODEM_NOVATEL_LTE_CCM))
+#define MM_BROADBAND_MODEM_NOVATEL_LTE_CCM_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj),  MM_TYPE_BROADBAND_MODEM_NOVATEL_LTE_CCM, MMBroadbandModemNovatelLteCcmClass))
+
+typedef struct _MMBroadbandModemNovatelLte MMBroadbandModemNovatelLteCcm;
+typedef struct _MMBroadbandModemNovatelLteClass MMBroadbandModemNovatelLteCcmClass;
+typedef struct _MMBroadbandModemNovatelLtePrivate MMBroadbandModemNovatelLteCcmPrivate;
+
+GType mm_broadband_modem_novatel_lte_ccm_get_type (void);
+
+MMBroadbandModemNovatelLte *mm_broadband_modem_novatel_lte_ccm_new (const gchar *device,
+                                                                    const gchar **drivers,
+                                                                    const gchar *plugin,
+                                                                    guint16 vendor_id,
+                                                                    guint16 product_id);
+
 #endif /* MM_BROADBAND_MODEM_NOVATEL_LTE_H */
--- ModemManager/plugins/novatel/mm-plugin-novatel-lte.c	2018-11-13 15:22:44.886516047 +1000
+++ ModemManager/plugins/novatel/mm-plugin-novatel-lte.c.new	2018-11-27 09:36:14.908938669 +1000
@@ -42,6 +42,13 @@
               GList *probes,
               GError **error)
 {
+    if (vendor == 0x1410 && product == 0x9022)
+        return MM_BASE_MODEM (mm_broadband_modem_novatel_lte_ccm_new (uid,
+                                                                      drivers,
+                                                                      mm_plugin_get_name (self),
+                                                                      vendor,
+                                                                      product));
+
     return MM_BASE_MODEM (mm_broadband_modem_novatel_lte_new (uid,
                                                               drivers,
                                                               mm_plugin_get_name (self),
@@ -56,6 +63,7 @@
 {
     static const gchar *subsystems[] = { "tty", "net", NULL };
     static const mm_uint16_pair products[] = { { 0x1410, 0x9010 }, /* Novatel E362 */
+                                               { 0x1410, 0x9022 }, /* Novatel Mifi U620L */
                                                {0, 0} };
 
     return MM_PLUGIN (
--- ModemManager/plugins/novatel/mm-plugin-novatel.c	2018-11-13 15:22:44.890516047 +1000
+++ ModemManager/plugins/novatel/mm-plugin-novatel.c.new	2018-11-27 09:38:53.380938657 +1000
@@ -79,6 +79,7 @@
     static const gchar *subsystems[] = { "tty", "net", "usb", NULL };
     static const guint16 vendors[] = { 0x1410, 0 };
     static const mm_uint16_pair forbidden_products[] = { { 0x1410, 0x9010 }, /* Novatel E362 */
+                                                         { 0x1410, 0x9022 },
                                                          { 0, 0 } };
     static const MMAsyncMethod custom_init = {
         .async  = G_CALLBACK (mm_common_novatel_custom_init),
--- ModemManager/src/mm-iface-modem.c.orig	2018-11-27 09:53:20.672938586 +1000
+++ ModemManager/src/mm-iface-modem.c	2018-11-27 10:32:45.436938395 +1000
@@ -292,9 +292,6 @@
                              MM_CORE_ERROR_CANCELLED) ||
             g_error_matches (error,
                              MM_MOBILE_EQUIPMENT_ERROR,
-                             MM_MOBILE_EQUIPMENT_ERROR_SIM_NOT_INSERTED) ||
-            g_error_matches (error,
-                             MM_MOBILE_EQUIPMENT_ERROR,
                              MM_MOBILE_EQUIPMENT_ERROR_SIM_FAILURE) ||
             g_error_matches (error,
                              MM_MOBILE_EQUIPMENT_ERROR,
@@ -317,6 +314,18 @@
             return;
         }
 
+       /* if last error was sim not inserted, report that */
+       if (g_error_matches (error,
+                             MM_MOBILE_EQUIPMENT_ERROR,
+                             MM_MOBILE_EQUIPMENT_ERROR_SIM_NOT_INSERTED)) {
+            g_task_return_new_error (task,
+                                     MM_MOBILE_EQUIPMENT_ERROR,
+                                     MM_MOBILE_EQUIPMENT_ERROR_SIM_NOT_INSERTED,
+                                     "SIM not inserted");
+            g_object_unref (task);
+            return;
+       }
+
         /* If reached max retries and still reporting error... default to SIM error */
         g_error_free (error);
         g_task_return_new_error (task,
