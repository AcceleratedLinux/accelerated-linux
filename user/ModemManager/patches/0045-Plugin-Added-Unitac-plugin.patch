From e80aa06bf433418f16e67a975b161bb2c33a76f6 Mon Sep 17 00:00:00 2001
From: Anubhav Gupta <anubhav.gupta@digi.com>
Date: Wed, 2 Jun 2021 16:37:39 -0400
Subject: [PATCH 1/7] plugin: Added a new Unitac plugin

Added a new Unitac plugin for ML660/ML620 LTE 450MHz modems.
Unitac modem only supports AT commands
---
 configure.ac                                 |    2 +
 plugins/Makefile.am                          |   26 +
 plugins/unitac/77-mm-unitac-port-types.rules |   20 +
 plugins/unitac/mm-broadband-bearer-unitac.c  | 1185 ++++++++++++++++++++++++++
 plugins/unitac/mm-broadband-bearer-unitac.h  |   58 ++
 plugins/unitac/mm-broadband-modem-unitac.c   |  759 +++++++++++++++++
 plugins/unitac/mm-broadband-modem-unitac.h   |   47 +
 plugins/unitac/mm-plugin-unitac.c            |  107 +++
 plugins/unitac/mm-plugin-unitac.h            |   40 +
 9 files changed, 2244 insertions(+)
 create mode 100644 plugins/unitac/77-mm-unitac-port-types.rules
 create mode 100644 plugins/unitac/mm-broadband-bearer-unitac.c
 create mode 100644 plugins/unitac/mm-broadband-bearer-unitac.h
 create mode 100644 plugins/unitac/mm-broadband-modem-unitac.c
 create mode 100644 plugins/unitac/mm-broadband-modem-unitac.h
 create mode 100644 plugins/unitac/mm-plugin-unitac.c
 create mode 100644 plugins/unitac/mm-plugin-unitac.h

diff --git a/configure.ac b/configure.ac
index c44bef3..e1f58da 100644
--- a/configure.ac
+++ b/configure.ac
@@ -507,6 +507,7 @@ MM_ENABLE_PLUGIN([wavecom])
 MM_ENABLE_PLUGIN([x22x])
 MM_ENABLE_PLUGIN([zte],
                  [with_shared_icera])
+MM_ENABLE_PLUGIN([unitac]
 
 MM_BUILD_SHARED([icera])
 MM_BUILD_SHARED([sierra])
@@ -636,6 +637,7 @@ echo "
       wavecom:                 ${enable_plugin_wavecom}
       x22x:                    ${enable_plugin_x22x}
       zte:                     ${enable_plugin_zte}
+      unitac:                  ${enable_plugin_unitac}
 
     Miscellaneous:
       gobject introspection:   ${found_introspection}
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 59f79a4..86c023f 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -1585,6 +1585,32 @@ AM_CFLAGS += -DTESTUDEVRULESDIR_ZTE=\"${srcdir}/zte\"
 endif
 
 ################################################################################
+# plugin: unitac
+################################################################################
+
+if ENABLE_PLUGIN_UNITAC
+
+dist_udevrules_DATA += unitac/77-mm-unitac-port-types.rules
+
+pkglib_LTLIBRARIES += libmm-plugin-unitac.la
+libmm_plugin_unitac_la_SOURCES = \
+	unitac/mm-plugin-unitac.c \
+	unitac/mm-plugin-unitac.h \
+	unitac/mm-broadband-bearer-unitac.c \
+	unitac/mm-broadband-bearer-unitac.h \
+	unitac/mm-broadband-modem-unitac.c  \
+	unitac/mm-broadband-modem-unitac.h  \
+	$(NULL)
+libmm_plugin_unitac_la_CPPFLAGS = \
+	$(PLUGIN_COMMON_COMPILER_FLAGS) \
+	-DMM_MODULE_NAME=\"unitac\" \
+	$(NULL)
+
+libmm_plugin_unitac_la_LDFLAGS  = $(PLUGIN_COMMON_LINKER_FLAGS)
+
+endif
+
+################################################################################
 # udev rules tester
 ################################################################################
 
diff --git a/plugins/unitac/77-mm-unitac-port-types.rules b/plugins/unitac/77-mm-unitac-port-types.rules
new file mode 100644
index 0000000..6fd523e
--- /dev/null
+++ b/plugins/unitac/77-mm-unitac-port-types.rules
@@ -0,0 +1,20 @@
+# do not edit this file, it will be overwritten on update
+
+ACTION!="add|change|move|bind", GOTO="mm_unitac_port_types_end"
+SUBSYSTEMS=="usb", ATTRS{idVendor}=="1076", GOTO="mm_unitac_port_types"
+GOTO="mm_unitac_port_types_end"
+
+LABEL="mm_unitac_port_types"
+SUBSYSTEMS=="usb", ATTRS{bInterfaceNumber}=="?*", ENV{.MM_USBIFNUM}="$attr{bInterfaceNumber}"
+
+# ML660PG -> wmode=router, used for firmware update
+ATTRS{idVendor}=="1076", ATTRS{idProduct}=="9082", ENV{.MM_USBIFNUM}=="02", ENV{ID_MM_PORT_TYPE_AT_PRIMARY}="1"
+ATTRS{idVendor}=="1076", ATTRS{idProduct}=="9082", ENV{.MM_USBIFNUM}=="08", ENV{ID_MM_PORT_TYPE_GPS}="1"
+ATTRS{idVendor}=="1076", ATTRS{idProduct}=="9082", ENV{.MM_USBIFNUM}=="04", ENV{ID_MM_PORT_IGNORE}="1"
+
+# ML660PG -> wmode=bridge-ecm, used for LTE connection
+ATTRS{idVendor}=="1076", ATTRS{idProduct}=="9003", ENV{.MM_USBIFNUM}=="02", ENV{ID_MM_PORT_TYPE_AT_PRIMARY}="1"
+ATTRS{idVendor}=="1076", ATTRS{idProduct}=="9003", ENV{.MM_USBIFNUM}=="08", ENV{ID_MM_PORT_TYPE_GPS}="1"
+ATTRS{idVendor}=="1076", ATTRS{idProduct}=="9003", ENV{.MM_USBIFNUM}=="04", ENV{ID_MM_PORT_IGNORE}="1"
+
+LABEL="mm_unitac_port_types_end"
diff --git a/plugins/unitac/mm-broadband-bearer-unitac.c b/plugins/unitac/mm-broadband-bearer-unitac.c
new file mode 100644
index 0000000..dbc26ac
--- /dev/null
+++ b/plugins/unitac/mm-broadband-bearer-unitac.c
@@ -0,0 +1,1185 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details:
+ *
+ * Copyright (C) 2021 Anubhav Gupta <anubhav.gupta@digi.com>
+ */
+
+#include <config.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <ctype.h>
+#include <arpa/inet.h>
+
+#include <ModemManager.h>
+#define _LIBMM_INSIDE_MM
+#include <libmm-glib.h>
+
+#include "mm-broadband-bearer-unitac.h"
+#include "mm-base-modem-at.h"
+#include "mm-log-object.h"
+#include "mm-modem-helpers.h"
+
+G_DEFINE_TYPE (MMBroadbandBearerUnitac, mm_broadband_bearer_unitac, MM_TYPE_BROADBAND_BEARER)
+
+static void dial_3gpp_context_step (GTask *task);
+
+typedef enum {
+    DIAL_3GPP_STEP_FIRST,
+    DIAL_3GPP_STEP_AUTHENTICATE,
+    DIAL_3GPP_STEP_PS_ATTACH,
+    DIAL_3GPP_STEP_CONNECT,
+    DIAL_3GPP_STEP_CONNECT_QUERY,
+    DIAL_3GPP_STEP_LAST
+} Dial3gppStep;
+
+/*****************************************************************************/
+/* Common connection context and task */
+
+typedef struct {
+    MMBroadbandModem    *modem;
+    MMPortSerialAt      *primary;
+    MMPort              *data;
+    guint               cid;
+    gboolean            auth_required;
+    Dial3gppStep        step;
+    MMBearerIpFamily    family;
+    MMBearerIpConfig    *ipv4_config; /* For IPv4 settings */
+    MMBearerIpConfig    *ipv6_config; /* For IPv6 settings */
+} CommonConnectContext;
+
+static void
+common_connect_context_free (CommonConnectContext *ctx)
+{
+    if (ctx->ipv4_config)
+        g_object_unref (ctx->ipv4_config);
+    if (ctx->ipv6_config)
+        g_object_unref (ctx->ipv6_config);
+    if (ctx->data)
+        g_object_unref (ctx->data);
+    g_object_unref (ctx->modem);
+    g_object_unref (ctx->primary);
+    g_slice_free (CommonConnectContext, ctx);
+}
+
+static GTask *
+common_connect_task_new (MMBroadbandBearerUnitac *self,
+                         MMBroadbandModem        *modem,
+                         MMPortSerialAt          *primary,
+                         guint                   cid,
+                         MMPort                  *data,
+                         GCancellable            *cancellable,
+                         GAsyncReadyCallback     callback,
+                         gpointer                user_data)
+{
+    CommonConnectContext *ctx;
+    GTask                *task;
+
+    ctx = g_slice_new0 (CommonConnectContext);
+    ctx->modem   = g_object_ref (modem);
+    ctx->primary = g_object_ref (primary);
+    ctx->cid     = cid;
+    ctx->step = DIAL_3GPP_STEP_FIRST;
+
+    task = g_task_new (self, cancellable, callback, user_data);
+    g_task_set_task_data (task, ctx, (GDestroyNotify) common_connect_context_free);
+
+    /* We need a net data port */
+    if (data)
+        ctx->data = g_object_ref (data);
+    else {
+        ctx->data = mm_base_modem_get_best_data_port (MM_BASE_MODEM (modem), MM_PORT_TYPE_NET);
+        if (!ctx->data) {
+            g_task_return_new_error (task,
+                                     MM_CORE_ERROR,
+                                     MM_CORE_ERROR_NOT_FOUND,
+                                     "No valid data port found to launch connection");
+            g_object_unref (task);
+            return NULL;
+        }
+    }
+
+    return task;
+}
+
+/*****************************************************************************/
+/* 3GPP IP config (sub-step of the 3GPP Connection sequence) */
+
+static gboolean
+get_ip_config_3gpp_finish (MMBroadbandBearer *self,
+                           GAsyncResult      *res,
+                           MMBearerIpConfig  **ipv4_config,
+                           MMBearerIpConfig  **ipv6_config,
+                           GError            **error)
+{
+    MMBearerConnectResult *configs;
+    MMBearerIpConfig      *ipv4, *ipv6;
+
+    configs = g_task_propagate_pointer (G_TASK (res), error);
+    if (!configs)
+        return FALSE;
+
+    ipv4 = mm_bearer_connect_result_peek_ipv4_config (configs);
+    ipv6 = mm_bearer_connect_result_peek_ipv6_config (configs);
+    g_assert (ipv4 || ipv6);
+    if (ipv4_config && ipv4)
+        *ipv4_config = g_object_ref (ipv4);
+    if (ipv6_config && ipv6)
+        *ipv6_config = g_object_ref (ipv6);
+    mm_bearer_connect_result_unref (configs);
+    return TRUE;
+}
+
+static void
+complete_get_ip_config_3gpp (GTask *task)
+{
+    CommonConnectContext  *ctx;
+    MMBearerConnectResult *connect_result;
+
+    ctx = g_task_get_task_data (task);
+
+    if (ctx->family == MM_BEARER_IP_FAMILY_IPV4) {
+        g_assert(mm_bearer_ip_config_get_method(ctx->ipv4_config) != MM_BEARER_IP_METHOD_UNKNOWN);
+        connect_result = mm_bearer_connect_result_new(ctx->data, ctx->ipv4_config, NULL);
+    }
+    else if(ctx->family == MM_BEARER_IP_FAMILY_IPV6) {
+        g_assert(mm_bearer_ip_config_get_method(ctx->ipv6_config) != MM_BEARER_IP_METHOD_UNKNOWN);
+        connect_result = mm_bearer_connect_result_new(ctx->data, ctx->ipv6_config, NULL);
+    }
+    else {
+        g_assert(mm_bearer_ip_config_get_method(ctx->ipv4_config) != MM_BEARER_IP_METHOD_UNKNOWN);
+        g_assert(mm_bearer_ip_config_get_method(ctx->ipv6_config) != MM_BEARER_IP_METHOD_UNKNOWN);
+        connect_result = mm_bearer_connect_result_new(ctx->data, ctx->ipv4_config, ctx->ipv6_config);
+    }
+
+    g_task_return_pointer (task,
+                           connect_result,
+                           (GDestroyNotify) mm_bearer_connect_result_unref);
+    g_object_unref (task);
+}
+
+/*****************************************************************************/
+/* CGPADDR=N response parser */
+
+static gboolean
+mm_unitac_parse_cgpaddr_response (const gchar *response,
+                                  gchar       **out_ipv4_address,
+                                  gchar       **out_ipv6_address,
+                                  GError      **error)
+{
+    GRegex     *r;
+    GMatchInfo *match_info;
+    GError     *inner_error = NULL;
+    gchar      *ipv4_address = NULL;
+    gchar      *ipv6_address = NULL;
+
+    /* Response may be e.g.:
+     * response: '+CGPADDR: 1,"172.22.1.100"'
+     *
+     * We assume only ONE line is returned; because we request +CGPADDR with a specific N CID.
+     */
+    r = g_regex_new ("\\+CGPADDR: (\\d+)(?:,([^,]*))(?:,([^,]*))?", 0, 0, NULL);
+    g_assert (r != NULL);
+
+    g_regex_match_full (r, response, strlen (response), 0, 0, &match_info, &inner_error);
+    if (inner_error)
+        goto out;
+
+    if (!g_match_info_matches (match_info)) {
+        inner_error = g_error_new (MM_CORE_ERROR, MM_CORE_ERROR_INVALID_ARGS, "Couldn't match +CGPADDR response");
+        goto out;
+    }
+
+    if (out_ipv4_address)
+        ipv4_address = mm_get_string_unquoted_from_match_info(match_info, 2);
+
+    if (out_ipv6_address)
+        ipv6_address = mm_get_string_unquoted_from_match_info(match_info, 3);
+
+    out:
+
+    g_match_info_free (match_info);
+    g_regex_unref (r);
+
+    if (inner_error) {
+        g_free (ipv4_address);
+        g_free (ipv6_address);
+        g_propagate_error (error, inner_error);
+        return FALSE;
+    }
+
+    if (out_ipv4_address && ipv4_address)
+        *out_ipv4_address = ipv4_address;
+
+    if (out_ipv6_address && ipv6_address)
+        *out_ipv6_address = ipv6_address;
+
+    return TRUE;
+}
+
+static gboolean
+split_local_address_and_subnet (const gchar  *str,
+								gchar       **local_address,
+								gchar       **subnet)
+{
+	const gchar *separator;
+	guint count = 0;
+
+	/* E.g. split: "2.43.2.44.255.255.255.255"
+	 * into:
+	 *    local address: "2.43.2.44",
+	 *    subnet: "255.255.255.255"
+	 */
+	g_assert (str);
+	g_assert (local_address);
+	g_assert (subnet);
+
+	separator = str;
+	while (1) {
+		separator = strchr (separator, '.');
+		if (separator) {
+			count++;
+			if (count == 4) {
+				if (local_address)
+					*local_address = g_strndup (str, (separator - str));
+				if (subnet)
+					*subnet = g_strdup (++separator);
+				return TRUE;
+			}
+			separator++;
+			continue;
+		}
+
+		/* Not even the full IP? report error parsing */
+		if (count < 3)
+			return FALSE;
+
+		if (count == 3) {
+			if (local_address)
+				*local_address = g_strdup (str);
+			if (subnet)
+				*subnet = NULL;
+			return TRUE;
+		}
+	}
+}
+
+static int
+ipv6_netmask_len(char * mask_str)
+{
+	struct in6_addr netmask;
+	int len = 0;
+	unsigned char val;
+	unsigned char *pnt;
+
+	inet_pton(AF_INET6, mask_str, &netmask);
+	pnt = (unsigned char *) & netmask;
+
+	while ((*pnt == 0xff) && len < 128)
+	{
+		len += 8;
+		pnt++;
+	}
+
+	if (len < 128)
+	{
+		val = *pnt;
+		while (val)
+		{
+			len++;
+			val <<= 1;
+		}
+	}
+	return len;
+}
+
+gboolean
+mm_3gpp_cust_parse_cgcontrdp_response (const gchar  *response,
+									   gchar        **ipv4_address,
+									   gchar        **ipv4_subnet,
+									   gchar        **ipv4_gateway,
+									   gchar        **ipv4_dns1_addresses,
+									   gchar        **ipv4_dns2_addresses,
+									   gchar        **ipv6_address,
+									   int          *ipv6_subnet,
+									   gchar        **ipv6_gateway,
+									   gchar        **ipv6_dns1_addresses,
+									   gchar        **ipv6_dns2_addresses,
+									   gpointer     self,
+									   GError       **error)
+{
+	GRegex       *r;
+	GMatchInfo   *match_info;
+	GError       *inner_error = NULL;
+	guint        cid = 0;
+	guint        bearer_id = 0;
+	gchar        *ipv4_addr = NULL;
+	gchar        *ipv4_sub = NULL;
+	gchar        *ipv4_gat = NULL;
+	gchar        *ipv4_dns1 = NULL;
+	gchar        *ipv4_dns2 = NULL;
+	gchar        *ipv6_addr = NULL;
+	int          ipv6_sub = NULL;
+	gchar        *ipv6_gat = NULL;
+	gchar        *ipv6_dns1 = NULL;
+	gchar        *ipv6_dns2 = NULL;
+
+	r = g_regex_new ("\\+CGCONTRDP: "
+					 "(\\d+),(\\d+),([^,]*)" /* cid, bearer id, apn */
+					 "(?:,([^,]*))?" /* (a)ip+mask        or (b)ip */
+					 "(?:,([^,]*))?" /* (a)gateway        or (b)mask */
+					 "(?:,([^,]*))?" /* (a)dns1           or (b)gateway */
+					 "(?:,([^,]*))?" /* (a)dns2           or (b)dns1 */
+					 "(?:,([^,]*))?" /* (a)p-cscf primary or (b)dns2 */
+					 "(?:,(.*))?"    /* others, ignored */
+					 "(?:\\r\\n)?",
+					 G_REGEX_DOLLAR_ENDONLY | G_REGEX_RAW, 0, NULL);
+	g_assert (r != NULL);
+
+	g_regex_match_full (r, response, strlen (response), 0, 0, &match_info, &inner_error);
+	if (inner_error)
+		goto out;
+
+	while (!inner_error &&
+		   g_match_info_matches (match_info))
+	{
+		// Check CID
+		if (!mm_get_uint_from_match_info(match_info, 1, &cid))
+		{
+			inner_error = g_error_new(MM_CORE_ERROR, MM_CORE_ERROR_FAILED, "Error parsing cid");
+			break;
+		}
+
+		// Check bearer ID
+		if (!mm_get_uint_from_match_info(match_info, 2, &bearer_id))
+		{
+			inner_error = g_error_new(MM_CORE_ERROR, MM_CORE_ERROR_FAILED, "Error parsing bearer id");
+			break;
+		}
+
+		// Skip APN check as not needed
+
+		// Get Local Address and Subnet
+		gchar      *local_address_and_subnet = NULL;
+
+		local_address_and_subnet = mm_get_string_unquoted_from_match_info(match_info, 4);
+		if (local_address_and_subnet)
+		{
+			if(strstr (local_address_and_subnet, ":"))
+			{
+				char delim[] = " ";
+				if (ipv6_address && ipv6_subnet)
+				{
+					char * temp = NULL;
+					temp = strtok(local_address_and_subnet, delim);
+					if (temp != NULL)
+						ipv6_addr = strdup(temp);
+					temp = strtok(NULL, delim);
+					if (temp != NULL)
+						ipv6_sub = ipv6_netmask_len(temp);
+				}
+				if (ipv6_gateway)
+					ipv6_gat = mm_get_string_unquoted_from_match_info(match_info, 5);
+				if (ipv6_dns1_addresses)
+					ipv6_dns1 = mm_get_string_unquoted_from_match_info(match_info, 6);
+				if (ipv6_dns2_addresses)
+					ipv6_dns2 = mm_get_string_unquoted_from_match_info(match_info, 7);
+			}
+			else
+			{
+				if (ipv4_address && ipv4_subnet)
+					split_local_address_and_subnet(local_address_and_subnet, &ipv4_addr, &ipv4_sub);
+				if (ipv4_gateway)
+					ipv4_gat = mm_get_string_unquoted_from_match_info(match_info, 5);
+				if (ipv4_dns1_addresses)
+					ipv4_dns1 = mm_get_string_unquoted_from_match_info(match_info, 6);
+				if (ipv4_dns2_addresses)
+					ipv4_dns2 = mm_get_string_unquoted_from_match_info(match_info, 7);
+			}
+		}
+
+		g_free (local_address_and_subnet);
+		g_match_info_next (match_info, &inner_error);
+	}
+
+	out:
+	g_match_info_free (match_info);
+	g_regex_unref (r);
+
+	if (inner_error) {
+		g_free (ipv4_addr);
+		g_free (ipv4_sub);
+		g_free (ipv4_gat);
+		g_free (ipv4_dns1);
+		g_free (ipv4_dns2);
+		g_free (ipv6_addr);
+		g_free (ipv6_gat);
+		g_free (ipv6_dns1);
+		g_free (ipv6_dns2);
+		g_propagate_error (error, inner_error);
+		return FALSE;
+	}
+
+	/* IPv4 Connection Details */
+	if (ipv4_address)
+		*ipv4_address = ipv4_addr;
+	else
+		g_free (ipv4_addr);
+
+	if (ipv4_subnet)
+		*ipv4_subnet = ipv4_sub;
+	else
+		g_free (ipv4_sub);
+
+	if (ipv4_gateway)
+		*ipv4_gateway = ipv4_gat;
+	if (ipv4_dns1_addresses)
+		*ipv4_dns1_addresses = ipv4_dns1;
+	if (ipv4_dns2_addresses)
+		*ipv4_dns2_addresses = ipv4_dns2;
+
+	/* IPv6 Connection Details */
+	if (ipv6_address)
+		*ipv6_address = ipv6_addr;
+	else
+		g_free (ipv6_addr);
+
+	if (ipv6_subnet)
+		*ipv6_subnet = ipv6_sub;
+	else
+		g_free (ipv6_sub);
+
+	if (ipv6_gateway)
+		*ipv6_gateway = ipv6_gat;
+	if (ipv6_dns1_addresses)
+		*ipv6_dns1_addresses = ipv6_dns1;
+	if (ipv6_dns2_addresses)
+		*ipv6_dns2_addresses = ipv6_dns2;
+
+	return TRUE;
+}
+
+static void
+cgcontrdp_ready (MMBaseModem  *modem,
+				 GAsyncResult *res,
+				 GTask        *task)
+{
+	MMBroadbandBearerUnitac *self;
+	const gchar            *response;
+	GError                 *error = NULL;
+	CommonConnectContext   *ctx;
+	gchar                  *ipv4_address = NULL;
+	gchar                  *ipv4_subnet = NULL;
+	gchar                  *ipv4_gateway = NULL;
+	gchar                  *ipv4_dns_addresses[3] = { NULL, NULL, NULL };
+	gchar                  *ipv6_address = NULL;
+	int                    ipv6_subnet;
+	gchar                  *ipv6_gateway = NULL;
+	gchar                  *ipv6_dns_addresses[3] = { NULL, NULL, NULL };
+
+	self = g_task_get_source_object (task);
+	ctx  = g_task_get_task_data (task);
+
+	response = mm_base_modem_at_command_finish (modem, res, &error);
+
+	if (!response || !mm_3gpp_cust_parse_cgcontrdp_response (response,
+															 &ipv4_address,
+															 &ipv4_subnet,
+															 &ipv4_gateway,
+															 &ipv4_dns_addresses[0],
+															 &ipv4_dns_addresses[1],
+															 &ipv6_address,
+															 &ipv6_subnet,
+															 &ipv6_gateway,
+															 &ipv6_dns_addresses[0],
+															 &ipv6_dns_addresses[1],
+															 self,
+															 &error)) {
+		g_task_return_error (task, error);
+		g_object_unref (task);
+		return;
+	}
+
+	if (ctx->family == MM_BEARER_IP_FAMILY_IPV4) {
+		mm_obj_dbg (self, "Family: IPV4");
+		mm_obj_dbg (self, "IPv4 address retrieved: %s", ipv4_address);
+		mm_obj_dbg (self, "IPv4 subnet retrieved: %s", ipv4_subnet);
+		mm_obj_dbg (self, "IPv4 gateway retrieved: %s", ipv4_gateway);
+		if (ipv4_dns_addresses[0])
+			mm_obj_dbg (self, "IPv4 primary DNS retrieved: %s", ipv4_dns_addresses[0]);
+		if (ipv4_dns_addresses[1])
+			mm_obj_dbg (self, "IPv4 secondary DNS retrieved: %s", ipv4_dns_addresses[1]);
+
+		mm_bearer_ip_config_set_address (ctx->ipv4_config, ipv4_address);
+		mm_bearer_ip_config_set_prefix (ctx->ipv4_config, mm_netmask_to_cidr (ipv4_subnet));
+		mm_bearer_ip_config_set_gateway (ctx->ipv4_config, ipv4_gateway);
+		mm_bearer_ip_config_set_dns (ctx->ipv4_config, (const gchar **) ipv4_dns_addresses);
+	}
+	else if (ctx->family == MM_BEARER_IP_FAMILY_IPV6) {
+		mm_obj_dbg (self, "Family: IPV6");
+		mm_obj_dbg (self, "IPv6 address retrieved: %s", ipv6_address);
+		mm_obj_dbg (self, "IPv6 subnet retrieved: %d", ipv6_subnet);
+		mm_obj_dbg (self, "IPv6 gateway retrieved: %s", ipv6_gateway);
+		if (ipv4_dns_addresses[0])
+			mm_obj_dbg (self, "IPv6 primary DNS retrieved: %s", ipv6_dns_addresses[0]);
+		if (ipv4_dns_addresses[1])
+			mm_obj_dbg (self, "IPv6 secondary DNS retrieved: %s", ipv6_dns_addresses[1]);
+
+		mm_bearer_ip_config_set_address (ctx->ipv6_config, ipv6_address);
+		mm_bearer_ip_config_set_prefix (ctx->ipv6_config, ipv6_subnet);
+		mm_bearer_ip_config_set_gateway (ctx->ipv6_config, ipv6_gateway);
+		mm_bearer_ip_config_set_dns (ctx->ipv6_config, (const gchar **) ipv6_dns_addresses);
+	}
+	else {
+		mm_obj_dbg (self, "Family: IPV4V6");
+		mm_obj_dbg (self, "IPv4 address retrieved: %s", ipv4_address);
+		mm_obj_dbg (self, "IPv4 subnet retrieved: %s", ipv4_subnet);
+		mm_obj_dbg (self, "IPv4 gateway retrieved: %s", ipv4_gateway);
+		if (ipv4_dns_addresses[0])
+			mm_obj_dbg (self, "IPv4 primary DNS retrieved: %s", ipv4_dns_addresses[0]);
+		if (ipv4_dns_addresses[1])
+			mm_obj_dbg (self, "IPv4 secondary DNS retrieved: %s", ipv4_dns_addresses[1]);
+
+		mm_obj_dbg (self, "IPv6 address retrieved: %s", ipv6_address);
+		mm_obj_dbg (self, "IPv6 subnet retrieved: %d", ipv6_subnet);
+		mm_obj_dbg (self, "IPv6 gateway retrieved: %s", ipv6_gateway);
+		if (ipv6_dns_addresses[0])
+			mm_obj_dbg (self, "IPv6 primary DNS retrieved: %s", ipv6_dns_addresses[0]);
+		if (ipv6_dns_addresses[1])
+			mm_obj_dbg (self, "IPv6 secondary DNS retrieved: %s", ipv6_dns_addresses[1]);
+
+		mm_bearer_ip_config_set_address (ctx->ipv4_config, ipv4_address);
+		mm_bearer_ip_config_set_prefix (ctx->ipv4_config, mm_netmask_to_cidr (ipv4_subnet));
+		mm_bearer_ip_config_set_gateway (ctx->ipv4_config, ipv4_gateway);
+		mm_bearer_ip_config_set_dns (ctx->ipv4_config, (const gchar **) ipv4_dns_addresses);
+
+		mm_bearer_ip_config_set_address (ctx->ipv6_config, ipv6_address);
+		mm_bearer_ip_config_set_prefix (ctx->ipv6_config, ipv6_subnet);
+		mm_bearer_ip_config_set_gateway (ctx->ipv6_config, ipv6_gateway);
+		mm_bearer_ip_config_set_dns (ctx->ipv6_config, (const gchar **) ipv6_dns_addresses);
+	}
+
+	g_free (ipv4_address);
+	g_free (ipv4_subnet);
+	g_free (ipv4_gateway);
+	g_free (ipv4_dns_addresses[0]);
+	g_free (ipv4_dns_addresses[1]);
+	g_free (ipv6_address);
+	g_free (ipv6_gateway);
+	g_free (ipv6_dns_addresses[0]);
+	g_free (ipv6_dns_addresses[1]);
+
+	mm_obj_dbg (self, "finished IP settings retrieval for PDP context #%u...", ctx->cid);
+	complete_get_ip_config_3gpp (task);
+}
+
+static void
+cgpiaf_ready (MMBaseModem  *modem,
+			  GAsyncResult *res,
+			  GTask        *task)
+{
+	MMBroadbandBearerUnitac *self;
+	const gchar             *response;
+	GError                  *error = NULL;
+	CommonConnectContext    *ctx;
+
+	self = g_task_get_source_object (task);
+	ctx  = g_task_get_task_data (task);
+
+	if (!mm_base_modem_at_command_finish (modem, res, &error)) {
+		g_task_return_error (task, error);
+		g_object_unref (task);
+		return;
+	}
+
+	gchar *cmd = g_strdup_printf ("+CGCONTRDP=%u", ctx->cid);
+	mm_obj_dbg (self, "gathering connection details for PDP context #%u...", ctx->cid);
+	mm_base_modem_at_command (MM_BASE_MODEM (modem),
+							  cmd,
+							  10,
+							  FALSE,
+							  (GAsyncReadyCallback) cgcontrdp_ready,
+							  task);
+
+	g_free (cmd);
+}
+
+static void
+cgpaddr_ready (MMBaseModem  *modem,
+			   GAsyncResult *res,
+			   GTask        *task)
+{
+	MMBroadbandBearerUnitac *self;
+	const gchar             *response;
+	GError                  *error = NULL;
+	CommonConnectContext    *ctx;
+	gchar                   *ipv4_address = NULL;
+	gchar                   *ipv6_address = NULL;
+
+	self = g_task_get_source_object (task);
+	ctx  = g_task_get_task_data (task);
+
+	response = mm_base_modem_at_command_finish (modem, res, &error);
+
+	if (!response || !mm_unitac_parse_cgpaddr_response (response,
+														&ipv4_address,
+														&ipv6_address,
+														&error)) {
+		g_task_return_error (task, error);
+		g_object_unref (task);
+		return;
+	}
+
+	mm_obj_dbg(self, "IPv4 address retrieved: %s", ipv4_address ? ipv4_address : "");
+	mm_obj_dbg(self, "IPv6 address retrieved: %s", ipv6_address ? ipv6_address : "");
+
+	g_free (ipv4_address);
+	g_free (ipv6_address);
+
+	mm_base_modem_at_command (MM_BASE_MODEM (modem),
+							  "+CGPIAF=1,0,1,1",
+							  10,
+							  FALSE,
+							  (GAsyncReadyCallback) cgpiaf_ready,
+							  task);
+
+}
+
+static void
+get_ip_config_3gpp (MMBroadbandBearer   *_self,
+                    MMBroadbandModem    *modem,
+                    MMPortSerialAt      *primary,
+                    MMPortSerialAt      *secondary,
+                    MMPort              *data,
+                    guint               cid,
+                    MMBearerIpFamily    ip_family,
+                    GAsyncReadyCallback callback,
+                    gpointer            user_data)
+{
+    MMBroadbandBearerUnitac *self = MM_BROADBAND_BEARER_UNITAC (_self);
+    GTask                   *task;
+    CommonConnectContext    *ctx;
+
+    if (!(task = common_connect_task_new (MM_BROADBAND_BEARER_UNITAC (self),
+                                          MM_BROADBAND_MODEM (modem),
+                                          primary,
+                                          cid,
+                                          data,
+                                          NULL,
+                                          callback,
+                                          user_data)))
+        return;
+
+    ctx = g_task_get_task_data (task);
+    ctx->family = ip_family;
+
+    if (ctx->family == MM_BEARER_IP_FAMILY_IPV4) {
+        ctx->ipv4_config = mm_bearer_ip_config_new();
+        mm_bearer_ip_config_set_method(ctx->ipv4_config, MM_BEARER_IP_METHOD_DHCP);
+    }
+    else if (ctx->family == MM_BEARER_IP_FAMILY_IPV6) {
+        ctx->ipv6_config = mm_bearer_ip_config_new();
+        mm_bearer_ip_config_set_method(ctx->ipv6_config, MM_BEARER_IP_METHOD_DHCP);
+    }
+    else {
+        ctx->ipv4_config = mm_bearer_ip_config_new ();
+        ctx->ipv6_config = mm_bearer_ip_config_new ();
+        mm_bearer_ip_config_set_method (ctx->ipv4_config, MM_BEARER_IP_METHOD_DHCP);
+        mm_bearer_ip_config_set_method (ctx->ipv6_config, MM_BEARER_IP_METHOD_DHCP);
+    }
+
+    gchar *cmd;
+
+    cmd = g_strdup_printf ("+CGPADDR=%u", cid);
+    mm_obj_dbg (self, "gathering IP-Address information for PDP context #%u...", cid);
+    mm_base_modem_at_command (MM_BASE_MODEM (modem),
+                              cmd,
+                              10,
+                              FALSE,
+                              (GAsyncReadyCallback) cgpaddr_ready,
+                              task);
+    g_free (cmd);
+
+    return;
+}
+
+/*****************************************************************************/
+/* 3GPP Dialing (sub-step of the 3GPP Connection sequence) */
+
+static MMPort *
+dial_3gpp_finish (MMBroadbandBearer *self,
+                  GAsyncResult      *res,
+                  GError            **error)
+{
+    return MM_PORT (g_task_propagate_pointer (G_TASK (res), error));
+}
+
+static void
+cgact_query_ready (MMBaseModem  *modem,
+                   GAsyncResult *res,
+                   GTask        *task)
+{
+    MMBroadbandBearerUnitac  *self;
+    CommonConnectContext     *ctx;
+    const gchar              *response;
+    GError                   *error           = NULL;
+    GList                    *pdp_active_list = NULL;
+    GList                    *l;
+    MMBearerConnectionStatus status           = MM_BEARER_CONNECTION_STATUS_UNKNOWN;
+
+    self = g_task_get_source_object (task);
+    ctx = g_task_get_task_data (task);
+
+    response = mm_base_modem_at_command_full_finish (modem, res, &error);
+    if (response)
+        pdp_active_list = mm_3gpp_parse_cgact_read_response (response, &error);
+
+    if (error) {
+        g_assert (!pdp_active_list);
+        g_prefix_error (&error, "couldn't check current list of active PDP contexts: ");
+        g_task_return_error (task, error);
+        g_object_unref (task);
+        return;
+    }
+
+    for (l = pdp_active_list; l; l = g_list_next (l)) {
+        MM3gppPdpContextActive *pdp_active;
+
+        /* We look for he just assume the first active PDP context found is the one we're
+         * looking for. */
+        pdp_active = (MM3gppPdpContextActive *)(l->data);
+        if (pdp_active->cid == ctx->cid) {
+            status = (pdp_active->active ? MM_BEARER_CONNECTION_STATUS_CONNECTED : MM_BEARER_CONNECTION_STATUS_DISCONNECTED);
+            break;
+        }
+    }
+    mm_3gpp_pdp_context_active_list_free (pdp_active_list);
+
+    /* PDP context not found? This shouldn't happen, error out */
+    if (status == MM_BEARER_CONNECTION_STATUS_UNKNOWN)
+        g_task_return_new_error (task, MM_CORE_ERROR, MM_CORE_ERROR_FAILED,
+                                 "PDP context not found in the known contexts list");
+    else
+        mm_obj_dbg (self, "active PDP context found : %u", ctx->cid);
+
+    /* Go on */
+    ctx->step++;
+    dial_3gpp_context_step (task);
+}
+
+static void
+cgact_ready (MMBaseModem  *modem,
+             GAsyncResult *res,
+             GTask        *task)
+{
+    CommonConnectContext *ctx;
+    GError               *error = NULL;
+
+    ctx = g_task_get_task_data (task);
+
+    if (!mm_base_modem_at_command_full_finish (modem, res, &error)) {
+        g_task_return_error (task, error);
+        g_object_unref (task);
+        return;
+    }
+
+    /* Go on */
+    ctx->step++;
+    dial_3gpp_context_step (task);
+}
+
+static void
+authenticate_ready (MMBaseModem  *modem,
+                    GAsyncResult *res,
+                    GTask        *task)
+{
+    CommonConnectContext *ctx;
+    GError *error = NULL;
+
+    ctx = g_task_get_task_data (task);
+
+    if (!mm_base_modem_at_command_full_finish (modem, res, &error)) {
+        g_task_return_error (task, error);
+        g_object_unref (task);
+        return;
+    }
+
+    /* Go on */
+    ctx->step++;
+    dial_3gpp_context_step (task);
+}
+
+static void
+cgatt_ready (MMBaseModem  *modem,
+             GAsyncResult *res,
+             GTask        *task)
+{
+    CommonConnectContext *ctx;
+    GError               *error = NULL;
+
+    ctx = g_task_get_task_data (task);
+
+    if (!mm_base_modem_at_command_full_finish (modem, res, &error)) {
+        g_task_return_error (task, error);
+        g_object_unref (task);
+        return;
+    }
+
+    /* Go on */
+    ctx->step++;
+    dial_3gpp_context_step (task);
+}
+
+static void
+cgatt_disconnect (MMBaseModem  *modem,
+                  GAsyncResult *res,
+                  GTask        *task)
+{
+    CommonConnectContext *ctx;
+    GError               *error = NULL;
+
+    ctx = g_task_get_task_data (task);
+
+    if (!mm_base_modem_at_command_full_finish (modem, res, &error)) {
+        g_task_return_error (task, error);
+        g_object_unref (task);
+        return;
+    }
+}
+
+static void
+dial_3gpp_context_step (GTask *task)
+{
+    MMBroadbandBearerUnitac *self;
+    CommonConnectContext    *ctx;
+
+    self = g_task_get_source_object (task);
+    ctx = g_task_get_task_data (task);
+
+    if (g_task_return_error_if_cancelled (task)) {
+        g_object_unref (task);
+        return;
+    }
+
+    switch (ctx->step) {
+        case DIAL_3GPP_STEP_FIRST:
+            ctx->step++;
+            /* fall through */
+
+        case DIAL_3GPP_STEP_AUTHENTICATE:
+            if (!MM_IS_PORT_SERIAL_AT (ctx->data)) {
+                gchar *command;
+                const gchar *user;
+                const gchar *password;
+                const gchar *apn = NULL;
+                MMBearerAllowedAuth allowed_auth;
+                MMBearerIpFamily ip_type;
+                size_t type;
+
+                apn            = mm_bearer_properties_get_apn (mm_base_bearer_peek_config (MM_BASE_BEARER (self)));
+                user           = mm_bearer_properties_get_user (mm_base_bearer_peek_config (MM_BASE_BEARER (self)));
+                password       = mm_bearer_properties_get_password (mm_base_bearer_peek_config (MM_BASE_BEARER (self)));
+                allowed_auth   = mm_bearer_properties_get_allowed_auth (mm_base_bearer_peek_config (MM_BASE_BEARER (self)));
+                ip_type        = mm_bearer_properties_get_ip_type(mm_base_bearer_peek_config(MM_BASE_BEARER(self)));
+
+                if (ip_type == MM_BEARER_IP_FAMILY_IPV4)
+                    type = 0;
+                else if (type == MM_BEARER_IP_FAMILY_IPV6)
+                    type = 1;
+                else
+                    type = 2;
+
+                if (!user || !password || allowed_auth == MM_BEARER_ALLOWED_AUTH_NONE) {
+                    mm_obj_dbg (self, "not using authentication");
+                    command = g_strdup_printf ("%%APNCONF=%d,1,%u,\"%s\",2,,", ctx->cid, type, apn);
+                } else {
+                    gchar *quoted_user;
+                    gchar *quoted_password;
+                    guint auth;
+
+                    if (allowed_auth == MM_BEARER_ALLOWED_AUTH_UNKNOWN) {
+                        mm_obj_dbg (self, "using default (PAP) authentication method");
+                        auth = 0;
+                    } else if (allowed_auth & MM_BEARER_ALLOWED_AUTH_PAP) {
+                        mm_obj_dbg (self, "using PAP authentication method");
+                        auth = 0;
+                    } else if (allowed_auth & MM_BEARER_ALLOWED_AUTH_CHAP) {
+                        mm_obj_dbg (self, "using CHAP authentication method");
+                        auth = 1;
+                    } else {
+                        gchar *str;
+
+                        str = mm_bearer_allowed_auth_build_string_from_mask (allowed_auth);
+                        g_task_return_new_error (
+                                task,
+                                MM_CORE_ERROR,
+                                MM_CORE_ERROR_UNSUPPORTED,
+                                "cannot use any of the specified authentication methods (%s)",
+                                str);
+                        g_free (str);
+                        g_object_unref (task);
+                        return;
+                    }
+
+                    quoted_user = mm_port_serial_at_quote_string (user);
+                    quoted_password = mm_port_serial_at_quote_string (password);
+                    command = g_strdup_printf ("%%APNCONF=%d,1,%u,\"%s\",%d,\"%s\",\"%s\"",
+                                               ctx->cid,
+                                               type,
+                                               apn,
+                                               auth,
+                                               quoted_user,
+                                               quoted_password);
+                    g_free (quoted_user);
+                    g_free (quoted_password);
+                }
+
+                mm_base_modem_at_command_full (MM_BASE_MODEM(ctx->modem),
+                                               ctx->primary,
+                                               command,
+                                               3,
+                                               FALSE,
+                                               FALSE, /* raw */
+                                               NULL, /* cancellable */
+                                               (GAsyncReadyCallback)authenticate_ready,
+                                               task);
+                g_free (command);
+                return;
+            }
+            return;
+
+        case DIAL_3GPP_STEP_PS_ATTACH:
+            mm_base_modem_at_command_full (MM_BASE_MODEM(ctx->modem),
+                                           ctx->primary,
+                                           "+CGATT=1",
+                                           10,
+                                           FALSE,
+                                           FALSE, /* raw */
+                                           NULL, /* cancellable */
+                                           (GAsyncReadyCallback)cgatt_ready,
+                                           task);
+            return;
+
+        case DIAL_3GPP_STEP_CONNECT:
+            ctx->data = mm_base_modem_get_best_data_port (ctx->modem, MM_PORT_TYPE_NET);
+            if (ctx->data) {
+                gchar *command = g_strdup_printf("+CGACT=1,%u", ctx->cid);
+                mm_base_modem_at_command_full(MM_BASE_MODEM(ctx->modem),
+                                              ctx->primary,
+                                              command,
+                                              10,
+                                              FALSE,
+                                              FALSE, /* raw */
+                                              NULL, /* cancellable */
+                                              (GAsyncReadyCallback) cgact_ready,
+                                              task);
+                g_free(command);
+                return;
+            }
+            return;
+
+        case DIAL_3GPP_STEP_CONNECT_QUERY:
+            ctx->data = mm_base_modem_get_best_data_port (ctx->modem, MM_PORT_TYPE_NET);
+            if (ctx->data) {
+                mm_base_modem_at_command_full(MM_BASE_MODEM(ctx->modem),
+                                              ctx->primary,
+                                              "+CGACT?",
+                                              10,
+                                              FALSE,
+                                              FALSE, /* raw */
+                                              NULL, /* cancellable */
+                                              (GAsyncReadyCallback) cgact_query_ready,
+                                              task);
+                return;
+            }
+            return;
+
+        case DIAL_3GPP_STEP_LAST:
+            g_task_return_pointer (task,
+                                   g_object_ref (ctx->data),
+                                   g_object_unref);
+            g_object_unref (task);
+            return;
+
+        default:
+            g_assert_not_reached ();
+    }
+}
+
+static void
+dial_3gpp (MMBroadbandBearer   *self,
+           MMBaseModem         *modem,
+           MMPortSerialAt      *primary,
+           guint               cid,
+           GCancellable        *cancellable,
+           GAsyncReadyCallback callback,
+           gpointer            user_data)
+{
+    GTask *task;
+
+    if (!(task = common_connect_task_new (MM_BROADBAND_BEARER_UNITAC (self),
+                                          MM_BROADBAND_MODEM (modem),
+                                          primary,
+                                          cid,
+                                          NULL, /* data, unused */
+                                          cancellable,
+                                          callback,
+                                          user_data)))
+        return;
+
+    dial_3gpp_context_step (task);
+}
+
+/*****************************************************************************/
+/* 3GPP disconnection */
+
+static gboolean
+disconnect_3gpp_finish (MMBroadbandBearer *self,
+                        GAsyncResult      *res,
+                        GError            **error)
+{
+    return g_task_propagate_boolean (G_TASK (res), error);
+}
+
+static void
+cgact_deactivate_ready (MMBaseModem  *modem,
+                        GAsyncResult *res,
+                        GTask        *task)
+{
+    MMBroadbandBearerUnitac *self;
+    const gchar             *response;
+    GError                  *error = NULL;
+
+    self = g_task_get_source_object (task);
+
+    response = mm_base_modem_at_command_finish (modem, res, &error);
+    if (!response) {
+        if (!g_error_matches (error, MM_MOBILE_EQUIPMENT_ERROR, MM_MOBILE_EQUIPMENT_ERROR_GPRS_UNKNOWN) &&
+            !g_error_matches (error, MM_MOBILE_EQUIPMENT_ERROR, MM_MOBILE_EQUIPMENT_ERROR_GPRS_LAST_PDN_DISCONNECTION_NOT_ALLOWED) &&
+            !g_error_matches (error, MM_MOBILE_EQUIPMENT_ERROR, MM_MOBILE_EQUIPMENT_ERROR_GPRS_LAST_PDN_DISCONNECTION_NOT_ALLOWED_LEGACY)) {
+            g_task_return_error (task, error);
+            g_object_unref (task);
+            return;
+        }
+
+        mm_obj_dbg (self, "ignored error when disconnecting last LTE bearer: %s", error->message);
+        g_clear_error (&error);
+    }
+
+    // PS Detach
+    mm_obj_dbg (self, "PS detach...");
+    mm_base_modem_at_command (MM_BASE_MODEM (modem),
+                              "+CGATT=0",
+                              120,
+                              FALSE,
+                              (GAsyncReadyCallback) cgatt_disconnect,
+                              task);
+
+    g_task_return_boolean (task, TRUE);
+    g_object_unref (task);
+}
+
+static void
+disconnect_3gpp  (MMBroadbandBearer   *self,
+                  MMBroadbandModem    *modem,
+                  MMPortSerialAt      *primary,
+                  MMPortSerialAt      *secondary,
+                  MMPort              *data,
+                  guint               cid,
+                  GAsyncReadyCallback callback,
+                  gpointer            user_data)
+{
+    GTask            *task;
+    g_autofree gchar *cmd = NULL;
+
+    if (!(task = common_connect_task_new (MM_BROADBAND_BEARER_UNITAC (self),
+                                          MM_BROADBAND_MODEM (modem),
+                                          primary,
+                                          cid,
+                                          data,
+                                          NULL,
+                                          callback,
+                                          user_data)))
+        return;
+
+    // PDP Context Deactivate
+    cmd = g_strdup_printf ("+CGACT=0,%u", cid);
+    mm_obj_dbg (self, "deactivating PDP context #%u...", cid);
+    mm_base_modem_at_command (MM_BASE_MODEM (modem),
+                              cmd,
+                              120,
+                              FALSE,
+                              (GAsyncReadyCallback) cgact_deactivate_ready,
+                              task);
+}
+
+/*****************************************************************************/
+
+MMBaseBearer *
+mm_broadband_bearer_unitac_new_finish (GAsyncResult *res,
+                                       GError       **error)
+{
+    GObject *source;
+    GObject *bearer;
+
+    source = g_async_result_get_source_object (res);
+    bearer = g_async_initable_new_finish (G_ASYNC_INITABLE (source), res, error);
+    g_object_unref (source);
+
+    if (!bearer)
+        return NULL;
+
+    /* Only export valid bearers */
+    mm_base_bearer_export (MM_BASE_BEARER (bearer));
+
+    return MM_BASE_BEARER (bearer);
+}
+
+void
+mm_broadband_bearer_unitac_new (MMBroadbandModem    *modem,
+                                MMBearerProperties  *config,
+                                GCancellable        *cancellable,
+                                GAsyncReadyCallback callback,
+                                gpointer            user_data)
+{
+
+    g_async_initable_new_async (
+            MM_TYPE_BROADBAND_BEARER_UNITAC,
+            G_PRIORITY_DEFAULT,
+            cancellable,
+            callback,
+            user_data,
+            MM_BASE_BEARER_MODEM, modem,
+            MM_BASE_BEARER_CONFIG, config,
+            NULL);
+}
+
+static void
+mm_broadband_bearer_unitac_init (MMBroadbandBearerUnitac *self)
+{
+}
+static void
+mm_broadband_bearer_unitac_class_init (MMBroadbandBearerUnitacClass *klass)
+{
+    MMBaseBearerClass      *base_bearer_class      = MM_BASE_BEARER_CLASS (klass);
+    MMBroadbandBearerClass *broadband_bearer_class = MM_BROADBAND_BEARER_CLASS (klass);
+
+    broadband_bearer_class->disconnect_3gpp           = disconnect_3gpp;
+    broadband_bearer_class->disconnect_3gpp_finish    = disconnect_3gpp_finish;
+    broadband_bearer_class->dial_3gpp                 = dial_3gpp;
+    broadband_bearer_class->dial_3gpp_finish          = dial_3gpp_finish;
+    broadband_bearer_class->get_ip_config_3gpp        = get_ip_config_3gpp;
+    broadband_bearer_class->get_ip_config_3gpp_finish = get_ip_config_3gpp_finish;
+
+}
diff --git a/plugins/unitac/mm-broadband-bearer-unitac.h b/plugins/unitac/mm-broadband-bearer-unitac.h
new file mode 100644
index 0000000..22fd1e4
--- /dev/null
+++ b/plugins/unitac/mm-broadband-bearer-unitac.h
@@ -0,0 +1,58 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details:
+ *
+ * Copyright (C) 2021 Anubhav Gupta <anubhav.gupta@digi.com>
+ */
+
+#ifndef MM_BROADBAND_BEARER_UNITAC_H
+#define MM_BROADBAND_BEARER_UNITAC_H
+
+#include <glib.h>
+#include <glib-object.h>
+
+#define _LIBMM_INSIDE_MM
+#include <libmm-glib.h>
+
+#include "mm-broadband-bearer.h"
+
+#define MM_TYPE_BROADBAND_BEARER_UNITAC            (mm_broadband_bearer_unitac_get_type ())
+#define MM_BROADBAND_BEARER_UNITAC(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), MM_TYPE_BROADBAND_BEARER_UNITAC, MMBroadbandBearerUnitac))
+#define MM_BROADBAND_BEARER_UNITAC_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass),  MM_TYPE_BROADBAND_BEARER_UNITAC, MMBroadbandBearerUnitacClass))
+#define MM_IS_BROADBAND_BEARER_UNITAC(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MM_TYPE_BROADBAND_BEARER_UNITAC))
+#define MM_IS_BROADBAND_BEARER_UNITAC_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass),  MM_TYPE_BROADBAND_BEARER_UNITAC))
+#define MM_BROADBAND_BEARER_UNITAC_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj),  MM_TYPE_BROADBAND_BEARER_UNITAC, MMBroadbandBearerUnitacClass))
+
+#define MM_BROADBAND_BEARER_UNITAC_USB_PROFILE     "broadband-bearer-unitac-usb-profile"
+#define MM_BROADBAND_BEARER_UNITAC_NETWORKING_MODE "broadband-bearer-unitac-networking-mode"
+
+typedef struct _MMBroadbandBearerUnitac MMBroadbandBearerUnitac;
+typedef struct _MMBroadbandBearerUnitacClass MMBroadbandBearerUnitacClass;
+
+struct _MMBroadbandBearerUnitac {
+    MMBroadbandBearer parent;
+};
+
+struct _MMBroadbandBearerUnitacClass {
+    MMBroadbandBearerClass parent;
+};
+
+GType mm_broadband_bearer_unitac_get_type (void);
+
+void          mm_broadband_bearer_unitac_new        (MMBroadbandModem *modem,
+                                                     MMBearerProperties *config,
+                                                     GCancellable *cancellable,
+                                                     GAsyncReadyCallback callback,
+                                                     gpointer user_data);
+MMBaseBearer *mm_broadband_bearer_unitac_new_finish (GAsyncResult *res,
+                                                     GError **error);
+
+#endif /* MM_BROADBAND_BEARER_UNITAC_H */
diff --git a/plugins/unitac/mm-broadband-modem-unitac.c b/plugins/unitac/mm-broadband-modem-unitac.c
new file mode 100644
index 0000000..add2029
--- /dev/null
+++ b/plugins/unitac/mm-broadband-modem-unitac.c
@@ -0,0 +1,759 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details:
+ *
+ * Copyright (C) 2021 Anubhav Gupta <anubhav.gupta@digi.com>
+ */
+
+#include <config.h>
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <ctype.h>
+
+#include "ModemManager.h"
+#include "mm-log-object.h"
+#include "mm-iface-modem.h"
+#include "mm-iface-modem-3gpp.h"
+#include "mm-base-modem-at.h"
+#include "mm-broadband-bearer.h"
+#include "mm-broadband-modem-unitac.h"
+#include "mm-broadband-bearer-unitac.h"
+#include "mm-iface-modem-signal.h"
+#include "mm-modem-helpers.h"
+
+static void iface_modem_init (MMIfaceModem *iface);
+static void iface_modem_signal_init (MMIfaceModemSignal *iface);
+
+G_DEFINE_TYPE_EXTENDED (MMBroadbandModemUnitac, mm_broadband_modem_unitac, MM_TYPE_BROADBAND_MODEM, 0,
+                        G_IMPLEMENT_INTERFACE (MM_TYPE_IFACE_MODEM, iface_modem_init)
+                        G_IMPLEMENT_INTERFACE (MM_TYPE_IFACE_MODEM_SIGNAL, iface_modem_signal_init))
+
+
+/*****************************************************************************/
+/* Create Bearer (Modem interface) */
+
+typedef enum {
+    CREATE_BEARER_STEP_FIRST,
+    CREATE_BEARER_STEP_CHECK_PROFILE,
+    CREATE_BEARER_STEP_CREATE_BEARER,
+    CREATE_BEARER_STEP_LAST,
+} CreateBearerStep;
+
+typedef struct {
+    CreateBearerStep step;
+    MMBearerProperties *properties;
+    MMBaseBearer *bearer;
+    gboolean has_net;
+} CreateBearerContext;
+
+static void
+create_bearer_context_free (CreateBearerContext *ctx)
+{
+    g_clear_object (&ctx->bearer);
+    g_object_unref (ctx->properties);
+    g_slice_free (CreateBearerContext, ctx);
+}
+
+static MMBaseBearer *
+modem_create_bearer_finish (MMIfaceModem *self,
+                            GAsyncResult *res,
+                            GError **error)
+{
+    return MM_BASE_BEARER (g_task_propagate_pointer (G_TASK (res), error));
+}
+
+static void create_bearer_step (GTask *task);
+
+static void
+broadband_bearer_unitac_new_ready (GObject *source,
+                                   GAsyncResult *res,
+                                   GTask *task)
+{
+    MMBroadbandModemUnitac *self;
+    CreateBearerContext    *ctx;
+    GError                 *error = NULL;
+
+    self = g_task_get_source_object (task);
+    ctx  = g_task_get_task_data (task);
+
+    g_assert (!ctx->bearer);
+    ctx->bearer = mm_broadband_bearer_unitac_new_finish (res, &error);
+    if (!ctx->bearer) {
+        g_task_return_error (task, error);
+        g_object_unref (task);
+        return;
+    }
+
+    mm_obj_dbg (self, "new unitac broadband bearer created at DBus path '%s'", mm_base_bearer_get_path (ctx->bearer));
+    ctx->step++;
+    create_bearer_step (task);
+}
+
+/*****************************************************************************/
+/* +CESQ response parser */
+
+gboolean
+mm_3gpp_parse_cesq_response (const gchar *response,
+                             guint *out_rxlev,
+                             guint *out_ber,
+                             guint *out_rscp,
+                             guint *out_ecn0,
+                             guint *out_rsrq,
+                             guint *out_rsrp,
+                             GError **error)
+{
+    GRegex     *r;
+    GMatchInfo *match_info;
+    GError     *inner_error = NULL;
+    guint      rxlev = 99;
+    guint      ber = 99;
+    guint      rscp = 255;
+    guint      ecn0 = 255;
+    guint      rsrq = 255;
+    guint      rsrp = 255;
+    gboolean   success = FALSE;
+
+    g_assert (out_rxlev);
+    g_assert (out_ber);
+    g_assert (out_rscp);
+    g_assert (out_ecn0);
+    g_assert (out_rsrq);
+    g_assert (out_rsrp);
+
+    /* Response may be e.g.:
+     * +CESQ: 99,99,255,255,20,80
+     */
+    r = g_regex_new ("\\+CESQ: (\\d+), (\\d+), (\\d+), (\\d+), (\\d+), (\\d+)(?:\\r\\n)?", 0, 0, NULL);
+    g_assert (r != NULL);
+
+    g_regex_match_full (r, response, strlen (response), 0, 0, &match_info, &inner_error);
+    if (!inner_error && g_match_info_matches (match_info)) {
+        if (!mm_get_uint_from_match_info (match_info, 1, &rxlev)) {
+            inner_error = g_error_new (MM_CORE_ERROR, MM_CORE_ERROR_FAILED, "Couldn't read RXLEV");
+            goto out;
+        }
+        if (!mm_get_uint_from_match_info (match_info, 2, &ber)) {
+            inner_error = g_error_new (MM_CORE_ERROR, MM_CORE_ERROR_FAILED, "Couldn't read BER");
+            goto out;
+        }
+        if (!mm_get_uint_from_match_info (match_info, 3, &rscp)) {
+            inner_error = g_error_new (MM_CORE_ERROR, MM_CORE_ERROR_FAILED, "Couldn't read RSCP");
+            goto out;
+        }
+        if (!mm_get_uint_from_match_info (match_info, 4, &ecn0)) {
+            inner_error = g_error_new (MM_CORE_ERROR, MM_CORE_ERROR_FAILED, "Couldn't read Ec/N0");
+            goto out;
+        }
+        if (!mm_get_uint_from_match_info (match_info, 5, &rsrq)) {
+            inner_error = g_error_new (MM_CORE_ERROR, MM_CORE_ERROR_FAILED, "Couldn't read RSRQ");
+            goto out;
+        }
+        if (!mm_get_uint_from_match_info (match_info, 6, &rsrp)) {
+            inner_error = g_error_new (MM_CORE_ERROR, MM_CORE_ERROR_FAILED, "Couldn't read RSRP");
+            goto out;
+        }
+        success = TRUE;
+    }
+
+    out:
+    g_match_info_free (match_info);
+    g_regex_unref (r);
+
+    if (inner_error) {
+        g_propagate_error (error, inner_error);
+        return FALSE;
+    }
+
+    if (!success) {
+        g_set_error (error, MM_CORE_ERROR, MM_CORE_ERROR_FAILED,
+                     "couldn't parse +CESQ response: %s", response);
+        return FALSE;
+    }
+
+    *out_rxlev = rxlev;
+    *out_ber = ber;
+    *out_rscp = rscp;
+    *out_ecn0 = ecn0;
+    *out_rsrq = rsrq;
+    *out_rsrp = rsrp;
+    return TRUE;
+}
+
+/*****************************************************************************/
+/* Load extended signal information (Signal interface) */
+
+gboolean
+mm_3gpp_cesq_response_to_signal_info (const gchar *response,
+                                      gpointer log_object,
+                                      MMSignal **out_gsm,
+                                      MMSignal **out_umts,
+                                      MMSignal **out_lte,
+                                      GError **error)
+{
+    guint     rxlev = 0;
+    guint     ber = 0;
+    guint     rscp_level = 0;
+    guint     ecn0_level = 0;
+    guint     rsrq_level = 0;
+    guint     rsrp_level = 0;
+    gdouble   rssi = -G_MAXDOUBLE;
+    gdouble   rscp = -G_MAXDOUBLE;
+    gdouble   ecio = -G_MAXDOUBLE;
+    gdouble   rsrq = -G_MAXDOUBLE;
+    gdouble   rsrp = -G_MAXDOUBLE;
+    MMSignal  *gsm = NULL;
+    MMSignal  *umts = NULL;
+    MMSignal  *lte = NULL;
+
+    if (!mm_3gpp_parse_cesq_response (response,
+                                      &rxlev, &ber,
+                                      &rscp_level, &ecn0_level,
+                                      &rsrq_level, &rsrp_level,
+                                      error))
+        return FALSE;
+
+    /* GERAN RSSI */
+    if (mm_3gpp_rxlev_to_rssi (rxlev, log_object, &rssi)) {
+        gsm = mm_signal_new ();
+        mm_signal_set_rssi (gsm, rssi);
+    }
+
+    /* ignore BER */
+
+    /* UMTS RSCP */
+    if (mm_3gpp_rscp_level_to_rscp (rscp_level, log_object, &rscp)) {
+        umts = mm_signal_new ();
+        mm_signal_set_rscp (umts, rscp);
+    }
+
+    /* UMTS EcIo (assumed EcN0) */
+    if (mm_3gpp_ecn0_level_to_ecio (ecn0_level, log_object, &ecio)) {
+        if (!umts)
+            umts = mm_signal_new ();
+        mm_signal_set_ecio (umts, ecio);
+    }
+
+    /* LTE RSRQ */
+    if (mm_3gpp_rsrq_level_to_rsrq (rsrq_level, log_object, &rsrq)) {
+        lte = mm_signal_new ();
+        mm_signal_set_rsrq (lte, rsrq);
+    }
+
+    /* LTE RSRP */
+    if (mm_3gpp_rsrp_level_to_rsrp (rsrp_level, log_object, &rsrp)) {
+        if (!lte)
+            lte = mm_signal_new ();
+        mm_signal_set_rsrp (lte, rsrp);
+    }
+
+    if (!gsm && !umts && !lte) {
+        g_set_error (error, MM_CORE_ERROR, MM_CORE_ERROR_FAILED,
+                     "couldn't build detailed signal info");
+        return FALSE;
+    }
+
+    if (gsm)
+        *out_gsm = gsm;
+    if (umts)
+        *out_umts = umts;
+    if (lte)
+        *out_lte = lte;
+
+    return TRUE;
+}
+
+static gboolean
+modem_signal_load_values_finish (MMIfaceModemSignal *self,
+                                 GAsyncResult *res,
+                                 MMSignal **cdma,
+                                 MMSignal **evdo,
+                                 MMSignal **gsm,
+                                 MMSignal **umts,
+                                 MMSignal **lte,
+                                 GError **error)
+{
+    const gchar *response;
+
+    response = mm_base_modem_at_command_finish (MM_BASE_MODEM (self), res, error);
+    if (!response || !mm_3gpp_cesq_response_to_signal_info (response, self, gsm, umts, lte, error))
+        return FALSE;
+
+    /* No 3GPP2 support */
+    if (cdma)
+        *cdma = NULL;
+    if (evdo)
+        *evdo = NULL;
+    return TRUE;
+}
+
+/*****************************************************************************/
+/* %WMODE? response parser */
+
+gboolean
+mm_unitac_parse_wmode_response (const gchar *response,
+                                GError **error,
+                                GTask *task)
+{
+    MMBroadbandModemUnitac *self;
+    GRegex                 *r;
+    GMatchInfo             *match_info;
+    GError                 *inner_error = NULL;
+
+    self = g_task_get_source_object (task);
+    /* Response may be e.g.:
+     * response: 'MODE: bridge-ecm'
+     */
+    r = g_regex_new ("^MODE: \\w+.*$", 0, 0, NULL);
+    g_assert (r != NULL);
+
+    g_regex_match_full (r, response, strlen (response), 0, 0, &match_info, &inner_error);
+    if (!inner_error && g_match_info_matches (match_info)) {
+        gchar *wmode;
+
+        wmode = mm_get_string_unquoted_from_match_info (match_info, 1);
+        if (wmode) {
+            if (g_str_equal (wmode, "bridge-ecm"))
+                mm_obj_dbg (self, "modem is in bridge-ecm wmode");
+            else
+                mm_obj_dbg (self, "unknown wmode for the modem...%s", wmode);
+        } else
+            mm_obj_dbg (self, "unable to parse wmode for the modem");
+        g_free (wmode);
+    }
+
+    g_match_info_free (match_info);
+    g_regex_unref (r);
+
+    if (inner_error) {
+        g_propagate_error (error, inner_error);
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
+static void
+wmode_check_ready (MMBaseModem *_self,
+                   GAsyncResult *res,
+                   GTask *task)
+{
+    MMBroadbandModemUnitac *self      = MM_BROADBAND_MODEM_UNITAC (_self);
+    const gchar            *response;
+    GError                 *error     = NULL;
+    CreateBearerContext    *ctx;
+
+    ctx = g_task_get_task_data (task);
+
+    response = mm_base_modem_at_command_finish (_self, res, &error);
+    if (!response && !mm_unitac_parse_wmode_response (response, &error, task)) {
+        mm_obj_dbg (self, "couldn't load wmode: %s", error->message);
+        g_error_free (error);
+    }
+
+    ctx->step++;
+    create_bearer_step (task);
+}
+
+static void
+create_bearer_step (GTask *task)
+{
+    MMBroadbandModemUnitac *self;
+    CreateBearerContext    *ctx;
+
+    self = g_task_get_source_object (task);
+    ctx  = g_task_get_task_data (task);
+
+    switch (ctx->step) {
+    case CREATE_BEARER_STEP_FIRST:
+        ctx->step++;
+        /* fall through */
+
+    case CREATE_BEARER_STEP_CHECK_PROFILE:
+        mm_obj_dbg (self, "checking current WMODE...");
+        mm_base_modem_at_command (
+            MM_BASE_MODEM (self),
+            "%WMODE?",
+            3,
+            FALSE,
+            (GAsyncReadyCallback) wmode_check_ready,
+            task);
+        return;
+
+    case CREATE_BEARER_STEP_CREATE_BEARER:
+        /* we'll create a unitac bearer */
+        mm_obj_dbg (self, "creating unitac broadband bearer...");
+        mm_broadband_bearer_unitac_new (
+            MM_BROADBAND_MODEM (self),
+            ctx->properties,
+            NULL, /* cancellable */
+            (GAsyncReadyCallback) broadband_bearer_unitac_new_ready,
+            task);
+        return;
+
+    case CREATE_BEARER_STEP_LAST:
+        g_assert (ctx->bearer);
+        g_task_return_pointer (task, g_object_ref (ctx->bearer), g_object_unref);
+        g_object_unref (task);
+        return;
+
+    default:
+        g_assert_not_reached ();
+    }
+
+    g_assert_not_reached ();
+}
+
+static void
+modem_create_bearer (MMIfaceModem *self,
+                     MMBearerProperties *properties,
+                     GAsyncReadyCallback callback,
+                     gpointer user_data)
+{
+    CreateBearerContext *ctx;
+    GTask               *task;
+
+    ctx = g_slice_new0 (CreateBearerContext);
+    ctx->step = CREATE_BEARER_STEP_FIRST;
+    ctx->properties = g_object_ref (properties);
+
+    /* Flag whether this modem has exposed a network interface */
+    ctx->has_net = !!mm_base_modem_peek_best_data_port (MM_BASE_MODEM (self), MM_PORT_TYPE_NET);
+
+    task = g_task_new (self, NULL, callback, user_data);
+    g_task_set_task_data (task, ctx, (GDestroyNotify) create_bearer_context_free);
+    create_bearer_step (task);
+}
+
+/*****************************************************************************/
+/* Load current bands (Modem interface) */
+
+typedef struct {
+    guint       num;
+    MMModemBand band;
+} UbandBandConfig;
+
+static const UbandBandConfig uband_band_config[] = {
+        /* LTE bands */
+        { .num =  3,  .band = MM_MODEM_BAND_EUTRAN_3  },
+        { .num =  7,  .band = MM_MODEM_BAND_EUTRAN_7  },
+        { .num =  20, .band = MM_MODEM_BAND_EUTRAN_20 },
+        { .num =  31, .band = MM_MODEM_BAND_EUTRAN_31 },
+};
+
+static GArray *
+load_current_bands_finish (MMIfaceModem *self,
+                           GAsyncResult *res,
+                           GError **error)
+{
+    return (GArray *) g_task_propagate_pointer (G_TASK (res), error);
+}
+
+static MMModemBand
+uband_num_to_band (guint num)
+{
+    guint i;
+
+    for (i = 0; i < G_N_ELEMENTS (uband_band_config); i++) {
+        if (num == uband_band_config[i].num)
+            return uband_band_config[i].band;
+    }
+    return MM_MODEM_BAND_UNKNOWN;
+}
+
+static GArray *
+uband_num_array_to_band_array (GArray *nums)
+{
+    GArray *bands = NULL;
+    guint  i;
+
+    if (!nums)
+        return NULL;
+
+    bands = g_array_sized_new (FALSE, FALSE, sizeof (MMModemBand), nums->len);
+    for (i = 0; i < nums->len; i++) {
+        MMModemBand band;
+
+        band = uband_num_to_band (g_array_index (nums, guint, i));
+        g_array_append_val (bands, band);
+    }
+
+    return bands;
+}
+
+
+GArray *
+mm_unitac_parse_uband_response (const gchar *response,
+                                gpointer log_object,
+                                GError **error)
+{
+    GRegex     *r;
+    GMatchInfo *match_info;
+    GError     *inner_error = NULL;
+    GArray     *nums        = NULL;
+    GArray     *bands       = NULL;
+
+    /*
+     * AT+UBAND?
+     * !UBAND: 31,20,3,72
+     */
+    r = g_regex_new ("\\!UBAND: (.*)(?:\\r\\n)?",
+                     G_REGEX_DOLLAR_ENDONLY | G_REGEX_RAW, 0, NULL);
+    g_assert (r != NULL);
+
+    g_regex_match_full (r, response, strlen (response), 0, 0, &match_info, &inner_error);
+    if (!inner_error && g_match_info_matches (match_info)) {
+        gchar *bandstr;
+        bandstr = mm_get_string_unquoted_from_match_info (match_info, 1);
+        nums = mm_parse_uint_list (bandstr, &inner_error);
+        g_free (bandstr);
+    }
+
+    g_match_info_free (match_info);
+    g_regex_unref (r);
+
+    if (inner_error) {
+        g_propagate_error (error, inner_error);
+        return NULL;
+    }
+
+    /* Convert to MMModemBand values */
+    if (nums) {
+        bands = uband_num_array_to_band_array (nums);
+        g_array_unref (nums);
+    }
+
+    if (!bands)
+        g_set_error (error, MM_CORE_ERROR, MM_CORE_ERROR_FAILED,
+                     "no known band selection values matched in !UBAND response: '%s'", response);
+
+    return bands;
+}
+
+static void
+uband_load_current_bands_ready (MMBaseModem *self,
+                                GAsyncResult *res,
+                                GTask *task)
+{
+    GError      *error = NULL;
+    const gchar *response;
+    GArray      *out;
+
+    response = mm_base_modem_at_command_finish (self, res, &error);
+    if (!response) {
+        g_task_return_error (task, error);
+        g_object_unref (task);
+        return;
+    }
+
+    out = mm_unitac_parse_uband_response (response, self, &error);
+    if (!out) {
+        g_task_return_error (task, error);
+        g_object_unref (task);
+        return;
+    }
+
+    g_task_return_pointer (task, out, (GDestroyNotify)g_array_unref);
+    g_object_unref (task);
+}
+
+static void
+load_current_bands (MMIfaceModem *_self,
+                    GAsyncReadyCallback callback,
+                    gpointer user_data)
+{
+    MMBroadbandModemUnitac *self = MM_BROADBAND_MODEM_UNITAC(_self);
+    GTask                  *task;
+
+    task = g_task_new (self, NULL, callback, user_data);
+
+    mm_obj_dbg (self, "loading current bands...");
+    mm_base_modem_at_command (
+            MM_BASE_MODEM (self),
+            "!UBAND?",
+            3,
+            FALSE,
+            (GAsyncReadyCallback)uband_load_current_bands_ready,
+            task);
+}
+
+/*****************************************************************************/
+/* Load supported bands (Modem interface) */
+typedef struct {
+    const gchar *model;
+    MMModemMode mode;
+    MMModemBand bands_4g[12];
+} BandConfiguration;
+
+static const BandConfiguration band_configuration[] = {
+        {
+                .model    = "ML660PG",
+                .mode     = MM_MODEM_MODE_4G,
+                .bands_4g = { MM_MODEM_BAND_EUTRAN_3, MM_MODEM_BAND_EUTRAN_20, MM_MODEM_BAND_EUTRAN_31 }
+        },
+        {
+                .model    = "ML620EU",
+                .mode     = MM_MODEM_MODE_4G,
+                .bands_4g = { MM_MODEM_BAND_EUTRAN_3, MM_MODEM_BAND_EUTRAN_7, MM_MODEM_BAND_EUTRAN_20,
+                              MM_MODEM_BAND_EUTRAN_31 }
+        },
+};
+
+GArray *
+mm_unitac_get_supported_bands (const gchar *model,
+                               gpointer log_object,
+                               GError **error)
+{
+    MMModemMode mode;
+    GArray      *bands;
+    guint       i, j;
+
+    bands = g_array_new (FALSE, FALSE, sizeof (MMModemBand));
+    for (i = 0; i < G_N_ELEMENTS (band_configuration); i++) {
+        if (g_str_has_prefix (model, band_configuration[i].model)) {
+            mm_obj_dbg (log_object, "known supported bands found for model: %s", band_configuration[i].model);
+            break;
+        }
+    }
+
+    if (i == G_N_ELEMENTS (band_configuration)) {
+        mm_obj_warn (log_object, "unknown model name given when looking for supported bands: %s", model);
+        return NULL;
+    }
+
+    mode = band_configuration[i].mode;
+
+    if (mode & MM_MODEM_MODE_4G) {
+        for (j = 0; j < G_N_ELEMENTS (band_configuration[i].bands_4g) && band_configuration[i].bands_4g[j]; j++) {
+            bands = g_array_append_val (bands, band_configuration[i].bands_4g[j]);
+        }
+    }
+
+    if (bands->len == 0) {
+        g_array_unref (bands);
+        g_set_error (error, MM_CORE_ERROR, MM_CORE_ERROR_FAILED,
+                     "no valid supported bands loaded");
+        return NULL;
+    }
+
+    return bands;
+}
+
+static GArray *
+load_supported_bands_finish (MMIfaceModem *self,
+                             GAsyncResult *res,
+                             GError **error)
+{
+    return (GArray *) g_task_propagate_pointer (G_TASK (res), error);
+}
+
+static void
+load_supported_bands (MMIfaceModem *self,
+                      GAsyncReadyCallback callback,
+                      gpointer user_data)
+{
+    GTask       *task;
+    GError      *error = NULL;
+    GArray      *bands = NULL;
+    const gchar *model;
+
+    mm_obj_dbg (self, "loading supported bands...");
+    model = mm_iface_modem_get_model (self);
+    task  = g_task_new (self, NULL, callback, user_data);
+
+    bands = mm_unitac_get_supported_bands (model, self, &error);
+    if (!bands)
+        g_task_return_error (task, error);
+    else
+        g_task_return_pointer(task, bands, (GDestroyNotify) g_array_unref);
+
+    g_object_unref (task);
+}
+
+/*****************************************************************************/
+/* Initializing the modem (during first enabling) */
+
+static gboolean
+enabling_modem_init_finish (MMBroadbandModem *self,
+                            GAsyncResult *res,
+                            GError **error)
+{
+    return !!mm_base_modem_at_command_full_finish (MM_BASE_MODEM (self), res, error);
+}
+
+static void
+enabling_modem_init (MMBroadbandModem *self,
+                     GAsyncReadyCallback callback,
+                     gpointer user_data)
+{
+    /* ATZ resets the Unitac modem and switches the WMODE, instead run AT */
+    mm_base_modem_at_command_full (MM_BASE_MODEM (self),
+                                   mm_base_modem_peek_port_primary (MM_BASE_MODEM (self)),
+                                   "AT",
+                                   6,
+                                   FALSE,
+                                   FALSE,
+                                   NULL, /* cancellable */
+                                   callback,
+                                   user_data);
+}
+
+/*****************************************************************************/
+
+MMBroadbandModemUnitac *
+mm_broadband_modem_unitac_new (const gchar *device,
+                              const gchar **drivers,
+                              const gchar *plugin,
+                              guint16 vendor_id,
+                              guint16 product_id)
+{
+    return g_object_new (MM_TYPE_BROADBAND_MODEM_UNITAC,
+                         MM_BASE_MODEM_DEVICE,     device,
+                         MM_BASE_MODEM_DRIVERS,    drivers,
+                         MM_BASE_MODEM_PLUGIN,     plugin,
+                         MM_BASE_MODEM_VENDOR_ID,  vendor_id,
+                         MM_BASE_MODEM_PRODUCT_ID, product_id,
+                         NULL);
+}
+
+static void
+mm_broadband_modem_unitac_init (MMBroadbandModemUnitac *self)
+{
+}
+
+static void
+iface_modem_init (MMIfaceModem *iface)
+{
+    iface->create_bearer               = modem_create_bearer;
+    iface->create_bearer_finish        = modem_create_bearer_finish;
+    iface->load_supported_bands        = load_supported_bands;
+    iface->load_supported_bands_finish = load_supported_bands_finish;
+    iface->load_current_bands          = load_current_bands;
+    iface->load_current_bands_finish   = load_current_bands_finish;
+}
+
+static void
+iface_modem_signal_init (MMIfaceModemSignal *iface)
+{
+    iface->load_values_finish = modem_signal_load_values_finish;
+}
+
+static void
+mm_broadband_modem_unitac_class_init (MMBroadbandModemUnitacClass *klass)
+{
+    GObjectClass          *object_class          = G_OBJECT_CLASS (klass);
+    MMBroadbandModemClass *broadband_modem_class = MM_BROADBAND_MODEM_CLASS (klass);
+
+    broadband_modem_class->enabling_modem_init        = enabling_modem_init;
+    broadband_modem_class->enabling_modem_init_finish = enabling_modem_init_finish;
+}
diff --git a/plugins/unitac/mm-broadband-modem-unitac.h b/plugins/unitac/mm-broadband-modem-unitac.h
new file mode 100644
index 0000000..6718fd4
--- /dev/null
+++ b/plugins/unitac/mm-broadband-modem-unitac.h
@@ -0,0 +1,47 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details:
+ *
+ * Copyright (C) 2021 Anubhav Gupta <anubhav.gupta@digi.com>
+ */
+
+#ifndef MM_BROADBAND_MODEM_UNITAC_H
+#define MM_BROADBAND_MODEM_UNITAC_H
+
+#include "mm-broadband-modem.h"
+
+#define MM_TYPE_BROADBAND_MODEM_UNITAC            (mm_broadband_modem_unitac_get_type ())
+#define MM_BROADBAND_MODEM_UNITAC(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), MM_TYPE_BROADBAND_MODEM_UNITAC, MMBroadbandModemUnitac))
+#define MM_BROADBAND_MODEM_UNITAC_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass),  MM_TYPE_BROADBAND_MODEM_UNITAC, MMBroadbandModemUnitacClass))
+#define MM_IS_BROADBAND_MODEM_UNITAC(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MM_TYPE_BROADBAND_MODEM_UNITAC))
+#define MM_IS_BROADBAND_MODEM_UNITAC_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass),  MM_TYPE_BROADBAND_MODEM_UNITAC))
+#define MM_BROADBAND_MODEM_UNITAC_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj),  MM_TYPE_BROADBAND_MODEM_UNITAC, MMBroadbandModemUnitacClass))
+
+typedef struct _MMBroadbandModemUnitac MMBroadbandModemUnitac;
+typedef struct _MMBroadbandModemUnitacClass MMBroadbandModemUnitacClass;
+
+struct _MMBroadbandModemUnitac {
+    MMBroadbandModem parent;
+};
+
+struct _MMBroadbandModemUnitacClass{
+    MMBroadbandModemClass parent;
+};
+
+GType mm_broadband_modem_unitac_get_type (void);
+
+MMBroadbandModemUnitac *mm_broadband_modem_unitac_new (const gchar *device,
+                                                       const gchar **drivers,
+                                                       const gchar *plugin,
+                                                       guint16 vendor_id,
+                                                       guint16 product_id);
+
+#endif /* MM_BROADBAND_MODEM_UNITAC_H */
diff --git a/plugins/unitac/mm-plugin-unitac.c b/plugins/unitac/mm-plugin-unitac.c
new file mode 100644
index 0000000..48b304e
--- /dev/null
+++ b/plugins/unitac/mm-plugin-unitac.c
@@ -0,0 +1,107 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details:
+ *
+ * Copyright (C) 2021 Anubhav Gupta <anubhav.gupta@digi.com>
+ */
+
+#include <string.h>
+#include <termios.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <time.h>
+
+#include <gmodule.h>
+
+#define _LIBMM_INSIDE_MM
+#include <libmm-glib.h>
+
+#if defined WITH_QMI
+#include "mm-broadband-modem-qmi.h"
+#endif
+
+#if defined WITH_MBIM
+#include "mm-broadband-modem-mbim.h"
+#endif
+
+#include "mm-plugin-unitac.h"
+#include "mm-broadband-modem.h"
+#include "mm-serial-parsers.h"
+#include "mm-log-object.h"
+
+G_DEFINE_TYPE (MMPluginUnitac, mm_plugin_unitac, MM_TYPE_PLUGIN)
+
+MM_PLUGIN_DEFINE_MAJOR_VERSION
+MM_PLUGIN_DEFINE_MINOR_VERSION
+
+/*****************************************************************************/
+
+static MMBaseModem *
+create_modem (MMPlugin *self,
+              const gchar *uid,
+              const gchar **drivers,
+              guint16 vendor,
+              guint16 product,
+              GList *probes,
+              GError **error)
+{
+    return MM_BASE_MODEM (mm_broadband_modem_unitac_new (uid,
+                                                         drivers,
+                                                         mm_plugin_get_name (self),
+                                                         vendor,
+                                                         product));
+}
+
+/*****************************************************************************/
+/* Custom init context */
+
+typedef struct {
+    MMPortSerialAt *port;
+    GRegex         *ready_regex;
+    guint           timeout_id;
+    gint            wait_timeout_secs;
+} CustomInitContext;
+
+
+G_MODULE_EXPORT MMPlugin *
+mm_plugin_create (void)
+{
+    static const gchar *subsystems[] = { "tty", "net", "usb", NULL };
+    static const guint16 vendor_ids[] = { 0x1076, 0 };
+
+    return MM_PLUGIN (
+        g_object_new (MM_TYPE_PLUGIN_UNITAC,
+                      MM_PLUGIN_NAME,               MM_MODULE_NAME,
+                      MM_PLUGIN_ALLOWED_SUBSYSTEMS, subsystems,
+                      MM_PLUGIN_ALLOWED_VENDOR_IDS, vendor_ids,
+                      MM_PLUGIN_ALLOWED_AT,         TRUE,
+                      MM_PLUGIN_ALLOWED_QCDM,       FALSE,
+                      MM_PLUGIN_ALLOWED_QMI,        FALSE,
+                      MM_PLUGIN_ALLOWED_MBIM,       FALSE,
+                      NULL));
+}
+
+static void
+mm_plugin_unitac_init (MMPluginUnitac *self)
+{
+}
+
+static void
+mm_plugin_unitac_class_init (MMPluginUnitacClass *klass)
+{
+    MMPluginClass *plugin_class = MM_PLUGIN_CLASS (klass);
+
+    plugin_class->create_modem = create_modem;
+}
diff --git a/plugins/unitac/mm-plugin-unitac.h b/plugins/unitac/mm-plugin-unitac.h
new file mode 100644
index 0000000..9128bf8
--- /dev/null
+++ b/plugins/unitac/mm-plugin-unitac.h
@@ -0,0 +1,40 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details:
+ *
+ * Copyright (C) 2021 Anubhav Gupta <anubhav.gupta@digi.com>.
+ */
+
+#ifndef MM_PLUGIN_UNITAC_H
+#define MM_PLUGIN_UNITAC_H
+
+#include "mm-plugin.h"
+
+#define MM_TYPE_PLUGIN_UNITAC            (mm_plugin_unitac_get_type ())
+#define MM_PLUGIN_UNITAC(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), MM_TYPE_PLUGIN_UNITAC, MMPluginUnitac))
+#define MM_PLUGIN_UNITAC_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass),  MM_TYPE_PLUGIN_UNITAC, MMPluginUnitacClass))
+#define MM_IS_PLUGIN_UNITAC(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MM_TYPE_PLUGIN_UNITAC))
+#define MM_IS_PLUGIN_UNITAC_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass),  MM_TYPE_PLUGIN_UNITAC))
+#define MM_PLUGIN_UNITAC_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj),  MM_TYPE_PLUGIN_UNITAC, MMPluginUnitacClass))
+
+typedef struct {
+    MMPlugin parent;
+} MMPluginUnitac;
+
+typedef struct {
+    MMPluginClass parent;
+} MMPluginUnitacClass;
+
+GType mm_plugin_unitac_get_type (void);
+
+G_MODULE_EXPORT MMPlugin *mm_plugin_create (void);
+
+#endif /* MM_PLUGIN_UNITAC_H */
-- 
2.7.4


From 0fe180dc3aae164adce0c507544ed59ff5bda20f Mon Sep 17 00:00:00 2001
From: Anubhav Gupta <anubhav.gupta@digi.com>
Date: Tue, 29 Jun 2021 09:49:07 -0400
Subject: [PATCH 2/7] Unitac: Updated Unitac plugin

1. Seperated helper functions into a separate mm-modem-helpers-unitac.c file to align with rest of the plugins
2. Changed the function to query the ICCID as ML620 uses proprietary command.
3. Fixed dial_3gpp method as instructed by Unitac to make a proper connection.
4. Fixed collection of IPv6 and IPv4 connection details.
5. Changed udev port rules for ML620
---
 configure.ac                                 |   2 +-
 include/ModemManager-enums.h                 |   1 +
 plugins/Makefile.am                          |  27 +-
 plugins/unitac/77-mm-unitac-port-types.rules |   6 +-
 plugins/unitac/mm-broadband-bearer-unitac.c  | 827 ++++++++++-----------------
 plugins/unitac/mm-broadband-modem-unitac.c   | 268 ++-------
 plugins/unitac/mm-modem-helpers-unitac.c     | 604 +++++++++++++++++++
 plugins/unitac/mm-modem-helpers-unitac.h     | 112 ++++
 plugins/unitac/mm-sim-unitac.c               | 165 ++++++
 plugins/unitac/mm-sim-unitac.h               |  51 ++
 10 files changed, 1283 insertions(+), 780 deletions(-)
 create mode 100644 plugins/unitac/mm-modem-helpers-unitac.c
 create mode 100644 plugins/unitac/mm-modem-helpers-unitac.h
 create mode 100644 plugins/unitac/mm-sim-unitac.c
 create mode 100644 plugins/unitac/mm-sim-unitac.h

diff --git a/configure.ac b/configure.ac
index e1f58da..d6badda 100644
--- a/configure.ac
+++ b/configure.ac
@@ -507,7 +507,7 @@ MM_ENABLE_PLUGIN([wavecom])
 MM_ENABLE_PLUGIN([x22x])
 MM_ENABLE_PLUGIN([zte],
                  [with_shared_icera])
-MM_ENABLE_PLUGIN([unitac]
+MM_ENABLE_PLUGIN([unitac])
 
 MM_BUILD_SHARED([icera])
 MM_BUILD_SHARED([sierra])
diff --git a/include/ModemManager-enums.h b/include/ModemManager-enums.h
index 9377ba0..333ded6 100644
--- a/include/ModemManager-enums.h
+++ b/include/ModemManager-enums.h
@@ -486,6 +486,7 @@ typedef enum { /*< underscore_name=mm_modem_band >*/
     MM_MODEM_BAND_EUTRAN_69 = 99,
     MM_MODEM_BAND_EUTRAN_70 = 100,
     MM_MODEM_BAND_EUTRAN_71 = 101,
+    MM_MODEM_BAND_EUTRAN_72 = 102,
     /* CDMA Band Classes (see 3GPP2 C.S0057-C) */
     MM_MODEM_BAND_CDMA_BC0  = 128,
     MM_MODEM_BAND_CDMA_BC1  = 129,
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 86c023f..5a28819 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -1592,7 +1592,26 @@ if ENABLE_PLUGIN_UNITAC
 
 dist_udevrules_DATA += unitac/77-mm-unitac-port-types.rules
 
+PLUGIN_UNITAC_COMPILER_FLAGS = \
+	-I$(top_srcdir)/plugins/unitac \
+	-I$(top_builddir)/plugins/unitac \
+	$(NULL)
+
+noinst_LTLIBRARIES += libhelpers-unitac.la
+
+libhelpers_unitac_la_SOURCES = \
+	unitac/mm-modem-helpers-unitac.c \
+	unitac/mm-modem-helpers-unitac.h \
+	$(NULL)
+
+libhelpers_unitac_la_CPPFLAGS = \
+	$(PLUGIN_UNITAC_COMPILER_FLAGS) \
+	-DMM_MODULE_NAME=\"unitac\" \
+	$(NULL)
+
+
 pkglib_LTLIBRARIES += libmm-plugin-unitac.la
+
 libmm_plugin_unitac_la_SOURCES = \
 	unitac/mm-plugin-unitac.c \
 	unitac/mm-plugin-unitac.h \
@@ -1600,13 +1619,17 @@ libmm_plugin_unitac_la_SOURCES = \
 	unitac/mm-broadband-bearer-unitac.h \
 	unitac/mm-broadband-modem-unitac.c  \
 	unitac/mm-broadband-modem-unitac.h  \
+	unitac/mm-sim-unitac.c \
+	unitac/mm-sim-unitac.h \
 	$(NULL)
+
 libmm_plugin_unitac_la_CPPFLAGS = \
 	$(PLUGIN_COMMON_COMPILER_FLAGS) \
+	$(PLUGIN_UNITAC_COMPILER_FLAGS) \
 	-DMM_MODULE_NAME=\"unitac\" \
 	$(NULL)
-
-libmm_plugin_unitac_la_LDFLAGS  = $(PLUGIN_COMMON_LINKER_FLAGS)
+libmm_plugin_unitac_la_LDFLAGS = $(PLUGIN_COMMON_LINKER_FLAGS)
+libmm_plugin_unitac_la_LIBADD = $(builddir)/libhelpers-unitac.la
 
 endif
 
diff --git a/plugins/unitac/77-mm-unitac-port-types.rules b/plugins/unitac/77-mm-unitac-port-types.rules
index 6fd523e..a59309b 100644
--- a/plugins/unitac/77-mm-unitac-port-types.rules
+++ b/plugins/unitac/77-mm-unitac-port-types.rules
@@ -7,14 +7,12 @@ GOTO="mm_unitac_port_types_end"
 LABEL="mm_unitac_port_types"
 SUBSYSTEMS=="usb", ATTRS{bInterfaceNumber}=="?*", ENV{.MM_USBIFNUM}="$attr{bInterfaceNumber}"
 
-# ML660PG -> wmode=router, used for firmware update
+# ML620EU -> wmode=router, used for firmware update
 ATTRS{idVendor}=="1076", ATTRS{idProduct}=="9082", ENV{.MM_USBIFNUM}=="02", ENV{ID_MM_PORT_TYPE_AT_PRIMARY}="1"
-ATTRS{idVendor}=="1076", ATTRS{idProduct}=="9082", ENV{.MM_USBIFNUM}=="08", ENV{ID_MM_PORT_TYPE_GPS}="1"
 ATTRS{idVendor}=="1076", ATTRS{idProduct}=="9082", ENV{.MM_USBIFNUM}=="04", ENV{ID_MM_PORT_IGNORE}="1"
 
-# ML660PG -> wmode=bridge-ecm, used for LTE connection
+# ML620EU -> wmode=bridge-ecm, used for LTE connection
 ATTRS{idVendor}=="1076", ATTRS{idProduct}=="9003", ENV{.MM_USBIFNUM}=="02", ENV{ID_MM_PORT_TYPE_AT_PRIMARY}="1"
-ATTRS{idVendor}=="1076", ATTRS{idProduct}=="9003", ENV{.MM_USBIFNUM}=="08", ENV{ID_MM_PORT_TYPE_GPS}="1"
 ATTRS{idVendor}=="1076", ATTRS{idProduct}=="9003", ENV{.MM_USBIFNUM}=="04", ENV{ID_MM_PORT_IGNORE}="1"
 
 LABEL="mm_unitac_port_types_end"
diff --git a/plugins/unitac/mm-broadband-bearer-unitac.c b/plugins/unitac/mm-broadband-bearer-unitac.c
index dbc26ac..a4f8fd0 100644
--- a/plugins/unitac/mm-broadband-bearer-unitac.c
+++ b/plugins/unitac/mm-broadband-bearer-unitac.c
@@ -30,6 +30,7 @@
 #include "mm-base-modem-at.h"
 #include "mm-log-object.h"
 #include "mm-modem-helpers.h"
+#include "mm-modem-helpers-unitac.h"
 
 G_DEFINE_TYPE (MMBroadbandBearerUnitac, mm_broadband_bearer_unitac, MM_TYPE_BROADBAND_BEARER)
 
@@ -38,8 +39,11 @@ static void dial_3gpp_context_step (GTask *task);
 typedef enum {
     DIAL_3GPP_STEP_FIRST,
     DIAL_3GPP_STEP_AUTHENTICATE,
+    DIAL_3GPP_STEP_DISABLE_CEREG,
+    DIAL_3GPP_STEP_PS_DETACH,
+    DIAL_3GPP_STEP_ENABLE_CEREG,
     DIAL_3GPP_STEP_PS_ATTACH,
-    DIAL_3GPP_STEP_CONNECT,
+    DIAL_3GPP_STEP_PS_ATTACH_QUERY,
     DIAL_3GPP_STEP_CONNECT_QUERY,
     DIAL_3GPP_STEP_LAST
 } Dial3gppStep;
@@ -91,6 +95,8 @@ common_connect_task_new (MMBroadbandBearerUnitac *self,
     ctx->primary = g_object_ref (primary);
     ctx->cid     = cid;
     ctx->step = DIAL_3GPP_STEP_FIRST;
+    ctx->ipv4_config = NULL;
+    ctx->ipv6_config = NULL;
 
     task = g_task_new (self, cancellable, callback, user_data);
     g_task_set_task_data (task, ctx, (GDestroyNotify) common_connect_context_free);
@@ -149,19 +155,9 @@ complete_get_ip_config_3gpp (GTask *task)
 
     ctx = g_task_get_task_data (task);
 
-    if (ctx->family == MM_BEARER_IP_FAMILY_IPV4) {
-        g_assert(mm_bearer_ip_config_get_method(ctx->ipv4_config) != MM_BEARER_IP_METHOD_UNKNOWN);
-        connect_result = mm_bearer_connect_result_new(ctx->data, ctx->ipv4_config, NULL);
-    }
-    else if(ctx->family == MM_BEARER_IP_FAMILY_IPV6) {
-        g_assert(mm_bearer_ip_config_get_method(ctx->ipv6_config) != MM_BEARER_IP_METHOD_UNKNOWN);
-        connect_result = mm_bearer_connect_result_new(ctx->data, ctx->ipv6_config, NULL);
-    }
-    else {
-        g_assert(mm_bearer_ip_config_get_method(ctx->ipv4_config) != MM_BEARER_IP_METHOD_UNKNOWN);
-        g_assert(mm_bearer_ip_config_get_method(ctx->ipv6_config) != MM_BEARER_IP_METHOD_UNKNOWN);
-        connect_result = mm_bearer_connect_result_new(ctx->data, ctx->ipv4_config, ctx->ipv6_config);
-    }
+    g_assert (ctx->ipv4_config || ctx->ipv6_config);
+
+    connect_result = mm_bearer_connect_result_new(ctx->data, ctx->ipv4_config, ctx->ipv6_config);
 
     g_task_return_pointer (task,
                            connect_result,
@@ -169,490 +165,191 @@ complete_get_ip_config_3gpp (GTask *task)
     g_object_unref (task);
 }
 
-/*****************************************************************************/
-/* CGPADDR=N response parser */
-
-static gboolean
-mm_unitac_parse_cgpaddr_response (const gchar *response,
-                                  gchar       **out_ipv4_address,
-                                  gchar       **out_ipv6_address,
-                                  GError      **error)
+static void
+cgcontrdp_ready (MMBaseModem  *modem,
+                 GAsyncResult *res,
+                 GTask        *task)
 {
-    GRegex     *r;
-    GMatchInfo *match_info;
-    GError     *inner_error = NULL;
-    gchar      *ipv4_address = NULL;
-    gchar      *ipv6_address = NULL;
-
-    /* Response may be e.g.:
-     * response: '+CGPADDR: 1,"172.22.1.100"'
-     *
-     * We assume only ONE line is returned; because we request +CGPADDR with a specific N CID.
-     */
-    r = g_regex_new ("\\+CGPADDR: (\\d+)(?:,([^,]*))(?:,([^,]*))?", 0, 0, NULL);
-    g_assert (r != NULL);
-
-    g_regex_match_full (r, response, strlen (response), 0, 0, &match_info, &inner_error);
-    if (inner_error)
-        goto out;
-
-    if (!g_match_info_matches (match_info)) {
-        inner_error = g_error_new (MM_CORE_ERROR, MM_CORE_ERROR_INVALID_ARGS, "Couldn't match +CGPADDR response");
-        goto out;
+    MMBroadbandBearerUnitac *self;
+    const gchar             *response;
+    GError                  *error = NULL;
+    CommonConnectContext    *ctx;
+    gchar                   *ipv4_address = NULL;
+    gchar                   *ipv4_subnet = NULL;
+    gchar                   *ipv4_gateway = NULL;
+    gchar                   *ipv4_dns_addresses[3] = { NULL, NULL, NULL };
+    guint                   ipv4_mtu = 0;
+    gchar                   *ipv6_address = NULL;
+    guint                   ipv6_subnet;
+    gchar                   *ipv6_gateway = NULL;
+    gchar                   *ipv6_dns_addresses[3] = { NULL, NULL, NULL };
+    guint                   ipv6_mtu = 0;
+
+    self = g_task_get_source_object (task);
+    ctx  = g_task_get_task_data (task);
+
+    response = mm_base_modem_at_command_finish (modem, res, &error);
+
+    if (!response || !mm_3gpp_cust_parse_cgcontrdp_response (response,
+                                                             &ipv4_address,
+                                                             &ipv4_subnet,
+                                                             &ipv4_gateway,
+                                                             &ipv4_dns_addresses[0],
+                                                             &ipv4_dns_addresses[1],
+                                                             &ipv4_mtu,
+                                                             &ipv6_address,
+                                                             &ipv6_subnet,
+                                                             &ipv6_gateway,
+                                                             &ipv6_dns_addresses[0],
+                                                             &ipv6_dns_addresses[1],
+                                                             &ipv6_mtu,
+                                                             &error)) {
+        g_task_return_error (task, error);
+        g_object_unref (task);
+        return;
     }
 
-    if (out_ipv4_address)
-        ipv4_address = mm_get_string_unquoted_from_match_info(match_info, 2);
+    if (ctx->family & MM_BEARER_IP_FAMILY_IPV4 || ctx->family & MM_BEARER_IP_FAMILY_IPV4V6) {
+        if (ipv4_address && ipv4_subnet) {
 
-    if (out_ipv6_address)
-        ipv6_address = mm_get_string_unquoted_from_match_info(match_info, 3);
+            mm_obj_dbg (self, "IPv4 address retrieved: %s", ipv4_address);
+            mm_obj_dbg (self, "IPv4 subnet retrieved: %s", ipv4_subnet);
+            mm_bearer_ip_config_set_address (ctx->ipv4_config, ipv4_address);
+            mm_bearer_ip_config_set_prefix (ctx->ipv4_config, mm_netmask_to_cidr (ipv4_subnet));
 
-    out:
+            if (ipv4_gateway) {
+                mm_obj_dbg(self, "IPv4 gateway retrieved: %s", ipv4_gateway);
+                mm_bearer_ip_config_set_gateway (ctx->ipv4_config, ipv4_gateway);
+            }
+            if (ipv4_dns_addresses[0])
+                mm_obj_dbg (self, "IPv4 primary DNS retrieved: %s", ipv4_dns_addresses[0]);
+            if (ipv4_dns_addresses[1])
+                mm_obj_dbg (self, "IPv4 secondary DNS retrieved: %s", ipv4_dns_addresses[1]);
 
-    g_match_info_free (match_info);
-    g_regex_unref (r);
+            if (ipv4_dns_addresses[0] || ipv4_dns_addresses[1])
+                mm_bearer_ip_config_set_dns (ctx->ipv4_config, (const gchar **) ipv4_dns_addresses);
 
-    if (inner_error) {
-        g_free (ipv4_address);
-        g_free (ipv6_address);
-        g_propagate_error (error, inner_error);
-        return FALSE;
+            mm_obj_dbg (self, "IPv4 MTU: %d", ipv4_mtu);
+            if (ipv4_mtu != 0)
+                mm_bearer_ip_config_set_mtu(ctx->ipv4_config, ipv4_mtu);
+        }
     }
 
-    if (out_ipv4_address && ipv4_address)
-        *out_ipv4_address = ipv4_address;
+    if (ctx->family & MM_BEARER_IP_FAMILY_IPV6 || ctx->family & MM_BEARER_IP_FAMILY_IPV4V6) {
+        if (ipv6_address && ipv6_subnet) {
 
-    if (out_ipv6_address && ipv6_address)
-        *out_ipv6_address = ipv6_address;
+            mm_obj_dbg(self, "IPv6 address retrieved: %s", ipv6_address);
+            mm_obj_dbg(self, "IPv6 subnet retrieved: %d", ipv6_subnet);
+            mm_bearer_ip_config_set_address(ctx->ipv6_config, ipv6_address);
+            mm_bearer_ip_config_set_prefix(ctx->ipv6_config, ipv6_subnet);
 
-    return TRUE;
-}
-
-static gboolean
-split_local_address_and_subnet (const gchar  *str,
-								gchar       **local_address,
-								gchar       **subnet)
-{
-	const gchar *separator;
-	guint count = 0;
-
-	/* E.g. split: "2.43.2.44.255.255.255.255"
-	 * into:
-	 *    local address: "2.43.2.44",
-	 *    subnet: "255.255.255.255"
-	 */
-	g_assert (str);
-	g_assert (local_address);
-	g_assert (subnet);
-
-	separator = str;
-	while (1) {
-		separator = strchr (separator, '.');
-		if (separator) {
-			count++;
-			if (count == 4) {
-				if (local_address)
-					*local_address = g_strndup (str, (separator - str));
-				if (subnet)
-					*subnet = g_strdup (++separator);
-				return TRUE;
-			}
-			separator++;
-			continue;
-		}
-
-		/* Not even the full IP? report error parsing */
-		if (count < 3)
-			return FALSE;
-
-		if (count == 3) {
-			if (local_address)
-				*local_address = g_strdup (str);
-			if (subnet)
-				*subnet = NULL;
-			return TRUE;
-		}
-	}
-}
+            if (ipv6_gateway) {
+                mm_obj_dbg(self, "IPv6 gateway retrieved: %s", ipv6_gateway);
+                mm_bearer_ip_config_set_gateway(ctx->ipv6_config, ipv6_gateway);
+            }
+            if (ipv6_dns_addresses[0])
+                mm_obj_dbg(self, "IPv6 primary DNS retrieved: %s", ipv6_dns_addresses[0]);
+            if (ipv6_dns_addresses[1])
+                mm_obj_dbg(self, "IPv6 secondary DNS retrieved: %s", ipv6_dns_addresses[1]);
 
-static int
-ipv6_netmask_len(char * mask_str)
-{
-	struct in6_addr netmask;
-	int len = 0;
-	unsigned char val;
-	unsigned char *pnt;
-
-	inet_pton(AF_INET6, mask_str, &netmask);
-	pnt = (unsigned char *) & netmask;
-
-	while ((*pnt == 0xff) && len < 128)
-	{
-		len += 8;
-		pnt++;
-	}
-
-	if (len < 128)
-	{
-		val = *pnt;
-		while (val)
-		{
-			len++;
-			val <<= 1;
-		}
-	}
-	return len;
-}
+            if (ipv6_dns_addresses[0] || ipv6_dns_addresses[1])
+                mm_bearer_ip_config_set_dns(ctx->ipv6_config, (const gchar **) ipv6_dns_addresses);
 
-gboolean
-mm_3gpp_cust_parse_cgcontrdp_response (const gchar  *response,
-									   gchar        **ipv4_address,
-									   gchar        **ipv4_subnet,
-									   gchar        **ipv4_gateway,
-									   gchar        **ipv4_dns1_addresses,
-									   gchar        **ipv4_dns2_addresses,
-									   gchar        **ipv6_address,
-									   int          *ipv6_subnet,
-									   gchar        **ipv6_gateway,
-									   gchar        **ipv6_dns1_addresses,
-									   gchar        **ipv6_dns2_addresses,
-									   gpointer     self,
-									   GError       **error)
-{
-	GRegex       *r;
-	GMatchInfo   *match_info;
-	GError       *inner_error = NULL;
-	guint        cid = 0;
-	guint        bearer_id = 0;
-	gchar        *ipv4_addr = NULL;
-	gchar        *ipv4_sub = NULL;
-	gchar        *ipv4_gat = NULL;
-	gchar        *ipv4_dns1 = NULL;
-	gchar        *ipv4_dns2 = NULL;
-	gchar        *ipv6_addr = NULL;
-	int          ipv6_sub = NULL;
-	gchar        *ipv6_gat = NULL;
-	gchar        *ipv6_dns1 = NULL;
-	gchar        *ipv6_dns2 = NULL;
-
-	r = g_regex_new ("\\+CGCONTRDP: "
-					 "(\\d+),(\\d+),([^,]*)" /* cid, bearer id, apn */
-					 "(?:,([^,]*))?" /* (a)ip+mask        or (b)ip */
-					 "(?:,([^,]*))?" /* (a)gateway        or (b)mask */
-					 "(?:,([^,]*))?" /* (a)dns1           or (b)gateway */
-					 "(?:,([^,]*))?" /* (a)dns2           or (b)dns1 */
-					 "(?:,([^,]*))?" /* (a)p-cscf primary or (b)dns2 */
-					 "(?:,(.*))?"    /* others, ignored */
-					 "(?:\\r\\n)?",
-					 G_REGEX_DOLLAR_ENDONLY | G_REGEX_RAW, 0, NULL);
-	g_assert (r != NULL);
-
-	g_regex_match_full (r, response, strlen (response), 0, 0, &match_info, &inner_error);
-	if (inner_error)
-		goto out;
-
-	while (!inner_error &&
-		   g_match_info_matches (match_info))
-	{
-		// Check CID
-		if (!mm_get_uint_from_match_info(match_info, 1, &cid))
-		{
-			inner_error = g_error_new(MM_CORE_ERROR, MM_CORE_ERROR_FAILED, "Error parsing cid");
-			break;
-		}
-
-		// Check bearer ID
-		if (!mm_get_uint_from_match_info(match_info, 2, &bearer_id))
-		{
-			inner_error = g_error_new(MM_CORE_ERROR, MM_CORE_ERROR_FAILED, "Error parsing bearer id");
-			break;
-		}
-
-		// Skip APN check as not needed
-
-		// Get Local Address and Subnet
-		gchar      *local_address_and_subnet = NULL;
-
-		local_address_and_subnet = mm_get_string_unquoted_from_match_info(match_info, 4);
-		if (local_address_and_subnet)
-		{
-			if(strstr (local_address_and_subnet, ":"))
-			{
-				char delim[] = " ";
-				if (ipv6_address && ipv6_subnet)
-				{
-					char * temp = NULL;
-					temp = strtok(local_address_and_subnet, delim);
-					if (temp != NULL)
-						ipv6_addr = strdup(temp);
-					temp = strtok(NULL, delim);
-					if (temp != NULL)
-						ipv6_sub = ipv6_netmask_len(temp);
-				}
-				if (ipv6_gateway)
-					ipv6_gat = mm_get_string_unquoted_from_match_info(match_info, 5);
-				if (ipv6_dns1_addresses)
-					ipv6_dns1 = mm_get_string_unquoted_from_match_info(match_info, 6);
-				if (ipv6_dns2_addresses)
-					ipv6_dns2 = mm_get_string_unquoted_from_match_info(match_info, 7);
-			}
-			else
-			{
-				if (ipv4_address && ipv4_subnet)
-					split_local_address_and_subnet(local_address_and_subnet, &ipv4_addr, &ipv4_sub);
-				if (ipv4_gateway)
-					ipv4_gat = mm_get_string_unquoted_from_match_info(match_info, 5);
-				if (ipv4_dns1_addresses)
-					ipv4_dns1 = mm_get_string_unquoted_from_match_info(match_info, 6);
-				if (ipv4_dns2_addresses)
-					ipv4_dns2 = mm_get_string_unquoted_from_match_info(match_info, 7);
-			}
-		}
-
-		g_free (local_address_and_subnet);
-		g_match_info_next (match_info, &inner_error);
-	}
-
-	out:
-	g_match_info_free (match_info);
-	g_regex_unref (r);
-
-	if (inner_error) {
-		g_free (ipv4_addr);
-		g_free (ipv4_sub);
-		g_free (ipv4_gat);
-		g_free (ipv4_dns1);
-		g_free (ipv4_dns2);
-		g_free (ipv6_addr);
-		g_free (ipv6_gat);
-		g_free (ipv6_dns1);
-		g_free (ipv6_dns2);
-		g_propagate_error (error, inner_error);
-		return FALSE;
-	}
-
-	/* IPv4 Connection Details */
-	if (ipv4_address)
-		*ipv4_address = ipv4_addr;
-	else
-		g_free (ipv4_addr);
-
-	if (ipv4_subnet)
-		*ipv4_subnet = ipv4_sub;
-	else
-		g_free (ipv4_sub);
-
-	if (ipv4_gateway)
-		*ipv4_gateway = ipv4_gat;
-	if (ipv4_dns1_addresses)
-		*ipv4_dns1_addresses = ipv4_dns1;
-	if (ipv4_dns2_addresses)
-		*ipv4_dns2_addresses = ipv4_dns2;
-
-	/* IPv6 Connection Details */
-	if (ipv6_address)
-		*ipv6_address = ipv6_addr;
-	else
-		g_free (ipv6_addr);
-
-	if (ipv6_subnet)
-		*ipv6_subnet = ipv6_sub;
-	else
-		g_free (ipv6_sub);
-
-	if (ipv6_gateway)
-		*ipv6_gateway = ipv6_gat;
-	if (ipv6_dns1_addresses)
-		*ipv6_dns1_addresses = ipv6_dns1;
-	if (ipv6_dns2_addresses)
-		*ipv6_dns2_addresses = ipv6_dns2;
-
-	return TRUE;
-}
+            if (ipv6_mtu != 0) {
+                mm_obj_dbg(self, "IPv6 MTU: %d", ipv6_mtu);
+                mm_bearer_ip_config_set_mtu(ctx->ipv6_config, ipv6_mtu);
+            }
+            else if (ipv4_mtu != 0) {
+                mm_obj_dbg(self, "No IPv6 MTU. Using IPv4 MTU for IPv6: %d", ipv4_mtu);
+                mm_bearer_ip_config_set_mtu(ctx->ipv6_config, ipv4_mtu);
+            }
+            else
+                mm_obj_dbg (self, "No IPv6 MTU");
+        }
+    }
 
-static void
-cgcontrdp_ready (MMBaseModem  *modem,
-				 GAsyncResult *res,
-				 GTask        *task)
-{
-	MMBroadbandBearerUnitac *self;
-	const gchar            *response;
-	GError                 *error = NULL;
-	CommonConnectContext   *ctx;
-	gchar                  *ipv4_address = NULL;
-	gchar                  *ipv4_subnet = NULL;
-	gchar                  *ipv4_gateway = NULL;
-	gchar                  *ipv4_dns_addresses[3] = { NULL, NULL, NULL };
-	gchar                  *ipv6_address = NULL;
-	int                    ipv6_subnet;
-	gchar                  *ipv6_gateway = NULL;
-	gchar                  *ipv6_dns_addresses[3] = { NULL, NULL, NULL };
-
-	self = g_task_get_source_object (task);
-	ctx  = g_task_get_task_data (task);
-
-	response = mm_base_modem_at_command_finish (modem, res, &error);
-
-	if (!response || !mm_3gpp_cust_parse_cgcontrdp_response (response,
-															 &ipv4_address,
-															 &ipv4_subnet,
-															 &ipv4_gateway,
-															 &ipv4_dns_addresses[0],
-															 &ipv4_dns_addresses[1],
-															 &ipv6_address,
-															 &ipv6_subnet,
-															 &ipv6_gateway,
-															 &ipv6_dns_addresses[0],
-															 &ipv6_dns_addresses[1],
-															 self,
-															 &error)) {
-		g_task_return_error (task, error);
-		g_object_unref (task);
-		return;
-	}
-
-	if (ctx->family == MM_BEARER_IP_FAMILY_IPV4) {
-		mm_obj_dbg (self, "Family: IPV4");
-		mm_obj_dbg (self, "IPv4 address retrieved: %s", ipv4_address);
-		mm_obj_dbg (self, "IPv4 subnet retrieved: %s", ipv4_subnet);
-		mm_obj_dbg (self, "IPv4 gateway retrieved: %s", ipv4_gateway);
-		if (ipv4_dns_addresses[0])
-			mm_obj_dbg (self, "IPv4 primary DNS retrieved: %s", ipv4_dns_addresses[0]);
-		if (ipv4_dns_addresses[1])
-			mm_obj_dbg (self, "IPv4 secondary DNS retrieved: %s", ipv4_dns_addresses[1]);
-
-		mm_bearer_ip_config_set_address (ctx->ipv4_config, ipv4_address);
-		mm_bearer_ip_config_set_prefix (ctx->ipv4_config, mm_netmask_to_cidr (ipv4_subnet));
-		mm_bearer_ip_config_set_gateway (ctx->ipv4_config, ipv4_gateway);
-		mm_bearer_ip_config_set_dns (ctx->ipv4_config, (const gchar **) ipv4_dns_addresses);
-	}
-	else if (ctx->family == MM_BEARER_IP_FAMILY_IPV6) {
-		mm_obj_dbg (self, "Family: IPV6");
-		mm_obj_dbg (self, "IPv6 address retrieved: %s", ipv6_address);
-		mm_obj_dbg (self, "IPv6 subnet retrieved: %d", ipv6_subnet);
-		mm_obj_dbg (self, "IPv6 gateway retrieved: %s", ipv6_gateway);
-		if (ipv4_dns_addresses[0])
-			mm_obj_dbg (self, "IPv6 primary DNS retrieved: %s", ipv6_dns_addresses[0]);
-		if (ipv4_dns_addresses[1])
-			mm_obj_dbg (self, "IPv6 secondary DNS retrieved: %s", ipv6_dns_addresses[1]);
-
-		mm_bearer_ip_config_set_address (ctx->ipv6_config, ipv6_address);
-		mm_bearer_ip_config_set_prefix (ctx->ipv6_config, ipv6_subnet);
-		mm_bearer_ip_config_set_gateway (ctx->ipv6_config, ipv6_gateway);
-		mm_bearer_ip_config_set_dns (ctx->ipv6_config, (const gchar **) ipv6_dns_addresses);
-	}
-	else {
-		mm_obj_dbg (self, "Family: IPV4V6");
-		mm_obj_dbg (self, "IPv4 address retrieved: %s", ipv4_address);
-		mm_obj_dbg (self, "IPv4 subnet retrieved: %s", ipv4_subnet);
-		mm_obj_dbg (self, "IPv4 gateway retrieved: %s", ipv4_gateway);
-		if (ipv4_dns_addresses[0])
-			mm_obj_dbg (self, "IPv4 primary DNS retrieved: %s", ipv4_dns_addresses[0]);
-		if (ipv4_dns_addresses[1])
-			mm_obj_dbg (self, "IPv4 secondary DNS retrieved: %s", ipv4_dns_addresses[1]);
-
-		mm_obj_dbg (self, "IPv6 address retrieved: %s", ipv6_address);
-		mm_obj_dbg (self, "IPv6 subnet retrieved: %d", ipv6_subnet);
-		mm_obj_dbg (self, "IPv6 gateway retrieved: %s", ipv6_gateway);
-		if (ipv6_dns_addresses[0])
-			mm_obj_dbg (self, "IPv6 primary DNS retrieved: %s", ipv6_dns_addresses[0]);
-		if (ipv6_dns_addresses[1])
-			mm_obj_dbg (self, "IPv6 secondary DNS retrieved: %s", ipv6_dns_addresses[1]);
-
-		mm_bearer_ip_config_set_address (ctx->ipv4_config, ipv4_address);
-		mm_bearer_ip_config_set_prefix (ctx->ipv4_config, mm_netmask_to_cidr (ipv4_subnet));
-		mm_bearer_ip_config_set_gateway (ctx->ipv4_config, ipv4_gateway);
-		mm_bearer_ip_config_set_dns (ctx->ipv4_config, (const gchar **) ipv4_dns_addresses);
-
-		mm_bearer_ip_config_set_address (ctx->ipv6_config, ipv6_address);
-		mm_bearer_ip_config_set_prefix (ctx->ipv6_config, ipv6_subnet);
-		mm_bearer_ip_config_set_gateway (ctx->ipv6_config, ipv6_gateway);
-		mm_bearer_ip_config_set_dns (ctx->ipv6_config, (const gchar **) ipv6_dns_addresses);
-	}
-
-	g_free (ipv4_address);
-	g_free (ipv4_subnet);
-	g_free (ipv4_gateway);
-	g_free (ipv4_dns_addresses[0]);
-	g_free (ipv4_dns_addresses[1]);
-	g_free (ipv6_address);
-	g_free (ipv6_gateway);
-	g_free (ipv6_dns_addresses[0]);
-	g_free (ipv6_dns_addresses[1]);
-
-	mm_obj_dbg (self, "finished IP settings retrieval for PDP context #%u...", ctx->cid);
-	complete_get_ip_config_3gpp (task);
+    g_free (ipv4_address);
+    g_free (ipv4_subnet);
+    g_free (ipv4_gateway);
+    g_free (ipv4_dns_addresses[0]);
+    g_free (ipv4_dns_addresses[1]);
+    g_free (ipv6_address);
+    g_free (ipv6_gateway);
+    g_free (ipv6_dns_addresses[0]);
+    g_free (ipv6_dns_addresses[1]);
+
+    mm_obj_dbg (self, "finished IP settings retrieval for PDP context #%u...", ctx->cid);
+    complete_get_ip_config_3gpp (task);
 }
 
 static void
 cgpiaf_ready (MMBaseModem  *modem,
-			  GAsyncResult *res,
-			  GTask        *task)
+              GAsyncResult *res,
+              GTask        *task)
 {
-	MMBroadbandBearerUnitac *self;
-	const gchar             *response;
-	GError                  *error = NULL;
-	CommonConnectContext    *ctx;
-
-	self = g_task_get_source_object (task);
-	ctx  = g_task_get_task_data (task);
-
-	if (!mm_base_modem_at_command_finish (modem, res, &error)) {
-		g_task_return_error (task, error);
-		g_object_unref (task);
-		return;
-	}
-
-	gchar *cmd = g_strdup_printf ("+CGCONTRDP=%u", ctx->cid);
-	mm_obj_dbg (self, "gathering connection details for PDP context #%u...", ctx->cid);
-	mm_base_modem_at_command (MM_BASE_MODEM (modem),
-							  cmd,
-							  10,
-							  FALSE,
-							  (GAsyncReadyCallback) cgcontrdp_ready,
-							  task);
-
-	g_free (cmd);
+    MMBroadbandBearerUnitac *self;
+    GError                  *error = NULL;
+    CommonConnectContext    *ctx;
+
+    self = g_task_get_source_object (task);
+    ctx  = g_task_get_task_data (task);
+
+    if (!mm_base_modem_at_command_finish (modem, res, &error)) {
+        g_task_return_error (task, error);
+        g_object_unref (task);
+        return;
+    }
+
+    // Strange seems like the modem needs some delay before the IPv6 address show up
+    sleep(8);
+    gchar *cmd = g_strdup_printf ("+CGCONTRDP=%u", ctx->cid);
+    mm_obj_dbg (self, "gathering connection details for PDP context #%u...", ctx->cid);
+    mm_base_modem_at_command (MM_BASE_MODEM (modem),
+                              cmd,
+                              10,
+                              FALSE,
+                              (GAsyncReadyCallback) cgcontrdp_ready,
+                              task);
+
+    g_free (cmd);
 }
 
 static void
 cgpaddr_ready (MMBaseModem  *modem,
-			   GAsyncResult *res,
-			   GTask        *task)
+               GAsyncResult *res,
+               GTask        *task)
 {
-	MMBroadbandBearerUnitac *self;
-	const gchar             *response;
-	GError                  *error = NULL;
-	CommonConnectContext    *ctx;
-	gchar                   *ipv4_address = NULL;
-	gchar                   *ipv6_address = NULL;
-
-	self = g_task_get_source_object (task);
-	ctx  = g_task_get_task_data (task);
-
-	response = mm_base_modem_at_command_finish (modem, res, &error);
-
-	if (!response || !mm_unitac_parse_cgpaddr_response (response,
-														&ipv4_address,
-														&ipv6_address,
-														&error)) {
-		g_task_return_error (task, error);
-		g_object_unref (task);
-		return;
-	}
-
-	mm_obj_dbg(self, "IPv4 address retrieved: %s", ipv4_address ? ipv4_address : "");
-	mm_obj_dbg(self, "IPv6 address retrieved: %s", ipv6_address ? ipv6_address : "");
-
-	g_free (ipv4_address);
-	g_free (ipv6_address);
-
-	mm_base_modem_at_command (MM_BASE_MODEM (modem),
-							  "+CGPIAF=1,0,1,1",
-							  10,
-							  FALSE,
-							  (GAsyncReadyCallback) cgpiaf_ready,
-							  task);
+    MMBroadbandBearerUnitac *self;
+    const gchar             *response;
+    GError                  *error = NULL;
+    gchar                   *ipv4_address = NULL;
+    gchar                   *ipv6_address = NULL;
+
+    self = g_task_get_source_object (task);
+
+    response = mm_base_modem_at_command_finish (modem, res, &error);
+
+    if (!response || !mm_unitac_parse_cgpaddr_response (response,
+                                                        &ipv4_address,
+                                                        &ipv6_address,
+                                                        &error)) {
+        g_task_return_error (task, error);
+        g_object_unref (task);
+        return;
+    }
+
+    mm_obj_dbg(self, "IPv4 address retrieved: %s", ipv4_address ? ipv4_address : "");
+    mm_obj_dbg(self, "IPv6 address retrieved: %s", ipv6_address ? ipv6_address : "");
+
+    g_free (ipv4_address);
+    g_free (ipv6_address);
+
+    mm_base_modem_at_command (MM_BASE_MODEM (modem),
+                              "+CGPIAF=1,0,1,1",
+                              10,
+                              FALSE,
+                              (GAsyncReadyCallback) cgpiaf_ready,
+                              task);
 
 }
 
@@ -684,18 +381,12 @@ get_ip_config_3gpp (MMBroadbandBearer   *_self,
     ctx = g_task_get_task_data (task);
     ctx->family = ip_family;
 
-    if (ctx->family == MM_BEARER_IP_FAMILY_IPV4) {
-        ctx->ipv4_config = mm_bearer_ip_config_new();
-        mm_bearer_ip_config_set_method(ctx->ipv4_config, MM_BEARER_IP_METHOD_DHCP);
-    }
-    else if (ctx->family == MM_BEARER_IP_FAMILY_IPV6) {
-        ctx->ipv6_config = mm_bearer_ip_config_new();
-        mm_bearer_ip_config_set_method(ctx->ipv6_config, MM_BEARER_IP_METHOD_DHCP);
-    }
-    else {
+    if (ctx->family & MM_BEARER_IP_FAMILY_IPV4 || ctx->family & MM_BEARER_IP_FAMILY_IPV4V6) {
         ctx->ipv4_config = mm_bearer_ip_config_new ();
-        ctx->ipv6_config = mm_bearer_ip_config_new ();
         mm_bearer_ip_config_set_method (ctx->ipv4_config, MM_BEARER_IP_METHOD_DHCP);
+    }
+    if (ctx->family & MM_BEARER_IP_FAMILY_IPV6 || ctx->family & MM_BEARER_IP_FAMILY_IPV4V6) {
+        ctx->ipv6_config = mm_bearer_ip_config_new ();
         mm_bearer_ip_config_set_method (ctx->ipv6_config, MM_BEARER_IP_METHOD_DHCP);
     }
 
@@ -726,6 +417,41 @@ dial_3gpp_finish (MMBroadbandBearer *self,
 }
 
 static void
+cgatt_query_ready (MMBaseModem  *modem,
+                   GAsyncResult *res,
+                   GTask        *task)
+{
+    MMBroadbandBearerUnitac *self;
+    CommonConnectContext     *ctx;
+    const gchar             *response;
+    GError                  *error = NULL;
+    guint                   attach = 0;
+
+    self = g_task_get_source_object (task);
+    ctx = g_task_get_task_data (task);
+
+    response = mm_base_modem_at_command_finish (modem, res, &error);
+
+    if (!response || !mm_unitac_parse_cgatt_response (response,
+                                                      &attach,
+                                                      &error)) {
+        g_task_return_error (task, error);
+        g_object_unref (task);
+        return;
+    }
+
+    mm_obj_dbg(self, "PS Attach: %d", attach);
+
+    if (attach != 1)
+        g_task_return_new_error (task, MM_CORE_ERROR, MM_CORE_ERROR_FAILED,
+                                 "PS detached...");
+
+    /* Go on */
+    ctx->step++;
+    dial_3gpp_context_step (task);
+}
+
+static void
 cgact_query_ready (MMBaseModem  *modem,
                    GAsyncResult *res,
                    GTask        *task)
@@ -779,12 +505,12 @@ cgact_query_ready (MMBaseModem  *modem,
 }
 
 static void
-cgact_ready (MMBaseModem  *modem,
-             GAsyncResult *res,
-             GTask        *task)
+authenticate_ready (MMBaseModem  *modem,
+                    GAsyncResult *res,
+                    GTask        *task)
 {
     CommonConnectContext *ctx;
-    GError               *error = NULL;
+    GError *error = NULL;
 
     ctx = g_task_get_task_data (task);
 
@@ -800,12 +526,12 @@ cgact_ready (MMBaseModem  *modem,
 }
 
 static void
-authenticate_ready (MMBaseModem  *modem,
+cgatt_detach_ready (MMBaseModem  *modem,
                     GAsyncResult *res,
                     GTask        *task)
 {
     CommonConnectContext *ctx;
-    GError *error = NULL;
+    GError               *error = NULL;
 
     ctx = g_task_get_task_data (task);
 
@@ -815,15 +541,17 @@ authenticate_ready (MMBaseModem  *modem,
         return;
     }
 
+    // Need 2-3 seconds delay after issuing +CGATT=0 before issuing +CGATT=1 as per Unitac
+    sleep(3);
     /* Go on */
     ctx->step++;
     dial_3gpp_context_step (task);
 }
 
 static void
-cgatt_ready (MMBaseModem  *modem,
-             GAsyncResult *res,
-             GTask        *task)
+cgatt_attach_ready (MMBaseModem  *modem,
+                    GAsyncResult *res,
+                    GTask        *task)
 {
     CommonConnectContext *ctx;
     GError               *error = NULL;
@@ -842,9 +570,9 @@ cgatt_ready (MMBaseModem  *modem,
 }
 
 static void
-cgatt_disconnect (MMBaseModem  *modem,
-                  GAsyncResult *res,
-                  GTask        *task)
+cereg_ready (MMBaseModem  *modem,
+             GAsyncResult *res,
+             GTask        *task)
 {
     CommonConnectContext *ctx;
     GError               *error = NULL;
@@ -856,6 +584,10 @@ cgatt_disconnect (MMBaseModem  *modem,
         g_object_unref (task);
         return;
     }
+
+    /* Go on */
+    ctx->step++;
+    dial_3gpp_context_step (task);
 }
 
 static void
@@ -885,7 +617,7 @@ dial_3gpp_context_step (GTask *task)
                 const gchar *apn = NULL;
                 MMBearerAllowedAuth allowed_auth;
                 MMBearerIpFamily ip_type;
-                size_t type;
+                guint type = 0;
 
                 apn            = mm_bearer_properties_get_apn (mm_base_bearer_peek_config (MM_BASE_BEARER (self)));
                 user           = mm_bearer_properties_get_user (mm_base_bearer_peek_config (MM_BASE_BEARER (self)));
@@ -948,7 +680,7 @@ dial_3gpp_context_step (GTask *task)
                 mm_base_modem_at_command_full (MM_BASE_MODEM(ctx->modem),
                                                ctx->primary,
                                                command,
-                                               3,
+                                               5,
                                                FALSE,
                                                FALSE, /* raw */
                                                NULL, /* cancellable */
@@ -959,50 +691,76 @@ dial_3gpp_context_step (GTask *task)
             }
             return;
 
+        case DIAL_3GPP_STEP_DISABLE_CEREG:
+            mm_base_modem_at_command_full(MM_BASE_MODEM(ctx->modem),
+                                          ctx->primary,
+                                          "+CEREG=0",
+                                          10,
+                                          FALSE,
+                                          FALSE, /* raw */
+                                          NULL, /* cancellable */
+                                          (GAsyncReadyCallback) cereg_ready,
+                                          task);
+            return;
+
+        case DIAL_3GPP_STEP_PS_DETACH:
+            mm_base_modem_at_command_full(MM_BASE_MODEM(ctx->modem),
+                                          ctx->primary,
+                                          "+CGATT=0",
+                                          20,
+                                          FALSE,
+                                          FALSE, /* raw */
+                                          NULL, /* cancellable */
+                                          (GAsyncReadyCallback) cgatt_detach_ready,
+                                          task);
+            return;
+
+        case DIAL_3GPP_STEP_ENABLE_CEREG:
+            mm_base_modem_at_command_full(MM_BASE_MODEM(ctx->modem),
+                                          ctx->primary,
+                                          "+CEREG=2",
+                                          10,
+                                          FALSE,
+                                          FALSE, /* raw */
+                                          NULL, /* cancellable */
+                                          (GAsyncReadyCallback) cereg_ready,
+                                          task);
+            return;
+
         case DIAL_3GPP_STEP_PS_ATTACH:
             mm_base_modem_at_command_full (MM_BASE_MODEM(ctx->modem),
                                            ctx->primary,
                                            "+CGATT=1",
-                                           10,
+                                           20,
                                            FALSE,
                                            FALSE, /* raw */
                                            NULL, /* cancellable */
-                                           (GAsyncReadyCallback)cgatt_ready,
+                                           (GAsyncReadyCallback)cgatt_attach_ready,
                                            task);
             return;
 
-        case DIAL_3GPP_STEP_CONNECT:
-            ctx->data = mm_base_modem_get_best_data_port (ctx->modem, MM_PORT_TYPE_NET);
-            if (ctx->data) {
-                gchar *command = g_strdup_printf("+CGACT=1,%u", ctx->cid);
-                mm_base_modem_at_command_full(MM_BASE_MODEM(ctx->modem),
-                                              ctx->primary,
-                                              command,
-                                              10,
-                                              FALSE,
-                                              FALSE, /* raw */
-                                              NULL, /* cancellable */
-                                              (GAsyncReadyCallback) cgact_ready,
-                                              task);
-                g_free(command);
-                return;
-            }
+        case DIAL_3GPP_STEP_PS_ATTACH_QUERY:
+            mm_base_modem_at_command_full(MM_BASE_MODEM(ctx->modem),
+                                          ctx->primary,
+                                          "+CGATT?",
+                                          10,
+                                          FALSE,
+                                          FALSE, /* raw */
+                                          NULL, /* cancellable */
+                                          (GAsyncReadyCallback) cgatt_query_ready,
+                                          task);
             return;
 
         case DIAL_3GPP_STEP_CONNECT_QUERY:
-            ctx->data = mm_base_modem_get_best_data_port (ctx->modem, MM_PORT_TYPE_NET);
-            if (ctx->data) {
-                mm_base_modem_at_command_full(MM_BASE_MODEM(ctx->modem),
-                                              ctx->primary,
-                                              "+CGACT?",
-                                              10,
-                                              FALSE,
-                                              FALSE, /* raw */
-                                              NULL, /* cancellable */
-                                              (GAsyncReadyCallback) cgact_query_ready,
-                                              task);
-                return;
-            }
+            mm_base_modem_at_command_full(MM_BASE_MODEM(ctx->modem),
+                                          ctx->primary,
+                                          "+CGACT?",
+                                          10,
+                                          FALSE,
+                                          FALSE, /* raw */
+                                          NULL, /* cancellable */
+                                          (GAsyncReadyCallback) cgact_query_ready,
+                                          task);
             return;
 
         case DIAL_3GPP_STEP_LAST:
@@ -1077,15 +835,6 @@ cgact_deactivate_ready (MMBaseModem  *modem,
         g_clear_error (&error);
     }
 
-    // PS Detach
-    mm_obj_dbg (self, "PS detach...");
-    mm_base_modem_at_command (MM_BASE_MODEM (modem),
-                              "+CGATT=0",
-                              120,
-                              FALSE,
-                              (GAsyncReadyCallback) cgatt_disconnect,
-                              task);
-
     g_task_return_boolean (task, TRUE);
     g_object_unref (task);
 }
@@ -1169,10 +918,10 @@ static void
 mm_broadband_bearer_unitac_init (MMBroadbandBearerUnitac *self)
 {
 }
+
 static void
 mm_broadband_bearer_unitac_class_init (MMBroadbandBearerUnitacClass *klass)
 {
-    MMBaseBearerClass      *base_bearer_class      = MM_BASE_BEARER_CLASS (klass);
     MMBroadbandBearerClass *broadband_bearer_class = MM_BROADBAND_BEARER_CLASS (klass);
 
     broadband_bearer_class->disconnect_3gpp           = disconnect_3gpp;
diff --git a/plugins/unitac/mm-broadband-modem-unitac.c b/plugins/unitac/mm-broadband-modem-unitac.c
index add2029..af008bf 100644
--- a/plugins/unitac/mm-broadband-modem-unitac.c
+++ b/plugins/unitac/mm-broadband-modem-unitac.c
@@ -31,6 +31,7 @@
 #include "mm-broadband-bearer-unitac.h"
 #include "mm-iface-modem-signal.h"
 #include "mm-modem-helpers.h"
+#include "mm-modem-helpers-unitac.h"
 
 static void iface_modem_init (MMIfaceModem *iface);
 static void iface_modem_signal_init (MMIfaceModemSignal *iface);
@@ -101,100 +102,10 @@ broadband_bearer_unitac_new_ready (GObject *source,
 }
 
 /*****************************************************************************/
-/* +CESQ response parser */
-
-gboolean
-mm_3gpp_parse_cesq_response (const gchar *response,
-                             guint *out_rxlev,
-                             guint *out_ber,
-                             guint *out_rscp,
-                             guint *out_ecn0,
-                             guint *out_rsrq,
-                             guint *out_rsrp,
-                             GError **error)
-{
-    GRegex     *r;
-    GMatchInfo *match_info;
-    GError     *inner_error = NULL;
-    guint      rxlev = 99;
-    guint      ber = 99;
-    guint      rscp = 255;
-    guint      ecn0 = 255;
-    guint      rsrq = 255;
-    guint      rsrp = 255;
-    gboolean   success = FALSE;
-
-    g_assert (out_rxlev);
-    g_assert (out_ber);
-    g_assert (out_rscp);
-    g_assert (out_ecn0);
-    g_assert (out_rsrq);
-    g_assert (out_rsrp);
-
-    /* Response may be e.g.:
-     * +CESQ: 99,99,255,255,20,80
-     */
-    r = g_regex_new ("\\+CESQ: (\\d+), (\\d+), (\\d+), (\\d+), (\\d+), (\\d+)(?:\\r\\n)?", 0, 0, NULL);
-    g_assert (r != NULL);
-
-    g_regex_match_full (r, response, strlen (response), 0, 0, &match_info, &inner_error);
-    if (!inner_error && g_match_info_matches (match_info)) {
-        if (!mm_get_uint_from_match_info (match_info, 1, &rxlev)) {
-            inner_error = g_error_new (MM_CORE_ERROR, MM_CORE_ERROR_FAILED, "Couldn't read RXLEV");
-            goto out;
-        }
-        if (!mm_get_uint_from_match_info (match_info, 2, &ber)) {
-            inner_error = g_error_new (MM_CORE_ERROR, MM_CORE_ERROR_FAILED, "Couldn't read BER");
-            goto out;
-        }
-        if (!mm_get_uint_from_match_info (match_info, 3, &rscp)) {
-            inner_error = g_error_new (MM_CORE_ERROR, MM_CORE_ERROR_FAILED, "Couldn't read RSCP");
-            goto out;
-        }
-        if (!mm_get_uint_from_match_info (match_info, 4, &ecn0)) {
-            inner_error = g_error_new (MM_CORE_ERROR, MM_CORE_ERROR_FAILED, "Couldn't read Ec/N0");
-            goto out;
-        }
-        if (!mm_get_uint_from_match_info (match_info, 5, &rsrq)) {
-            inner_error = g_error_new (MM_CORE_ERROR, MM_CORE_ERROR_FAILED, "Couldn't read RSRQ");
-            goto out;
-        }
-        if (!mm_get_uint_from_match_info (match_info, 6, &rsrp)) {
-            inner_error = g_error_new (MM_CORE_ERROR, MM_CORE_ERROR_FAILED, "Couldn't read RSRP");
-            goto out;
-        }
-        success = TRUE;
-    }
-
-    out:
-    g_match_info_free (match_info);
-    g_regex_unref (r);
-
-    if (inner_error) {
-        g_propagate_error (error, inner_error);
-        return FALSE;
-    }
-
-    if (!success) {
-        g_set_error (error, MM_CORE_ERROR, MM_CORE_ERROR_FAILED,
-                     "couldn't parse +CESQ response: %s", response);
-        return FALSE;
-    }
-
-    *out_rxlev = rxlev;
-    *out_ber = ber;
-    *out_rscp = rscp;
-    *out_ecn0 = ecn0;
-    *out_rsrq = rsrq;
-    *out_rsrp = rsrp;
-    return TRUE;
-}
-
-/*****************************************************************************/
 /* Load extended signal information (Signal interface) */
 
 gboolean
-mm_3gpp_cesq_response_to_signal_info (const gchar *response,
+mm_3gpp_cust_cesq_response_to_signal_info (const gchar *response,
                                       gpointer log_object,
                                       MMSignal **out_gsm,
                                       MMSignal **out_umts,
@@ -286,7 +197,7 @@ modem_signal_load_values_finish (MMIfaceModemSignal *self,
     const gchar *response;
 
     response = mm_base_modem_at_command_finish (MM_BASE_MODEM (self), res, error);
-    if (!response || !mm_3gpp_cesq_response_to_signal_info (response, self, gsm, umts, lte, error))
+    if (!response || !mm_3gpp_cust_cesq_response_to_signal_info (response, self, gsm, umts, lte, error))
         return FALSE;
 
     /* No 3GPP2 support */
@@ -300,49 +211,6 @@ modem_signal_load_values_finish (MMIfaceModemSignal *self,
 /*****************************************************************************/
 /* %WMODE? response parser */
 
-gboolean
-mm_unitac_parse_wmode_response (const gchar *response,
-                                GError **error,
-                                GTask *task)
-{
-    MMBroadbandModemUnitac *self;
-    GRegex                 *r;
-    GMatchInfo             *match_info;
-    GError                 *inner_error = NULL;
-
-    self = g_task_get_source_object (task);
-    /* Response may be e.g.:
-     * response: 'MODE: bridge-ecm'
-     */
-    r = g_regex_new ("^MODE: \\w+.*$", 0, 0, NULL);
-    g_assert (r != NULL);
-
-    g_regex_match_full (r, response, strlen (response), 0, 0, &match_info, &inner_error);
-    if (!inner_error && g_match_info_matches (match_info)) {
-        gchar *wmode;
-
-        wmode = mm_get_string_unquoted_from_match_info (match_info, 1);
-        if (wmode) {
-            if (g_str_equal (wmode, "bridge-ecm"))
-                mm_obj_dbg (self, "modem is in bridge-ecm wmode");
-            else
-                mm_obj_dbg (self, "unknown wmode for the modem...%s", wmode);
-        } else
-            mm_obj_dbg (self, "unable to parse wmode for the modem");
-        g_free (wmode);
-    }
-
-    g_match_info_free (match_info);
-    g_regex_unref (r);
-
-    if (inner_error) {
-        g_propagate_error (error, inner_error);
-        return FALSE;
-    }
-
-    return TRUE;
-}
-
 static void
 wmode_check_ready (MMBaseModem *_self,
                    GAsyncResult *res,
@@ -358,7 +226,9 @@ wmode_check_ready (MMBaseModem *_self,
     response = mm_base_modem_at_command_finish (_self, res, &error);
     if (!response && !mm_unitac_parse_wmode_response (response, &error, task)) {
         mm_obj_dbg (self, "couldn't load wmode: %s", error->message);
-        g_error_free (error);
+        g_task_return_error (task, error);
+        g_object_unref (task);
+        return;
     }
 
     ctx->step++;
@@ -384,7 +254,7 @@ create_bearer_step (GTask *task)
         mm_base_modem_at_command (
             MM_BASE_MODEM (self),
             "%WMODE?",
-            3,
+            5,
             FALSE,
             (GAsyncReadyCallback) wmode_check_ready,
             task);
@@ -438,19 +308,6 @@ modem_create_bearer (MMIfaceModem *self,
 /*****************************************************************************/
 /* Load current bands (Modem interface) */
 
-typedef struct {
-    guint       num;
-    MMModemBand band;
-} UbandBandConfig;
-
-static const UbandBandConfig uband_band_config[] = {
-        /* LTE bands */
-        { .num =  3,  .band = MM_MODEM_BAND_EUTRAN_3  },
-        { .num =  7,  .band = MM_MODEM_BAND_EUTRAN_7  },
-        { .num =  20, .band = MM_MODEM_BAND_EUTRAN_20 },
-        { .num =  31, .band = MM_MODEM_BAND_EUTRAN_31 },
-};
-
 static GArray *
 load_current_bands_finish (MMIfaceModem *self,
                            GAsyncResult *res,
@@ -459,87 +316,6 @@ load_current_bands_finish (MMIfaceModem *self,
     return (GArray *) g_task_propagate_pointer (G_TASK (res), error);
 }
 
-static MMModemBand
-uband_num_to_band (guint num)
-{
-    guint i;
-
-    for (i = 0; i < G_N_ELEMENTS (uband_band_config); i++) {
-        if (num == uband_band_config[i].num)
-            return uband_band_config[i].band;
-    }
-    return MM_MODEM_BAND_UNKNOWN;
-}
-
-static GArray *
-uband_num_array_to_band_array (GArray *nums)
-{
-    GArray *bands = NULL;
-    guint  i;
-
-    if (!nums)
-        return NULL;
-
-    bands = g_array_sized_new (FALSE, FALSE, sizeof (MMModemBand), nums->len);
-    for (i = 0; i < nums->len; i++) {
-        MMModemBand band;
-
-        band = uband_num_to_band (g_array_index (nums, guint, i));
-        g_array_append_val (bands, band);
-    }
-
-    return bands;
-}
-
-
-GArray *
-mm_unitac_parse_uband_response (const gchar *response,
-                                gpointer log_object,
-                                GError **error)
-{
-    GRegex     *r;
-    GMatchInfo *match_info;
-    GError     *inner_error = NULL;
-    GArray     *nums        = NULL;
-    GArray     *bands       = NULL;
-
-    /*
-     * AT+UBAND?
-     * !UBAND: 31,20,3,72
-     */
-    r = g_regex_new ("\\!UBAND: (.*)(?:\\r\\n)?",
-                     G_REGEX_DOLLAR_ENDONLY | G_REGEX_RAW, 0, NULL);
-    g_assert (r != NULL);
-
-    g_regex_match_full (r, response, strlen (response), 0, 0, &match_info, &inner_error);
-    if (!inner_error && g_match_info_matches (match_info)) {
-        gchar *bandstr;
-        bandstr = mm_get_string_unquoted_from_match_info (match_info, 1);
-        nums = mm_parse_uint_list (bandstr, &inner_error);
-        g_free (bandstr);
-    }
-
-    g_match_info_free (match_info);
-    g_regex_unref (r);
-
-    if (inner_error) {
-        g_propagate_error (error, inner_error);
-        return NULL;
-    }
-
-    /* Convert to MMModemBand values */
-    if (nums) {
-        bands = uband_num_array_to_band_array (nums);
-        g_array_unref (nums);
-    }
-
-    if (!bands)
-        g_set_error (error, MM_CORE_ERROR, MM_CORE_ERROR_FAILED,
-                     "no known band selection values matched in !UBAND response: '%s'", response);
-
-    return bands;
-}
-
 static void
 uband_load_current_bands_ready (MMBaseModem *self,
                                 GAsyncResult *res,
@@ -599,13 +375,14 @@ static const BandConfiguration band_configuration[] = {
         {
                 .model    = "ML660PG",
                 .mode     = MM_MODEM_MODE_4G,
-                .bands_4g = { MM_MODEM_BAND_EUTRAN_3, MM_MODEM_BAND_EUTRAN_20, MM_MODEM_BAND_EUTRAN_31 }
+                .bands_4g = { MM_MODEM_BAND_EUTRAN_3, MM_MODEM_BAND_EUTRAN_20, MM_MODEM_BAND_EUTRAN_31,
+                              MM_MODEM_BAND_EUTRAN_72 }
         },
         {
                 .model    = "ML620EU",
                 .mode     = MM_MODEM_MODE_4G,
                 .bands_4g = { MM_MODEM_BAND_EUTRAN_3, MM_MODEM_BAND_EUTRAN_7, MM_MODEM_BAND_EUTRAN_20,
-                              MM_MODEM_BAND_EUTRAN_31 }
+                              MM_MODEM_BAND_EUTRAN_31, MM_MODEM_BAND_EUTRAN_72 }
         },
 };
 
@@ -709,6 +486,28 @@ enabling_modem_init (MMBroadbandModem *self,
 }
 
 /*****************************************************************************/
+/* Create SIM (Modem interface) */
+
+static MMBaseSim *
+modem_create_sim_finish (MMIfaceModem  *self,
+                         GAsyncResult  *res,
+                         GError        **error)
+{
+    return mm_sim_unitac_new_finish (res, error);
+}
+
+static void
+modem_create_sim (MMIfaceModem         *self,
+                  GAsyncReadyCallback  callback,
+                  gpointer             user_data)
+{
+    mm_sim_unitac_new (MM_BASE_MODEM (self),
+                       NULL, /* cancellable */
+                       callback,
+                       user_data);
+}
+
+/*****************************************************************************/
 
 MMBroadbandModemUnitac *
 mm_broadband_modem_unitac_new (const gchar *device,
@@ -734,6 +533,8 @@ mm_broadband_modem_unitac_init (MMBroadbandModemUnitac *self)
 static void
 iface_modem_init (MMIfaceModem *iface)
 {
+    iface->create_sim                  = modem_create_sim;
+    iface->create_sim_finish           = modem_create_sim_finish;
     iface->create_bearer               = modem_create_bearer;
     iface->create_bearer_finish        = modem_create_bearer_finish;
     iface->load_supported_bands        = load_supported_bands;
@@ -751,7 +552,6 @@ iface_modem_signal_init (MMIfaceModemSignal *iface)
 static void
 mm_broadband_modem_unitac_class_init (MMBroadbandModemUnitacClass *klass)
 {
-    GObjectClass          *object_class          = G_OBJECT_CLASS (klass);
     MMBroadbandModemClass *broadband_modem_class = MM_BROADBAND_MODEM_CLASS (klass);
 
     broadband_modem_class->enabling_modem_init        = enabling_modem_init;
diff --git a/plugins/unitac/mm-modem-helpers-unitac.c b/plugins/unitac/mm-modem-helpers-unitac.c
new file mode 100644
index 0000000..cfb5f38
--- /dev/null
+++ b/plugins/unitac/mm-modem-helpers-unitac.c
@@ -0,0 +1,604 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details:
+ *
+ * Copyright (C) 2021 Anubhav Gupta <anubhav.gupta@digi.com>
+ */
+
+#include <glib.h>
+#include <string.h>
+#include <arpa/inet.h>
+
+#include "mm-log.h"
+#include "mm-modem-helpers.h"
+#include "mm-modem-helpers-unitac.h"
+
+/*****************************************************************************/
+/* +CGATT? response parser */
+
+gboolean
+mm_unitac_parse_cgatt_response (const gchar *response,
+                                guint       *attach,
+                                GError      **error)
+{
+    GRegex     *r;
+    GMatchInfo *match_info;
+    GError     *inner_error = NULL;
+    guint      cgatt = 0;
+
+    /* Response may be e.g.:
+     * response: '+CGATT:1'
+     */
+    r = g_regex_new ("\\+CGATT:(\\d)", 0, 0, NULL);
+    g_assert (r != NULL);
+
+    g_regex_match_full (r, response, strlen (response), 0, 0, &match_info, &inner_error);
+    if (inner_error)
+        goto out;
+
+    if (!g_match_info_matches (match_info)) {
+        inner_error = g_error_new (MM_CORE_ERROR, MM_CORE_ERROR_INVALID_ARGS, "Couldn't match +CGATT response");
+        goto out;
+    }
+
+    if (!mm_get_uint_from_match_info(match_info, 1, &cgatt))
+    {
+        inner_error = g_error_new(MM_CORE_ERROR, MM_CORE_ERROR_FAILED, "Error parsing +CGATT");
+        goto out;
+    }
+
+    out:
+
+    g_match_info_free (match_info);
+    g_regex_unref (r);
+
+    if (inner_error) {
+        g_propagate_error (error, inner_error);
+        return FALSE;
+    }
+
+    *attach = cgatt;
+
+    return TRUE;
+}
+
+/*****************************************************************************/
+/* CGPADDR=N response parser */
+
+gboolean
+mm_unitac_parse_cgpaddr_response (const gchar *response,
+                                  gchar       **out_ipv4_address,
+                                  gchar       **out_ipv6_address,
+                                  GError      **error)
+{
+    GRegex     *r;
+    GMatchInfo *match_info;
+    GError     *inner_error = NULL;
+    gchar      *ipv4_address = NULL;
+    gchar      *ipv6_address = NULL;
+
+    /* Response may be e.g.:
+     * response: '+CGPADDR: 1,"172.22.1.100"'
+     *
+     * We assume only ONE line is returned; because we request +CGPADDR with a specific N CID.
+     */
+    r = g_regex_new ("\\+CGPADDR: (\\d+)(?:,([^,]*))(?:,([^,]*))?", 0, 0, NULL);
+    g_assert (r != NULL);
+
+    g_regex_match_full (r, response, strlen (response), 0, 0, &match_info, &inner_error);
+    if (inner_error)
+        goto out;
+
+    if (!g_match_info_matches (match_info)) {
+        inner_error = g_error_new (MM_CORE_ERROR, MM_CORE_ERROR_INVALID_ARGS, "Couldn't match +CGPADDR response");
+        goto out;
+    }
+
+    if (out_ipv4_address)
+        ipv4_address = mm_get_string_unquoted_from_match_info(match_info, 2);
+
+    if (out_ipv6_address)
+        ipv6_address = mm_get_string_unquoted_from_match_info(match_info, 3);
+
+    out:
+
+    g_match_info_free (match_info);
+    g_regex_unref (r);
+
+    if (inner_error) {
+        g_free (ipv4_address);
+        g_free (ipv6_address);
+        g_propagate_error (error, inner_error);
+        return FALSE;
+    }
+
+    if (out_ipv4_address && ipv4_address)
+        *out_ipv4_address = ipv4_address;
+
+    if (out_ipv6_address && ipv6_address)
+        *out_ipv6_address = ipv6_address;
+
+    return TRUE;
+}
+
+
+/*****************************************************************************/
+/* +CGCONTRDP=N response parser */
+
+static gboolean
+split_local_address_and_subnet (const gchar *str,
+                                gchar       **local_address,
+                                gchar       **subnet)
+{
+    const gchar *separator;
+    guint count = 0;
+
+    /* E.g. split: "2.43.2.44.255.255.255.255"
+     * into:
+     *    local address: "2.43.2.44",
+     *    subnet: "255.255.255.255"
+     */
+    g_assert (str);
+    g_assert (local_address);
+    g_assert (subnet);
+
+    separator = str;
+    while (1) {
+        separator = strchr (separator, '.');
+        if (separator) {
+            count++;
+            if (count == 4) {
+                if (local_address)
+                    *local_address = g_strndup (str, (separator - str));
+                if (subnet)
+                    *subnet = g_strdup (++separator);
+                return TRUE;
+            }
+            separator++;
+            continue;
+        }
+
+        /* Not even the full IP? report error parsing */
+        if (count < 3)
+            return FALSE;
+
+        if (count == 3) {
+            if (local_address)
+                *local_address = g_strdup (str);
+            if (subnet)
+                *subnet = NULL;
+            return TRUE;
+        }
+    }
+}
+
+static int
+ipv6_netmask_len(char * mask_str)
+{
+    struct in6_addr netmask;
+    int len = 0;
+    unsigned char val;
+    unsigned char *pnt;
+
+    inet_pton(AF_INET6, mask_str, &netmask);
+    pnt = (unsigned char *) & netmask;
+
+    while ((*pnt == 0xff) && len < 128)
+    {
+        len += 8;
+        pnt++;
+    }
+
+    if (len < 128)
+    {
+        val = *pnt;
+        while (val)
+        {
+            len++;
+            val <<= 1;
+        }
+    }
+    return len;
+}
+
+gboolean
+mm_3gpp_cust_parse_cgcontrdp_response (const gchar  *response,
+                                       gchar        **ipv4_address,
+                                       gchar        **ipv4_subnet,
+                                       gchar        **ipv4_gateway,
+                                       gchar        **ipv4_dns1_addresses,
+                                       gchar        **ipv4_dns2_addresses,
+                                       guint        *ipv4_mtu,
+                                       gchar        **ipv6_address,
+                                       guint        *ipv6_subnet,
+                                       gchar        **ipv6_gateway,
+                                       gchar        **ipv6_dns1_addresses,
+                                       gchar        **ipv6_dns2_addresses,
+                                       guint        *ipv6_mtu,
+                                       GError       **error)
+{
+    GRegex       *r;
+    GMatchInfo   *match_info;
+    GError       *inner_error = NULL;
+    guint        cid = 0;
+    guint        bearer_id = 0;
+
+    gchar        *ipv4_addr = NULL;
+    gchar        *ipv4_sub = NULL;
+    gchar        *ipv4_gat = NULL;
+    gchar        *ipv4_dns1 = NULL;
+    gchar        *ipv4_dns2 = NULL;
+    guint        v4_mtu = 0;
+
+    gchar        *ipv6_addr = NULL;
+    guint        ipv6_sub = 0;
+    gchar        *ipv6_gat = NULL;
+    gchar        *ipv6_dns1 = NULL;
+    gchar        *ipv6_dns2 = NULL;
+    guint        v6_mtu = 0;
+
+    r = g_regex_new ("\\+CGCONTRDP: "
+                     "(\\d+),(\\d+),([^,]*)" /* cid, bearer id, apn */
+                     "(?:,([^,]*))?" /* (a)ip+mask        or (b)ip */
+                     "(?:,([^,]*))?" /* (a)gateway        or (b)mask */
+                     "(?:,([^,]*))?" /* (a)dns1           or (b)gateway */
+                     "(?:,([^,]*))?" /* (a)dns2           or (b)dns1 */
+                     "(?:,([^,]*))?" /* (a)p-cscf primary or (b)dns2 */
+                     "(?:,(.*))?"    /* others, ignored */
+                     ",(\\d+\\d+\\d+\\d+)?" /* MTU */
+                     "(?:\\r\\n)?",
+                     G_REGEX_DOLLAR_ENDONLY | G_REGEX_RAW, 0, NULL);
+    g_assert (r != NULL);
+
+    g_regex_match_full (r, response, strlen (response), 0, 0, &match_info, &inner_error);
+    if (inner_error)
+        goto out;
+
+    while (!inner_error &&
+           g_match_info_matches (match_info))
+    {
+        // Check CID
+        if (!mm_get_uint_from_match_info(match_info, 1, &cid))
+        {
+            inner_error = g_error_new(MM_CORE_ERROR, MM_CORE_ERROR_FAILED, "Error parsing cid");
+            break;
+        }
+
+        // Check bearer ID
+        if (!mm_get_uint_from_match_info(match_info, 2, &bearer_id))
+        {
+            inner_error = g_error_new(MM_CORE_ERROR, MM_CORE_ERROR_FAILED, "Error parsing bearer id");
+            break;
+        }
+
+        // Skip APN check as not needed
+
+        // Get Local Address and Subnet
+        gchar      *local_address_and_subnet = NULL;
+
+        local_address_and_subnet = mm_get_string_unquoted_from_match_info(match_info, 4);
+        if (local_address_and_subnet)
+        {
+            if(strstr (local_address_and_subnet, ":"))
+            {
+                char delim[] = " ";
+                if (ipv6_address && ipv6_subnet)
+                {
+                    char * temp = NULL;
+                    temp = strtok(local_address_and_subnet, delim);
+                    if (temp != NULL)
+                        ipv6_addr = strdup(temp);
+                    temp = strtok(NULL, delim);
+                    if (temp != NULL)
+                        ipv6_sub = ipv6_netmask_len(temp);
+                }
+                if (ipv6_gateway)
+                    ipv6_gat = mm_get_string_unquoted_from_match_info(match_info, 5);
+                if (ipv6_dns1_addresses)
+                    ipv6_dns1 = mm_get_string_unquoted_from_match_info(match_info, 6);
+                if (ipv6_dns2_addresses)
+                    ipv6_dns2 = mm_get_string_unquoted_from_match_info(match_info, 7);
+                mm_get_uint_from_match_info(match_info, 10, &v6_mtu);
+            }
+            else
+            {
+                if (ipv4_address && ipv4_subnet)
+                    split_local_address_and_subnet(local_address_and_subnet, &ipv4_addr, &ipv4_sub);
+                if (ipv4_gateway)
+                    ipv4_gat = mm_get_string_unquoted_from_match_info(match_info, 5);
+                if (ipv4_dns1_addresses)
+                    ipv4_dns1 = mm_get_string_unquoted_from_match_info(match_info, 6);
+                if (ipv4_dns2_addresses)
+                    ipv4_dns2 = mm_get_string_unquoted_from_match_info(match_info, 7);
+                mm_get_uint_from_match_info(match_info, 10, &v4_mtu);
+            }
+        }
+
+        g_free (local_address_and_subnet);
+        g_match_info_next (match_info, &inner_error);
+    }
+
+    out:
+    g_match_info_free (match_info);
+    g_regex_unref (r);
+
+    if (inner_error) {
+        g_free (ipv4_addr);
+        g_free (ipv4_sub);
+        g_free (ipv4_gat);
+        g_free (ipv4_dns1);
+        g_free (ipv4_dns2);
+        g_free (ipv6_addr);
+        g_free (ipv6_gat);
+        g_free (ipv6_dns1);
+        g_free (ipv6_dns2);
+        g_propagate_error (error, inner_error);
+        return FALSE;
+    }
+
+    /* IPv4 Connection Details */
+    if (ipv4_address)
+        *ipv4_address = ipv4_addr;
+    else
+        g_free (ipv4_addr);
+
+    if (ipv4_subnet)
+        *ipv4_subnet = ipv4_sub;
+    else
+        g_free (ipv4_sub);
+
+    if (ipv4_gateway)
+        *ipv4_gateway = ipv4_gat;
+    if (ipv4_dns1_addresses)
+        *ipv4_dns1_addresses = ipv4_dns1;
+    if (ipv4_dns2_addresses)
+        *ipv4_dns2_addresses = ipv4_dns2;
+
+    *ipv4_mtu = v4_mtu;
+
+    /* IPv6 Connection Details */
+    if (ipv6_address)
+        *ipv6_address = ipv6_addr;
+    else
+        g_free (ipv6_addr);
+
+    if (ipv6_subnet)
+        *ipv6_subnet = ipv6_sub;
+
+    if (ipv6_gateway)
+        *ipv6_gateway = ipv6_gat;
+    if (ipv6_dns1_addresses)
+        *ipv6_dns1_addresses = ipv6_dns1;
+    if (ipv6_dns2_addresses)
+        *ipv6_dns2_addresses = ipv6_dns2;
+
+    *ipv6_mtu = v6_mtu;
+
+    return TRUE;
+}
+
+/*****************************************************************************/
+/* +CESQ response parser */
+
+gboolean
+mm_3gpp_parse_cesq_response (const gchar *response,
+                             guint *out_rxlev,
+                             guint *out_ber,
+                             guint *out_rscp,
+                             guint *out_ecn0,
+                             guint *out_rsrq,
+                             guint *out_rsrp,
+                             GError **error)
+{
+    GRegex     *r;
+    GMatchInfo *match_info;
+    GError     *inner_error = NULL;
+    guint      rxlev = 99;
+    guint      ber = 99;
+    guint      rscp = 255;
+    guint      ecn0 = 255;
+    guint      rsrq = 255;
+    guint      rsrp = 255;
+    gboolean   success = FALSE;
+
+    g_assert (out_rxlev);
+    g_assert (out_ber);
+    g_assert (out_rscp);
+    g_assert (out_ecn0);
+    g_assert (out_rsrq);
+    g_assert (out_rsrp);
+
+    /* Response may be e.g.:
+     * +CESQ: 99,99,255,255,20,80
+     */
+    r = g_regex_new ("\\+CESQ: (\\d+), (\\d+), (\\d+), (\\d+), (\\d+), (\\d+)(?:\\r\\n)?", 0, 0, NULL);
+    g_assert (r != NULL);
+
+    g_regex_match_full (r, response, strlen (response), 0, 0, &match_info, &inner_error);
+    if (!inner_error && g_match_info_matches (match_info)) {
+        if (!mm_get_uint_from_match_info (match_info, 1, &rxlev)) {
+            inner_error = g_error_new (MM_CORE_ERROR, MM_CORE_ERROR_FAILED, "Couldn't read RXLEV");
+            goto out;
+        }
+        if (!mm_get_uint_from_match_info (match_info, 2, &ber)) {
+            inner_error = g_error_new (MM_CORE_ERROR, MM_CORE_ERROR_FAILED, "Couldn't read BER");
+            goto out;
+        }
+        if (!mm_get_uint_from_match_info (match_info, 3, &rscp)) {
+            inner_error = g_error_new (MM_CORE_ERROR, MM_CORE_ERROR_FAILED, "Couldn't read RSCP");
+            goto out;
+        }
+        if (!mm_get_uint_from_match_info (match_info, 4, &ecn0)) {
+            inner_error = g_error_new (MM_CORE_ERROR, MM_CORE_ERROR_FAILED, "Couldn't read Ec/N0");
+            goto out;
+        }
+        if (!mm_get_uint_from_match_info (match_info, 5, &rsrq)) {
+            inner_error = g_error_new (MM_CORE_ERROR, MM_CORE_ERROR_FAILED, "Couldn't read RSRQ");
+            goto out;
+        }
+        if (!mm_get_uint_from_match_info (match_info, 6, &rsrp)) {
+            inner_error = g_error_new (MM_CORE_ERROR, MM_CORE_ERROR_FAILED, "Couldn't read RSRP");
+            goto out;
+        }
+        success = TRUE;
+    }
+
+    out:
+    g_match_info_free (match_info);
+    g_regex_unref (r);
+
+    if (inner_error) {
+        g_propagate_error (error, inner_error);
+        return FALSE;
+    }
+
+    if (!success) {
+        g_set_error (error, MM_CORE_ERROR, MM_CORE_ERROR_FAILED,
+                     "couldn't parse +CESQ response: %s", response);
+        return FALSE;
+    }
+
+    *out_rxlev = rxlev;
+    *out_ber = ber;
+    *out_rscp = rscp;
+    *out_ecn0 = ecn0;
+    *out_rsrq = rsrq;
+    *out_rsrp = rsrp;
+    return TRUE;
+}
+
+
+/*****************************************************************************/
+/* %WMODE? response parser */
+
+gboolean
+mm_unitac_parse_wmode_response (const gchar *response,
+                                GError **error,
+                                GTask *task)
+{
+    GRegex                 *r;
+    GMatchInfo             *match_info;
+    GError                 *inner_error = NULL;
+
+    /* Response may be e.g.:
+     * response: 'MODE: bridge-ecm'
+     */
+    r = g_regex_new ("^MODE: \\w+.*$", 0, 0, NULL);
+    g_assert (r != NULL);
+
+    g_regex_match_full (r, response, strlen (response), 0, 0, &match_info, &inner_error);
+    if (!inner_error && g_match_info_matches (match_info)) {
+        gchar *wmode;
+
+        wmode = mm_get_string_unquoted_from_match_info (match_info, 1);
+        if (wmode) {
+            if (!g_str_equal (wmode, "bridge-ecm"))
+                inner_error = g_error_new(MM_CORE_ERROR, MM_CORE_ERROR_FAILED, "unknown wmode for the modem...");
+        } else
+            inner_error = g_error_new(MM_CORE_ERROR, MM_CORE_ERROR_FAILED, "unable to parse wmode for the modem...");
+
+        g_free (wmode);
+    }
+
+    g_match_info_free (match_info);
+    g_regex_unref (r);
+
+    if (inner_error) {
+        g_propagate_error (error, inner_error);
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
+/*****************************************************************************/
+/* Load current bands (Modem interface) */
+
+static MMModemBand
+uband_num_to_band (guint num)
+{
+    guint i;
+
+    for (i = 0; i < G_N_ELEMENTS (uband_band_config); i++) {
+        if (num == uband_band_config[i].num)
+            return uband_band_config[i].band;
+    }
+    return MM_MODEM_BAND_UNKNOWN;
+}
+
+static GArray *
+uband_num_array_to_band_array (GArray *nums)
+{
+    GArray *bands = NULL;
+    guint  i;
+
+    if (!nums)
+        return NULL;
+
+    bands = g_array_sized_new (FALSE, FALSE, sizeof (MMModemBand), nums->len);
+    for (i = 0; i < nums->len; i++) {
+        MMModemBand band;
+
+        band = uband_num_to_band (g_array_index (nums, guint, i));
+        g_array_append_val (bands, band);
+    }
+
+    return bands;
+}
+
+
+GArray *
+mm_unitac_parse_uband_response (const gchar *response,
+                                gpointer log_object,
+                                GError **error)
+{
+    GRegex     *r;
+    GMatchInfo *match_info;
+    GError     *inner_error = NULL;
+    GArray     *nums        = NULL;
+    GArray     *bands       = NULL;
+
+    /*
+     * AT+UBAND?
+     * !UBAND: 31,20,3,72
+     */
+    r = g_regex_new ("\\!UBAND: (.*)(?:\\r\\n)?",
+                     G_REGEX_DOLLAR_ENDONLY | G_REGEX_RAW, 0, NULL);
+    g_assert (r != NULL);
+
+    g_regex_match_full (r, response, strlen (response), 0, 0, &match_info, &inner_error);
+    if (!inner_error && g_match_info_matches (match_info)) {
+        gchar *bandstr;
+        bandstr = mm_get_string_unquoted_from_match_info (match_info, 1);
+        nums = mm_parse_uint_list (bandstr, &inner_error);
+        g_free (bandstr);
+    }
+
+    g_match_info_free (match_info);
+    g_regex_unref (r);
+
+    if (inner_error) {
+        g_propagate_error (error, inner_error);
+        return NULL;
+    }
+
+    /* Convert to MMModemBand values */
+    if (nums) {
+        bands = uband_num_array_to_band_array (nums);
+        g_array_unref (nums);
+    }
+
+    if (!bands)
+        g_set_error (error, MM_CORE_ERROR, MM_CORE_ERROR_FAILED,
+                     "no known band selection values matched in !UBAND response: '%s'", response);
+
+    return bands;
+}
\ No newline at end of file
diff --git a/plugins/unitac/mm-modem-helpers-unitac.h b/plugins/unitac/mm-modem-helpers-unitac.h
new file mode 100644
index 0000000..45fa726
--- /dev/null
+++ b/plugins/unitac/mm-modem-helpers-unitac.h
@@ -0,0 +1,112 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details:
+ *
+ * Copyright (C) 2021 Anubhav Gupta <anubhav.gupta@digi.com>
+ */
+
+#ifndef MM_MODEM_HELPERS_UNITAC_H
+#define MM_MODEM_HELPERS_UNITAC_H
+
+#include <glib.h>
+#include <ModemManager.h>
+
+/*****************************************************************************/
+/* +CGATT? response parser */
+
+gboolean
+mm_unitac_parse_cgatt_response (const gchar *response,
+                                guint       *attach,
+                                GError      **error);
+
+/*****************************************************************************/
+/* +CGPADDR=N response parser */
+
+gboolean
+mm_unitac_parse_cgpaddr_response (const gchar *response,
+                                  gchar       **out_ipv4_address,
+                                  gchar       **out_ipv6_address,
+                                  GError      **error);
+
+/*****************************************************************************/
+/* +CGCONTRDP=N response parser */
+
+gboolean
+mm_3gpp_cust_parse_cgcontrdp_response (const gchar  *response,
+                                       gchar        **ipv4_address,
+                                       gchar        **ipv4_subnet,
+                                       gchar        **ipv4_gateway,
+                                       gchar        **ipv4_dns1_addresses,
+                                       gchar        **ipv4_dns2_addresses,
+                                       guint        *ipv4_mtu,
+                                       gchar        **ipv6_address,
+                                       guint        *ipv6_subnet,
+                                       gchar        **ipv6_gateway,
+                                       gchar        **ipv6_dns1_addresses,
+                                       gchar        **ipv6_dns2_addresses,
+                                       guint        *ipv6_mtu,
+                                       GError       **error);
+
+
+/*****************************************************************************/
+/* +CESQ response parser */
+
+gboolean mm_3gpp_parse_cesq_response (const gchar *response,
+                                      guint *out_rxlev,
+                                      guint *out_ber,
+                                      guint *out_rscp,
+                                      guint *out_ecn0,
+                                      guint *out_rsrq,
+                                      guint *out_rsrp,
+                                      GError **error);
+
+/*****************************************************************************/
+/* %WMODE? response parser */
+
+gboolean mm_unitac_parse_wmode_response (const gchar *response,
+                                         GError **error,
+                                         GTask *task);
+
+/*****************************************************************************/
+/* +UBAND? response parser */
+
+typedef struct {
+    guint       num;
+    MMModemBand band;
+} UbandBandConfig;
+
+static const UbandBandConfig uband_band_config[] = {
+        /* LTE bands */
+        { .num =  3,  .band = MM_MODEM_BAND_EUTRAN_3  },
+        { .num =  7,  .band = MM_MODEM_BAND_EUTRAN_7  },
+        { .num =  20, .band = MM_MODEM_BAND_EUTRAN_20 },
+        { .num =  31, .band = MM_MODEM_BAND_EUTRAN_31 },
+        { .num =  72, .band = MM_MODEM_BAND_EUTRAN_72 },
+};
+
+GArray * mm_unitac_parse_uband_response (const gchar *response,
+                                         gpointer log_object,
+                                         GError **error);
+
+/*****************************************************************************/
+/* UIPADDR=N response parser */
+
+gboolean mm_ublox_parse_uipaddr_response (const gchar  *response,
+                                          guint        *out_cid,
+                                          gchar       **out_if_name,
+                                          gchar       **out_ipv4_address,
+                                          gchar       **out_ipv4_subnet,
+                                          gchar       **out_ipv6_global_address,
+                                          gchar       **out_ipv6_link_local_address,
+                                          GError      **error);
+
+
+#endif  /* MM_MODEM_HELPERS_UNITAC_H */
diff --git a/plugins/unitac/mm-sim-unitac.c b/plugins/unitac/mm-sim-unitac.c
new file mode 100644
index 0000000..2d4417d
--- /dev/null
+++ b/plugins/unitac/mm-sim-unitac.c
@@ -0,0 +1,165 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details:
+ *
+ * Copyright (C) 2021 Anubhav Gupta <anubhav.gupta@digi.com>
+ */
+
+#include <config.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <ctype.h>
+
+#include <ModemManager.h>
+#define _LIBMM_INSIDE_MM
+#include <libmm-glib.h>
+#include "mm-log.h"
+#include "mm-modem-helpers.h"
+#include "mm-base-modem-at.h"
+
+#include "mm-sim-unitac.h"
+
+G_DEFINE_TYPE (MMSimUnitac, mm_sim_unitac, MM_TYPE_BASE_SIM)
+
+/*****************************************************************************/
+/* SIM identifier loading */
+
+static gchar *
+load_sim_identifier_finish (MMBaseSim     *self,
+                            GAsyncResult  *res,
+                            GError       **error)
+{
+    return g_task_propagate_pointer (G_TASK (res), error);
+}
+
+static void
+parent_load_sim_identifier_ready (MMSimUnitac   *self,
+                                  GAsyncResult *res,
+                                  GTask        *task)
+{
+    GError *error = NULL;
+    gchar  *simid;
+
+    simid = MM_BASE_SIM_CLASS (mm_sim_unitac_parent_class)->load_sim_identifier_finish (MM_BASE_SIM (self), res, &error);
+    if (simid)
+        g_task_return_pointer (task, simid, g_free);
+    else
+        g_task_return_error (task, error);
+    g_object_unref (task);
+}
+
+static void
+giccid_ready (MMBaseModem  *modem,
+              GAsyncResult *res,
+              GTask        *task)
+{
+    MMBaseSim   *self;
+    const gchar *response;
+    gchar       *parsed;
+
+    self = g_task_get_source_object (task);
+    response = mm_base_modem_at_command_finish (modem, res, NULL);
+    if (!response)
+        goto error;
+
+    response = mm_strip_tag (response, "%GICCID:");
+    if (!response)
+        goto error;
+
+    parsed = mm_3gpp_parse_iccid (response, NULL);
+    if (parsed) {
+        mm_obj_dbg (self, "loaded SIM identifier: %s", parsed);
+        g_task_return_pointer (task, parsed, g_free);
+        g_object_unref (task);
+        return;
+    }
+
+    error:
+    /* Chain up to parent method to for devices that don't support +CCID properly */
+    MM_BASE_SIM_CLASS (mm_sim_unitac_parent_class)->load_sim_identifier (self,
+                                                                        (GAsyncReadyCallback) parent_load_sim_identifier_ready,
+                                                                        task);
+}
+
+static void
+load_sim_identifier (MMBaseSim           *self,
+                     GAsyncReadyCallback  callback,
+                     gpointer             user_data)
+{
+    MMBaseModem *modem = NULL;
+
+    mm_obj_dbg (self, "loading SIM identifier...");
+
+    g_object_get (self,
+                  MM_BASE_SIM_MODEM, &modem,
+                  NULL);
+    mm_base_modem_at_command (
+            modem,
+            "%GICCID",
+            5,
+            FALSE,
+            (GAsyncReadyCallback)giccid_ready,
+            g_task_new (self, NULL, callback, user_data));
+    g_object_unref (modem);
+}
+
+/*****************************************************************************/
+
+MMBaseSim *
+mm_sim_unitac_new_finish (GAsyncResult  *res,
+                         GError       **error)
+{
+    GObject *source;
+    GObject *sim;
+
+    source = g_async_result_get_source_object (res);
+    sim = g_async_initable_new_finish (G_ASYNC_INITABLE (source), res, error);
+    g_object_unref (source);
+
+    if (!sim)
+        return NULL;
+
+    /* Only export valid SIMs */
+    mm_base_sim_export (MM_BASE_SIM (sim));
+
+    return MM_BASE_SIM (sim);
+}
+
+void
+mm_sim_unitac_new (MMBaseModem         *modem,
+                  GCancellable         *cancellable,
+                  GAsyncReadyCallback  callback,
+                  gpointer             user_data)
+{
+    g_async_initable_new_async (MM_TYPE_SIM_UNITAC,
+                                G_PRIORITY_DEFAULT,
+                                cancellable,
+                                callback,
+                                user_data,
+                                MM_BASE_SIM_MODEM, modem,
+                                NULL);
+}
+
+static void
+mm_sim_unitac_init (MMSimUnitac *self)
+{
+}
+
+static void
+mm_sim_unitac_class_init (MMSimUnitacClass *klass)
+{
+    MMBaseSimClass *base_sim_class = MM_BASE_SIM_CLASS (klass);
+
+    base_sim_class->load_sim_identifier = load_sim_identifier;
+    base_sim_class->load_sim_identifier_finish = load_sim_identifier_finish;
+}
diff --git a/plugins/unitac/mm-sim-unitac.h b/plugins/unitac/mm-sim-unitac.h
new file mode 100644
index 0000000..6f119df
--- /dev/null
+++ b/plugins/unitac/mm-sim-unitac.h
@@ -0,0 +1,51 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details:
+ *
+ * Copyright (C) 2021 Anubhav Gupta <anubhav.gupta@digi.com>
+ */
+
+#ifndef MM_SIM_UNITAC_H
+#define MM_SIM_UNITAC_H
+
+#include <glib.h>
+#include <glib-object.h>
+
+#include "mm-base-sim.h"
+
+#define MM_TYPE_SIM_UNITAC            (mm_sim_unitac_get_type ())
+#define MM_SIM_UNITAC(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), MM_TYPE_SIM_UNITAC, MMSimUnitac))
+#define MM_SIM_UNITAC_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass),  MM_TYPE_SIM_UNITAC, MMSimUnitacClass))
+#define MM_IS_SIM_UNITAC(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MM_TYPE_SIM_UNITAC))
+#define MM_IS_SIM_UNITAC_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass),  MM_TYPE_SIM_UNITAC))
+#define MM_SIM_UNITAC_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj),  MM_TYPE_SIM_UNITAC, MMSimUnitacClass))
+
+typedef struct _MMSimUnitac MMSimUnitac;
+typedef struct _MMSimUnitacClass MMSimUnitacClass;
+
+struct _MMSimUnitac {
+    MMBaseSim parent;
+};
+
+struct _MMSimUnitacClass {
+    MMBaseSimClass parent;
+};
+
+GType mm_sim_unitac_get_type (void);
+
+void       mm_sim_unitac_new        (MMBaseModem         *modem,
+                                    GCancellable         *cancellable,
+                                    GAsyncReadyCallback  callback,
+                                    gpointer             user_data);
+MMBaseSim *mm_sim_unitac_new_finish (GAsyncResult        *res,
+                                    GError               **error);
+
+#endif /* MM_SIM_UNITAC_H */
-- 
2.7.4


From 25b2ad0b7742e15993205d37021c23efd075acb6 Mon Sep 17 00:00:00 2001
From: UnitacSW <unitacsw@unitac.cn>
Date: Tue, 3 Aug 2021 00:50:24 -0700
Subject: [PATCH 3/7] 1.Deleted some code that was not called.

---
 configure.ac                               |  4 +-
 plugins/Makefile.am                        | 98 +++++++++++++++---------------
 plugins/unitac/mm-broadband-modem-unitac.c |  4 +-
 plugins/unitac/mm-modem-helpers-unitac.h   | 13 +---
 plugins/unitac/mm-plugin-unitac.c          | 38 ++----------
 5 files changed, 61 insertions(+), 96 deletions(-)

diff --git a/configure.ac b/configure.ac
index d6badda..802b9f3 100644
--- a/configure.ac
+++ b/configure.ac
@@ -502,12 +502,12 @@ MM_ENABLE_PLUGIN([telit],
 MM_ENABLE_PLUGIN([thuraya])
 MM_ENABLE_PLUGIN([tplink])
 MM_ENABLE_PLUGIN([ublox])
+MM_ENABLE_PLUGIN([unitac])
 MM_ENABLE_PLUGIN([via])
 MM_ENABLE_PLUGIN([wavecom])
 MM_ENABLE_PLUGIN([x22x])
 MM_ENABLE_PLUGIN([zte],
                  [with_shared_icera])
-MM_ENABLE_PLUGIN([unitac])
 
 MM_BUILD_SHARED([icera])
 MM_BUILD_SHARED([sierra])
@@ -633,11 +633,11 @@ echo "
       thuraya:                 ${enable_plugin_thuraya}
       tplink:                  ${enable_plugin_tplink}
       ublox:                   ${enable_plugin_ublox}
+      unitac:                  ${enable_plugin_unitac}
       via:                     ${enable_plugin_via}
       wavecom:                 ${enable_plugin_wavecom}
       x22x:                    ${enable_plugin_x22x}
       zte:                     ${enable_plugin_zte}
-      unitac:                  ${enable_plugin_unitac}
 
     Miscellaneous:
       gobject introspection:   ${found_introspection}
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 5a28819..d937036 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -1488,6 +1488,55 @@ libmm_plugin_ublox_la_LIBADD = $(builddir)/libhelpers-ublox.la
 endif
 
 ################################################################################
+# plugin: unitac
+################################################################################
+
+if ENABLE_PLUGIN_UNITAC
+
+dist_udevrules_DATA += unitac/77-mm-unitac-port-types.rules
+
+PLUGIN_UNITAC_COMPILER_FLAGS = \
+	-I$(top_srcdir)/plugins/unitac \
+	-I$(top_builddir)/plugins/unitac \
+	$(NULL)
+
+noinst_LTLIBRARIES += libhelpers-unitac.la
+
+libhelpers_unitac_la_SOURCES = \
+	unitac/mm-modem-helpers-unitac.c \
+	unitac/mm-modem-helpers-unitac.h \
+	$(NULL)
+
+libhelpers_unitac_la_CPPFLAGS = \
+	$(PLUGIN_UNITAC_COMPILER_FLAGS) \
+	-DMM_MODULE_NAME=\"unitac\" \
+	$(NULL)
+
+pkglib_LTLIBRARIES += libmm-plugin-unitac.la
+
+libmm_plugin_unitac_la_SOURCES = \
+	unitac/mm-plugin-unitac.c \
+	unitac/mm-plugin-unitac.h \
+	unitac/mm-broadband-bearer-unitac.c \
+	unitac/mm-broadband-bearer-unitac.h \
+	unitac/mm-broadband-modem-unitac.c \
+	unitac/mm-broadband-modem-unitac.h \
+	unitac/mm-sim-unitac.c \
+	unitac/mm-sim-unitac.h \
+	$(NULL)
+
+libmm_plugin_unitac_la_CPPFLAGS = \
+	$(PLUGIN_COMMON_COMPILER_FLAGS) \
+	$(PLUGIN_UNITAC_COMPILER_FLAGS) \
+	-DMM_MODULE_NAME=\"unitac\" \
+	$(NULL)
+
+libmm_plugin_unitac_la_LDFLAGS = $(PLUGIN_COMMON_LINKER_FLAGS)
+libmm_plugin_unitac_la_LIBADD = $(builddir)/libhelpers-unitac.la
+
+endif
+
+################################################################################
 # plugin: via
 ################################################################################
 
@@ -1585,55 +1634,6 @@ AM_CFLAGS += -DTESTUDEVRULESDIR_ZTE=\"${srcdir}/zte\"
 endif
 
 ################################################################################
-# plugin: unitac
-################################################################################
-
-if ENABLE_PLUGIN_UNITAC
-
-dist_udevrules_DATA += unitac/77-mm-unitac-port-types.rules
-
-PLUGIN_UNITAC_COMPILER_FLAGS = \
-	-I$(top_srcdir)/plugins/unitac \
-	-I$(top_builddir)/plugins/unitac \
-	$(NULL)
-
-noinst_LTLIBRARIES += libhelpers-unitac.la
-
-libhelpers_unitac_la_SOURCES = \
-	unitac/mm-modem-helpers-unitac.c \
-	unitac/mm-modem-helpers-unitac.h \
-	$(NULL)
-
-libhelpers_unitac_la_CPPFLAGS = \
-	$(PLUGIN_UNITAC_COMPILER_FLAGS) \
-	-DMM_MODULE_NAME=\"unitac\" \
-	$(NULL)
-
-
-pkglib_LTLIBRARIES += libmm-plugin-unitac.la
-
-libmm_plugin_unitac_la_SOURCES = \
-	unitac/mm-plugin-unitac.c \
-	unitac/mm-plugin-unitac.h \
-	unitac/mm-broadband-bearer-unitac.c \
-	unitac/mm-broadband-bearer-unitac.h \
-	unitac/mm-broadband-modem-unitac.c  \
-	unitac/mm-broadband-modem-unitac.h  \
-	unitac/mm-sim-unitac.c \
-	unitac/mm-sim-unitac.h \
-	$(NULL)
-
-libmm_plugin_unitac_la_CPPFLAGS = \
-	$(PLUGIN_COMMON_COMPILER_FLAGS) \
-	$(PLUGIN_UNITAC_COMPILER_FLAGS) \
-	-DMM_MODULE_NAME=\"unitac\" \
-	$(NULL)
-libmm_plugin_unitac_la_LDFLAGS = $(PLUGIN_COMMON_LINKER_FLAGS)
-libmm_plugin_unitac_la_LIBADD = $(builddir)/libhelpers-unitac.la
-
-endif
-
-################################################################################
 # udev rules tester
 ################################################################################
 
diff --git a/plugins/unitac/mm-broadband-modem-unitac.c b/plugins/unitac/mm-broadband-modem-unitac.c
index af008bf..6dc52e2 100644
--- a/plugins/unitac/mm-broadband-modem-unitac.c
+++ b/plugins/unitac/mm-broadband-modem-unitac.c
@@ -11,6 +11,7 @@
  * GNU General Public License for more details:
  *
  * Copyright (C) 2021 Anubhav Gupta <anubhav.gupta@digi.com>
+ * Copyright (C) 2021 UnitacSW <UnitacSW@unitac.cn>
  */
 
 #include <config.h>
@@ -29,6 +30,7 @@
 #include "mm-broadband-bearer.h"
 #include "mm-broadband-modem-unitac.h"
 #include "mm-broadband-bearer-unitac.h"
+#include "mm-sim-unitac.h"
 #include "mm-iface-modem-signal.h"
 #include "mm-modem-helpers.h"
 #include "mm-modem-helpers-unitac.h"
@@ -38,7 +40,7 @@ static void iface_modem_signal_init (MMIfaceModemSignal *iface);
 
 G_DEFINE_TYPE_EXTENDED (MMBroadbandModemUnitac, mm_broadband_modem_unitac, MM_TYPE_BROADBAND_MODEM, 0,
                         G_IMPLEMENT_INTERFACE (MM_TYPE_IFACE_MODEM, iface_modem_init)
-                        G_IMPLEMENT_INTERFACE (MM_TYPE_IFACE_MODEM_SIGNAL, iface_modem_signal_init))
+                        G_IMPLEMENT_INTERFACE (MM_TYPE_IFACE_MODEM_SIGNAL, iface_modem_signal_init));
 
 
 /*****************************************************************************/
diff --git a/plugins/unitac/mm-modem-helpers-unitac.h b/plugins/unitac/mm-modem-helpers-unitac.h
index 45fa726..458f9fc 100644
--- a/plugins/unitac/mm-modem-helpers-unitac.h
+++ b/plugins/unitac/mm-modem-helpers-unitac.h
@@ -11,6 +11,7 @@
  * GNU General Public License for more details:
  *
  * Copyright (C) 2021 Anubhav Gupta <anubhav.gupta@digi.com>
+ * Copyright (C) 2021 UnitacSW <UnitacSW@unitac.cn>
  */
 
 #ifndef MM_MODEM_HELPERS_UNITAC_H
@@ -96,17 +97,7 @@ GArray * mm_unitac_parse_uband_response (const gchar *response,
                                          gpointer log_object,
                                          GError **error);
 
-/*****************************************************************************/
-/* UIPADDR=N response parser */
-
-gboolean mm_ublox_parse_uipaddr_response (const gchar  *response,
-                                          guint        *out_cid,
-                                          gchar       **out_if_name,
-                                          gchar       **out_ipv4_address,
-                                          gchar       **out_ipv4_subnet,
-                                          gchar       **out_ipv6_global_address,
-                                          gchar       **out_ipv6_link_local_address,
-                                          GError      **error);
+
 
 
 #endif  /* MM_MODEM_HELPERS_UNITAC_H */
diff --git a/plugins/unitac/mm-plugin-unitac.c b/plugins/unitac/mm-plugin-unitac.c
index 48b304e..f566ca3 100644
--- a/plugins/unitac/mm-plugin-unitac.c
+++ b/plugins/unitac/mm-plugin-unitac.c
@@ -11,35 +11,15 @@
  * GNU General Public License for more details:
  *
  * Copyright (C) 2021 Anubhav Gupta <anubhav.gupta@digi.com>
+ * Copyright (C) 2021 UnitacSW <UnitacSW@unitac.cn>
  */
 
 #include <string.h>
-#include <termios.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <stdio.h>
-#include <string.h>
-#include <stdlib.h>
-#include <getopt.h>
-#include <time.h>
-
 #include <gmodule.h>
 
-#define _LIBMM_INSIDE_MM
-#include <libmm-glib.h>
-
-#if defined WITH_QMI
-#include "mm-broadband-modem-qmi.h"
-#endif
-
-#if defined WITH_MBIM
-#include "mm-broadband-modem-mbim.h"
-#endif
-
 #include "mm-plugin-unitac.h"
-#include "mm-broadband-modem.h"
-#include "mm-serial-parsers.h"
-#include "mm-log-object.h"
+#include "mm-private-boxed-types.h"
+#include "mm-broadband-modem-unitac.h"
 
 G_DEFINE_TYPE (MMPluginUnitac, mm_plugin_unitac, MM_TYPE_PLUGIN)
 
@@ -65,15 +45,6 @@ create_modem (MMPlugin *self,
 }
 
 /*****************************************************************************/
-/* Custom init context */
-
-typedef struct {
-    MMPortSerialAt *port;
-    GRegex         *ready_regex;
-    guint           timeout_id;
-    gint            wait_timeout_secs;
-} CustomInitContext;
-
 
 G_MODULE_EXPORT MMPlugin *
 mm_plugin_create (void)
@@ -86,7 +57,7 @@ mm_plugin_create (void)
                       MM_PLUGIN_NAME,               MM_MODULE_NAME,
                       MM_PLUGIN_ALLOWED_SUBSYSTEMS, subsystems,
                       MM_PLUGIN_ALLOWED_VENDOR_IDS, vendor_ids,
-                      MM_PLUGIN_ALLOWED_AT,         TRUE,
+                      MM_PLUGIN_ALLOWED_SINGLE_AT,  TRUE,
                       MM_PLUGIN_ALLOWED_QCDM,       FALSE,
                       MM_PLUGIN_ALLOWED_QMI,        FALSE,
                       MM_PLUGIN_ALLOWED_MBIM,       FALSE,
@@ -105,3 +76,4 @@ mm_plugin_unitac_class_init (MMPluginUnitacClass *klass)
 
     plugin_class->create_modem = create_modem;
 }
+
-- 
2.7.4


From 2ca204367a72a7305cec0859d4915fd226d2a7f0 Mon Sep 17 00:00:00 2001
From: UnitacSW <unitacsw@unitac.cn>
Date: Tue, 3 Aug 2021 00:56:51 -0700
Subject: [PATCH 4/7] =?UTF-8?q?1.Add=20"unlock=20retries".=202.Add=20"mode?=
 =?UTF-8?q?m=20power=20down"=203.Get=20supported=20bands=20from=20AT!UBAND?=
 =?UTF-8?q?=3D=3F?=

---
 include/ModemManager-enums.h               |   1 +
 plugins/unitac/mm-broadband-modem-unitac.c | 145 +++++++++++++++++++++++++++++
 plugins/unitac/mm-modem-helpers-unitac.c   |  61 +++++++++++-
 plugins/unitac/mm-modem-helpers-unitac.h   |   1 +
 4 files changed, 207 insertions(+), 1 deletion(-)

diff --git a/include/ModemManager-enums.h b/include/ModemManager-enums.h
index 333ded6..566a35e 100644
--- a/include/ModemManager-enums.h
+++ b/include/ModemManager-enums.h
@@ -487,6 +487,7 @@ typedef enum { /*< underscore_name=mm_modem_band >*/
     MM_MODEM_BAND_EUTRAN_70 = 100,
     MM_MODEM_BAND_EUTRAN_71 = 101,
     MM_MODEM_BAND_EUTRAN_72 = 102,
+    MM_MODEM_BAND_EUTRAN_87 = 117,
     /* CDMA Band Classes (see 3GPP2 C.S0057-C) */
     MM_MODEM_BAND_CDMA_BC0  = 128,
     MM_MODEM_BAND_CDMA_BC1  = 129,
diff --git a/plugins/unitac/mm-broadband-modem-unitac.c b/plugins/unitac/mm-broadband-modem-unitac.c
index 6dc52e2..4b66a6b 100644
--- a/plugins/unitac/mm-broadband-modem-unitac.c
+++ b/plugins/unitac/mm-broadband-modem-unitac.c
@@ -42,6 +42,7 @@ G_DEFINE_TYPE_EXTENDED (MMBroadbandModemUnitac, mm_broadband_modem_unitac, MM_TY
                         G_IMPLEMENT_INTERFACE (MM_TYPE_IFACE_MODEM, iface_modem_init)
                         G_IMPLEMENT_INTERFACE (MM_TYPE_IFACE_MODEM_SIGNAL, iface_modem_signal_init));
 
+#define MM_UNITAC_GET_SUPPORTED_BANDS_FROM_AT
 
 /*****************************************************************************/
 /* Create Bearer (Modem interface) */
@@ -367,6 +368,7 @@ load_current_bands (MMIfaceModem *_self,
 
 /*****************************************************************************/
 /* Load supported bands (Modem interface) */
+#ifndef MM_UNITAC_GET_SUPPORTED_BANDS_FROM_AT
 typedef struct {
     const gchar *model;
     MMModemMode mode;
@@ -427,6 +429,7 @@ mm_unitac_get_supported_bands (const gchar *model,
 
     return bands;
 }
+#endif
 
 static GArray *
 load_supported_bands_finish (MMIfaceModem *self,
@@ -435,12 +438,57 @@ load_supported_bands_finish (MMIfaceModem *self,
 {
     return (GArray *) g_task_propagate_pointer (G_TASK (res), error);
 }
+#ifdef MM_UNITAC_GET_SUPPORTED_BANDS_FROM_AT
+static void
+load_supported_bands_ready (MMIfaceModem *self,
+                           GAsyncResult *res,
+                           GTask *task)
+{
+    GArray *bands = NULL;
+    const gchar *response = NULL;
+    GError *error = NULL;
+
+    response = mm_base_modem_at_command_finish (self, res, &error);
+    if (!response)
+        g_task_return_error (task, error);
+    else {
+	    /***************************
+         * AT!UBAND=?
+         * 
+         * !UBAND: (3-7-20-31)
+         * 
+         * OK
+         */
+        bands = mm_unitac_parse_supported_bands_response(response,&error);
+        if (!bands){
+            g_task_return_error (task, error);
+        }
+        else{
+            g_task_return_pointer (task, bands, (GDestroyNotify)g_array_unref);
+        }
+    }
+    g_object_unref (task);
+}
 
 static void
 load_supported_bands (MMIfaceModem *self,
                       GAsyncReadyCallback callback,
                       gpointer user_data)
 {
+    mm_base_modem_at_command (
+        MM_BASE_MODEM (self),
+        "!UBAND=?",
+        5,
+        FALSE,
+        (GAsyncReadyCallback)load_supported_bands_ready,
+        g_task_new (self, NULL, callback, user_data));
+}
+#else
+static void
+load_supported_bands (MMIfaceModem *self,
+                      GAsyncReadyCallback callback,
+                      gpointer user_data)
+{
     GTask       *task;
     GError      *error = NULL;
     GArray      *bands = NULL;
@@ -458,6 +506,98 @@ load_supported_bands (MMIfaceModem *self,
 
     g_object_unref (task);
 }
+#endif
+
+/*****************************************************************************/
+/* Modem power down (Modem interface) */
+
+static gboolean
+modem_power_down_finish (MMIfaceModem *self,
+                         GAsyncResult *res,
+                         GError **error)
+{
+    return !!mm_base_modem_at_command_finish (MM_BASE_MODEM (self), res, error);
+}
+
+static void
+modem_power_down (MMIfaceModem *self,
+                  GAsyncReadyCallback callback,
+                  gpointer user_data)
+{
+    mm_base_modem_at_command (MM_BASE_MODEM (self),
+                              "+CFUN=4",
+                              10,
+                              FALSE,
+                              callback,
+                              user_data);
+}
+
+/*****************************************************************************/
+/* Load unlock retries (Modem interface) */
+
+static MMUnlockRetries *
+load_unlock_retries_finish (MMIfaceModem *self,
+                            GAsyncResult *res,
+                            GError **error)
+{
+    return g_task_propagate_pointer (G_TASK (res), error);
+}
+
+static void
+load_unlock_retries_ready (MMBaseModem *self,
+                           GAsyncResult *res,
+                           GTask *task)
+{
+    const gchar *response;
+    GError *error = NULL;
+    gint pin1, pin2, puk1,  puk2;
+
+    response = mm_base_modem_at_command_finish (MM_BASE_MODEM (self), res, &error);
+    if (!response) {
+        g_task_return_error (task, error);
+        g_object_unref (task);
+        return;
+    }
+
+    /***************************
+     * AT+CPINC?
+     * 
+     * +CPINC: 3, 3, 10, 10
+     * 
+     * OK
+     */
+    response = mm_strip_tag (response, "+CPINC:");
+    if (sscanf (response, " %d, %d, %d, %d", &pin1, &pin2, &puk1,  &puk2) == 4) {
+        MMUnlockRetries *retries;
+        retries = mm_unlock_retries_new ();
+        mm_unlock_retries_set (retries, MM_MODEM_LOCK_SIM_PIN, pin1);
+        mm_unlock_retries_set (retries, MM_MODEM_LOCK_SIM_PUK, puk1);
+        mm_unlock_retries_set (retries, MM_MODEM_LOCK_SIM_PIN2, pin2);
+        mm_unlock_retries_set (retries, MM_MODEM_LOCK_SIM_PUK2, puk2);
+        g_task_return_pointer (task, retries, g_object_unref);
+    } else {
+        g_task_return_new_error (task,
+                                 MM_CORE_ERROR,
+                                 MM_CORE_ERROR_FAILED,
+                                 "Invalid unlock retries response: '%s'",
+                                 response);
+    }
+    g_object_unref (task);
+}
+
+static void
+load_unlock_retries (MMIfaceModem *self,
+                     GAsyncReadyCallback callback,
+                     gpointer user_data)
+{
+    mm_base_modem_at_command (
+        MM_BASE_MODEM (self),
+        "+CPINC?",
+        3,
+        FALSE,
+        (GAsyncReadyCallback)load_unlock_retries_ready,
+        g_task_new (self, NULL, callback, user_data));
+}
 
 /*****************************************************************************/
 /* Initializing the modem (during first enabling) */
@@ -543,6 +683,11 @@ iface_modem_init (MMIfaceModem *iface)
     iface->load_supported_bands_finish = load_supported_bands_finish;
     iface->load_current_bands          = load_current_bands;
     iface->load_current_bands_finish   = load_current_bands_finish;
+
+    iface->modem_power_down           = modem_power_down;
+    iface->modem_power_down_finish    = modem_power_down_finish;
+    iface->load_unlock_retries        = load_unlock_retries;
+    iface->load_unlock_retries_finish = load_unlock_retries_finish;
 }
 
 static void
diff --git a/plugins/unitac/mm-modem-helpers-unitac.c b/plugins/unitac/mm-modem-helpers-unitac.c
index cfb5f38..6b6973c 100644
--- a/plugins/unitac/mm-modem-helpers-unitac.c
+++ b/plugins/unitac/mm-modem-helpers-unitac.c
@@ -601,4 +601,63 @@ mm_unitac_parse_uband_response (const gchar *response,
                      "no known band selection values matched in !UBAND response: '%s'", response);
 
     return bands;
-}
\ No newline at end of file
+}
+
+GArray *
+mm_unitac_parse_supported_bands_response(const gchar *response,GError **error)
+{
+    GRegex     *regex      = NULL;
+    GMatchInfo *match_info = NULL;
+    gchar      *match_str  = NULL;
+    gchar      **split;
+    GArray     *bands      = NULL;
+    guint      i           = 0;
+    guint32     band_value = 0;
+    MMModemBand band       = 0;
+
+    static const gchar *load_regex = "\\!UBAND:\\s*\\(([0-9\\-]*)\\)";  //Eg: !UBAND: (31-20-3-7)
+    regex = g_regex_new (load_regex, G_REGEX_DOLLAR_ENDONLY | G_REGEX_RAW, 0, NULL);
+    g_assert (regex);
+
+    if (!g_regex_match (regex, response, 0, &match_info)) {
+        g_set_error (error, MM_CORE_ERROR, MM_CORE_ERROR_FAILED,
+                     "Could not parse response '%s'", response);
+        goto out;
+    }
+
+    if( g_match_info_matches (match_info) ){
+        match_str = g_match_info_fetch(match_info, 1);
+        if(match_str){
+            split = g_strsplit_set (match_str, "-", -1);
+            if (!split){
+                g_free(match_str);
+                goto out;
+            }
+            else if( 0 == split[0] ){
+                g_strfreev(split);
+                g_free(match_str);
+                g_set_error (error, MM_CORE_ERROR, MM_CORE_ERROR_FAILED,
+                             "Could not split values in matchs");
+                goto out;
+            }
+            bands = g_array_sized_new (FALSE, FALSE, sizeof (MMModemBand), g_strv_length(split));
+            for (i = 0; split[i]; i++) {
+                band_value = (guint32)strtoul (split[i], NULL, 10);
+                band = MM_MODEM_BAND_EUTRAN_1 - 1 + band_value;
+                if (band >= MM_MODEM_BAND_EUTRAN_1 && band <= MM_MODEM_BAND_EUTRAN_71){
+                    g_array_append_val(bands, band);
+               }
+            }
+            g_strfreev(split);
+            g_free(match_str);
+        }
+    }
+    else{
+        g_set_error (error, MM_CORE_ERROR, MM_CORE_ERROR_FAILED,
+                     "Could not find matches in response '%s'", response);
+    }
+out:
+    g_match_info_free(match_info);
+    g_regex_unref(regex);
+    return bands;
+}
diff --git a/plugins/unitac/mm-modem-helpers-unitac.h b/plugins/unitac/mm-modem-helpers-unitac.h
index 458f9fc..f45cd1e 100644
--- a/plugins/unitac/mm-modem-helpers-unitac.h
+++ b/plugins/unitac/mm-modem-helpers-unitac.h
@@ -97,6 +97,7 @@ GArray * mm_unitac_parse_uband_response (const gchar *response,
                                          gpointer log_object,
                                          GError **error);
 
+GArray * mm_unitac_parse_supported_bands_response(const gchar *response,GError **error);
 
 
 
-- 
2.7.4


From b2546dc4deb7b809511d6f6f717b54e0ba05b7cd Mon Sep 17 00:00:00 2001
From: Anubhav Gupta <anubhav.gupta@digi.com>
Date: Thu, 5 Aug 2021 13:52:53 -0400
Subject: [PATCH 5/7] Unitac: Expanded the plugin

1. Removed MM_UNITAC_GET_SUPPORTED_BANDS_FROM_AT flag and moved to single method to get supported bands using AT!UBAND=?
2. Changed the implementation to get RF information using AT!USTATUS instead of AT+CESQ
3. Added DIAL_3GPP_STEP_PDP_ACTIVATE (AT+CGACT=1,cid) step in dial_3gpp
---
 plugins/unitac/mm-broadband-bearer-unitac.c |  39 +++
 plugins/unitac/mm-broadband-modem-unitac.c  | 412 ++++++++++++++--------------
 plugins/unitac/mm-broadband-modem-unitac.h  |   6 +-
 plugins/unitac/mm-plugin-unitac.c           |   2 -
 4 files changed, 245 insertions(+), 214 deletions(-)

diff --git a/plugins/unitac/mm-broadband-bearer-unitac.c b/plugins/unitac/mm-broadband-bearer-unitac.c
index a4f8fd0..8c66d15 100644
--- a/plugins/unitac/mm-broadband-bearer-unitac.c
+++ b/plugins/unitac/mm-broadband-bearer-unitac.c
@@ -44,6 +44,7 @@ typedef enum {
     DIAL_3GPP_STEP_ENABLE_CEREG,
     DIAL_3GPP_STEP_PS_ATTACH,
     DIAL_3GPP_STEP_PS_ATTACH_QUERY,
+    DIAL_3GPP_STEP_PDP_ACTIVATE,
     DIAL_3GPP_STEP_CONNECT_QUERY,
     DIAL_3GPP_STEP_LAST
 } Dial3gppStep;
@@ -452,6 +453,27 @@ cgatt_query_ready (MMBaseModem  *modem,
 }
 
 static void
+cgact_set_ready (MMBaseModem  *modem,
+                 GAsyncResult *res,
+                 GTask        *task)
+{
+    CommonConnectContext *ctx;
+    GError               *error = NULL;
+
+    ctx = g_task_get_task_data (task);
+
+    if (!mm_base_modem_at_command_full_finish (modem, res, &error)) {
+        g_task_return_error (task, error);
+        g_object_unref (task);
+        return;
+    }
+
+    /* Go on */
+    ctx->step++;
+    dial_3gpp_context_step (task);
+}
+
+static void
 cgact_query_ready (MMBaseModem  *modem,
                    GAsyncResult *res,
                    GTask        *task)
@@ -751,6 +773,23 @@ dial_3gpp_context_step (GTask *task)
                                           task);
             return;
 
+        case DIAL_3GPP_STEP_PDP_ACTIVATE:
+        {
+            gchar *command;
+            command = g_strdup_printf("+CGACT=1,%d", ctx->cid);
+            mm_base_modem_at_command_full(MM_BASE_MODEM(ctx->modem),
+                                          ctx->primary,
+                                          command,
+                                          10,
+                                          FALSE,
+                                          FALSE, /* raw */
+                                          NULL, /* cancellable */
+                                          (GAsyncReadyCallback) cgact_set_ready,
+                                          task);
+            g_free(command);
+            return;
+        }
+
         case DIAL_3GPP_STEP_CONNECT_QUERY:
             mm_base_modem_at_command_full(MM_BASE_MODEM(ctx->modem),
                                           ctx->primary,
diff --git a/plugins/unitac/mm-broadband-modem-unitac.c b/plugins/unitac/mm-broadband-modem-unitac.c
index 4b66a6b..f48cfa2 100644
--- a/plugins/unitac/mm-broadband-modem-unitac.c
+++ b/plugins/unitac/mm-broadband-modem-unitac.c
@@ -34,15 +34,25 @@
 #include "mm-iface-modem-signal.h"
 #include "mm-modem-helpers.h"
 #include "mm-modem-helpers-unitac.h"
+#include "mm-sim-unitac.h"
 
 static void iface_modem_init (MMIfaceModem *iface);
 static void iface_modem_signal_init (MMIfaceModemSignal *iface);
 
+static MMIfaceModemSignal *iface_signal_parent;
+
 G_DEFINE_TYPE_EXTENDED (MMBroadbandModemUnitac, mm_broadband_modem_unitac, MM_TYPE_BROADBAND_MODEM, 0,
                         G_IMPLEMENT_INTERFACE (MM_TYPE_IFACE_MODEM, iface_modem_init)
                         G_IMPLEMENT_INTERFACE (MM_TYPE_IFACE_MODEM_SIGNAL, iface_modem_signal_init));
 
-#define MM_UNITAC_GET_SUPPORTED_BANDS_FROM_AT
+typedef struct {
+    MMSignal *lte;
+} DetailedSignal;
+
+
+struct _MMBroadbandModemUnitacPrivate {
+    DetailedSignal detailed_signal;
+};
 
 /*****************************************************************************/
 /* Create Bearer (Modem interface) */
@@ -106,109 +116,151 @@ broadband_bearer_unitac_new_ready (GObject *source,
 
 /*****************************************************************************/
 /* Load extended signal information (Signal interface) */
+static void
+detailed_signal_clear (DetailedSignal *signal)
+{
+    g_clear_object (&signal->lte);
+}
+
+static void
+detailed_signal_free (DetailedSignal *signal)
+{
+    detailed_signal_clear (signal);
+    g_slice_free (DetailedSignal, signal);
+}
+
+static gboolean
+signal_load_values_finish (MMIfaceModemSignal *self,
+                           GAsyncResult *res,
+                           MMSignal **cdma,
+                           MMSignal **evdo,
+                           MMSignal **gsm,
+                           MMSignal **umts,
+                           MMSignal **lte,
+                           GError **error)
+{
+    DetailedSignal *signals;
 
-gboolean
-mm_3gpp_cust_cesq_response_to_signal_info (const gchar *response,
-                                      gpointer log_object,
-                                      MMSignal **out_gsm,
-                                      MMSignal **out_umts,
-                                      MMSignal **out_lte,
-                                      GError **error)
-{
-    guint     rxlev = 0;
-    guint     ber = 0;
-    guint     rscp_level = 0;
-    guint     ecn0_level = 0;
-    guint     rsrq_level = 0;
-    guint     rsrp_level = 0;
-    gdouble   rssi = -G_MAXDOUBLE;
-    gdouble   rscp = -G_MAXDOUBLE;
-    gdouble   ecio = -G_MAXDOUBLE;
-    gdouble   rsrq = -G_MAXDOUBLE;
-    gdouble   rsrp = -G_MAXDOUBLE;
-    MMSignal  *gsm = NULL;
-    MMSignal  *umts = NULL;
-    MMSignal  *lte = NULL;
-
-    if (!mm_3gpp_parse_cesq_response (response,
-                                      &rxlev, &ber,
-                                      &rscp_level, &ecn0_level,
-                                      &rsrq_level, &rsrp_level,
-                                      error))
+    signals = g_task_propagate_pointer (G_TASK (res), error);
+    if (!signals)
         return FALSE;
 
-    /* GERAN RSSI */
-    if (mm_3gpp_rxlev_to_rssi (rxlev, log_object, &rssi)) {
-        gsm = mm_signal_new ();
-        mm_signal_set_rssi (gsm, rssi);
-    }
+    *lte  = signals->lte ? g_object_ref (signals->lte) : NULL;
 
-    /* ignore BER */
+    detailed_signal_free (signals);
+    return TRUE;
+}
 
-    /* UMTS RSCP */
-    if (mm_3gpp_rscp_level_to_rscp (rscp_level, log_object, &rscp)) {
-        umts = mm_signal_new ();
-        mm_signal_set_rscp (umts, rscp);
+static gboolean
+get_gutatus_field(MMBroadbandModemUnitac *self, const gchar *response, const gchar *keyword, gdouble *value)
+{
+    GRegex *r;
+    GMatchInfo *match_info = NULL;
+    GError *match_error = NULL;
+    gchar regex[256];
+    gboolean ret = FALSE;
+
+    sprintf (regex, "%s:(-?\\d+)", keyword);
+
+    r = g_regex_new (regex, 0, 0, NULL);
+    g_assert (r != NULL);
+
+    g_regex_match_full (r, response, strlen (response), 0, 0, &match_info, &match_error);
+    if (match_error) {
+        mm_obj_dbg(self, "%s: USTATUS match error %s", __func__, match_error->message);
+        g_error_free(match_error);
+        goto done;
     }
 
-    /* UMTS EcIo (assumed EcN0) */
-    if (mm_3gpp_ecn0_level_to_ecio (ecn0_level, log_object, &ecio)) {
-        if (!umts)
-            umts = mm_signal_new ();
-        mm_signal_set_ecio (umts, ecio);
+    if (!g_match_info_matches (match_info)) {
+        mm_obj_dbg (self, "USTATUS %s Couldn't get value", __func__);
+        goto done;
     }
 
-    /* LTE RSRQ */
-    if (mm_3gpp_rsrq_level_to_rsrq (rsrq_level, log_object, &rsrq)) {
-        lte = mm_signal_new ();
-        mm_signal_set_rsrq (lte, rsrq);
+    if (!mm_get_double_from_match_info(match_info, 1, value)) {
+        mm_obj_dbg(self, "Could not get USTATUS keyword (%s)", keyword);
+        goto done;
     }
 
-    /* LTE RSRP */
-    if (mm_3gpp_rsrp_level_to_rsrp (rsrp_level, log_object, &rsrp)) {
-        if (!lte)
-            lte = mm_signal_new ();
-        mm_signal_set_rsrp (lte, rsrp);
+    mm_obj_dbg (self, "Got USTATUS keyword [%s] = [%f]", keyword, *value);
+    ret = TRUE;
+
+    done:
+    if (match_info)
+        g_match_info_free (match_info);
+    g_regex_unref (r);
+    return ret;
+}
+
+static void update_lte_signal(const gchar *response, MMBroadbandModemUnitac *self)
+{
+    gdouble value;
+
+    self->priv->detailed_signal.lte = mm_signal_new ();
+    if (get_gutatus_field(self, response, "RSSI",  &value)) {
+        mm_signal_set_rssi (self->priv->detailed_signal.lte, value);
     }
+    if (get_gutatus_field(self, response, "RSRP",  &value)) {
+        mm_signal_set_rsrp (self->priv->detailed_signal.lte, value);
+    }
+    if (get_gutatus_field(self, response, "RSRQ",  &value)) {
+        mm_signal_set_rsrq (self->priv->detailed_signal.lte, value);
+    }
+    if (get_gutatus_field(self, response, "SINR",  &value)) {
+        mm_signal_set_sinr (self->priv->detailed_signal.lte, value);
+    }
+}
 
-    if (!gsm && !umts && !lte) {
-        g_set_error (error, MM_CORE_ERROR, MM_CORE_ERROR_FAILED,
-                     "couldn't build detailed signal info");
-        return FALSE;
+static void
+ustatus_ready (MMBaseModem *_self,
+               GAsyncResult *res,
+               GTask *task)
+{
+    MMBroadbandModemUnitac *self = MM_BROADBAND_MODEM_UNITAC (_self);
+    DetailedSignal *signals;
+    const gchar *response;
+    GError *error = NULL;
+
+    mm_obj_dbg (self, "USTATUS ustatus_ready");
+
+    response = mm_base_modem_at_command_finish (_self, res, &error);
+    if (error || !response) {
+        mm_obj_dbg (self, "!USTATUS failed: %s", error->message);
+        g_task_return_error (task, error);
+        g_object_unref (task);
+        return;
     }
+    /* The modems from Unitac we support only do 4G */
+    update_lte_signal(response, self);
 
-    if (gsm)
-        *out_gsm = gsm;
-    if (umts)
-        *out_umts = umts;
-    if (lte)
-        *out_lte = lte;
+    signals = g_slice_new0 (DetailedSignal);
+    signals->lte = self->priv->detailed_signal.lte ? g_object_ref (self->priv->detailed_signal.lte) : NULL;
 
-    return TRUE;
+    g_task_return_pointer (task, signals, (GDestroyNotify)detailed_signal_free);
+    g_object_unref (task);
 }
 
-static gboolean
-modem_signal_load_values_finish (MMIfaceModemSignal *self,
-                                 GAsyncResult *res,
-                                 MMSignal **cdma,
-                                 MMSignal **evdo,
-                                 MMSignal **gsm,
-                                 MMSignal **umts,
-                                 MMSignal **lte,
-                                 GError **error)
+
+static void
+signal_load_values (MMIfaceModemSignal *_self,
+                    GCancellable *cancellable,
+                    GAsyncReadyCallback callback,
+                    gpointer user_data)
 {
-    const gchar *response;
+    MMBroadbandModemUnitac *self      = MM_BROADBAND_MODEM_UNITAC (_self);
+    GTask *task;
 
-    response = mm_base_modem_at_command_finish (MM_BASE_MODEM (self), res, error);
-    if (!response || !mm_3gpp_cust_cesq_response_to_signal_info (response, self, gsm, umts, lte, error))
-        return FALSE;
+    task = g_task_new (self, cancellable, callback, user_data);
 
-    /* No 3GPP2 support */
-    if (cdma)
-        *cdma = NULL;
-    if (evdo)
-        *evdo = NULL;
-    return TRUE;
+    /* Clear any previous detailed signal values to get new ones */
+    detailed_signal_clear (&self->priv->detailed_signal);
+
+    mm_base_modem_at_command (MM_BASE_MODEM (self),
+                              "!USTATUS",
+                              20,
+                              FALSE,
+                              (GAsyncReadyCallback)ustatus_ready,
+                              task);
 }
 
 /*****************************************************************************/
@@ -248,40 +300,40 @@ create_bearer_step (GTask *task)
     ctx  = g_task_get_task_data (task);
 
     switch (ctx->step) {
-    case CREATE_BEARER_STEP_FIRST:
-        ctx->step++;
-        /* fall through */
-
-    case CREATE_BEARER_STEP_CHECK_PROFILE:
-        mm_obj_dbg (self, "checking current WMODE...");
-        mm_base_modem_at_command (
-            MM_BASE_MODEM (self),
-            "%WMODE?",
-            5,
-            FALSE,
-            (GAsyncReadyCallback) wmode_check_ready,
-            task);
-        return;
-
-    case CREATE_BEARER_STEP_CREATE_BEARER:
-        /* we'll create a unitac bearer */
-        mm_obj_dbg (self, "creating unitac broadband bearer...");
-        mm_broadband_bearer_unitac_new (
-            MM_BROADBAND_MODEM (self),
-            ctx->properties,
-            NULL, /* cancellable */
-            (GAsyncReadyCallback) broadband_bearer_unitac_new_ready,
-            task);
-        return;
-
-    case CREATE_BEARER_STEP_LAST:
-        g_assert (ctx->bearer);
-        g_task_return_pointer (task, g_object_ref (ctx->bearer), g_object_unref);
-        g_object_unref (task);
-        return;
-
-    default:
-        g_assert_not_reached ();
+        case CREATE_BEARER_STEP_FIRST:
+            ctx->step++;
+            /* fall through */
+
+        case CREATE_BEARER_STEP_CHECK_PROFILE:
+            mm_obj_dbg (self, "checking current WMODE...");
+            mm_base_modem_at_command (
+                    MM_BASE_MODEM (self),
+                    "%WMODE?",
+                    5,
+                    FALSE,
+                    (GAsyncReadyCallback) wmode_check_ready,
+                    task);
+            return;
+
+        case CREATE_BEARER_STEP_CREATE_BEARER:
+            /* we'll create a unitac bearer */
+            mm_obj_dbg (self, "creating unitac broadband bearer...");
+            mm_broadband_bearer_unitac_new (
+                    MM_BROADBAND_MODEM (self),
+                    ctx->properties,
+                    NULL, /* cancellable */
+                    (GAsyncReadyCallback) broadband_bearer_unitac_new_ready,
+                    task);
+            return;
+
+        case CREATE_BEARER_STEP_LAST:
+            g_assert (ctx->bearer);
+            g_task_return_pointer (task, g_object_ref (ctx->bearer), g_object_unref);
+            g_object_unref (task);
+            return;
+
+        default:
+            g_assert_not_reached ();
     }
 
     g_assert_not_reached ();
@@ -368,68 +420,6 @@ load_current_bands (MMIfaceModem *_self,
 
 /*****************************************************************************/
 /* Load supported bands (Modem interface) */
-#ifndef MM_UNITAC_GET_SUPPORTED_BANDS_FROM_AT
-typedef struct {
-    const gchar *model;
-    MMModemMode mode;
-    MMModemBand bands_4g[12];
-} BandConfiguration;
-
-static const BandConfiguration band_configuration[] = {
-        {
-                .model    = "ML660PG",
-                .mode     = MM_MODEM_MODE_4G,
-                .bands_4g = { MM_MODEM_BAND_EUTRAN_3, MM_MODEM_BAND_EUTRAN_20, MM_MODEM_BAND_EUTRAN_31,
-                              MM_MODEM_BAND_EUTRAN_72 }
-        },
-        {
-                .model    = "ML620EU",
-                .mode     = MM_MODEM_MODE_4G,
-                .bands_4g = { MM_MODEM_BAND_EUTRAN_3, MM_MODEM_BAND_EUTRAN_7, MM_MODEM_BAND_EUTRAN_20,
-                              MM_MODEM_BAND_EUTRAN_31, MM_MODEM_BAND_EUTRAN_72 }
-        },
-};
-
-GArray *
-mm_unitac_get_supported_bands (const gchar *model,
-                               gpointer log_object,
-                               GError **error)
-{
-    MMModemMode mode;
-    GArray      *bands;
-    guint       i, j;
-
-    bands = g_array_new (FALSE, FALSE, sizeof (MMModemBand));
-    for (i = 0; i < G_N_ELEMENTS (band_configuration); i++) {
-        if (g_str_has_prefix (model, band_configuration[i].model)) {
-            mm_obj_dbg (log_object, "known supported bands found for model: %s", band_configuration[i].model);
-            break;
-        }
-    }
-
-    if (i == G_N_ELEMENTS (band_configuration)) {
-        mm_obj_warn (log_object, "unknown model name given when looking for supported bands: %s", model);
-        return NULL;
-    }
-
-    mode = band_configuration[i].mode;
-
-    if (mode & MM_MODEM_MODE_4G) {
-        for (j = 0; j < G_N_ELEMENTS (band_configuration[i].bands_4g) && band_configuration[i].bands_4g[j]; j++) {
-            bands = g_array_append_val (bands, band_configuration[i].bands_4g[j]);
-        }
-    }
-
-    if (bands->len == 0) {
-        g_array_unref (bands);
-        g_set_error (error, MM_CORE_ERROR, MM_CORE_ERROR_FAILED,
-                     "no valid supported bands loaded");
-        return NULL;
-    }
-
-    return bands;
-}
-#endif
 
 static GArray *
 load_supported_bands_finish (MMIfaceModem *self,
@@ -438,7 +428,7 @@ load_supported_bands_finish (MMIfaceModem *self,
 {
     return (GArray *) g_task_propagate_pointer (G_TASK (res), error);
 }
-#ifdef MM_UNITAC_GET_SUPPORTED_BANDS_FROM_AT
+
 static void
 load_supported_bands_ready (MMIfaceModem *self,
                            GAsyncResult *res,
@@ -452,7 +442,7 @@ load_supported_bands_ready (MMIfaceModem *self,
     if (!response)
         g_task_return_error (task, error);
     else {
-	    /***************************
+        /***************************
          * AT!UBAND=?
          * 
          * !UBAND: (3-7-20-31)
@@ -483,30 +473,6 @@ load_supported_bands (MMIfaceModem *self,
         (GAsyncReadyCallback)load_supported_bands_ready,
         g_task_new (self, NULL, callback, user_data));
 }
-#else
-static void
-load_supported_bands (MMIfaceModem *self,
-                      GAsyncReadyCallback callback,
-                      gpointer user_data)
-{
-    GTask       *task;
-    GError      *error = NULL;
-    GArray      *bands = NULL;
-    const gchar *model;
-
-    mm_obj_dbg (self, "loading supported bands...");
-    model = mm_iface_modem_get_model (self);
-    task  = g_task_new (self, NULL, callback, user_data);
-
-    bands = mm_unitac_get_supported_bands (model, self, &error);
-    if (!bands)
-        g_task_return_error (task, error);
-    else
-        g_task_return_pointer(task, bands, (GDestroyNotify) g_array_unref);
-
-    g_object_unref (task);
-}
-#endif
 
 /*****************************************************************************/
 /* Modem power down (Modem interface) */
@@ -653,10 +619,10 @@ modem_create_sim (MMIfaceModem         *self,
 
 MMBroadbandModemUnitac *
 mm_broadband_modem_unitac_new (const gchar *device,
-                              const gchar **drivers,
-                              const gchar *plugin,
-                              guint16 vendor_id,
-                              guint16 product_id)
+                               const gchar **drivers,
+                               const gchar *plugin,
+                               guint16 vendor_id,
+                               guint16 product_id)
 {
     return g_object_new (MM_TYPE_BROADBAND_MODEM_UNITAC,
                          MM_BASE_MODEM_DEVICE,     device,
@@ -670,6 +636,12 @@ mm_broadband_modem_unitac_new (const gchar *device,
 static void
 mm_broadband_modem_unitac_init (MMBroadbandModemUnitac *self)
 {
+    /* Initialize private data */
+    self->priv = G_TYPE_INSTANCE_GET_PRIVATE (self,
+                                              MM_TYPE_BROADBAND_MODEM_UNITAC,
+                                              MMBroadbandModemUnitacPrivate);
+
+
 }
 
 static void
@@ -693,14 +665,32 @@ iface_modem_init (MMIfaceModem *iface)
 static void
 iface_modem_signal_init (MMIfaceModemSignal *iface)
 {
-    iface->load_values_finish = modem_signal_load_values_finish;
+    iface_signal_parent = g_type_interface_peek_parent (iface);
+    iface->load_values = signal_load_values;
+    iface->load_values_finish = signal_load_values_finish;
+}
+
+static void
+dispose (GObject *object)
+{
+    MMBroadbandModemUnitac *self = MM_BROADBAND_MODEM_UNITAC (object);
+
+    detailed_signal_clear (&self->priv->detailed_signal);
+
+    G_OBJECT_CLASS (mm_broadband_modem_unitac_parent_class)->dispose (object);
 }
 
 static void
 mm_broadband_modem_unitac_class_init (MMBroadbandModemUnitacClass *klass)
 {
+    GObjectClass *object_class = G_OBJECT_CLASS (klass);
     MMBroadbandModemClass *broadband_modem_class = MM_BROADBAND_MODEM_CLASS (klass);
 
+    g_type_class_add_private (object_class, sizeof (MMBroadbandModemUnitacPrivate));
+
     broadband_modem_class->enabling_modem_init        = enabling_modem_init;
     broadband_modem_class->enabling_modem_init_finish = enabling_modem_init_finish;
-}
+
+    object_class->dispose = dispose;
+
+}
\ No newline at end of file
diff --git a/plugins/unitac/mm-broadband-modem-unitac.h b/plugins/unitac/mm-broadband-modem-unitac.h
index 6718fd4..ddd215f 100644
--- a/plugins/unitac/mm-broadband-modem-unitac.h
+++ b/plugins/unitac/mm-broadband-modem-unitac.h
@@ -27,9 +27,13 @@
 
 typedef struct _MMBroadbandModemUnitac MMBroadbandModemUnitac;
 typedef struct _MMBroadbandModemUnitacClass MMBroadbandModemUnitacClass;
+typedef struct _MMBroadbandModemUnitacPrivate MMBroadbandModemUnitacPrivate;
+
+
 
 struct _MMBroadbandModemUnitac {
     MMBroadbandModem parent;
+    MMBroadbandModemUnitacPrivate *priv;
 };
 
 struct _MMBroadbandModemUnitacClass{
@@ -44,4 +48,4 @@ MMBroadbandModemUnitac *mm_broadband_modem_unitac_new (const gchar *device,
                                                        guint16 vendor_id,
                                                        guint16 product_id);
 
-#endif /* MM_BROADBAND_MODEM_UNITAC_H */
+#endif /* MM_BROADBAND_MODEM_UNITAC_H */
\ No newline at end of file
diff --git a/plugins/unitac/mm-plugin-unitac.c b/plugins/unitac/mm-plugin-unitac.c
index f566ca3..447de4c 100644
--- a/plugins/unitac/mm-plugin-unitac.c
+++ b/plugins/unitac/mm-plugin-unitac.c
@@ -44,8 +44,6 @@ create_modem (MMPlugin *self,
                                                          product));
 }
 
-/*****************************************************************************/
-
 G_MODULE_EXPORT MMPlugin *
 mm_plugin_create (void)
 {
-- 
2.7.4


From c62e02b8ab95f7549d7615c0519f935a28c743d4 Mon Sep 17 00:00:00 2001
From: Anubhav Gupta <anubhav.gupta@digi.com>
Date: Fri, 6 Aug 2021 17:03:42 -0400
Subject: [PATCH 6/7] Unitac: Fixed wmode and bands

1. Fixed WMODE? where modem manager was not parsing it correctly and causing the modem manager to make a connection on a wrong mode.
2. Fixed supported bands, where it was missing BAND 72 and causing the current bands to also not show 72 in the list.
---
 plugins/unitac/mm-broadband-modem-unitac.c |  9 ++++++++-
 plugins/unitac/mm-modem-helpers-unitac.c   | 12 ++++++++----
 plugins/unitac/mm-modem-helpers-unitac.h   |  4 +++-
 3 files changed, 19 insertions(+), 6 deletions(-)

diff --git a/plugins/unitac/mm-broadband-modem-unitac.c b/plugins/unitac/mm-broadband-modem-unitac.c
index f48cfa2..785b713 100644
--- a/plugins/unitac/mm-broadband-modem-unitac.c
+++ b/plugins/unitac/mm-broadband-modem-unitac.c
@@ -279,7 +279,14 @@ wmode_check_ready (MMBaseModem *_self,
     ctx = g_task_get_task_data (task);
 
     response = mm_base_modem_at_command_finish (_self, res, &error);
-    if (!response && !mm_unitac_parse_wmode_response (response, &error, task)) {
+    if (error || !response) {
+        mm_obj_dbg (self, "%WMODE failed: %s", error->message);
+        g_task_return_error (task, error);
+        g_object_unref (task);
+        return;
+    }
+
+    if (!mm_unitac_parse_wmode_response (response, &error, self, task)) {
         mm_obj_dbg (self, "couldn't load wmode: %s", error->message);
         g_task_return_error (task, error);
         g_object_unref (task);
diff --git a/plugins/unitac/mm-modem-helpers-unitac.c b/plugins/unitac/mm-modem-helpers-unitac.c
index 6b6973c..5eb42fc 100644
--- a/plugins/unitac/mm-modem-helpers-unitac.c
+++ b/plugins/unitac/mm-modem-helpers-unitac.c
@@ -482,6 +482,7 @@ mm_3gpp_parse_cesq_response (const gchar *response,
 gboolean
 mm_unitac_parse_wmode_response (const gchar *response,
                                 GError **error,
+                                gpointer log,
                                 GTask *task)
 {
     GRegex                 *r;
@@ -491,7 +492,7 @@ mm_unitac_parse_wmode_response (const gchar *response,
     /* Response may be e.g.:
      * response: 'MODE: bridge-ecm'
      */
-    r = g_regex_new ("^MODE: \\w+.*$", 0, 0, NULL);
+    r = g_regex_new ("MODE: (\\w+.*)", 0, 0, NULL);
     g_assert (r != NULL);
 
     g_regex_match_full (r, response, strlen (response), 0, 0, &match_info, &inner_error);
@@ -500,8 +501,9 @@ mm_unitac_parse_wmode_response (const gchar *response,
 
         wmode = mm_get_string_unquoted_from_match_info (match_info, 1);
         if (wmode) {
+            mm_obj_dbg (log, "WMODE mode: %s", wmode);
             if (!g_str_equal (wmode, "bridge-ecm"))
-                inner_error = g_error_new(MM_CORE_ERROR, MM_CORE_ERROR_FAILED, "unknown wmode for the modem...");
+                inner_error = g_error_new(MM_CORE_ERROR, MM_CORE_ERROR_FAILED, "wrong wmode for the modem...");
         } else
             inner_error = g_error_new(MM_CORE_ERROR, MM_CORE_ERROR_FAILED, "unable to parse wmode for the modem...");
 
@@ -531,6 +533,7 @@ uband_num_to_band (guint num)
         if (num == uband_band_config[i].num)
             return uband_band_config[i].band;
     }
+
     return MM_MODEM_BAND_UNKNOWN;
 }
 
@@ -557,7 +560,7 @@ uband_num_array_to_band_array (GArray *nums)
 
 GArray *
 mm_unitac_parse_uband_response (const gchar *response,
-                                gpointer log_object,
+                                gpointer log,
                                 GError **error)
 {
     GRegex     *r;
@@ -578,6 +581,7 @@ mm_unitac_parse_uband_response (const gchar *response,
     if (!inner_error && g_match_info_matches (match_info)) {
         gchar *bandstr;
         bandstr = mm_get_string_unquoted_from_match_info (match_info, 1);
+        mm_obj_dbg (log, "UBAND string: %s", bandstr);
         nums = mm_parse_uint_list (bandstr, &inner_error);
         g_free (bandstr);
     }
@@ -644,7 +648,7 @@ mm_unitac_parse_supported_bands_response(const gchar *response,GError **error)
             for (i = 0; split[i]; i++) {
                 band_value = (guint32)strtoul (split[i], NULL, 10);
                 band = MM_MODEM_BAND_EUTRAN_1 - 1 + band_value;
-                if (band >= MM_MODEM_BAND_EUTRAN_1 && band <= MM_MODEM_BAND_EUTRAN_71){
+                if (band >= MM_MODEM_BAND_EUTRAN_1 && band <= MM_MODEM_BAND_EUTRAN_72){
                     g_array_append_val(bands, band);
                }
             }
diff --git a/plugins/unitac/mm-modem-helpers-unitac.h b/plugins/unitac/mm-modem-helpers-unitac.h
index f45cd1e..61a020b 100644
--- a/plugins/unitac/mm-modem-helpers-unitac.h
+++ b/plugins/unitac/mm-modem-helpers-unitac.h
@@ -74,6 +74,7 @@ gboolean mm_3gpp_parse_cesq_response (const gchar *response,
 
 gboolean mm_unitac_parse_wmode_response (const gchar *response,
                                          GError **error,
+                                         gpointer log,
                                          GTask *task);
 
 /*****************************************************************************/
@@ -91,10 +92,11 @@ static const UbandBandConfig uband_band_config[] = {
         { .num =  20, .band = MM_MODEM_BAND_EUTRAN_20 },
         { .num =  31, .band = MM_MODEM_BAND_EUTRAN_31 },
         { .num =  72, .band = MM_MODEM_BAND_EUTRAN_72 },
+        { .num =  87, .band = MM_MODEM_BAND_EUTRAN_87 },
 };
 
 GArray * mm_unitac_parse_uband_response (const gchar *response,
-                                         gpointer log_object,
+                                         gpointer log,
                                          GError **error);
 
 GArray * mm_unitac_parse_supported_bands_response(const gchar *response,GError **error);
-- 
2.7.4


From d347093374d365cb56ffc81f434a12900fd92cab Mon Sep 17 00:00:00 2001
From: Anubhav Gupta <anubhav.gupta@digi.com>
Date: Wed, 29 Sep 2021 13:46:38 -0400
Subject: [PATCH 7/7] unitac: Changed dial_3gpp sequence

Modified the dial_3gpp sequence for Unitac modems to not issue %APNCONF as well as
to not detach from the network (+CGATT=0) before issuing attach (+CGATT=1). As per
Unitac, detach is only needed if context changes and that is now handled by the host
firmware.
---
 plugins/unitac/mm-broadband-bearer-unitac.c | 226 ----------------------------
 1 file changed, 226 deletions(-)

diff --git a/plugins/unitac/mm-broadband-bearer-unitac.c b/plugins/unitac/mm-broadband-bearer-unitac.c
index 8c66d15..3fb872a 100644
--- a/plugins/unitac/mm-broadband-bearer-unitac.c
+++ b/plugins/unitac/mm-broadband-bearer-unitac.c
@@ -38,13 +38,8 @@ static void dial_3gpp_context_step (GTask *task);
 
 typedef enum {
     DIAL_3GPP_STEP_FIRST,
-    DIAL_3GPP_STEP_AUTHENTICATE,
-    DIAL_3GPP_STEP_DISABLE_CEREG,
-    DIAL_3GPP_STEP_PS_DETACH,
-    DIAL_3GPP_STEP_ENABLE_CEREG,
     DIAL_3GPP_STEP_PS_ATTACH,
     DIAL_3GPP_STEP_PS_ATTACH_QUERY,
-    DIAL_3GPP_STEP_PDP_ACTIVATE,
     DIAL_3GPP_STEP_CONNECT_QUERY,
     DIAL_3GPP_STEP_LAST
 } Dial3gppStep;
@@ -453,27 +448,6 @@ cgatt_query_ready (MMBaseModem  *modem,
 }
 
 static void
-cgact_set_ready (MMBaseModem  *modem,
-                 GAsyncResult *res,
-                 GTask        *task)
-{
-    CommonConnectContext *ctx;
-    GError               *error = NULL;
-
-    ctx = g_task_get_task_data (task);
-
-    if (!mm_base_modem_at_command_full_finish (modem, res, &error)) {
-        g_task_return_error (task, error);
-        g_object_unref (task);
-        return;
-    }
-
-    /* Go on */
-    ctx->step++;
-    dial_3gpp_context_step (task);
-}
-
-static void
 cgact_query_ready (MMBaseModem  *modem,
                    GAsyncResult *res,
                    GTask        *task)
@@ -527,50 +501,6 @@ cgact_query_ready (MMBaseModem  *modem,
 }
 
 static void
-authenticate_ready (MMBaseModem  *modem,
-                    GAsyncResult *res,
-                    GTask        *task)
-{
-    CommonConnectContext *ctx;
-    GError *error = NULL;
-
-    ctx = g_task_get_task_data (task);
-
-    if (!mm_base_modem_at_command_full_finish (modem, res, &error)) {
-        g_task_return_error (task, error);
-        g_object_unref (task);
-        return;
-    }
-
-    /* Go on */
-    ctx->step++;
-    dial_3gpp_context_step (task);
-}
-
-static void
-cgatt_detach_ready (MMBaseModem  *modem,
-                    GAsyncResult *res,
-                    GTask        *task)
-{
-    CommonConnectContext *ctx;
-    GError               *error = NULL;
-
-    ctx = g_task_get_task_data (task);
-
-    if (!mm_base_modem_at_command_full_finish (modem, res, &error)) {
-        g_task_return_error (task, error);
-        g_object_unref (task);
-        return;
-    }
-
-    // Need 2-3 seconds delay after issuing +CGATT=0 before issuing +CGATT=1 as per Unitac
-    sleep(3);
-    /* Go on */
-    ctx->step++;
-    dial_3gpp_context_step (task);
-}
-
-static void
 cgatt_attach_ready (MMBaseModem  *modem,
                     GAsyncResult *res,
                     GTask        *task)
@@ -592,27 +522,6 @@ cgatt_attach_ready (MMBaseModem  *modem,
 }
 
 static void
-cereg_ready (MMBaseModem  *modem,
-             GAsyncResult *res,
-             GTask        *task)
-{
-    CommonConnectContext *ctx;
-    GError               *error = NULL;
-
-    ctx = g_task_get_task_data (task);
-
-    if (!mm_base_modem_at_command_full_finish (modem, res, &error)) {
-        g_task_return_error (task, error);
-        g_object_unref (task);
-        return;
-    }
-
-    /* Go on */
-    ctx->step++;
-    dial_3gpp_context_step (task);
-}
-
-static void
 dial_3gpp_context_step (GTask *task)
 {
     MMBroadbandBearerUnitac *self;
@@ -631,124 +540,6 @@ dial_3gpp_context_step (GTask *task)
             ctx->step++;
             /* fall through */
 
-        case DIAL_3GPP_STEP_AUTHENTICATE:
-            if (!MM_IS_PORT_SERIAL_AT (ctx->data)) {
-                gchar *command;
-                const gchar *user;
-                const gchar *password;
-                const gchar *apn = NULL;
-                MMBearerAllowedAuth allowed_auth;
-                MMBearerIpFamily ip_type;
-                guint type = 0;
-
-                apn            = mm_bearer_properties_get_apn (mm_base_bearer_peek_config (MM_BASE_BEARER (self)));
-                user           = mm_bearer_properties_get_user (mm_base_bearer_peek_config (MM_BASE_BEARER (self)));
-                password       = mm_bearer_properties_get_password (mm_base_bearer_peek_config (MM_BASE_BEARER (self)));
-                allowed_auth   = mm_bearer_properties_get_allowed_auth (mm_base_bearer_peek_config (MM_BASE_BEARER (self)));
-                ip_type        = mm_bearer_properties_get_ip_type(mm_base_bearer_peek_config(MM_BASE_BEARER(self)));
-
-                if (ip_type == MM_BEARER_IP_FAMILY_IPV4)
-                    type = 0;
-                else if (type == MM_BEARER_IP_FAMILY_IPV6)
-                    type = 1;
-                else
-                    type = 2;
-
-                if (!user || !password || allowed_auth == MM_BEARER_ALLOWED_AUTH_NONE) {
-                    mm_obj_dbg (self, "not using authentication");
-                    command = g_strdup_printf ("%%APNCONF=%d,1,%u,\"%s\",2,,", ctx->cid, type, apn);
-                } else {
-                    gchar *quoted_user;
-                    gchar *quoted_password;
-                    guint auth;
-
-                    if (allowed_auth == MM_BEARER_ALLOWED_AUTH_UNKNOWN) {
-                        mm_obj_dbg (self, "using default (PAP) authentication method");
-                        auth = 0;
-                    } else if (allowed_auth & MM_BEARER_ALLOWED_AUTH_PAP) {
-                        mm_obj_dbg (self, "using PAP authentication method");
-                        auth = 0;
-                    } else if (allowed_auth & MM_BEARER_ALLOWED_AUTH_CHAP) {
-                        mm_obj_dbg (self, "using CHAP authentication method");
-                        auth = 1;
-                    } else {
-                        gchar *str;
-
-                        str = mm_bearer_allowed_auth_build_string_from_mask (allowed_auth);
-                        g_task_return_new_error (
-                                task,
-                                MM_CORE_ERROR,
-                                MM_CORE_ERROR_UNSUPPORTED,
-                                "cannot use any of the specified authentication methods (%s)",
-                                str);
-                        g_free (str);
-                        g_object_unref (task);
-                        return;
-                    }
-
-                    quoted_user = mm_port_serial_at_quote_string (user);
-                    quoted_password = mm_port_serial_at_quote_string (password);
-                    command = g_strdup_printf ("%%APNCONF=%d,1,%u,\"%s\",%d,\"%s\",\"%s\"",
-                                               ctx->cid,
-                                               type,
-                                               apn,
-                                               auth,
-                                               quoted_user,
-                                               quoted_password);
-                    g_free (quoted_user);
-                    g_free (quoted_password);
-                }
-
-                mm_base_modem_at_command_full (MM_BASE_MODEM(ctx->modem),
-                                               ctx->primary,
-                                               command,
-                                               5,
-                                               FALSE,
-                                               FALSE, /* raw */
-                                               NULL, /* cancellable */
-                                               (GAsyncReadyCallback)authenticate_ready,
-                                               task);
-                g_free (command);
-                return;
-            }
-            return;
-
-        case DIAL_3GPP_STEP_DISABLE_CEREG:
-            mm_base_modem_at_command_full(MM_BASE_MODEM(ctx->modem),
-                                          ctx->primary,
-                                          "+CEREG=0",
-                                          10,
-                                          FALSE,
-                                          FALSE, /* raw */
-                                          NULL, /* cancellable */
-                                          (GAsyncReadyCallback) cereg_ready,
-                                          task);
-            return;
-
-        case DIAL_3GPP_STEP_PS_DETACH:
-            mm_base_modem_at_command_full(MM_BASE_MODEM(ctx->modem),
-                                          ctx->primary,
-                                          "+CGATT=0",
-                                          20,
-                                          FALSE,
-                                          FALSE, /* raw */
-                                          NULL, /* cancellable */
-                                          (GAsyncReadyCallback) cgatt_detach_ready,
-                                          task);
-            return;
-
-        case DIAL_3GPP_STEP_ENABLE_CEREG:
-            mm_base_modem_at_command_full(MM_BASE_MODEM(ctx->modem),
-                                          ctx->primary,
-                                          "+CEREG=2",
-                                          10,
-                                          FALSE,
-                                          FALSE, /* raw */
-                                          NULL, /* cancellable */
-                                          (GAsyncReadyCallback) cereg_ready,
-                                          task);
-            return;
-
         case DIAL_3GPP_STEP_PS_ATTACH:
             mm_base_modem_at_command_full (MM_BASE_MODEM(ctx->modem),
                                            ctx->primary,
@@ -773,23 +564,6 @@ dial_3gpp_context_step (GTask *task)
                                           task);
             return;
 
-        case DIAL_3GPP_STEP_PDP_ACTIVATE:
-        {
-            gchar *command;
-            command = g_strdup_printf("+CGACT=1,%d", ctx->cid);
-            mm_base_modem_at_command_full(MM_BASE_MODEM(ctx->modem),
-                                          ctx->primary,
-                                          command,
-                                          10,
-                                          FALSE,
-                                          FALSE, /* raw */
-                                          NULL, /* cancellable */
-                                          (GAsyncReadyCallback) cgact_set_ready,
-                                          task);
-            g_free(command);
-            return;
-        }
-
         case DIAL_3GPP_STEP_CONNECT_QUERY:
             mm_base_modem_at_command_full(MM_BASE_MODEM(ctx->modem),
                                           ctx->primary,
-- 
2.7.4

