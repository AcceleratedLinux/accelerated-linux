From 21568a118a2c0d14bdd36712a661b795ffbe570b Mon Sep 17 00:00:00 2001
From: Ming Liu-Chan <ming.liu-chan@digi.com>
Date: Wed, 27 Jul 2022 15:12:24 -0400
Subject: [PATCH] ModemManager SMS: UTF-16 charset

Patch ModemManager 1.14 to allow sending UTF-16
as if it were UCS-2 and increase send SMS timeout

DAL-6318
---
 src/mm-charsets.c      |  40 ++++++---
 src/mm-charsets.h      |   3 +-
 src/mm-sms-part-3gpp.c | 196 ++++++++++++++++++++++++-----------------
 src/mm-sms-qmi.c       |   4 +-
 4 files changed, 148 insertions(+), 95 deletions(-)

diff --git a/src/mm-charsets.c b/src/mm-charsets.c
index e48cec3e..b8afb4c1 100644
--- a/src/mm-charsets.c
+++ b/src/mm-charsets.c
@@ -43,6 +43,7 @@ static CharsetEntry charset_map[] = {
     { "PCCP437", "CP437",  "CP437",     "CP437//TRANSLIT",     MM_MODEM_CHARSET_PCCP437 },
     { "PCDN",    "CP850",  "CP850",     "CP850//TRANSLIT",     MM_MODEM_CHARSET_PCDN },
     { "HEX",     NULL,     NULL,        NULL,                  MM_MODEM_CHARSET_HEX },
+    { "UTF-16",  "UTF16",  "UTF-16BE",  "UTF-16BE",            MM_MODEM_CHARSET_UTF16 },
     { NULL,      NULL,     NULL,        NULL,                  MM_MODEM_CHARSET_UNKNOWN }
 };
 
@@ -408,7 +409,7 @@ guint8 *
 mm_charset_gsm_unpacked_to_utf8 (const guint8 *gsm, guint32 len)
 {
     guint i;
-    GByteArray *utf8;
+    GByteArray *utf8 = NULL;
 
     g_return_val_if_fail (gsm != NULL, NULL);
     g_return_val_if_fail (len < 4096, NULL);
@@ -466,8 +467,8 @@ mm_charset_gsm_unpacked_to_utf8 (const guint8 *gsm, guint32 len)
 guint8 *
 mm_charset_utf8_to_unpacked_gsm (const char *utf8, guint32 *out_len)
 {
-    GByteArray *gsm;
-    const char *c = utf8, *next = c;
+    GByteArray *gsm = NULL;
+    const char *c, *next;
     static const guint8 gesc = GSM_ESCAPE_CHAR;
     int i = 0;
 
@@ -485,6 +486,8 @@ mm_charset_utf8_to_unpacked_gsm (const char *utf8, guint32 *out_len)
         return g_byte_array_free (gsm, FALSE);
     }
 
+    next = utf8;
+    c    = utf8;
     while (next && *next) {
         guint8 gch = 0x3f;  /* 0x3f == '?' */
 
@@ -535,6 +538,14 @@ ucs2_is_subset (gunichar c, const char *utf8, gsize ulen)
     return (c <= 0xFFFF);
 }
 
+static gboolean
+utf16_is_subset (gunichar     c,
+                 const gchar *utf8,
+                 gsize        ulen)
+{
+    return TRUE;
+}
+
 static gboolean
 iso88591_is_subset (gunichar c, const char *utf8, gsize ulen)
 {
@@ -613,6 +624,7 @@ SubsetEntry subset_table[] = {
     { MM_MODEM_CHARSET_GSM,     gsm_is_subset },
     { MM_MODEM_CHARSET_IRA,     ira_is_subset },
     { MM_MODEM_CHARSET_UCS2,    ucs2_is_subset },
+    { MM_MODEM_CHARSET_UTF16,   utf16_is_subset },
     { MM_MODEM_CHARSET_8859_1,  iso88591_is_subset },
     { MM_MODEM_CHARSET_PCCP437, pccp437_is_subset },
     { MM_MODEM_CHARSET_PCDN,    pcdn_is_subset },
@@ -630,8 +642,8 @@ gboolean
 mm_charset_can_convert_to (const char *utf8,
                            MMModemCharset charset)
 {
-    const char *p = utf8;
-    SubsetEntry *e;
+    const char *p;
+	guint i;
 
     g_return_val_if_fail (charset != MM_MODEM_CHARSET_UNKNOWN, FALSE);
     g_return_val_if_fail (utf8 != NULL, FALSE);
@@ -640,11 +652,13 @@ mm_charset_can_convert_to (const char *utf8,
         return TRUE;
 
     /* Find the charset in our subset table */
-    for (e = &subset_table[0];
-         e->cs != charset && e->cs != MM_MODEM_CHARSET_UNKNOWN;
-         e++);
-    g_return_val_if_fail (e->cs != MM_MODEM_CHARSET_UNKNOWN, FALSE);
+    for (i = 0; i < G_N_ELEMENTS (subset_table); i++) {
+        if (subset_table[i].cs == charset)
+            break;
+    }
+    g_return_val_if_fail (i < G_N_ELEMENTS (subset_table), FALSE);
 
+    p = utf8;
     while (*p) {
         gunichar c;
         const char *end;
@@ -658,7 +672,7 @@ mm_charset_can_convert_to (const char *utf8,
             while (*++end);
         }
 
-        if (!e->func (c, p, (end - p)))
+        if (!subset_table[i].func (c, p, (end - p)))
             return FALSE;
 
         p = end;
@@ -786,7 +800,8 @@ mm_charset_take_and_convert_to_utf8 (gchar *str, MMModemCharset charset)
         break;
     }
 
-    case MM_MODEM_CHARSET_UCS2: {
+    case MM_MODEM_CHARSET_UCS2:
+    case MM_MODEM_CHARSET_UTF16: {
         gsize len;
         gboolean possibly_hex = TRUE;
         gsize bread = 0, bwritten = 0;
@@ -914,7 +929,8 @@ mm_utf8_take_and_convert_to_charset (gchar *str,
         break;
     }
 
-    case MM_MODEM_CHARSET_UCS2: {
+    case MM_MODEM_CHARSET_UCS2:
+    case MM_MODEM_CHARSET_UTF16: {
         const gchar *iconv_to;
         gsize encoded_len = 0;
         GError *error = NULL;
diff --git a/src/mm-charsets.h b/src/mm-charsets.h
index 9e9215d5..e81674c4 100644
--- a/src/mm-charsets.h
+++ b/src/mm-charsets.h
@@ -27,7 +27,8 @@ typedef enum {
     MM_MODEM_CHARSET_UCS2    = 0x00000010,
     MM_MODEM_CHARSET_PCCP437 = 0x00000020,
     MM_MODEM_CHARSET_PCDN    = 0x00000040,
-    MM_MODEM_CHARSET_HEX     = 0x00000080
+    MM_MODEM_CHARSET_HEX     = 0x00000080,
+    MM_MODEM_CHARSET_UTF16   = 0x00000100,
 } MMModemCharset;
 
 const char *mm_modem_charset_to_string (MMModemCharset charset);
diff --git a/src/mm-sms-part-3gpp.c b/src/mm-sms-part-3gpp.c
index c4f6154f..7f73de23 100644
--- a/src/mm-sms-part-3gpp.c
+++ b/src/mm-sms-part-3gpp.c
@@ -247,10 +247,10 @@ sms_decode_text (const guint8 *text,
                  gpointer      log_object)
 {
     char *utf8;
-    guint8 *unpacked;
-    guint32 unpacked_len;
 
     if (encoding == MM_SMS_ENCODING_GSM7) {
+        guint8 *unpacked = NULL;
+        guint32 unpacked_len;
         mm_obj_dbg (log_object, "converting SMS part text from GSM-7 to UTF-8...");
         unpacked = mm_charset_gsm_unpack ((const guint8 *) text, len, bit_offset, &unpacked_len);
         utf8 = (char *) mm_charset_gsm_unpacked_to_utf8 (unpacked, unpacked_len);
@@ -829,6 +829,7 @@ mm_sms_part_3gpp_get_submit_pdu (MMSmsPart *part,
     guint len, offset = 0;
     guint shift = 0;
     guint8 *udl_ptr;
+    MMSmsEncoding encoding;
 
     g_return_val_if_fail (mm_sms_part_get_number (part) != NULL, NULL);
     g_return_val_if_fail (mm_sms_part_get_text (part) != NULL || mm_sms_part_get_data (part) != NULL, NULL);
@@ -923,7 +924,9 @@ mm_sms_part_3gpp_get_submit_pdu (MMSmsPart *part,
         pdu[offset] |= mm_sms_part_get_class (part);
     }
 
-    switch (mm_sms_part_get_encoding (part)) {
+    encoding = mm_sms_part_get_encoding (part);
+
+    switch (encoding) {
     case MM_SMS_ENCODING_UCS2:
         mm_obj_dbg (log_object, "  using UCS2 encoding...");
         pdu[offset] |= SMS_DCS_CODING_UCS2;
@@ -976,7 +979,7 @@ mm_sms_part_3gpp_get_submit_pdu (MMSmsPart *part,
         shift = 1;
     }
 
-    if (mm_sms_part_get_encoding (part) == MM_SMS_ENCODING_GSM7) {
+    if (encoding == MM_SMS_ENCODING_GSM7) {
         guint8 *unpacked, *packed;
         guint32 unlen = 0, packlen = 0;
 
@@ -1012,17 +1015,18 @@ mm_sms_part_3gpp_get_submit_pdu (MMSmsPart *part,
         memcpy (&pdu[offset], packed, packlen);
         g_free (packed);
         offset += packlen;
-    } else if (mm_sms_part_get_encoding (part) == MM_SMS_ENCODING_UCS2) {
+    } else if (encoding == MM_SMS_ENCODING_UCS2) {
         g_autoptr(GByteArray) array = NULL;
         g_autoptr(GError)     inner_error = NULL;
 
         /* Try to guess a good value for the array */
         array = g_byte_array_sized_new (strlen (mm_sms_part_get_text (part)) * 2);
-        if (!mm_modem_charset_byte_array_append (array, mm_sms_part_get_text (part), FALSE, MM_MODEM_CHARSET_UCS2, &inner_error)) {
+        /* Always assume UTF-16 instead of UCS-2! */
+        if (!mm_modem_charset_byte_array_append (array, mm_sms_part_get_text (part), FALSE, MM_MODEM_CHARSET_UTF16, &inner_error)) {
             g_set_error (error,
                          MM_MESSAGE_ERROR,
                          MM_MESSAGE_ERROR_INVALID_PDU_PARAMETER,
-                         "Failed to convert message text to UCS2: %s", inner_error->message);
+                         "Failed to convert message text to UTF-16: %s", inner_error->message);
             goto error;
         }
 
@@ -1063,22 +1067,109 @@ error:
     return NULL;
 }
 
+static gchar **
+util_split_text_gsm7 (const gchar *text,
+                      gsize        text_len,
+                      gpointer     log_object)
+{
+    gchar **out;
+    guint   n_chunks;
+    guint   i;
+    guint   j;
+
+    /* No splitting needed? */
+    if (text_len <= 160) {
+        out = g_new0 (gchar *, 2);
+        out[0] = g_strdup (text);
+        return out;
+    }
+
+    /* Compute number of chunks needed */
+    n_chunks = text_len / 153;
+    if (text_len % 153 != 0)
+        n_chunks++;
+
+    /* Fill in all chunks */
+    out = g_new0 (gchar *, n_chunks + 1);
+    for (i = 0, j = 0; i < n_chunks; i++, j += 153)
+        out[i] = g_strndup (&text[j], 153);
+
+    return out;
+}
+
+static gchar **
+util_split_text_utf16_or_ucs2 (const gchar *text,
+                               gsize        text_len,
+                               gpointer     log_object)
+{
+    g_autoptr(GPtrArray)  chunks = NULL;
+    const gchar          *walker;
+    const gchar          *chunk_start;
+    glong                 encoded_chunk_length;
+    glong                 total_encoded_chunk_length;
+
+    chunks = g_ptr_array_new_with_free_func ((GDestroyNotify)g_free);
+
+    walker = text;
+    chunk_start = text;
+    encoded_chunk_length = 0;
+    total_encoded_chunk_length = 0;
+    while (walker && *walker) {
+        g_autofree gunichar2 *unichar2 = NULL;
+        glong                 unichar2_written = 0;
+        glong                 unichar2_written_bytes = 0;
+        gunichar              single;
+
+        single = g_utf8_get_char (walker);
+        unichar2 = g_ucs4_to_utf16 (&single, 1, NULL, &unichar2_written, NULL);
+        g_assert (unichar2_written > 0);
+
+        /* When splitting for UCS-2 encoding, only one single unichar2 will be
+         * written, because all codepoints represented in UCS2 fit in the BMP.
+         * When splitting for UTF-16, though, we may end up writing one or two
+         * unichar2 (without or with surrogate pairs), because UTF-16 covers the
+         * whole Unicode spectrum. */
+        unichar2_written_bytes = (unichar2_written * sizeof (gunichar2));
+        if ((encoded_chunk_length + unichar2_written_bytes) > 134) {
+            g_ptr_array_add (chunks, g_strndup (chunk_start, walker - chunk_start));
+            chunk_start = walker;
+            encoded_chunk_length = unichar2_written_bytes;
+        } else
+            encoded_chunk_length += unichar2_written_bytes;
+
+        total_encoded_chunk_length += unichar2_written_bytes;
+        walker = g_utf8_next_char (walker);
+    }
+
+    /* We have split the original string in chunks, where each chunk
+     * does not require more than 134 bytes when encoded in UTF-16.
+     * As a special case now, we consider the case that no splitting
+     * is necessary, i.e. if the total amount of bytes after encoding
+     * in UTF-16 is less or equal than 140. */
+    if (total_encoded_chunk_length <= 140) {
+        gchar **out;
+
+        out = g_new0 (gchar *, 2);
+        out[0] = g_strdup (text);
+        return out;
+    }
+
+    /* Otherwise, we do need the splitted chunks. Add the last one
+     * with contents plus the last trailing NULL */
+    g_ptr_array_add (chunks, g_strndup (chunk_start, walker - chunk_start));
+    g_ptr_array_add (chunks, NULL);
+
+    return (gchar **) g_ptr_array_free (g_steal_pointer (&chunks), FALSE);
+}
+
 gchar **
 mm_sms_part_3gpp_util_split_text (const gchar   *text,
                                   MMSmsEncoding *encoding,
                                   gpointer       log_object)
 {
-    gchar **out;
-    guint n_chunks;
-    guint i;
-    guint j;
-    gsize in_len;
-
     if (!text)
         return NULL;
 
-    in_len = strlen (text);
-
     /* Some info about the rules for splitting.
      *
      * The User Data can be up to 140 bytes in the SMS part:
@@ -1093,80 +1184,25 @@ mm_sms_part_3gpp_util_split_text (const gchar   *text,
      *      134 * 8 = 1072; 1072/7=153.14
      *  2) If we're using UCS2 encoding, we can pack up to 70 characters in
      *     140 bytes (each with 2 bytes), or up to 67 characters in 134 bytes.
+     *  3) If we're using UTF-16 encoding (instead of UCS2), the amount of
+     *     characters we can pack is variable, depends on how the characters
+     *     are encoded in UTF-16 (e.g. if there are characters out of the BMP
+     *     we'll need surrogate pairs and a single character will need 4 bytes
+     *     instead of 2).
      *
      * This method does the split of the input string into N strings, so that
      * each of the strings can be placed in a SMS part.
      */
 
     /* Check if we can do GSM encoding */
-    if (!mm_charset_can_convert_to (text, MM_MODEM_CHARSET_GSM)) {
-        /* If cannot do it in GSM encoding, do it in UCS-2 */
-        g_autoptr(GByteArray) array = NULL;
-        g_autoptr(GError) error = NULL;
-
-        *encoding = MM_SMS_ENCODING_UCS2;
-
-        /* Guess more or less the size of the output array to avoid multiple
-         * allocations */
-        array = g_byte_array_sized_new (in_len * 2);
-        if (!mm_modem_charset_byte_array_append (array,
-                                                 text,
-                                                 FALSE,
-                                                 MM_MODEM_CHARSET_UCS2,
-                                                 &error)) {
-            mm_obj_warn (log_object, "failed to append UCS2: %s", error->message);
-            return NULL;
-        }
-
-        /* Our bytearray has it in UCS-2 now.
-         * UCS-2 is a fixed-size encoding, which means that the text has exactly
-         * 2 bytes for each unicode point. We can now split this array into
-         * chunks of 67 UCS-2 characters (134 bytes).
-         *
-         * Note that UCS-2 covers unicode points between U+0000 and U+FFFF, which
-         * means that there is no direct relationship between the size of the
-         * input text in UTF-8 and the size of the text in UCS-2. A 3-byte UTF-8
-         * encoded character will still be represented with 2 bytes in UCS-2.
-         */
-        if (array->len <= 140) {
-            out = g_new (gchar *, 2);
-            out[0] = g_strdup (text);
-            out[1] = NULL;
-        } else {
-            n_chunks = array->len / 134;
-            if (array->len % 134 != 0)
-                n_chunks++;
-
-            out = g_new0 (gchar *, n_chunks + 1);
-            for (i = 0, j = 0; i < n_chunks; i++, j += 134) {
-                out[i] = sms_decode_text (&array->data[j],
-                                          MIN (array->len - j, 134),
-                                          MM_SMS_ENCODING_UCS2,
-                                          0,
-                                          log_object);
-            }
-        }
-    } else {
-        /* Do it with GSM encoding */
+    if (mm_charset_can_convert_to (text, MM_MODEM_CHARSET_GSM)) {
         *encoding = MM_SMS_ENCODING_GSM7;
-
-        if (in_len <= 160) {
-            out = g_new (gchar *, 2);
-            out[0] = g_strdup (text);
-            out[1] = NULL;
-        } else {
-            n_chunks = in_len / 153;
-            if (in_len % 153 != 0)
-                n_chunks++;
-
-            out = g_new0 (gchar *, n_chunks + 1);
-            for (i = 0, j = 0; i < n_chunks; i++, j += 153) {
-                out[i] = g_strndup (&text[j], 153);
-            }
-        }
+        return util_split_text_gsm7 (text, strlen (text), log_object);
     }
 
-    return out;
+    /* Otherwise fallback to report UCS-2 and split supporting UTF-16 */
+    *encoding = MM_SMS_ENCODING_UCS2;
+    return util_split_text_utf16_or_ucs2 (text, strlen (text), log_object);
 }
 
 GByteArray **
diff --git a/src/mm-sms-qmi.c b/src/mm-sms-qmi.c
index 6f3fe0d2..efc87a65 100644
--- a/src/mm-sms-qmi.c
+++ b/src/mm-sms-qmi.c
@@ -436,7 +436,7 @@ sms_send_generic (GTask *task)
 
     qmi_client_wms_raw_send (ctx->client,
                              input,
-                             30,
+                             5 * 60,
                              NULL,
                              (GAsyncReadyCallback)send_generic_ready,
                              task);
@@ -564,7 +564,7 @@ sms_send_from_storage (GTask *task)
     qmi_client_wms_send_from_memory_storage (
         ctx->client,
         input,
-        30,
+        5 * 60,
         NULL,
         (GAsyncReadyCallback)send_from_storage_ready,
         task);
-- 
2.25.1

