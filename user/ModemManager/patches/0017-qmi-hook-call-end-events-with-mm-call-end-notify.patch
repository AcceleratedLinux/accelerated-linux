From: Samuel Brian <sam.brian@accelerated.com>
Date: Thu, 4 May 2017 16:53:25 +1000
Subject: qmi: hook call end events with mm-call-end-notify

Otherwise the call end reasons are syslogged and not reported anywhere
else.
---
 src/mm-bearer-qmi.c | 80 ++++++++++++++++++++++++++++++++++++---------
 1 file changed, 64 insertions(+), 16 deletions(-)

diff --git a/src/mm-bearer-qmi.c b/src/mm-bearer-qmi.c
index 4d3909f7..88c778f2 100644
--- a/src/mm-bearer-qmi.c
+++ b/src/mm-bearer-qmi.c
@@ -575,26 +575,50 @@ start_network_ready (QmiClientWds *client,
             if (g_error_matches (error,
                                  QMI_PROTOCOL_ERROR,
                                  QMI_PROTOCOL_ERROR_CALL_FAILED)) {
-                QmiWdsCallEndReason cer;
-                QmiWdsVerboseCallEndReasonType verbose_cer_type;
-                gint16 verbose_cer_reason;
+                QmiWdsCallEndReason cer = 0;
+                QmiWdsVerboseCallEndReasonType verbose_cer_type = 0;
+                gint16 verbose_cer_reason = 0;
+                const char *cer_str = NULL;
+                const char *verbose_cer_type_str = NULL;
+                const char *verbose_cer_reason_str = NULL;
+                char *str;
 
                 if (qmi_message_wds_start_network_output_get_call_end_reason (
                         output,
                         &cer,
-                        NULL))
-                    mm_obj_info (self, "call end reason (%u): %s", cer, qmi_wds_call_end_reason_get_string (cer));
+                        NULL)) {
+                    cer_str = qmi_wds_call_end_reason_get_string (cer);
+                    mm_obj_info (self, "call end reason (%u): %s", cer, cer_str);
+                }
 
                 if (qmi_message_wds_start_network_output_get_verbose_call_end_reason (
                         output,
                         &verbose_cer_type,
                         &verbose_cer_reason,
-                        NULL))
+                        NULL)) {
+                    verbose_cer_type_str = qmi_wds_verbose_call_end_reason_type_get_string (verbose_cer_type);
+                    verbose_cer_reason_str = qmi_wds_verbose_call_end_reason_get_string (verbose_cer_type, verbose_cer_reason);
                     mm_obj_info (self, "verbose call end reason (%u,%d): [%s] %s",
                                  verbose_cer_type,
                                  verbose_cer_reason,
-                                 qmi_wds_verbose_call_end_reason_type_get_string (verbose_cer_type),
-                                 qmi_wds_verbose_call_end_reason_get_string (verbose_cer_type, verbose_cer_reason));
+                                 verbose_cer_type_str,
+                                 verbose_cer_reason_str);
+                }
+
+                if (asprintf (
+                        &str,
+                        "mm-call-end-notify.sh \"%s\" \"%s\" \"%s %s %s (%u,%u,%u)\"",
+                        mm_base_bearer_get_path(&ctx->self->parent),
+                        ctx->running_ipv6 ? "ipv6" : "ipv4",
+                        cer_str ?: "",
+                        verbose_cer_type_str ?: "",
+                        verbose_cer_reason_str ?: "",
+                        cer,
+                        verbose_cer_type,
+                        verbose_cer_reason) != -1) {
+                    system (str);
+                    free (str);
+                }
             }
         }
     }
@@ -1030,26 +1054,50 @@ packet_service_status_indication_cb (QmiClientWds *client,
         if (connection_status == QMI_WDS_CONNECTION_STATUS_DISCONNECTED &&
             bearer_status != MM_BEARER_STATUS_DISCONNECTED &&
             bearer_status != MM_BEARER_STATUS_DISCONNECTING) {
-            QmiWdsCallEndReason cer;
-            QmiWdsVerboseCallEndReasonType verbose_cer_type;
-            gint16 verbose_cer_reason;
+
+            QmiWdsCallEndReason cer = 0;
+            QmiWdsVerboseCallEndReasonType verbose_cer_type = 0;
+            gint16 verbose_cer_reason = 0;
+            const char *cer_str = NULL;
+            const char *verbose_cer_type_str = NULL;
+            const char *verbose_cer_reason_str = NULL;
+            char *str;
 
             if (qmi_indication_wds_packet_service_status_output_get_call_end_reason (
                     output,
                     &cer,
-                    NULL))
-                mm_obj_info (self, "bearer call end reason (%u): '%s'", cer, qmi_wds_call_end_reason_get_string (cer));
+                    NULL)) {
+                cer_str = qmi_wds_call_end_reason_get_string (cer);
+                mm_obj_info (self, "bearer call end reason (%u): %s", cer, cer_str);
+            }
 
             if (qmi_indication_wds_packet_service_status_output_get_verbose_call_end_reason (
                     output,
                     &verbose_cer_type,
                     &verbose_cer_reason,
-                    NULL))
+                    NULL)) {
+                verbose_cer_type_str = qmi_wds_verbose_call_end_reason_type_get_string (verbose_cer_type);
+                verbose_cer_reason_str = qmi_wds_verbose_call_end_reason_get_string (verbose_cer_type, verbose_cer_reason);
                 mm_obj_info (self, "bearer verbose call end reason (%u,%d): [%s] %s",
                              verbose_cer_type,
                              verbose_cer_reason,
-                             qmi_wds_verbose_call_end_reason_type_get_string (verbose_cer_type),
-                             qmi_wds_verbose_call_end_reason_get_string (verbose_cer_type, verbose_cer_reason));
+                             verbose_cer_type_str,
+                             verbose_cer_reason_str);
+            }
+
+            if (asprintf (
+                    &str,
+                    "mm-call-end-notify.sh \"%s\" \"\" \"%s %s %s (%u,%u,%u)\"",
+                    mm_base_bearer_get_path(&self->parent),
+                    cer_str ?: "",
+                    verbose_cer_type_str ?: "",
+                    verbose_cer_reason_str ?: "",
+                    cer,
+                    verbose_cer_type,
+                    verbose_cer_reason) != -1) {
+                system (str);
+                free (str);
+            }
 
             mm_base_bearer_report_connection_status (MM_BASE_BEARER (self), MM_BEARER_CONNECTION_STATUS_DISCONNECTED);
         }
