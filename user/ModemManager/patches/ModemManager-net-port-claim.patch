port: prevent bearers from trying to use the same data port

When two bearers on a modem attempt to grab a data port to start their
connection setups, there is a chance they may grab the same data port.
As a result, ModemManager gets very confused and bad things happen.

Previously, the criteria for an available data port was only that it was not
yet connected. Now we require bearer connect and disconnect procedures
"claim" the data port during connect and disconnect procedures.
The states during connection are:    claimed -> connected -> unclaimed
The states during disconnection are: claimed -> disconnected -> unclaimed

diff -Nurd ModemManager.orig/src/mm-base-modem.c ModemManager/src/mm-base-modem.c
--- ModemManager.orig/src/mm-base-modem.c	2019-05-27 15:37:56.000000000 +1000
+++ ModemManager/src/mm-base-modem.c	2019-05-29 11:08:19.640306659 +1000
@@ -826,6 +826,7 @@
     /* Return first not-connected data port */
     for (l = self->priv->data; l; l = g_list_next (l)) {
         if (!mm_port_get_connected ((MMPort *)l->data) &&
+            !mm_port_get_claimed ((MMPort *)l->data) &&
             (mm_port_get_port_type ((MMPort *)l->data) == type ||
              type == MM_PORT_TYPE_UNKNOWN)) {
             return (MMPort *)l->data;
diff -Nurd ModemManager.orig/src/mm-bearer-qmi.c ModemManager/src/mm-bearer-qmi.c
--- ModemManager.orig/src/mm-bearer-qmi.c	2019-05-29 11:08:19.436305652 +1000
+++ ModemManager/src/mm-bearer-qmi.c	2019-05-29 11:08:19.640306659 +1000
@@ -449,6 +449,9 @@
     g_free (ctx->user);
     g_free (ctx->password);
 
+    if (ctx->data)
+        mm_port_set_claimed ((MMPort *)ctx->data, FALSE);
+
     if (ctx->packet_service_status_ipv4_indication_id) {
         common_setup_cleanup_packet_service_status_unsolicited_events (ctx->self,
                                                                        ctx->client_ipv4,
@@ -1728,6 +1731,10 @@
         }
     }
 
+    /* Claim the data port so other bearers do not try to use it while this
+     * bearer is connecting. */
+    mm_port_set_claimed ((MMPort *)ctx->data, TRUE);
+
     /* Run! */
     connect_context_step (task);
 }
@@ -1754,6 +1761,8 @@
     QmiClientWds *client_ipv6;
     guint32 packet_data_handle_ipv6;
     GError *error_ipv6;
+
+    MMPort *data;
 } DisconnectContext;
 
 static void
@@ -1767,6 +1776,8 @@
         g_object_unref (ctx->client_ipv4);
     if (ctx->client_ipv6)
         g_object_unref (ctx->client_ipv6);
+    if (ctx->data)
+        mm_port_set_claimed ((MMPort *)ctx->data, FALSE);
     g_slice_free (DisconnectContext, ctx);
 }
 
@@ -1991,6 +2002,7 @@
     }
 
     ctx = g_slice_new0 (DisconnectContext);
+    ctx->data = g_object_ref (self->priv->data);
     ctx->client_ipv4 = self->priv->client_ipv4 ? g_object_ref (self->priv->client_ipv4) : NULL;
     ctx->packet_data_handle_ipv4 = self->priv->packet_data_handle_ipv4;
     ctx->client_ipv6 = self->priv->client_ipv6 ? g_object_ref (self->priv->client_ipv6) : NULL;
@@ -2000,6 +2012,8 @@
     task = g_task_new (self, NULL, callback, user_data);
     g_task_set_task_data (task, ctx, (GDestroyNotify)disconnect_context_free);
 
+    mm_port_set_claimed ((MMPort *)ctx->data, TRUE);
+
     /* Run! */
     disconnect_context_step (task);
 }
diff -Nurd ModemManager.orig/src/mm-port.c ModemManager/src/mm-port.c
--- ModemManager.orig/src/mm-port.c	2019-05-27 15:37:56.000000000 +1000
+++ ModemManager/src/mm-port.c	2019-05-29 11:08:19.640306659 +1000
@@ -38,6 +38,7 @@
     MMPortSubsys subsys;
     MMPortType ptype;
     gboolean connected;
+    gboolean claimed;
     MMKernelDevice *kernel_device;
 };
 
@@ -95,6 +96,30 @@
     }
 }
 
+gboolean
+mm_port_get_claimed (MMPort *self)
+{
+    g_return_val_if_fail (self != NULL, FALSE);
+    g_return_val_if_fail (MM_IS_PORT (self), FALSE);
+
+    return self->priv->claimed;
+}
+
+void
+mm_port_set_claimed (MMPort *self, gboolean claimed)
+{
+    g_return_if_fail (self != NULL);
+    g_return_if_fail (MM_IS_PORT (self));
+
+    if (self->priv->claimed != claimed) {
+        self->priv->claimed = claimed;
+
+        mm_dbg ("(%s): port now %s",
+                self->priv->device,
+                claimed ? "claimed" : "unclaimed");
+    }
+}
+
 MMKernelDevice *
 mm_port_peek_kernel_device (MMPort *self)
 {
diff -Nurd ModemManager.orig/src/mm-port.h ModemManager/src/mm-port.h
--- ModemManager.orig/src/mm-port.h	2019-05-27 15:37:56.000000000 +1000
+++ ModemManager/src/mm-port.h	2019-05-29 11:08:19.640306659 +1000
@@ -77,6 +77,8 @@
 MMPortType      mm_port_get_port_type      (MMPort *self);
 gboolean        mm_port_get_connected      (MMPort *self);
 void            mm_port_set_connected      (MMPort *self, gboolean connected);
+gboolean        mm_port_get_claimed        (MMPort *self);
+void            mm_port_set_claimed        (MMPort *self, gboolean claimed);
 MMKernelDevice *mm_port_peek_kernel_device (MMPort *self);
 
 #endif /* MM_PORT_H */
