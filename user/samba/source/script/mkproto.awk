BEGIN {
  inheader=0;
#  use_ldap_define = 0;
  current_file="";
  if (headername=="") {
    headername="_PROTO_H_";
  }

  print "#ifndef",headername
  print "#define",headername
  print ""
  print "/* This file is automatically generated with \"make proto\". DO NOT EDIT */"
  print ""
}

END {
  print ""
  print "#endif /* ",headername," */"
}

{
  if (FILENAME!=current_file) {
#    if (use_ldap_define)
#    {
#      print "#endif /* USE_LDAP */"
#      use_ldap_define = 0;
#    }
    print ""
    print "/* The following definitions come from",FILENAME," */"
    print ""
    current_file=FILENAME
  }
  if (inheader) {
    if (match($0,"[)][ \t]*$")) {
      inheader = 0;
      printf "%s;\n",$0;
    } else {
      printf "%s\n",$0;
    }
    next;
  }
}

# we handle the loadparm.c fns separately

/^FN_LOCAL_BOOL/ {
  split($0,a,"[,()]")
  printf "BOOL %s(int );\n", a[2]
}

/^FN_LOCAL_PARM_BOOL/ {
  split($0,a,"[,()]")
  printf "BOOL %s(const struct share_params *p );\n", a[2]
}

/^FN_LOCAL_PARM_INTEGER/ {
  split($0,a,"[,()]")
  printf "int %s(const struct share_params *p );\n", a[2]
}

/^FN_LOCAL_LIST/ {
  split($0,a,"[,()]")
  printf "const char **%s(int );\n", a[2]
}

/^FN_LOCAL_STRING/ {
  split($0,a,"[,()]")
  printf "char *%s(int );\n", a[2]
}

/^FN_LOCAL_PARM_STRING/ {
  split($0,a,"[,()]")
  printf "char *%s(const struct share_params *p );\n", a[2]
}

/^FN_LOCAL_CONST_STRING/ {
  split($0,a,"[,()]")
  printf "const char *%s(int );\n", a[2]
}

/^FN_LOCAL_INT/ {
  split($0,a,"[,()]")
  printf "int %s(int );\n", a[2]
}

/^FN_LOCAL_CHAR/ {
  split($0,a,"[,()]")
  printf "char %s(const struct share_params *p );\n", a[2]
}

/^FN_GLOBAL_BOOL/ {
  split($0,a,"[,()]")
  printf "BOOL %s(void);\n", a[2]
}

/^FN_GLOBAL_LIST/ {
  split($0,a,"[,()]")
  printf "const char **%s(void);\n", a[2]
}

/^FN_GLOBAL_STRING/ {
  split($0,a,"[,()]")
  printf "char *%s(void);\n", a[2]
}

/^FN_GLOBAL_CONST_STRING/ {
  split($0,a,"[,()]")
  printf "const char *%s(void);\n", a[2]
}

/^FN_GLOBAL_INT/ {
  split($0,a,"[,()]")
  printf "int %s(void);\n", a[2]
}

/^static|^extern/ || !/^[a-zA-Z]/ || /[;]/ {
  next;
}

#
# We have to split up the start
# matching as we now have so many start
# types that it can cause some versions
# of nawk/awk to choke and fail on
# the full match. JRA.
#

{
  gotstart = 0;
  if( $0 ~ /^const|^connection_struct|^pipes_struct|^smb_np_struct|^file_fd_struct|^files_struct|^connection_struct|^uid_t|^gid_t|^unsigned|^mode_t|^DIR|^user|^int|^pid_t|^ino_t|^off_t|^double/ ) {
    gotstart = 1;
  }

  if( $0 ~ /^vuser_key|^UNISTR2|^LOCAL_GRP|^DOMAIN_GRP|^SMB_STRUCT_DIRENT|^SEC_ACL|^SEC_DESC|^SEC_DESC_BUF|^DOM_SID|^RPC_HND_NODE|^BYTE/ ) {
    gotstart = 1;
  }

  if( $0 ~ /^ADS_STRUCT|^ADS_STATUS|^DATA_BLOB|^ASN1_DATA|^TDB_CONTEXT|^TDB_DATA|^smb_ucs2_t|^TALLOC_CTX|^hash_element|^NT_DEVICEMODE|^enum.*\(|^NT_USER_TOKEN|^SAM_ACCOUNT|^NTTIME/ ) {
    gotstart = 1;
  }

  if( $0 ~ /^smb_iconv_t|^long|^char|^uint|^NTSTATUS|^WERROR|^CLI_POLICY_HND|^struct|^BOOL|^void|^time|^smb_shm_offset_t|^shm_offset_t|^FILE|^XFILE|^SMB_OFF_T|^size_t|^ssize_t|^SMB_BIG_UINT|^SMB_BIG_INT/ ) {
    gotstart = 1;
  }

  if( $0 ~ /^SAM_ACCT_INFO_NODE|^SMB_ACL_T|^ADS_MODLIST|^PyObject|^SORTED_TREE|^REGISTRY_HOOK|^REGISTRY_VALUE|^REGVAL_CTR|^DEVICEMODE|^PAC_DATA|^NET_USER_INFO_3|^smb_event_id_t/ ) {
    gotstart = 1;
  }

  if( $0 ~ /^WINBINDD_PW|^WINBINDD_GR|^NT_PRINTER_INFO_LEVEL_2|^LOGIN_CACHE|^krb5_error_code|^LDAP|^u32|^LUID_ATTR|^NSS_STATUS/ ) {
    gotstart = 1;
  }

  if( $0 ~ /^NODE_STATUS_STRUCT|SMB_STRUCT_DIR|ELOG_TDB|codepoint_t/ ) {
    gotstart = 1;
  }

  if(!gotstart) {
    next;
  }
}


/[(].*[)][ \t]*$/ {
    printf "%s;\n",$0;
    next;
}

/[(]/ {
  inheader=1;
  printf "%s\n",$0;
  next;
}

