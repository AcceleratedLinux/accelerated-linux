.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "RPNTUTORIAL 1"
.TH RPNTUTORIAL 1 "2005-06-17" "1.2.10" "rrdtool"
.SH "NAME"
rpntutorial \- Reading RRDtool RPN Expressions by Steve Rader
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This tutorial should help you get to grips with RRDtool \s-1RPN\s0 expressions
as seen in \s-1CDEF\s0 arguments of RRDtool graph.
.SH "Reading Comparison Operators"
.IX Header "Reading Comparison Operators"
The \s-1LT\s0, \s-1LE\s0, \s-1GT\s0, \s-1GE\s0 and \s-1EQ\s0 \s-1RPN\s0 logic operators are not as tricky as
they appear.  These operators act on the two values on the stack
preceding them (to the left).  Read these two values on the stack
from left to right inserting the operator in the middle.  If the
resulting statement is true, then replace the three values from the
stack with \*(L"1\*(R".  If the statement if false, replace the three values
with \*(L"0\*(R".
.PP
For example, think about \*(L"2,1,GT\*(R".  This \s-1RPN\s0 expression could be
read as \*(L"is two greater than one?\*(R"  The answer to that question is
\&\*(L"true\*(R".  So the three values should be replaced with \*(L"1\*(R".  Thus the
\&\s-1RPN\s0 expression 2,1,GT evaluates to 1.
.PP
Now consider \*(L"2,1,LE\*(R".  This \s-1RPN\s0 expression could be read as \*(L"is
two less than or equal to one?\*(R".   The natural response is \*(L"no\*(R"
and thus the \s-1RPN\s0 expression 2,1,LE evaluates to 0.
.SH "Reading the IF Operator"
.IX Header "Reading the IF Operator"
The \s-1IF\s0 \s-1RPN\s0 logic operator can be straightforward also.  The key
to reading \s-1IF\s0 operators is to understand that the condition part
of the traditional \*(L"if X than Y else Z\*(R" notation has *already*
been evaluated.  So the \s-1IF\s0 operator acts on only one value on the
stack: the third value to the left of the \s-1IF\s0 value.  The second
value to the left of the \s-1IF\s0 corresponds to the true (\*(L"Y\*(R") branch.
And the first value to the left of the \s-1IF\s0 corresponds to the false
(\*(L"Z\*(R") branch.  Read the \s-1RPN\s0 expression \*(L"X,Y,Z,IF\*(R" from left to
right like so: \*(L"if X then Y else Z\*(R".
.PP
For example, consider \*(L"1,10,100,IF\*(R".  It looks bizarre to me.
But when I read \*(L"if 1 then 10 else 100\*(R" it's crystal clear: 1 is true
so the answer is 10.  Note that only zero is false; all other values
are true.  \*(L"2,20,200,IF\*(R" (\*(L"if 2 then 20 else 200\*(R") evaluates to 20.
And \*(L"0,1,2,IF\*(R" ("if 0 then 1 else 2) evaluates to 2.
.PP
Notice that none of the above examples really simulate the whole
\&\*(L"if X then Y else Z\*(R" statement.  This is because computer programmers
read this statement as \*(L"if Some Condition then Y else Z\*(R".  So it's
important to be able to read \s-1IF\s0 operators along with the \s-1LT\s0, \s-1LE\s0,
\&\s-1GT\s0, \s-1GE\s0 and \s-1EQ\s0 operators.
.SH "Some Examples"
.IX Header "Some Examples"
While compound expressions can look overly complex, they can be
considered elegantly simple.  To quickly comprehend \s-1RPN\s0 expressions,
you must know the the algorithm for evaluating \s-1RPN\s0 expressions:
iterate searches from the left to the right looking for an operator.
When it's found, apply that operator by popping the operator and some
number of values (and by definition, not operators) off the stack.
.PP
For example, the stack \*(L"1,2,3,+,+\*(R" gets \*(L"2,3,+\*(R" evaluated (as \*(L"2+3\*(R")
during the first iteration and is replaced by 5.  This results in
the stack \*(L"1,5,+\*(R".  Finally, \*(L"1,5,+\*(R" is evaluated resulting in the
answer 6.  For convenience, it's useful to write this set of
operations as:
.PP
.Vb 3
\& 1) 1,2,3,+,+    eval is 2,3,+ = 5    result is 1,5,+
\& 2) 1,5,+        eval is 1,5,+ = 6    result is 6
\& 3) 6
.Ve
.PP
Let's use that notation to conveniently solve some complex \s-1RPN\s0 expressions
with multiple logic operators:
.PP
.Vb 1
\& 1) 20,10,GT,10,20,IF  eval is 20,10,GT = 1     result is 1,10,20,IF
.Ve
.PP
read the eval as pop \*(L"20 is greater than 10\*(R" so push 1
.PP
.Vb 1
\& 2) 1,10,20,IF         eval is 1,10,20,IF = 10  result is 10
.Ve
.PP
read pop \*(L"if 1 then 10 else 20\*(R" so push 10.  Only 10 is left so
10 is the answer.
.PP
Let's read a complex \s-1RPN\s0 expression that also has the traditional
multiplication operator:
.PP
.Vb 4
\& 1) 128,8,*,7000,GT,7000,128,8,*,IF  eval 128,8,*       result is 1024
\& 2) 1024,7000,GT,7000,128,8,*,IF     eval 1024,7000,GT  result is 0
\& 3) 0,128,8,*,IF                     eval 128,8,*       result is 1024
\& 4) 0,7000,1024,IF                                      result is 1024
.Ve
.PP
Now let's go back to the first example of multiple logic operators,
but replace the value 20 with the variable \*(L"input\*(R":
.PP
.Vb 1
\& 1) input,10,GT,10,input,IF  eval is input,10,GT  ( lets call this A )
.Ve
.PP
Read eval as \*(L"if input > 10 then true\*(R" and replace \*(L"input,10,GT\*(R"
with \*(L"A\*(R":
.PP
.Vb 1
\& 2) A,10,input,IF            eval is A,10,input,IF
.Ve
.PP
read \*(L"if A then 10 else input\*(R".  Now replace A with it's verbose
description againg and\*(--voila!\-\-you have a easily readable description
of the expression:
.PP
.Vb 1
\& if input > 10 then 10 else input
.Ve
.PP
Finally, let's go back to the first most complex example and replace
the value 128 with \*(L"input\*(R":
.PP
.Vb 1
\& 1) input,8,*,7000,GT,7000,input,8,*,IF  eval input,8,*     result is A
.Ve
.PP
where A is \*(L"input * 8\*(R"
.PP
.Vb 1
\& 2) A,7000,GT,7000,input,8,*,IF          eval is A,7000,GT  result is B
.Ve
.PP
where B is \*(L"if ((input * 8) > 7000) then true\*(R"
.PP
.Vb 1
\& 3) B,7000,input,8,*,IF                  eval is input,8,*  result is C
.Ve
.PP
where C is \*(L"input * 8\*(R"
.PP
.Vb 1
\& 4) B,7000,C,IF
.Ve
.PP
At last we have a readable decoding of the complex \s-1RPN\s0 expression with
a variable:
.PP
.Vb 1
\& if ((input * 8) > 7000) then 7000 else (input * 8)
.Ve
.SH "Exercises"
.IX Header "Exercises"
Exercise 1:
.PP
Compute \*(L"3,2,*,1,+ and \*(R"3,2,1,+,*" by hand.  Rewrite them in
traditional notation.  Explain why they have different answers.
.PP
Answer 1:
.PP
.Vb 3
\&    3*2+1 = 7 and 3*(2+1) = 9.  These expressions have
\&    different answers because the altering of the plus and
\&    times operators alter the order of their evaluation.
.Ve
.PP
Exercise 2:
.PP
One may be tempted to shorten the expression
.PP
.Vb 1
\& input,8,*,56000,GT,56000,input,*,8,IF
.Ve
.PP
by removing the redundant use of \*(L"input,8,*\*(R" like so:
.PP
.Vb 1
\& input,56000,GT,56000,input,IF,8,*
.Ve
.PP
Use traditional notation to show these expressions are not the same.
Write an expression that's equivalent to the first expression, but
uses the \s-1LE\s0 and \s-1DIV\s0 operators.
.PP
Answer 2:
.PP
.Vb 2
\&    if (input <= 56000/8 ) { input*8 } else { 56000 }
\&    input,56000,8,DIV,LT,input,8,*,56000,IF
.Ve
.PP
Exercise 3:
.PP
Briefly explain why traditional mathematic notation requires the
use of parentheses.  Explain why \s-1RPN\s0 notation does not require
the use of parentheses.
.PP
Answer 3:
.PP
.Vb 6
\&    Traditional mathematic expressions are evaluated by
\&    doing multiplication and division first, then addition and
\&    subtraction.  Parentheses are used to force the evaluation of
\&    addition before multiplication (etc).  RPN does not require
\&    parentheses because the ordering of objects on the stack
\&    can force the evaluation of addition before multiplication.
.Ve
.PP
Exercise 4:
.PP
Explain why it was desirable for the RRDtool developers to implement
\&\s-1RPN\s0 notation instead of traditional mathematical notation.
.PP
Answer 4:
.PP
.Vb 5
\&    The algorithm that implements traditional mathematical
\&    notation is more complex then algorithm used for RPN.
\&    So implementing RPN allowed Tobias Oetiker to write less
\&    code!  (The code is also less complex and therefore less
\&    likely to have bugs.)
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Steve Rader <rader@wiscnet.net>
