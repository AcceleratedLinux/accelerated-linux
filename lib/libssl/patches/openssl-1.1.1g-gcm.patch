diff --git a/crypto/evp/evp_aad.c b/crypto/evp/evp_aad.c
new file mode 100644
index 000000000000..2ee2d67828ae
--- /dev/null
+++ b/crypto/evp/evp_aad.c
@@ -0,0 +1,39 @@
+/*
+ * Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved.
+ * Copyright 2017 BaishanCloud. All Rights Reserved.
+ *
+ * Licensed under the OpenSSL license (the "License").  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * https://www.openssl.org/source/license.html
+ */
+
+#include <stdio.h>
+#include "internal/cryptlib.h"
+#include <openssl/x509.h>
+#include <openssl/objects.h>
+#include <openssl/evp.h>
+#include <openssl/ui.h>
+
+
+int EVP_read_aad_string(char *buf, int len, const char *prompt)
+{
+    return EVP_read_aad_string_min(buf, 0, len, prompt);
+}
+
+int EVP_read_aad_string_min(char *buf, int min, int len, const char *prompt)
+{
+    int ret = -1;
+    UI *ui;
+
+    ui = UI_new();
+    if (ui == NULL)
+        return ret;
+    if (UI_add_input_string(ui, prompt, UI_INPUT_FLAG_ECHO, buf, min,
+                            len) < 0)
+        goto end;
+    ret = UI_process(ui);
+ end:
+    UI_free(ui);
+    return ret;
+}
--- openssl-1.1.1g/apps/enc.c.orig	2020-10-07 08:39:18.426048172 +1000
+++ openssl-1.1.1g/apps/enc.c	2020-10-07 11:06:06.486155308 +1000
@@ -43,7 +43,7 @@
     OPT_LIST,
     OPT_E, OPT_IN, OPT_OUT, OPT_PASS, OPT_ENGINE, OPT_D, OPT_P, OPT_V,
     OPT_NOPAD, OPT_SALT, OPT_NOSALT, OPT_DEBUG, OPT_UPPER_P, OPT_UPPER_A,
-    OPT_A, OPT_Z, OPT_BUFSIZE, OPT_K, OPT_KFILE, OPT_UPPER_K, OPT_NONE,
+    OPT_A, OPT_Z, OPT_BUFSIZE, OPT_K, OPT_AAD, OPT_KFILE, OPT_UPPER_K, OPT_NONE,
     OPT_UPPER_S, OPT_IV, OPT_MD, OPT_ITER, OPT_PBKDF2, OPT_CIPHER,
     OPT_R_ENUM
 } OPTION_CHOICE;
@@ -57,7 +57,7 @@
     {"pass", OPT_PASS, 's', "Passphrase source"},
     {"e", OPT_E, '-', "Encrypt"},
     {"d", OPT_D, '-', "Decrypt"},
-    {"p", OPT_P, '-', "Print the iv/key"},
+    {"p", OPT_P, '-', "Print the iv/key/aad/tag"},
     {"P", OPT_UPPER_P, '-', "Print the iv/key and exit"},
     {"v", OPT_V, '-', "Verbose output"},
     {"nopad", OPT_NOPAD, '-', "Disable standard block padding"},
@@ -70,6 +70,7 @@
      "Used with -[base64|a] to specify base64 buffer as a single line"},
     {"bufsize", OPT_BUFSIZE, 's', "Buffer size"},
     {"k", OPT_K, 's', "Passphrase"},
+	{"aad", OPT_AAD, 's', "Additional Authenticated Data for AEAD ciphers"},
     {"kfile", OPT_KFILE, '<', "Read passphrase from file"},
     {"K", OPT_UPPER_K, 's', "Raw key, in hex"},
     {"S", OPT_UPPER_S, 's', "Salt, in hex"},
@@ -93,6 +94,8 @@
 {
     static char buf[128];
     static const char magic[] = "Salted__";
+	static const char pretag[] = "Tag__";
+	unsigned char tag[16] = {0};
     ENGINE *e = NULL;
     BIO *in = NULL, *out = NULL, *b64 = NULL, *benc = NULL, *rbio =
         NULL, *wbio = NULL;
@@ -102,9 +105,12 @@
     char *hkey = NULL, *hiv = NULL, *hsalt = NULL, *p;
     char *infile = NULL, *outfile = NULL, *prog;
     char *str = NULL, *passarg = NULL, *pass = NULL, *strbuf = NULL;
+	char *aad = NULL, *aadbuf = NULL;
     char mbuf[sizeof(magic) - 1];
+	char tbuf[sizeof pretag - 1];
     OPTION_CHOICE o;
     int bsize = BSIZE, verbose = 0, debug = 0, olb64 = 0, nosalt = 0;
+	int outlen, offset = 0;
     int enc = 1, printkey = 0, i, k;
     int base64 = 0, informat = FORMAT_BINARY, outformat = FORMAT_BINARY;
     int ret = 1, inl, nopad = 0;
@@ -222,6 +228,9 @@
         case OPT_K:
             str = opt_arg();
             break;
+		case OPT_AAD:
+			aad = opt_arg();
+			break;
         case OPT_KFILE:
             in = bio_open_default(opt_arg(), 'r', FORMAT_TEXT);
             if (in == NULL)
@@ -284,9 +293,11 @@
         goto opthelp;
     }
 
-    if (cipher && EVP_CIPHER_flags(cipher) & EVP_CIPH_FLAG_AEAD_CIPHER) {
-        BIO_printf(bio_err, "%s: AEAD ciphers not supported\n", prog);
-        goto end;
+    if (cipher && (EVP_CIPHER_flags(cipher) & EVP_CIPH_FLAG_AEAD_CIPHER)) {
+		if ((EVP_CIPHER_mode(cipher) != EVP_CIPH_GCM_MODE)) {
+			BIO_printf(bio_err, "%s: AEAD ciphers not supported\n", prog);
+			goto end;
+		}
     }
 
     if (cipher && (EVP_CIPHER_mode(cipher) == EVP_CIPH_XTS_MODE)) {
@@ -317,6 +328,7 @@
         }
 
     strbuf = app_malloc(SIZE, "strbuf");
+	aadbuf = app_malloc(SIZE, "aadbuf");
     buff = app_malloc(EVP_ENCODE_LENGTH(bsize), "evp buffer");
 
     if (infile == NULL) {
@@ -365,6 +377,30 @@
             goto end;
         }
     }
+    if (cipher && (EVP_CIPHER_flags(cipher) & EVP_CIPH_FLAG_AEAD_CIPHER) && (aad == NULL)) {
+#ifndef OPENSSL_NO_UI
+        for (;;) {
+            char prompt[200];
+
+            BIO_snprintf(prompt, sizeof prompt, "enter %s %s aad:",
+                         OBJ_nid2ln(EVP_CIPHER_nid(cipher)),
+                         (enc) ? "encryption" : "decryption");
+            aadbuf[0] = '\0';
+            i = EVP_read_aad_string((char *)aadbuf, SIZE, prompt);
+            if (i == 0) {
+                aad = aadbuf;
+                break;
+            }
+            if (i < 0) {
+                BIO_printf(bio_err, "bad aad read\n");
+                goto end;
+            }
+        }
+#else
+        aadbuf[0] = '\0';
+        aad = aadbuf;
+#endif
+    }
 
     out = bio_open_default(outfile, 'w', outformat);
     if (out == NULL)
@@ -524,6 +560,30 @@
             /* wiping secret data as we no longer need it */
             OPENSSL_cleanse(hkey, strlen(hkey));
         }
+        if ((EVP_CIPHER_flags(cipher) & EVP_CIPH_FLAG_AEAD_CIPHER)) {
+            if (enc) {
+                if ((printkey != 2)
+                    && (BIO_write(wbio, pretag,
+                                  sizeof pretag - 1) != sizeof pretag - 1
+                        || BIO_write(wbio,
+                                     (char *)tag,
+                                     sizeof tag) != sizeof tag)) {
+                    BIO_printf(bio_err, "error writing tag to output file\n");
+                    goto end;
+                }
+            } else {
+                if (BIO_read(rbio, tbuf, sizeof tbuf) != sizeof tbuf
+                           || BIO_read(rbio,
+                                       (unsigned char *)tag,
+                                       sizeof tag) != sizeof tag) {
+                    BIO_printf(bio_err, "error reading tag from input file\n");
+                    goto end;
+                } else if (memcmp(tbuf, pretag, sizeof pretag - 1)) {
+                    BIO_printf(bio_err, "bad tag number\n");
+                    goto end;
+                }
+            }
+		}
 
         if ((benc = BIO_new(BIO_f_cipher())) == NULL)
             goto end;
@@ -552,18 +612,45 @@
             goto end;
         }
 
+        if ((EVP_CIPHER_flags(cipher) & EVP_CIPH_FLAG_AEAD_CIPHER)) {
+            if (!EVP_CipherUpdate(ctx, NULL, &outlen, (unsigned char*)aad, strlen(aad))) {
+                BIO_printf(bio_err, "Error setting cipher %s\n",
+                           EVP_CIPHER_name(cipher));
+                ERR_print_errors(bio_err);
+                goto end;
+            }
+            if (!enc) {
+                if (!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_TAG, sizeof(tag), (void *)tag)) {
+                    BIO_printf(bio_err, "Error setting tag ctrl %s\n",
+                               EVP_CIPHER_name(cipher));
+                    ERR_print_errors(bio_err);
+                    goto end;
+                }
+            }
+        }
+
         if (debug) {
             BIO_set_callback(benc, BIO_debug_callback);
             BIO_set_callback_arg(benc, (char *)bio_err);
         }
 
         if (printkey) {
+			if (!aad) {
+				printf("aad=%s", aad);
+				printf("\n");
+			}
             if (!nosalt) {
                 printf("salt=");
                 for (i = 0; i < (int)sizeof(salt); i++)
                     printf("%02X", salt[i]);
                 printf("\n");
             }
+			if (tag[0]) {
+				printf("tag=");
+				for (i = 0; i < (int)sizeof(tag); i++)
+					printf("%02X", tag[i]);
+				printf("\n");
+			}
             if (EVP_CIPHER_key_length(cipher) > 0) {
                 printf("key=");
                 for (i = 0; i < EVP_CIPHER_key_length(cipher); i++)
@@ -600,6 +687,29 @@
         BIO_printf(bio_err, "bad decrypt\n");
         goto end;
     }
+    if (cipher && (EVP_CIPHER_flags(cipher) & EVP_CIPH_FLAG_AEAD_CIPHER) && enc) {
+        /* Get tag */
+        EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_GET_TAG, 16, tag);
+
+        /* Insert tag to output file */
+        if (!nosalt && str != NULL)
+            offset += sizeof(magic) - 1 + sizeof(salt);
+
+        offset += sizeof(pretag) - 1;
+        (void)BIO_seek(out, offset);
+        if (BIO_write(out, (char *)tag, sizeof(tag)) != sizeof(tag)) {
+            BIO_printf(bio_err, "error writing tag to output file\n");
+            goto end;
+        }
+        if (printkey) {
+            if (!tag[0]) {
+                printf("tag=");
+                for (i = 0; i < (int)sizeof(tag); i++)
+                    printf("%02X", tag[i]);
+                printf("\n");
+            }
+        }
+    }
 
     ret = 0;
     if (verbose) {
@@ -610,6 +720,7 @@
     ERR_print_errors(bio_err);
     OPENSSL_free(strbuf);
     OPENSSL_free(buff);
+	OPENSSL_free(aadbuf);
     BIO_free(in);
     BIO_free_all(out);
     BIO_free(benc);
@@ -633,7 +744,8 @@
     /* Filter out ciphers that we cannot use */
     cipher = EVP_get_cipherbyname(name->name);
     if (cipher == NULL ||
-            (EVP_CIPHER_flags(cipher) & EVP_CIPH_FLAG_AEAD_CIPHER) != 0 ||
+            ((EVP_CIPHER_flags(cipher) & EVP_CIPH_FLAG_AEAD_CIPHER) != 0 &&
+            EVP_CIPHER_mode(cipher) != EVP_CIPH_GCM_MODE) ||
             EVP_CIPHER_mode(cipher) == EVP_CIPH_XTS_MODE)
         return;
 
--- openssl-1.1.1g/test/recipes/20-test_enc_more.t.orig	2020-10-07 08:39:18.438048172 +1000
+++ openssl-1.1.1g/test/recipes/20-test_enc_more.t	2020-10-07 11:32:57.638174905 +1000
@@ -47,7 +47,8 @@
         my $ciphername = substr $cipher, 1;
         my $cipherfile = "$plaintext.$ciphername.cipher";
         my $clearfile = "$plaintext.$ciphername.clear";
-        my @common = ( $cmd, "enc", "$cipher", "-k", "test" );
+        my @common = ( $cmd, "enc", "$cipher", "-k", "test", "-aad", "test");
+
 
         ok(run(app([@common, "-e", "-in", $plaintext, "-out", $cipherfile]))
            && compare_text($plaintext, $cipherfile) != 0
--- openssl-1.1.1g/crypto/evp/build.info.orig	2020-10-07 12:06:04.370199071 +1000
+++ openssl-1.1.1g/crypto/evp/build.info	2020-10-07 12:06:55.954199698 +1000
@@ -1,6 +1,6 @@
 LIBS=../../libcrypto
 SOURCE[../../libcrypto]=\
-        encode.c digest.c evp_enc.c evp_key.c evp_cnf.c \
+        encode.c digest.c evp_enc.c evp_key.c evp_aad.c evp_cnf.c \
         e_des.c e_bf.c e_idea.c e_des3.c e_camellia.c\
         e_rc4.c e_aes.c names.c e_seed.c e_aria.c e_sm4.c \
         e_xcbc_d.c e_rc2.c e_cast.c e_rc5.c \
--- openssl-1.1.1g/doc/man1/enc.pod.orig	2020-10-07 12:08:16.234200675 +1000
+++ openssl-1.1.1g/doc/man1/enc.pod	2020-10-07 12:08:49.746201082 +1000
@@ -20,6 +20,7 @@
 [B<-base64>]
 [B<-A>]
 [B<-k password>]
+[B<-aad arg>]
 [B<-kfile filename>]
 [B<-K key>]
 [B<-iv IV>]
@@ -105,6 +106,10 @@
 The password to derive the key from. This is for compatibility with previous
 versions of OpenSSL. Superseded by the B<-pass> argument.
 
+=item B<-aad arg>
+
+specify the additional authenticated data for AEAD ciphers
+
 =item B<-kfile filename>
 
 Read the password to derive the key from the first line of B<filename>.
@@ -259,8 +264,7 @@
 list of ciphers, supported by your version of OpenSSL, including
 ones provided by configured engines.
 
-The B<enc> program does not support authenticated encryption modes
-like CCM and GCM, and will not support such modes in the future.
+The B<enc> program only supports authenticated encryption mode GCM.
 The B<enc> interface by necessity must begin streaming output (e.g.,
 to standard output when B<-out> is not used) before the authentication
 tag could be validated, leading to the usage of B<enc> in pipelines
@@ -363,6 +367,7 @@
  aes-[128|192|256]-ctr  128/192/256 bit AES in CTR mode
  aes-[128|192|256]-ecb  128/192/256 bit AES in ECB mode
  aes-[128|192|256]-ofb  128/192/256 bit AES in OFB mode
+ aes-[128|192|256]-gcm  128/192/256 bit AES in GCM mode
 
  aria-[128|192|256]-cbc  128/192/256 bit ARIA in CBC mode
  aria[128|192|256]       Alias for aria-[128|192|256]-cbc
--- openssl-1.1.1g/include/openssl/evp.h.orig	2020-10-07 12:09:54.962201875 +1000
+++ openssl-1.1.1g/include/openssl/evp.h	2020-10-07 12:10:06.682202018 +1000
@@ -562,6 +562,10 @@
 __owur int EVP_DigestFinalXOF(EVP_MD_CTX *ctx, unsigned char *md,
                               size_t len);
 
+int EVP_read_aad_string(char *buf, int length, const char *prompt);
+int EVP_read_aad_string_min(char *buf, int minlen, int maxlen,
+                            const char *prompt);
+
 int EVP_read_pw_string(char *buf, int length, const char *prompt, int verify);
 int EVP_read_pw_string_min(char *buf, int minlen, int maxlen,
                            const char *prompt, int verify);
--- openssl-1.1.1g/util/libcrypto.num.orig	2020-10-07 14:10:48.770290106 +1000
+++ openssl-1.1.1g/util/libcrypto.num	2020-10-07 14:12:00.926290984 +1000
@@ -4587,3 +4587,5 @@
 EVP_PKEY_meth_get_digestverify          4541	1_1_1e	EXIST::FUNCTION:
 EVP_PKEY_meth_get_digestsign            4542	1_1_1e	EXIST::FUNCTION:
 RSA_get0_pss_params                     4543	1_1_1e	EXIST::FUNCTION:RSA
+EVP_read_aad_string                     4544    1_1_1e  EXIST::FUNCTION:
+EVP_read_aad_string_min                 4545    1_1_1e  EXIST::FUNCTION:
