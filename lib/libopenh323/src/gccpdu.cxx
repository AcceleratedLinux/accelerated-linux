//
// gccpdu.cxx
//
// Code automatically generated by asnparse.
//

#ifdef P_USE_PRAGMA
#pragma implementation "gccpdu.h"
#endif

#include <ptlib.h>
#include "gccpdu.h"

#define new PNEW


#if ! H323_DISABLE_GCC

//
// ChannelID
//

GCC_ChannelID::GCC_ChannelID(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
}


GCC_ChannelID & GCC_ChannelID::operator=(int v)
{
  SetValue(v);
  return *this;
}


GCC_ChannelID & GCC_ChannelID::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * GCC_ChannelID::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ChannelID::Class()), PInvalidCast);
#endif
  return new GCC_ChannelID(*this);
}


//
// StaticChannelID
//

GCC_StaticChannelID::GCC_StaticChannelID(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 1000);
}


GCC_StaticChannelID & GCC_StaticChannelID::operator=(int v)
{
  SetValue(v);
  return *this;
}


GCC_StaticChannelID & GCC_StaticChannelID::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * GCC_StaticChannelID::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_StaticChannelID::Class()), PInvalidCast);
#endif
  return new GCC_StaticChannelID(*this);
}


//
// DynamicChannelID
//

GCC_DynamicChannelID::GCC_DynamicChannelID(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1001, 65535);
}


GCC_DynamicChannelID & GCC_DynamicChannelID::operator=(int v)
{
  SetValue(v);
  return *this;
}


GCC_DynamicChannelID & GCC_DynamicChannelID::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * GCC_DynamicChannelID::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_DynamicChannelID::Class()), PInvalidCast);
#endif
  return new GCC_DynamicChannelID(*this);
}


//
// UserID
//

GCC_UserID::GCC_UserID(unsigned tag, PASN_Object::TagClass tagClass)
  : GCC_DynamicChannelID(tag, tagClass)
{
}


GCC_UserID & GCC_UserID::operator=(int v)
{
  SetValue(v);
  return *this;
}


GCC_UserID & GCC_UserID::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * GCC_UserID::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_UserID::Class()), PInvalidCast);
#endif
  return new GCC_UserID(*this);
}


//
// TokenID
//

GCC_TokenID::GCC_TokenID(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
}


GCC_TokenID & GCC_TokenID::operator=(int v)
{
  SetValue(v);
  return *this;
}


GCC_TokenID & GCC_TokenID::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * GCC_TokenID::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_TokenID::Class()), PInvalidCast);
#endif
  return new GCC_TokenID(*this);
}


//
// StaticTokenID
//

GCC_StaticTokenID::GCC_StaticTokenID(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 16383);
}


GCC_StaticTokenID & GCC_StaticTokenID::operator=(int v)
{
  SetValue(v);
  return *this;
}


GCC_StaticTokenID & GCC_StaticTokenID::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * GCC_StaticTokenID::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_StaticTokenID::Class()), PInvalidCast);
#endif
  return new GCC_StaticTokenID(*this);
}


//
// DynamicTokenID
//

GCC_DynamicTokenID::GCC_DynamicTokenID(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 16384, 65535);
}


GCC_DynamicTokenID & GCC_DynamicTokenID::operator=(int v)
{
  SetValue(v);
  return *this;
}


GCC_DynamicTokenID & GCC_DynamicTokenID::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * GCC_DynamicTokenID::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_DynamicTokenID::Class()), PInvalidCast);
#endif
  return new GCC_DynamicTokenID(*this);
}


//
// Time
//

GCC_Time::GCC_Time(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, -2147483647, 2147483647);
}


GCC_Time & GCC_Time::operator=(int v)
{
  SetValue(v);
  return *this;
}


GCC_Time & GCC_Time::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * GCC_Time::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_Time::Class()), PInvalidCast);
#endif
  return new GCC_Time(*this);
}


//
// Handle
//

GCC_Handle::GCC_Handle(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 0, 4294967295U);
}


GCC_Handle & GCC_Handle::operator=(int v)
{
  SetValue(v);
  return *this;
}


GCC_Handle & GCC_Handle::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * GCC_Handle::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_Handle::Class()), PInvalidCast);
#endif
  return new GCC_Handle(*this);
}


//
// H221NonStandardIdentifier
//

GCC_H221NonStandardIdentifier::GCC_H221NonStandardIdentifier(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_OctetString(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 4, 255);
}


GCC_H221NonStandardIdentifier::GCC_H221NonStandardIdentifier(const char * v)
{
  SetValue(v);
}


GCC_H221NonStandardIdentifier::GCC_H221NonStandardIdentifier(const PString & v)
{
  SetValue(v);
}


GCC_H221NonStandardIdentifier::GCC_H221NonStandardIdentifier(const PBYTEArray & v)
{
  SetValue(v);
}


GCC_H221NonStandardIdentifier & GCC_H221NonStandardIdentifier::operator=(const char * v)
{
  SetValue(v);
  return *this;
}


GCC_H221NonStandardIdentifier & GCC_H221NonStandardIdentifier::operator=(const PString & v)
{
  SetValue(v);
  return *this;
}


GCC_H221NonStandardIdentifier & GCC_H221NonStandardIdentifier::operator=(const PBYTEArray & v)
{
  SetValue(v);
  return *this;
}


PObject * GCC_H221NonStandardIdentifier::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_H221NonStandardIdentifier::Class()), PInvalidCast);
#endif
  return new GCC_H221NonStandardIdentifier(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_GCC_Key[]={
      {"object",0}
     ,{"h221NonStandard",1}
};
#endif
//
// Key
//

GCC_Key::GCC_Key(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_GCC_Key,2
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_Key::operator GCC_H221NonStandardIdentifier &() const
#else
GCC_Key::operator GCC_H221NonStandardIdentifier &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_H221NonStandardIdentifier), PInvalidCast);
#endif
  return *(GCC_H221NonStandardIdentifier *)choice;
}


GCC_Key::operator const GCC_H221NonStandardIdentifier &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_H221NonStandardIdentifier), PInvalidCast);
#endif
  return *(GCC_H221NonStandardIdentifier *)choice;
}


BOOL GCC_Key::CreateObject()
{
  switch (tag) {
    case e_object :
      choice = new PASN_ObjectId();
      return TRUE;
    case e_h221NonStandard :
      choice = new GCC_H221NonStandardIdentifier();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * GCC_Key::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_Key::Class()), PInvalidCast);
#endif
  return new GCC_Key(*this);
}


//
// NonStandardParameter
//

GCC_NonStandardParameter::GCC_NonStandardParameter(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_NonStandardParameter::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+6) << "key = " << setprecision(indent) << m_key << '\n';
  strm << setw(indent+7) << "data = " << setprecision(indent) << m_data << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_NonStandardParameter::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_NonStandardParameter), PInvalidCast);
#endif
  const GCC_NonStandardParameter & other = (const GCC_NonStandardParameter &)obj;

  Comparison result;

  if ((result = m_key.Compare(other.m_key)) != EqualTo)
    return result;
  if ((result = m_data.Compare(other.m_data)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_NonStandardParameter::GetDataLength() const
{
  PINDEX length = 0;
  length += m_key.GetObjectLength();
  length += m_data.GetObjectLength();
  return length;
}


BOOL GCC_NonStandardParameter::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_key.Decode(strm))
    return FALSE;
  if (!m_data.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_NonStandardParameter::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_key.Encode(strm);
  m_data.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_NonStandardParameter::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_NonStandardParameter::Class()), PInvalidCast);
#endif
  return new GCC_NonStandardParameter(*this);
}


//
// TextString
//

GCC_TextString::GCC_TextString(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_BMPString(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


GCC_TextString & GCC_TextString::operator=(const char * v)
{
  SetValue(v);
  return *this;
}


GCC_TextString & GCC_TextString::operator=(const PString & v)
{
  SetValue(v);
  return *this;
}


GCC_TextString & GCC_TextString::operator=(const PWORDArray & v)
{
  SetValue(v);
  return *this;
}


GCC_TextString & GCC_TextString::operator=(const PASN_BMPString & v)
{
  SetValue(v);
  return *this;
}


PObject * GCC_TextString::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_TextString::Class()), PInvalidCast);
#endif
  return new GCC_TextString(*this);
}


//
// SimpleTextString
//

GCC_SimpleTextString::GCC_SimpleTextString(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_BMPString(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 0, 255);
  SetCharacterSet(PASN_Object::FixedConstraint, 0, 255);
}


GCC_SimpleTextString & GCC_SimpleTextString::operator=(const char * v)
{
  SetValue(v);
  return *this;
}


GCC_SimpleTextString & GCC_SimpleTextString::operator=(const PString & v)
{
  SetValue(v);
  return *this;
}


GCC_SimpleTextString & GCC_SimpleTextString::operator=(const PWORDArray & v)
{
  SetValue(v);
  return *this;
}


GCC_SimpleTextString & GCC_SimpleTextString::operator=(const PASN_BMPString & v)
{
  SetValue(v);
  return *this;
}


PObject * GCC_SimpleTextString::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_SimpleTextString::Class()), PInvalidCast);
#endif
  return new GCC_SimpleTextString(*this);
}


//
// SimpleNumericString
//

GCC_SimpleNumericString::GCC_SimpleNumericString(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_NumericString(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 255);
  SetCharacterSet(PASN_Object::FixedConstraint, "0123456789");
}


GCC_SimpleNumericString & GCC_SimpleNumericString::operator=(const char * v)
{
  SetValue(v);
  return *this;
}


GCC_SimpleNumericString & GCC_SimpleNumericString::operator=(const PString & v)
{
  SetValue(v);
  return *this;
}


PObject * GCC_SimpleNumericString::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_SimpleNumericString::Class()), PInvalidCast);
#endif
  return new GCC_SimpleNumericString(*this);
}


//
// DialingString
//

GCC_DialingString::GCC_DialingString(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_NumericString(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 16);
  SetCharacterSet(PASN_Object::FixedConstraint, "0123456789");
}


GCC_DialingString & GCC_DialingString::operator=(const char * v)
{
  SetValue(v);
  return *this;
}


GCC_DialingString & GCC_DialingString::operator=(const PString & v)
{
  SetValue(v);
  return *this;
}


PObject * GCC_DialingString::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_DialingString::Class()), PInvalidCast);
#endif
  return new GCC_DialingString(*this);
}


//
// SubAddressString
//

GCC_SubAddressString::GCC_SubAddressString(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_NumericString(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 40);
  SetCharacterSet(PASN_Object::FixedConstraint, "0123456789");
}


GCC_SubAddressString & GCC_SubAddressString::operator=(const char * v)
{
  SetValue(v);
  return *this;
}


GCC_SubAddressString & GCC_SubAddressString::operator=(const PString & v)
{
  SetValue(v);
  return *this;
}


PObject * GCC_SubAddressString::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_SubAddressString::Class()), PInvalidCast);
#endif
  return new GCC_SubAddressString(*this);
}


//
// ExtraDialingString
//

GCC_ExtraDialingString::GCC_ExtraDialingString(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_BMPString(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 255);
  SetCharacterSet(PASN_Object::FixedConstraint, "0123456789#*,");
}


GCC_ExtraDialingString & GCC_ExtraDialingString::operator=(const char * v)
{
  SetValue(v);
  return *this;
}


GCC_ExtraDialingString & GCC_ExtraDialingString::operator=(const PString & v)
{
  SetValue(v);
  return *this;
}


GCC_ExtraDialingString & GCC_ExtraDialingString::operator=(const PWORDArray & v)
{
  SetValue(v);
  return *this;
}


GCC_ExtraDialingString & GCC_ExtraDialingString::operator=(const PASN_BMPString & v)
{
  SetValue(v);
  return *this;
}


PObject * GCC_ExtraDialingString::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ExtraDialingString::Class()), PInvalidCast);
#endif
  return new GCC_ExtraDialingString(*this);
}


//
// UserData
//

GCC_UserData::GCC_UserData(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * GCC_UserData::CreateObject() const
{
  return new GCC_UserData_subtype;
}


GCC_UserData_subtype & GCC_UserData::operator[](PINDEX i) const
{
  return (GCC_UserData_subtype &)array[i];
}


PObject * GCC_UserData::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_UserData::Class()), PInvalidCast);
#endif
  return new GCC_UserData(*this);
}


//
// Password
//

GCC_Password::GCC_Password(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_Password::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+10) << "numeric = " << setprecision(indent) << m_numeric << '\n';
  if (HasOptionalField(e_text))
    strm << setw(indent+7) << "text = " << setprecision(indent) << m_text << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_Password::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_Password), PInvalidCast);
#endif
  const GCC_Password & other = (const GCC_Password &)obj;

  Comparison result;

  if ((result = m_numeric.Compare(other.m_numeric)) != EqualTo)
    return result;
  if ((result = m_text.Compare(other.m_text)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_Password::GetDataLength() const
{
  PINDEX length = 0;
  length += m_numeric.GetObjectLength();
  if (HasOptionalField(e_text))
    length += m_text.GetObjectLength();
  return length;
}


BOOL GCC_Password::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_numeric.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_text) && !m_text.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_Password::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_numeric.Encode(strm);
  if (HasOptionalField(e_text))
    m_text.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_Password::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_Password::Class()), PInvalidCast);
#endif
  return new GCC_Password(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_GCC_PasswordSelector[]={
      {"numeric",0}
     ,{"text",1}
};
#endif
//
// PasswordSelector
//

GCC_PasswordSelector::GCC_PasswordSelector(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_GCC_PasswordSelector,2
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_PasswordSelector::operator GCC_SimpleNumericString &() const
#else
GCC_PasswordSelector::operator GCC_SimpleNumericString &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_SimpleNumericString), PInvalidCast);
#endif
  return *(GCC_SimpleNumericString *)choice;
}


GCC_PasswordSelector::operator const GCC_SimpleNumericString &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_SimpleNumericString), PInvalidCast);
#endif
  return *(GCC_SimpleNumericString *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_PasswordSelector::operator GCC_SimpleTextString &() const
#else
GCC_PasswordSelector::operator GCC_SimpleTextString &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_SimpleTextString), PInvalidCast);
#endif
  return *(GCC_SimpleTextString *)choice;
}


GCC_PasswordSelector::operator const GCC_SimpleTextString &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_SimpleTextString), PInvalidCast);
#endif
  return *(GCC_SimpleTextString *)choice;
}


BOOL GCC_PasswordSelector::CreateObject()
{
  switch (tag) {
    case e_numeric :
      choice = new GCC_SimpleNumericString();
      return TRUE;
    case e_text :
      choice = new GCC_SimpleTextString();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * GCC_PasswordSelector::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_PasswordSelector::Class()), PInvalidCast);
#endif
  return new GCC_PasswordSelector(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_GCC_ChallengeResponseItem[]={
      {"passwordString",0}
     ,{"responseData",1}
};
#endif
//
// ChallengeResponseItem
//

GCC_ChallengeResponseItem::GCC_ChallengeResponseItem(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_GCC_ChallengeResponseItem,2
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_ChallengeResponseItem::operator GCC_PasswordSelector &() const
#else
GCC_ChallengeResponseItem::operator GCC_PasswordSelector &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_PasswordSelector), PInvalidCast);
#endif
  return *(GCC_PasswordSelector *)choice;
}


GCC_ChallengeResponseItem::operator const GCC_PasswordSelector &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_PasswordSelector), PInvalidCast);
#endif
  return *(GCC_PasswordSelector *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_ChallengeResponseItem::operator GCC_UserData &() const
#else
GCC_ChallengeResponseItem::operator GCC_UserData &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_UserData), PInvalidCast);
#endif
  return *(GCC_UserData *)choice;
}


GCC_ChallengeResponseItem::operator const GCC_UserData &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_UserData), PInvalidCast);
#endif
  return *(GCC_UserData *)choice;
}


BOOL GCC_ChallengeResponseItem::CreateObject()
{
  switch (tag) {
    case e_passwordString :
      choice = new GCC_PasswordSelector();
      return TRUE;
    case e_responseData :
      choice = new GCC_UserData();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * GCC_ChallengeResponseItem::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ChallengeResponseItem::Class()), PInvalidCast);
#endif
  return new GCC_ChallengeResponseItem(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_GCC_ChallengeResponseAlgorithm[]={
      {"passwordInTheClear",0}
     ,{"nonStandardAlgorithm",1}
};
#endif
//
// ChallengeResponseAlgorithm
//

GCC_ChallengeResponseAlgorithm::GCC_ChallengeResponseAlgorithm(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_GCC_ChallengeResponseAlgorithm,2
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_ChallengeResponseAlgorithm::operator GCC_NonStandardParameter &() const
#else
GCC_ChallengeResponseAlgorithm::operator GCC_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_NonStandardParameter), PInvalidCast);
#endif
  return *(GCC_NonStandardParameter *)choice;
}


GCC_ChallengeResponseAlgorithm::operator const GCC_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_NonStandardParameter), PInvalidCast);
#endif
  return *(GCC_NonStandardParameter *)choice;
}


BOOL GCC_ChallengeResponseAlgorithm::CreateObject()
{
  switch (tag) {
    case e_passwordInTheClear :
      choice = new PASN_Null();
      return TRUE;
    case e_nonStandardAlgorithm :
      choice = new GCC_NonStandardParameter();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * GCC_ChallengeResponseAlgorithm::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ChallengeResponseAlgorithm::Class()), PInvalidCast);
#endif
  return new GCC_ChallengeResponseAlgorithm(*this);
}


//
// ChallengeItem
//

GCC_ChallengeItem::GCC_ChallengeItem(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_ChallengeItem::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+20) << "responseAlgorithm = " << setprecision(indent) << m_responseAlgorithm << '\n';
  strm << setw(indent+16) << "challengeData = " << setprecision(indent) << m_challengeData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_ChallengeItem::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_ChallengeItem), PInvalidCast);
#endif
  const GCC_ChallengeItem & other = (const GCC_ChallengeItem &)obj;

  Comparison result;

  if ((result = m_responseAlgorithm.Compare(other.m_responseAlgorithm)) != EqualTo)
    return result;
  if ((result = m_challengeData.Compare(other.m_challengeData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_ChallengeItem::GetDataLength() const
{
  PINDEX length = 0;
  length += m_responseAlgorithm.GetObjectLength();
  length += m_challengeData.GetObjectLength();
  return length;
}


BOOL GCC_ChallengeItem::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_responseAlgorithm.Decode(strm))
    return FALSE;
  if (!m_challengeData.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_ChallengeItem::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_responseAlgorithm.Encode(strm);
  m_challengeData.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_ChallengeItem::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ChallengeItem::Class()), PInvalidCast);
#endif
  return new GCC_ChallengeItem(*this);
}


//
// ChallengeResponse
//

GCC_ChallengeResponse::GCC_ChallengeResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_ChallengeResponse::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "challengeTag = " << setprecision(indent) << m_challengeTag << '\n';
  strm << setw(indent+20) << "responseAlgorithm = " << setprecision(indent) << m_responseAlgorithm << '\n';
  strm << setw(indent+15) << "responseItem = " << setprecision(indent) << m_responseItem << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_ChallengeResponse::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_ChallengeResponse), PInvalidCast);
#endif
  const GCC_ChallengeResponse & other = (const GCC_ChallengeResponse &)obj;

  Comparison result;

  if ((result = m_challengeTag.Compare(other.m_challengeTag)) != EqualTo)
    return result;
  if ((result = m_responseAlgorithm.Compare(other.m_responseAlgorithm)) != EqualTo)
    return result;
  if ((result = m_responseItem.Compare(other.m_responseItem)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_ChallengeResponse::GetDataLength() const
{
  PINDEX length = 0;
  length += m_challengeTag.GetObjectLength();
  length += m_responseAlgorithm.GetObjectLength();
  length += m_responseItem.GetObjectLength();
  return length;
}


BOOL GCC_ChallengeResponse::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_challengeTag.Decode(strm))
    return FALSE;
  if (!m_responseAlgorithm.Decode(strm))
    return FALSE;
  if (!m_responseItem.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_ChallengeResponse::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_challengeTag.Encode(strm);
  m_responseAlgorithm.Encode(strm);
  m_responseItem.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_ChallengeResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ChallengeResponse::Class()), PInvalidCast);
#endif
  return new GCC_ChallengeResponse(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_GCC_PasswordChallengeRequestResponse[]={
      {"passwordInTheClear",0}
     ,{"challengeRequestResponse",1}
};
#endif
//
// PasswordChallengeRequestResponse
//

GCC_PasswordChallengeRequestResponse::GCC_PasswordChallengeRequestResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_GCC_PasswordChallengeRequestResponse,2
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_PasswordChallengeRequestResponse::operator GCC_PasswordSelector &() const
#else
GCC_PasswordChallengeRequestResponse::operator GCC_PasswordSelector &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_PasswordSelector), PInvalidCast);
#endif
  return *(GCC_PasswordSelector *)choice;
}


GCC_PasswordChallengeRequestResponse::operator const GCC_PasswordSelector &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_PasswordSelector), PInvalidCast);
#endif
  return *(GCC_PasswordSelector *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_PasswordChallengeRequestResponse::operator GCC_PasswordChallengeRequestResponse_challengeRequestResponse &() const
#else
GCC_PasswordChallengeRequestResponse::operator GCC_PasswordChallengeRequestResponse_challengeRequestResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_PasswordChallengeRequestResponse_challengeRequestResponse), PInvalidCast);
#endif
  return *(GCC_PasswordChallengeRequestResponse_challengeRequestResponse *)choice;
}


GCC_PasswordChallengeRequestResponse::operator const GCC_PasswordChallengeRequestResponse_challengeRequestResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_PasswordChallengeRequestResponse_challengeRequestResponse), PInvalidCast);
#endif
  return *(GCC_PasswordChallengeRequestResponse_challengeRequestResponse *)choice;
}


BOOL GCC_PasswordChallengeRequestResponse::CreateObject()
{
  switch (tag) {
    case e_passwordInTheClear :
      choice = new GCC_PasswordSelector();
      return TRUE;
    case e_challengeRequestResponse :
      choice = new GCC_PasswordChallengeRequestResponse_challengeRequestResponse();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * GCC_PasswordChallengeRequestResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_PasswordChallengeRequestResponse::Class()), PInvalidCast);
#endif
  return new GCC_PasswordChallengeRequestResponse(*this);
}


//
// ConferenceName
//

GCC_ConferenceName::GCC_ConferenceName(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_ConferenceName::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+10) << "numeric = " << setprecision(indent) << m_numeric << '\n';
  if (HasOptionalField(e_text))
    strm << setw(indent+7) << "text = " << setprecision(indent) << m_text << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_ConferenceName::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_ConferenceName), PInvalidCast);
#endif
  const GCC_ConferenceName & other = (const GCC_ConferenceName &)obj;

  Comparison result;

  if ((result = m_numeric.Compare(other.m_numeric)) != EqualTo)
    return result;
  if ((result = m_text.Compare(other.m_text)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_ConferenceName::GetDataLength() const
{
  PINDEX length = 0;
  length += m_numeric.GetObjectLength();
  if (HasOptionalField(e_text))
    length += m_text.GetObjectLength();
  return length;
}


BOOL GCC_ConferenceName::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_numeric.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_text) && !m_text.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_ConferenceName::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_numeric.Encode(strm);
  if (HasOptionalField(e_text))
    m_text.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_ConferenceName::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferenceName::Class()), PInvalidCast);
#endif
  return new GCC_ConferenceName(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_GCC_ConferenceNameSelector[]={
      {"numeric",0}
     ,{"text",1}
};
#endif
//
// ConferenceNameSelector
//

GCC_ConferenceNameSelector::GCC_ConferenceNameSelector(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_GCC_ConferenceNameSelector,2
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_ConferenceNameSelector::operator GCC_SimpleNumericString &() const
#else
GCC_ConferenceNameSelector::operator GCC_SimpleNumericString &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_SimpleNumericString), PInvalidCast);
#endif
  return *(GCC_SimpleNumericString *)choice;
}


GCC_ConferenceNameSelector::operator const GCC_SimpleNumericString &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_SimpleNumericString), PInvalidCast);
#endif
  return *(GCC_SimpleNumericString *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_ConferenceNameSelector::operator GCC_SimpleTextString &() const
#else
GCC_ConferenceNameSelector::operator GCC_SimpleTextString &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_SimpleTextString), PInvalidCast);
#endif
  return *(GCC_SimpleTextString *)choice;
}


GCC_ConferenceNameSelector::operator const GCC_SimpleTextString &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_SimpleTextString), PInvalidCast);
#endif
  return *(GCC_SimpleTextString *)choice;
}


BOOL GCC_ConferenceNameSelector::CreateObject()
{
  switch (tag) {
    case e_numeric :
      choice = new GCC_SimpleNumericString();
      return TRUE;
    case e_text :
      choice = new GCC_SimpleTextString();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * GCC_ConferenceNameSelector::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferenceNameSelector::Class()), PInvalidCast);
#endif
  return new GCC_ConferenceNameSelector(*this);
}


//
// ConferenceNameModifier
//

GCC_ConferenceNameModifier::GCC_ConferenceNameModifier(unsigned tag, PASN_Object::TagClass tagClass)
  : GCC_SimpleNumericString(tag, tagClass)
{
}


GCC_ConferenceNameModifier & GCC_ConferenceNameModifier::operator=(const char * v)
{
  SetValue(v);
  return *this;
}


GCC_ConferenceNameModifier & GCC_ConferenceNameModifier::operator=(const PString & v)
{
  SetValue(v);
  return *this;
}


PObject * GCC_ConferenceNameModifier::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferenceNameModifier::Class()), PInvalidCast);
#endif
  return new GCC_ConferenceNameModifier(*this);
}


#ifndef PASN_NOPRINTON
const static PASN_Names Names_GCC_Privilege[]={
        {"terminate",0}
       ,{"ejectUser",1}
       ,{"add",2}
       ,{"lockUnlock",3}
       ,{"transfer",4}
};
#endif
//
// Privilege
//

GCC_Privilege::GCC_Privilege(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_GCC_Privilege,5
#endif
    )
{
}


GCC_Privilege & GCC_Privilege::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * GCC_Privilege::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_Privilege::Class()), PInvalidCast);
#endif
  return new GCC_Privilege(*this);
}


#ifndef PASN_NOPRINTON
const static PASN_Names Names_GCC_TerminationMethod[]={
        {"automatic",0}
       ,{"manual",1}
};
#endif
//
// TerminationMethod
//

GCC_TerminationMethod::GCC_TerminationMethod(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 1, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_GCC_TerminationMethod,2
#endif
    )
{
}


GCC_TerminationMethod & GCC_TerminationMethod::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * GCC_TerminationMethod::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_TerminationMethod::Class()), PInvalidCast);
#endif
  return new GCC_TerminationMethod(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_GCC_ConferencePriorityScheme[]={
      {"nonStandardScheme",0}
};
#endif
//
// ConferencePriorityScheme
//

GCC_ConferencePriorityScheme::GCC_ConferencePriorityScheme(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 1, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_GCC_ConferencePriorityScheme,1
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_ConferencePriorityScheme::operator GCC_NonStandardParameter &() const
#else
GCC_ConferencePriorityScheme::operator GCC_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_NonStandardParameter), PInvalidCast);
#endif
  return *(GCC_NonStandardParameter *)choice;
}


GCC_ConferencePriorityScheme::operator const GCC_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_NonStandardParameter), PInvalidCast);
#endif
  return *(GCC_NonStandardParameter *)choice;
}


BOOL GCC_ConferencePriorityScheme::CreateObject()
{
  switch (tag) {
    case e_nonStandardScheme :
      choice = new GCC_NonStandardParameter();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * GCC_ConferencePriorityScheme::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferencePriorityScheme::Class()), PInvalidCast);
#endif
  return new GCC_ConferencePriorityScheme(*this);
}


//
// ConferencePriority
//

GCC_ConferencePriority::GCC_ConferencePriority(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_priority.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void GCC_ConferencePriority::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "priority = " << setprecision(indent) << m_priority << '\n';
  strm << setw(indent+9) << "scheme = " << setprecision(indent) << m_scheme << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_ConferencePriority::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_ConferencePriority), PInvalidCast);
#endif
  const GCC_ConferencePriority & other = (const GCC_ConferencePriority &)obj;

  Comparison result;

  if ((result = m_priority.Compare(other.m_priority)) != EqualTo)
    return result;
  if ((result = m_scheme.Compare(other.m_scheme)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_ConferencePriority::GetDataLength() const
{
  PINDEX length = 0;
  length += m_priority.GetObjectLength();
  length += m_scheme.GetObjectLength();
  return length;
}


BOOL GCC_ConferencePriority::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_priority.Decode(strm))
    return FALSE;
  if (!m_scheme.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_ConferencePriority::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_priority.Encode(strm);
  m_scheme.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_ConferencePriority::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferencePriority::Class()), PInvalidCast);
#endif
  return new GCC_ConferencePriority(*this);
}


//
// NetworkAddress
//

GCC_NetworkAddress::GCC_NetworkAddress(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 64);
}


PASN_Object * GCC_NetworkAddress::CreateObject() const
{
  return new GCC_NetworkAddress_subtype;
}


GCC_NetworkAddress_subtype & GCC_NetworkAddress::operator[](PINDEX i) const
{
  return (GCC_NetworkAddress_subtype &)array[i];
}


PObject * GCC_NetworkAddress::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_NetworkAddress::Class()), PInvalidCast);
#endif
  return new GCC_NetworkAddress(*this);
}


#ifndef PASN_NOPRINTON
const static PASN_Names Names_GCC_NodeType[]={
        {"terminal",0}
       ,{"multiportTerminal",1}
       ,{"mcu",2}
};
#endif
//
// NodeType
//

GCC_NodeType::GCC_NodeType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_GCC_NodeType,3
#endif
    )
{
}


GCC_NodeType & GCC_NodeType::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * GCC_NodeType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_NodeType::Class()), PInvalidCast);
#endif
  return new GCC_NodeType(*this);
}


//
// NodeProperties
//

GCC_NodeProperties::GCC_NodeProperties(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_NodeProperties::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+19) << "managementDevice = " << setprecision(indent) << m_managementDevice << '\n';
  strm << setw(indent+19) << "peripheralDevice = " << setprecision(indent) << m_peripheralDevice << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_NodeProperties::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_NodeProperties), PInvalidCast);
#endif
  const GCC_NodeProperties & other = (const GCC_NodeProperties &)obj;

  Comparison result;

  if ((result = m_managementDevice.Compare(other.m_managementDevice)) != EqualTo)
    return result;
  if ((result = m_peripheralDevice.Compare(other.m_peripheralDevice)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_NodeProperties::GetDataLength() const
{
  PINDEX length = 0;
  length += m_managementDevice.GetObjectLength();
  length += m_peripheralDevice.GetObjectLength();
  return length;
}


BOOL GCC_NodeProperties::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_managementDevice.Decode(strm))
    return FALSE;
  if (!m_peripheralDevice.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_NodeProperties::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_managementDevice.Encode(strm);
  m_peripheralDevice.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_NodeProperties::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_NodeProperties::Class()), PInvalidCast);
#endif
  return new GCC_NodeProperties(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_GCC_AsymmetryIndicator[]={
      {"callingNode",0}
     ,{"calledNode",1}
     ,{"unknown",2}
};
#endif
//
// AsymmetryIndicator
//

GCC_AsymmetryIndicator::GCC_AsymmetryIndicator(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_GCC_AsymmetryIndicator,3
#endif
)
{
}


BOOL GCC_AsymmetryIndicator::CreateObject()
{
  switch (tag) {
    case e_callingNode :
    case e_calledNode :
      choice = new PASN_Null();
      return TRUE;
    case e_unknown :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 0, 4294967295U);
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * GCC_AsymmetryIndicator::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_AsymmetryIndicator::Class()), PInvalidCast);
#endif
  return new GCC_AsymmetryIndicator(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_GCC_AlternativeNodeID[]={
      {"h243NodeID",0}
};
#endif
//
// AlternativeNodeID
//

GCC_AlternativeNodeID::GCC_AlternativeNodeID(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 1, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_GCC_AlternativeNodeID,1
#endif
)
{
}


BOOL GCC_AlternativeNodeID::CreateObject()
{
  switch (tag) {
    case e_h243NodeID :
      choice = new PASN_OctetString();
      choice->SetConstraints(PASN_Object::FixedConstraint, 2);
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * GCC_AlternativeNodeID::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_AlternativeNodeID::Class()), PInvalidCast);
#endif
  return new GCC_AlternativeNodeID(*this);
}


//
// ConferenceDescriptor
//

GCC_ConferenceDescriptor::GCC_ConferenceDescriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 1)
{
  IncludeOptionalField(e_defaultConferenceFlag);
}


#ifndef PASN_NOPRINTON
void GCC_ConferenceDescriptor::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "conferenceName = " << setprecision(indent) << m_conferenceName << '\n';
  if (HasOptionalField(e_conferenceNameModifier))
    strm << setw(indent+25) << "conferenceNameModifier = " << setprecision(indent) << m_conferenceNameModifier << '\n';
  if (HasOptionalField(e_conferenceDescription))
    strm << setw(indent+24) << "conferenceDescription = " << setprecision(indent) << m_conferenceDescription << '\n';
  strm << setw(indent+19) << "lockedConference = " << setprecision(indent) << m_lockedConference << '\n';
  strm << setw(indent+29) << "passwordInTheClearRequired = " << setprecision(indent) << m_passwordInTheClearRequired << '\n';
  if (HasOptionalField(e_networkAddress))
    strm << setw(indent+17) << "networkAddress = " << setprecision(indent) << m_networkAddress << '\n';
  if (HasOptionalField(e_defaultConferenceFlag))
    strm << setw(indent+24) << "defaultConferenceFlag = " << setprecision(indent) << m_defaultConferenceFlag << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_ConferenceDescriptor::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_ConferenceDescriptor), PInvalidCast);
#endif
  const GCC_ConferenceDescriptor & other = (const GCC_ConferenceDescriptor &)obj;

  Comparison result;

  if ((result = m_conferenceName.Compare(other.m_conferenceName)) != EqualTo)
    return result;
  if ((result = m_conferenceNameModifier.Compare(other.m_conferenceNameModifier)) != EqualTo)
    return result;
  if ((result = m_conferenceDescription.Compare(other.m_conferenceDescription)) != EqualTo)
    return result;
  if ((result = m_lockedConference.Compare(other.m_lockedConference)) != EqualTo)
    return result;
  if ((result = m_passwordInTheClearRequired.Compare(other.m_passwordInTheClearRequired)) != EqualTo)
    return result;
  if ((result = m_networkAddress.Compare(other.m_networkAddress)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_ConferenceDescriptor::GetDataLength() const
{
  PINDEX length = 0;
  length += m_conferenceName.GetObjectLength();
  if (HasOptionalField(e_conferenceNameModifier))
    length += m_conferenceNameModifier.GetObjectLength();
  if (HasOptionalField(e_conferenceDescription))
    length += m_conferenceDescription.GetObjectLength();
  length += m_lockedConference.GetObjectLength();
  length += m_passwordInTheClearRequired.GetObjectLength();
  if (HasOptionalField(e_networkAddress))
    length += m_networkAddress.GetObjectLength();
  return length;
}


BOOL GCC_ConferenceDescriptor::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_conferenceName.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_conferenceNameModifier) && !m_conferenceNameModifier.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_conferenceDescription) && !m_conferenceDescription.Decode(strm))
    return FALSE;
  if (!m_lockedConference.Decode(strm))
    return FALSE;
  if (!m_passwordInTheClearRequired.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_networkAddress) && !m_networkAddress.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_defaultConferenceFlag, m_defaultConferenceFlag))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_ConferenceDescriptor::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_conferenceName.Encode(strm);
  if (HasOptionalField(e_conferenceNameModifier))
    m_conferenceNameModifier.Encode(strm);
  if (HasOptionalField(e_conferenceDescription))
    m_conferenceDescription.Encode(strm);
  m_lockedConference.Encode(strm);
  m_passwordInTheClearRequired.Encode(strm);
  if (HasOptionalField(e_networkAddress))
    m_networkAddress.Encode(strm);
  KnownExtensionEncode(strm, e_defaultConferenceFlag, m_defaultConferenceFlag);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_ConferenceDescriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferenceDescriptor::Class()), PInvalidCast);
#endif
  return new GCC_ConferenceDescriptor(*this);
}


//
// SessionKey
//

GCC_SessionKey::GCC_SessionKey(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_SessionKey::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+25) << "applicationProtocolKey = " << setprecision(indent) << m_applicationProtocolKey << '\n';
  if (HasOptionalField(e_sessionID))
    strm << setw(indent+12) << "sessionID = " << setprecision(indent) << m_sessionID << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_SessionKey::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_SessionKey), PInvalidCast);
#endif
  const GCC_SessionKey & other = (const GCC_SessionKey &)obj;

  Comparison result;

  if ((result = m_applicationProtocolKey.Compare(other.m_applicationProtocolKey)) != EqualTo)
    return result;
  if ((result = m_sessionID.Compare(other.m_sessionID)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_SessionKey::GetDataLength() const
{
  PINDEX length = 0;
  length += m_applicationProtocolKey.GetObjectLength();
  if (HasOptionalField(e_sessionID))
    length += m_sessionID.GetObjectLength();
  return length;
}


BOOL GCC_SessionKey::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_applicationProtocolKey.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_sessionID) && !m_sessionID.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_SessionKey::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_applicationProtocolKey.Encode(strm);
  if (HasOptionalField(e_sessionID))
    m_sessionID.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_SessionKey::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_SessionKey::Class()), PInvalidCast);
#endif
  return new GCC_SessionKey(*this);
}


#ifndef PASN_NOPRINTON
const static PASN_Names Names_GCC_ChannelType[]={
        {"static",0}
       ,{"dynamicMulticast",1}
       ,{"dynamicPrivate",2}
       ,{"dynamicUserId",3}
};
#endif
//
// ChannelType
//

GCC_ChannelType::GCC_ChannelType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 3, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_GCC_ChannelType,4
#endif
    )
{
}


GCC_ChannelType & GCC_ChannelType::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * GCC_ChannelType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ChannelType::Class()), PInvalidCast);
#endif
  return new GCC_ChannelType(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_GCC_CapabilityID[]={
      {"standard",0}
     ,{"nonStandard",1}
};
#endif
//
// CapabilityID
//

GCC_CapabilityID::GCC_CapabilityID(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_GCC_CapabilityID,2
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_CapabilityID::operator GCC_Key &() const
#else
GCC_CapabilityID::operator GCC_Key &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_Key), PInvalidCast);
#endif
  return *(GCC_Key *)choice;
}


GCC_CapabilityID::operator const GCC_Key &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_Key), PInvalidCast);
#endif
  return *(GCC_Key *)choice;
}


BOOL GCC_CapabilityID::CreateObject()
{
  switch (tag) {
    case e_standard :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
      return TRUE;
    case e_nonStandard :
      choice = new GCC_Key();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * GCC_CapabilityID::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_CapabilityID::Class()), PInvalidCast);
#endif
  return new GCC_CapabilityID(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_GCC_CapabilityClass[]={
      {"logical",0}
     ,{"unsignedMin",1}
     ,{"unsignedMax",2}
};
#endif
//
// CapabilityClass
//

GCC_CapabilityClass::GCC_CapabilityClass(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_GCC_CapabilityClass,3
#endif
)
{
}


BOOL GCC_CapabilityClass::CreateObject()
{
  switch (tag) {
    case e_logical :
      choice = new PASN_Null();
      return TRUE;
    case e_unsignedMin :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 0, MaximumValue);
      return TRUE;
    case e_unsignedMax :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 0, MaximumValue);
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * GCC_CapabilityClass::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_CapabilityClass::Class()), PInvalidCast);
#endif
  return new GCC_CapabilityClass(*this);
}


//
// EntityID
//

GCC_EntityID::GCC_EntityID(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


GCC_EntityID & GCC_EntityID::operator=(int v)
{
  SetValue(v);
  return *this;
}


GCC_EntityID & GCC_EntityID::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * GCC_EntityID::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_EntityID::Class()), PInvalidCast);
#endif
  return new GCC_EntityID(*this);
}


//
// RegistryKey
//

GCC_RegistryKey::GCC_RegistryKey(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
  m_resourceID.SetConstraints(PASN_Object::FixedConstraint, 0, 64);
}


#ifndef PASN_NOPRINTON
void GCC_RegistryKey::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+13) << "sessionKey = " << setprecision(indent) << m_sessionKey << '\n';
  strm << setw(indent+13) << "resourceID = " << setprecision(indent) << m_resourceID << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_RegistryKey::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_RegistryKey), PInvalidCast);
#endif
  const GCC_RegistryKey & other = (const GCC_RegistryKey &)obj;

  Comparison result;

  if ((result = m_sessionKey.Compare(other.m_sessionKey)) != EqualTo)
    return result;
  if ((result = m_resourceID.Compare(other.m_resourceID)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_RegistryKey::GetDataLength() const
{
  PINDEX length = 0;
  length += m_sessionKey.GetObjectLength();
  length += m_resourceID.GetObjectLength();
  return length;
}


BOOL GCC_RegistryKey::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_sessionKey.Decode(strm))
    return FALSE;
  if (!m_resourceID.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_RegistryKey::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_sessionKey.Encode(strm);
  m_resourceID.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_RegistryKey::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_RegistryKey::Class()), PInvalidCast);
#endif
  return new GCC_RegistryKey(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_GCC_RegistryItem[]={
      {"channelID",0}
     ,{"tokenID",1}
     ,{"parameter",2}
     ,{"vacant",3}
};
#endif
//
// RegistryItem
//

GCC_RegistryItem::GCC_RegistryItem(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_GCC_RegistryItem,4
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_RegistryItem::operator GCC_DynamicChannelID &() const
#else
GCC_RegistryItem::operator GCC_DynamicChannelID &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_DynamicChannelID), PInvalidCast);
#endif
  return *(GCC_DynamicChannelID *)choice;
}


GCC_RegistryItem::operator const GCC_DynamicChannelID &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_DynamicChannelID), PInvalidCast);
#endif
  return *(GCC_DynamicChannelID *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_RegistryItem::operator GCC_DynamicTokenID &() const
#else
GCC_RegistryItem::operator GCC_DynamicTokenID &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_DynamicTokenID), PInvalidCast);
#endif
  return *(GCC_DynamicTokenID *)choice;
}


GCC_RegistryItem::operator const GCC_DynamicTokenID &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_DynamicTokenID), PInvalidCast);
#endif
  return *(GCC_DynamicTokenID *)choice;
}


BOOL GCC_RegistryItem::CreateObject()
{
  switch (tag) {
    case e_channelID :
      choice = new GCC_DynamicChannelID();
      return TRUE;
    case e_tokenID :
      choice = new GCC_DynamicTokenID();
      return TRUE;
    case e_parameter :
      choice = new PASN_OctetString();
      choice->SetConstraints(PASN_Object::FixedConstraint, 0, 64);
      return TRUE;
    case e_vacant :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * GCC_RegistryItem::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_RegistryItem::Class()), PInvalidCast);
#endif
  return new GCC_RegistryItem(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_GCC_RegistryEntryOwner[]={
      {"owned",0}
     ,{"notOwned",1}
};
#endif
//
// RegistryEntryOwner
//

GCC_RegistryEntryOwner::GCC_RegistryEntryOwner(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_GCC_RegistryEntryOwner,2
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_RegistryEntryOwner::operator GCC_RegistryEntryOwner_owned &() const
#else
GCC_RegistryEntryOwner::operator GCC_RegistryEntryOwner_owned &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_RegistryEntryOwner_owned), PInvalidCast);
#endif
  return *(GCC_RegistryEntryOwner_owned *)choice;
}


GCC_RegistryEntryOwner::operator const GCC_RegistryEntryOwner_owned &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_RegistryEntryOwner_owned), PInvalidCast);
#endif
  return *(GCC_RegistryEntryOwner_owned *)choice;
}


BOOL GCC_RegistryEntryOwner::CreateObject()
{
  switch (tag) {
    case e_owned :
      choice = new GCC_RegistryEntryOwner_owned();
      return TRUE;
    case e_notOwned :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * GCC_RegistryEntryOwner::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_RegistryEntryOwner::Class()), PInvalidCast);
#endif
  return new GCC_RegistryEntryOwner(*this);
}


#ifndef PASN_NOPRINTON
const static PASN_Names Names_GCC_RegistryModificationRights[]={
        {"owner",0}
       ,{"session",1}
       ,{"public",2}
};
#endif
//
// RegistryModificationRights
//

GCC_RegistryModificationRights::GCC_RegistryModificationRights(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_GCC_RegistryModificationRights,3
#endif
    )
{
}


GCC_RegistryModificationRights & GCC_RegistryModificationRights::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * GCC_RegistryModificationRights::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_RegistryModificationRights::Class()), PInvalidCast);
#endif
  return new GCC_RegistryModificationRights(*this);
}


//
// UserIDIndication
//

GCC_UserIDIndication::GCC_UserIDIndication(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_UserIDIndication::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+6) << "tag = " << setprecision(indent) << m_tag << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_UserIDIndication::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_UserIDIndication), PInvalidCast);
#endif
  const GCC_UserIDIndication & other = (const GCC_UserIDIndication &)obj;

  Comparison result;

  if ((result = m_tag.Compare(other.m_tag)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_UserIDIndication::GetDataLength() const
{
  PINDEX length = 0;
  length += m_tag.GetObjectLength();
  return length;
}


BOOL GCC_UserIDIndication::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_tag.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_UserIDIndication::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_tag.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_UserIDIndication::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_UserIDIndication::Class()), PInvalidCast);
#endif
  return new GCC_UserIDIndication(*this);
}


//
// ConferenceQueryRequest
//

GCC_ConferenceQueryRequest::GCC_ConferenceQueryRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_ConferenceQueryRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "nodeType = " << setprecision(indent) << m_nodeType << '\n';
  if (HasOptionalField(e_asymmetryIndicator))
    strm << setw(indent+21) << "asymmetryIndicator = " << setprecision(indent) << m_asymmetryIndicator << '\n';
  if (HasOptionalField(e_userData))
    strm << setw(indent+11) << "userData = " << setprecision(indent) << m_userData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_ConferenceQueryRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_ConferenceQueryRequest), PInvalidCast);
#endif
  const GCC_ConferenceQueryRequest & other = (const GCC_ConferenceQueryRequest &)obj;

  Comparison result;

  if ((result = m_nodeType.Compare(other.m_nodeType)) != EqualTo)
    return result;
  if ((result = m_asymmetryIndicator.Compare(other.m_asymmetryIndicator)) != EqualTo)
    return result;
  if ((result = m_userData.Compare(other.m_userData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_ConferenceQueryRequest::GetDataLength() const
{
  PINDEX length = 0;
  length += m_nodeType.GetObjectLength();
  if (HasOptionalField(e_asymmetryIndicator))
    length += m_asymmetryIndicator.GetObjectLength();
  if (HasOptionalField(e_userData))
    length += m_userData.GetObjectLength();
  return length;
}


BOOL GCC_ConferenceQueryRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_nodeType.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_asymmetryIndicator) && !m_asymmetryIndicator.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_userData) && !m_userData.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_ConferenceQueryRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_nodeType.Encode(strm);
  if (HasOptionalField(e_asymmetryIndicator))
    m_asymmetryIndicator.Encode(strm);
  if (HasOptionalField(e_userData))
    m_userData.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_ConferenceQueryRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferenceQueryRequest::Class()), PInvalidCast);
#endif
  return new GCC_ConferenceQueryRequest(*this);
}


//
// ConferenceJoinRequest
//

GCC_ConferenceJoinRequest::GCC_ConferenceJoinRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 7, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_ConferenceJoinRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_conferenceName))
    strm << setw(indent+17) << "conferenceName = " << setprecision(indent) << m_conferenceName << '\n';
  if (HasOptionalField(e_conferenceNameModifier))
    strm << setw(indent+25) << "conferenceNameModifier = " << setprecision(indent) << m_conferenceNameModifier << '\n';
  if (HasOptionalField(e_tag))
    strm << setw(indent+6) << "tag = " << setprecision(indent) << m_tag << '\n';
  if (HasOptionalField(e_password))
    strm << setw(indent+11) << "password = " << setprecision(indent) << m_password << '\n';
  if (HasOptionalField(e_convenerPassword))
    strm << setw(indent+19) << "convenerPassword = " << setprecision(indent) << m_convenerPassword << '\n';
  if (HasOptionalField(e_callerIdentifier))
    strm << setw(indent+19) << "callerIdentifier = " << setprecision(indent) << m_callerIdentifier << '\n';
  if (HasOptionalField(e_userData))
    strm << setw(indent+11) << "userData = " << setprecision(indent) << m_userData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_ConferenceJoinRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_ConferenceJoinRequest), PInvalidCast);
#endif
  const GCC_ConferenceJoinRequest & other = (const GCC_ConferenceJoinRequest &)obj;

  Comparison result;

  if ((result = m_conferenceName.Compare(other.m_conferenceName)) != EqualTo)
    return result;
  if ((result = m_conferenceNameModifier.Compare(other.m_conferenceNameModifier)) != EqualTo)
    return result;
  if ((result = m_tag.Compare(other.m_tag)) != EqualTo)
    return result;
  if ((result = m_password.Compare(other.m_password)) != EqualTo)
    return result;
  if ((result = m_convenerPassword.Compare(other.m_convenerPassword)) != EqualTo)
    return result;
  if ((result = m_callerIdentifier.Compare(other.m_callerIdentifier)) != EqualTo)
    return result;
  if ((result = m_userData.Compare(other.m_userData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_ConferenceJoinRequest::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_conferenceName))
    length += m_conferenceName.GetObjectLength();
  if (HasOptionalField(e_conferenceNameModifier))
    length += m_conferenceNameModifier.GetObjectLength();
  if (HasOptionalField(e_tag))
    length += m_tag.GetObjectLength();
  if (HasOptionalField(e_password))
    length += m_password.GetObjectLength();
  if (HasOptionalField(e_convenerPassword))
    length += m_convenerPassword.GetObjectLength();
  if (HasOptionalField(e_callerIdentifier))
    length += m_callerIdentifier.GetObjectLength();
  if (HasOptionalField(e_userData))
    length += m_userData.GetObjectLength();
  return length;
}


BOOL GCC_ConferenceJoinRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_conferenceName) && !m_conferenceName.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_conferenceNameModifier) && !m_conferenceNameModifier.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_tag) && !m_tag.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_password) && !m_password.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_convenerPassword) && !m_convenerPassword.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_callerIdentifier) && !m_callerIdentifier.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_userData) && !m_userData.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_ConferenceJoinRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_conferenceName))
    m_conferenceName.Encode(strm);
  if (HasOptionalField(e_conferenceNameModifier))
    m_conferenceNameModifier.Encode(strm);
  if (HasOptionalField(e_tag))
    m_tag.Encode(strm);
  if (HasOptionalField(e_password))
    m_password.Encode(strm);
  if (HasOptionalField(e_convenerPassword))
    m_convenerPassword.Encode(strm);
  if (HasOptionalField(e_callerIdentifier))
    m_callerIdentifier.Encode(strm);
  if (HasOptionalField(e_userData))
    m_userData.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_ConferenceJoinRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferenceJoinRequest::Class()), PInvalidCast);
#endif
  return new GCC_ConferenceJoinRequest(*this);
}


//
// ConferenceAddRequest
//

GCC_ConferenceAddRequest::GCC_ConferenceAddRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_ConferenceAddRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "networkAddress = " << setprecision(indent) << m_networkAddress << '\n';
  strm << setw(indent+17) << "requestingNode = " << setprecision(indent) << m_requestingNode << '\n';
  strm << setw(indent+6) << "tag = " << setprecision(indent) << m_tag << '\n';
  if (HasOptionalField(e_addingMCU))
    strm << setw(indent+12) << "addingMCU = " << setprecision(indent) << m_addingMCU << '\n';
  if (HasOptionalField(e_userData))
    strm << setw(indent+11) << "userData = " << setprecision(indent) << m_userData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_ConferenceAddRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_ConferenceAddRequest), PInvalidCast);
#endif
  const GCC_ConferenceAddRequest & other = (const GCC_ConferenceAddRequest &)obj;

  Comparison result;

  if ((result = m_networkAddress.Compare(other.m_networkAddress)) != EqualTo)
    return result;
  if ((result = m_requestingNode.Compare(other.m_requestingNode)) != EqualTo)
    return result;
  if ((result = m_tag.Compare(other.m_tag)) != EqualTo)
    return result;
  if ((result = m_addingMCU.Compare(other.m_addingMCU)) != EqualTo)
    return result;
  if ((result = m_userData.Compare(other.m_userData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_ConferenceAddRequest::GetDataLength() const
{
  PINDEX length = 0;
  length += m_networkAddress.GetObjectLength();
  length += m_requestingNode.GetObjectLength();
  length += m_tag.GetObjectLength();
  if (HasOptionalField(e_addingMCU))
    length += m_addingMCU.GetObjectLength();
  if (HasOptionalField(e_userData))
    length += m_userData.GetObjectLength();
  return length;
}


BOOL GCC_ConferenceAddRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_networkAddress.Decode(strm))
    return FALSE;
  if (!m_requestingNode.Decode(strm))
    return FALSE;
  if (!m_tag.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_addingMCU) && !m_addingMCU.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_userData) && !m_userData.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_ConferenceAddRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_networkAddress.Encode(strm);
  m_requestingNode.Encode(strm);
  m_tag.Encode(strm);
  if (HasOptionalField(e_addingMCU))
    m_addingMCU.Encode(strm);
  if (HasOptionalField(e_userData))
    m_userData.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_ConferenceAddRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferenceAddRequest::Class()), PInvalidCast);
#endif
  return new GCC_ConferenceAddRequest(*this);
}


//
// ConferenceLockRequest
//

GCC_ConferenceLockRequest::GCC_ConferenceLockRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_ConferenceLockRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PINDEX GCC_ConferenceLockRequest::GetDataLength() const
{
  PINDEX length = 0;
  return length;
}


BOOL GCC_ConferenceLockRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;


  return UnknownExtensionsDecode(strm);
}


void GCC_ConferenceLockRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);


  UnknownExtensionsEncode(strm);
}


PObject * GCC_ConferenceLockRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferenceLockRequest::Class()), PInvalidCast);
#endif
  return new GCC_ConferenceLockRequest(*this);
}


//
// ConferenceLockIndication
//

GCC_ConferenceLockIndication::GCC_ConferenceLockIndication(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_ConferenceLockIndication::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PINDEX GCC_ConferenceLockIndication::GetDataLength() const
{
  PINDEX length = 0;
  return length;
}


BOOL GCC_ConferenceLockIndication::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;


  return UnknownExtensionsDecode(strm);
}


void GCC_ConferenceLockIndication::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);


  UnknownExtensionsEncode(strm);
}


PObject * GCC_ConferenceLockIndication::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferenceLockIndication::Class()), PInvalidCast);
#endif
  return new GCC_ConferenceLockIndication(*this);
}


//
// ConferenceUnlockRequest
//

GCC_ConferenceUnlockRequest::GCC_ConferenceUnlockRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_ConferenceUnlockRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PINDEX GCC_ConferenceUnlockRequest::GetDataLength() const
{
  PINDEX length = 0;
  return length;
}


BOOL GCC_ConferenceUnlockRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;


  return UnknownExtensionsDecode(strm);
}


void GCC_ConferenceUnlockRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);


  UnknownExtensionsEncode(strm);
}


PObject * GCC_ConferenceUnlockRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferenceUnlockRequest::Class()), PInvalidCast);
#endif
  return new GCC_ConferenceUnlockRequest(*this);
}


//
// ConferenceUnlockIndication
//

GCC_ConferenceUnlockIndication::GCC_ConferenceUnlockIndication(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_ConferenceUnlockIndication::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PINDEX GCC_ConferenceUnlockIndication::GetDataLength() const
{
  PINDEX length = 0;
  return length;
}


BOOL GCC_ConferenceUnlockIndication::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;


  return UnknownExtensionsDecode(strm);
}


void GCC_ConferenceUnlockIndication::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);


  UnknownExtensionsEncode(strm);
}


PObject * GCC_ConferenceUnlockIndication::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferenceUnlockIndication::Class()), PInvalidCast);
#endif
  return new GCC_ConferenceUnlockIndication(*this);
}


//
// RegistryRegisterChannelRequest
//

GCC_RegistryRegisterChannelRequest::GCC_RegistryRegisterChannelRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_RegistryRegisterChannelRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "entityID = " << setprecision(indent) << m_entityID << '\n';
  strm << setw(indent+6) << "key = " << setprecision(indent) << m_key << '\n';
  strm << setw(indent+12) << "channelID = " << setprecision(indent) << m_channelID << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_RegistryRegisterChannelRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_RegistryRegisterChannelRequest), PInvalidCast);
#endif
  const GCC_RegistryRegisterChannelRequest & other = (const GCC_RegistryRegisterChannelRequest &)obj;

  Comparison result;

  if ((result = m_entityID.Compare(other.m_entityID)) != EqualTo)
    return result;
  if ((result = m_key.Compare(other.m_key)) != EqualTo)
    return result;
  if ((result = m_channelID.Compare(other.m_channelID)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_RegistryRegisterChannelRequest::GetDataLength() const
{
  PINDEX length = 0;
  length += m_entityID.GetObjectLength();
  length += m_key.GetObjectLength();
  length += m_channelID.GetObjectLength();
  return length;
}


BOOL GCC_RegistryRegisterChannelRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_entityID.Decode(strm))
    return FALSE;
  if (!m_key.Decode(strm))
    return FALSE;
  if (!m_channelID.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_RegistryRegisterChannelRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_entityID.Encode(strm);
  m_key.Encode(strm);
  m_channelID.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_RegistryRegisterChannelRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_RegistryRegisterChannelRequest::Class()), PInvalidCast);
#endif
  return new GCC_RegistryRegisterChannelRequest(*this);
}


//
// RegistryAssignTokenRequest
//

GCC_RegistryAssignTokenRequest::GCC_RegistryAssignTokenRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_RegistryAssignTokenRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "entityID = " << setprecision(indent) << m_entityID << '\n';
  strm << setw(indent+6) << "key = " << setprecision(indent) << m_key << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_RegistryAssignTokenRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_RegistryAssignTokenRequest), PInvalidCast);
#endif
  const GCC_RegistryAssignTokenRequest & other = (const GCC_RegistryAssignTokenRequest &)obj;

  Comparison result;

  if ((result = m_entityID.Compare(other.m_entityID)) != EqualTo)
    return result;
  if ((result = m_key.Compare(other.m_key)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_RegistryAssignTokenRequest::GetDataLength() const
{
  PINDEX length = 0;
  length += m_entityID.GetObjectLength();
  length += m_key.GetObjectLength();
  return length;
}


BOOL GCC_RegistryAssignTokenRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_entityID.Decode(strm))
    return FALSE;
  if (!m_key.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_RegistryAssignTokenRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_entityID.Encode(strm);
  m_key.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_RegistryAssignTokenRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_RegistryAssignTokenRequest::Class()), PInvalidCast);
#endif
  return new GCC_RegistryAssignTokenRequest(*this);
}


//
// RegistrySetParameterRequest
//

GCC_RegistrySetParameterRequest::GCC_RegistrySetParameterRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_parameter.SetConstraints(PASN_Object::FixedConstraint, 0, 64);
}


#ifndef PASN_NOPRINTON
void GCC_RegistrySetParameterRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "entityID = " << setprecision(indent) << m_entityID << '\n';
  strm << setw(indent+6) << "key = " << setprecision(indent) << m_key << '\n';
  strm << setw(indent+12) << "parameter = " << setprecision(indent) << m_parameter << '\n';
  if (HasOptionalField(e_modificationRights))
    strm << setw(indent+21) << "modificationRights = " << setprecision(indent) << m_modificationRights << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_RegistrySetParameterRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_RegistrySetParameterRequest), PInvalidCast);
#endif
  const GCC_RegistrySetParameterRequest & other = (const GCC_RegistrySetParameterRequest &)obj;

  Comparison result;

  if ((result = m_entityID.Compare(other.m_entityID)) != EqualTo)
    return result;
  if ((result = m_key.Compare(other.m_key)) != EqualTo)
    return result;
  if ((result = m_parameter.Compare(other.m_parameter)) != EqualTo)
    return result;
  if ((result = m_modificationRights.Compare(other.m_modificationRights)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_RegistrySetParameterRequest::GetDataLength() const
{
  PINDEX length = 0;
  length += m_entityID.GetObjectLength();
  length += m_key.GetObjectLength();
  length += m_parameter.GetObjectLength();
  if (HasOptionalField(e_modificationRights))
    length += m_modificationRights.GetObjectLength();
  return length;
}


BOOL GCC_RegistrySetParameterRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_entityID.Decode(strm))
    return FALSE;
  if (!m_key.Decode(strm))
    return FALSE;
  if (!m_parameter.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_modificationRights) && !m_modificationRights.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_RegistrySetParameterRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_entityID.Encode(strm);
  m_key.Encode(strm);
  m_parameter.Encode(strm);
  if (HasOptionalField(e_modificationRights))
    m_modificationRights.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_RegistrySetParameterRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_RegistrySetParameterRequest::Class()), PInvalidCast);
#endif
  return new GCC_RegistrySetParameterRequest(*this);
}


//
// RegistryRetrieveEntryRequest
//

GCC_RegistryRetrieveEntryRequest::GCC_RegistryRetrieveEntryRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_RegistryRetrieveEntryRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "entityID = " << setprecision(indent) << m_entityID << '\n';
  strm << setw(indent+6) << "key = " << setprecision(indent) << m_key << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_RegistryRetrieveEntryRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_RegistryRetrieveEntryRequest), PInvalidCast);
#endif
  const GCC_RegistryRetrieveEntryRequest & other = (const GCC_RegistryRetrieveEntryRequest &)obj;

  Comparison result;

  if ((result = m_entityID.Compare(other.m_entityID)) != EqualTo)
    return result;
  if ((result = m_key.Compare(other.m_key)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_RegistryRetrieveEntryRequest::GetDataLength() const
{
  PINDEX length = 0;
  length += m_entityID.GetObjectLength();
  length += m_key.GetObjectLength();
  return length;
}


BOOL GCC_RegistryRetrieveEntryRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_entityID.Decode(strm))
    return FALSE;
  if (!m_key.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_RegistryRetrieveEntryRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_entityID.Encode(strm);
  m_key.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_RegistryRetrieveEntryRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_RegistryRetrieveEntryRequest::Class()), PInvalidCast);
#endif
  return new GCC_RegistryRetrieveEntryRequest(*this);
}


//
// RegistryDeleteEntryRequest
//

GCC_RegistryDeleteEntryRequest::GCC_RegistryDeleteEntryRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_RegistryDeleteEntryRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "entityID = " << setprecision(indent) << m_entityID << '\n';
  strm << setw(indent+6) << "key = " << setprecision(indent) << m_key << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_RegistryDeleteEntryRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_RegistryDeleteEntryRequest), PInvalidCast);
#endif
  const GCC_RegistryDeleteEntryRequest & other = (const GCC_RegistryDeleteEntryRequest &)obj;

  Comparison result;

  if ((result = m_entityID.Compare(other.m_entityID)) != EqualTo)
    return result;
  if ((result = m_key.Compare(other.m_key)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_RegistryDeleteEntryRequest::GetDataLength() const
{
  PINDEX length = 0;
  length += m_entityID.GetObjectLength();
  length += m_key.GetObjectLength();
  return length;
}


BOOL GCC_RegistryDeleteEntryRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_entityID.Decode(strm))
    return FALSE;
  if (!m_key.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_RegistryDeleteEntryRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_entityID.Encode(strm);
  m_key.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_RegistryDeleteEntryRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_RegistryDeleteEntryRequest::Class()), PInvalidCast);
#endif
  return new GCC_RegistryDeleteEntryRequest(*this);
}


//
// RegistryMonitorEntryRequest
//

GCC_RegistryMonitorEntryRequest::GCC_RegistryMonitorEntryRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_RegistryMonitorEntryRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "entityID = " << setprecision(indent) << m_entityID << '\n';
  strm << setw(indent+6) << "key = " << setprecision(indent) << m_key << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_RegistryMonitorEntryRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_RegistryMonitorEntryRequest), PInvalidCast);
#endif
  const GCC_RegistryMonitorEntryRequest & other = (const GCC_RegistryMonitorEntryRequest &)obj;

  Comparison result;

  if ((result = m_entityID.Compare(other.m_entityID)) != EqualTo)
    return result;
  if ((result = m_key.Compare(other.m_key)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_RegistryMonitorEntryRequest::GetDataLength() const
{
  PINDEX length = 0;
  length += m_entityID.GetObjectLength();
  length += m_key.GetObjectLength();
  return length;
}


BOOL GCC_RegistryMonitorEntryRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_entityID.Decode(strm))
    return FALSE;
  if (!m_key.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_RegistryMonitorEntryRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_entityID.Encode(strm);
  m_key.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_RegistryMonitorEntryRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_RegistryMonitorEntryRequest::Class()), PInvalidCast);
#endif
  return new GCC_RegistryMonitorEntryRequest(*this);
}


//
// RegistryMonitorEntryIndication
//

GCC_RegistryMonitorEntryIndication::GCC_RegistryMonitorEntryIndication(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_RegistryMonitorEntryIndication::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+6) << "key = " << setprecision(indent) << m_key << '\n';
  strm << setw(indent+7) << "item = " << setprecision(indent) << m_item << '\n';
  strm << setw(indent+8) << "owner = " << setprecision(indent) << m_owner << '\n';
  if (HasOptionalField(e_modificationRights))
    strm << setw(indent+21) << "modificationRights = " << setprecision(indent) << m_modificationRights << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_RegistryMonitorEntryIndication::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_RegistryMonitorEntryIndication), PInvalidCast);
#endif
  const GCC_RegistryMonitorEntryIndication & other = (const GCC_RegistryMonitorEntryIndication &)obj;

  Comparison result;

  if ((result = m_key.Compare(other.m_key)) != EqualTo)
    return result;
  if ((result = m_item.Compare(other.m_item)) != EqualTo)
    return result;
  if ((result = m_owner.Compare(other.m_owner)) != EqualTo)
    return result;
  if ((result = m_modificationRights.Compare(other.m_modificationRights)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_RegistryMonitorEntryIndication::GetDataLength() const
{
  PINDEX length = 0;
  length += m_key.GetObjectLength();
  length += m_item.GetObjectLength();
  length += m_owner.GetObjectLength();
  if (HasOptionalField(e_modificationRights))
    length += m_modificationRights.GetObjectLength();
  return length;
}


BOOL GCC_RegistryMonitorEntryIndication::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_key.Decode(strm))
    return FALSE;
  if (!m_item.Decode(strm))
    return FALSE;
  if (!m_owner.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_modificationRights) && !m_modificationRights.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_RegistryMonitorEntryIndication::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_key.Encode(strm);
  m_item.Encode(strm);
  m_owner.Encode(strm);
  if (HasOptionalField(e_modificationRights))
    m_modificationRights.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_RegistryMonitorEntryIndication::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_RegistryMonitorEntryIndication::Class()), PInvalidCast);
#endif
  return new GCC_RegistryMonitorEntryIndication(*this);
}


//
// RegistryAllocateHandleRequest
//

GCC_RegistryAllocateHandleRequest::GCC_RegistryAllocateHandleRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_numberOfHandles.SetConstraints(PASN_Object::FixedConstraint, 1, 1024);
}


#ifndef PASN_NOPRINTON
void GCC_RegistryAllocateHandleRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "entityID = " << setprecision(indent) << m_entityID << '\n';
  strm << setw(indent+18) << "numberOfHandles = " << setprecision(indent) << m_numberOfHandles << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_RegistryAllocateHandleRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_RegistryAllocateHandleRequest), PInvalidCast);
#endif
  const GCC_RegistryAllocateHandleRequest & other = (const GCC_RegistryAllocateHandleRequest &)obj;

  Comparison result;

  if ((result = m_entityID.Compare(other.m_entityID)) != EqualTo)
    return result;
  if ((result = m_numberOfHandles.Compare(other.m_numberOfHandles)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_RegistryAllocateHandleRequest::GetDataLength() const
{
  PINDEX length = 0;
  length += m_entityID.GetObjectLength();
  length += m_numberOfHandles.GetObjectLength();
  return length;
}


BOOL GCC_RegistryAllocateHandleRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_entityID.Decode(strm))
    return FALSE;
  if (!m_numberOfHandles.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_RegistryAllocateHandleRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_entityID.Encode(strm);
  m_numberOfHandles.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_RegistryAllocateHandleRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_RegistryAllocateHandleRequest::Class()), PInvalidCast);
#endif
  return new GCC_RegistryAllocateHandleRequest(*this);
}


//
// ConductorAssignIndication
//

GCC_ConductorAssignIndication::GCC_ConductorAssignIndication(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_ConductorAssignIndication::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "conductingNode = " << setprecision(indent) << m_conductingNode << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_ConductorAssignIndication::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_ConductorAssignIndication), PInvalidCast);
#endif
  const GCC_ConductorAssignIndication & other = (const GCC_ConductorAssignIndication &)obj;

  Comparison result;

  if ((result = m_conductingNode.Compare(other.m_conductingNode)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_ConductorAssignIndication::GetDataLength() const
{
  PINDEX length = 0;
  length += m_conductingNode.GetObjectLength();
  return length;
}


BOOL GCC_ConductorAssignIndication::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_conductingNode.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_ConductorAssignIndication::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_conductingNode.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_ConductorAssignIndication::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConductorAssignIndication::Class()), PInvalidCast);
#endif
  return new GCC_ConductorAssignIndication(*this);
}


//
// ConductorReleaseIndication
//

GCC_ConductorReleaseIndication::GCC_ConductorReleaseIndication(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_ConductorReleaseIndication::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PINDEX GCC_ConductorReleaseIndication::GetDataLength() const
{
  PINDEX length = 0;
  return length;
}


BOOL GCC_ConductorReleaseIndication::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;


  return UnknownExtensionsDecode(strm);
}


void GCC_ConductorReleaseIndication::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);


  UnknownExtensionsEncode(strm);
}


PObject * GCC_ConductorReleaseIndication::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConductorReleaseIndication::Class()), PInvalidCast);
#endif
  return new GCC_ConductorReleaseIndication(*this);
}


//
// ConductorPermissionAskIndication
//

GCC_ConductorPermissionAskIndication::GCC_ConductorPermissionAskIndication(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_ConductorPermissionAskIndication::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+12) << "grantFlag = " << setprecision(indent) << m_grantFlag << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_ConductorPermissionAskIndication::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_ConductorPermissionAskIndication), PInvalidCast);
#endif
  const GCC_ConductorPermissionAskIndication & other = (const GCC_ConductorPermissionAskIndication &)obj;

  Comparison result;

  if ((result = m_grantFlag.Compare(other.m_grantFlag)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_ConductorPermissionAskIndication::GetDataLength() const
{
  PINDEX length = 0;
  length += m_grantFlag.GetObjectLength();
  return length;
}


BOOL GCC_ConductorPermissionAskIndication::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_grantFlag.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_ConductorPermissionAskIndication::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_grantFlag.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_ConductorPermissionAskIndication::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConductorPermissionAskIndication::Class()), PInvalidCast);
#endif
  return new GCC_ConductorPermissionAskIndication(*this);
}


//
// ConferenceTimeRemainingIndication
//

GCC_ConferenceTimeRemainingIndication::GCC_ConferenceTimeRemainingIndication(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_ConferenceTimeRemainingIndication::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "timeRemaining = " << setprecision(indent) << m_timeRemaining << '\n';
  if (HasOptionalField(e_nodeID))
    strm << setw(indent+9) << "nodeID = " << setprecision(indent) << m_nodeID << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_ConferenceTimeRemainingIndication::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_ConferenceTimeRemainingIndication), PInvalidCast);
#endif
  const GCC_ConferenceTimeRemainingIndication & other = (const GCC_ConferenceTimeRemainingIndication &)obj;

  Comparison result;

  if ((result = m_timeRemaining.Compare(other.m_timeRemaining)) != EqualTo)
    return result;
  if ((result = m_nodeID.Compare(other.m_nodeID)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_ConferenceTimeRemainingIndication::GetDataLength() const
{
  PINDEX length = 0;
  length += m_timeRemaining.GetObjectLength();
  if (HasOptionalField(e_nodeID))
    length += m_nodeID.GetObjectLength();
  return length;
}


BOOL GCC_ConferenceTimeRemainingIndication::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_timeRemaining.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_nodeID) && !m_nodeID.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_ConferenceTimeRemainingIndication::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_timeRemaining.Encode(strm);
  if (HasOptionalField(e_nodeID))
    m_nodeID.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_ConferenceTimeRemainingIndication::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferenceTimeRemainingIndication::Class()), PInvalidCast);
#endif
  return new GCC_ConferenceTimeRemainingIndication(*this);
}


//
// ConferenceTimeInquireIndication
//

GCC_ConferenceTimeInquireIndication::GCC_ConferenceTimeInquireIndication(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_ConferenceTimeInquireIndication::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+23) << "nodeSpecificTimeFlag = " << setprecision(indent) << m_nodeSpecificTimeFlag << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_ConferenceTimeInquireIndication::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_ConferenceTimeInquireIndication), PInvalidCast);
#endif
  const GCC_ConferenceTimeInquireIndication & other = (const GCC_ConferenceTimeInquireIndication &)obj;

  Comparison result;

  if ((result = m_nodeSpecificTimeFlag.Compare(other.m_nodeSpecificTimeFlag)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_ConferenceTimeInquireIndication::GetDataLength() const
{
  PINDEX length = 0;
  length += m_nodeSpecificTimeFlag.GetObjectLength();
  return length;
}


BOOL GCC_ConferenceTimeInquireIndication::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_nodeSpecificTimeFlag.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_ConferenceTimeInquireIndication::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_nodeSpecificTimeFlag.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_ConferenceTimeInquireIndication::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferenceTimeInquireIndication::Class()), PInvalidCast);
#endif
  return new GCC_ConferenceTimeInquireIndication(*this);
}


//
// ConferenceTimeExtendIndication
//

GCC_ConferenceTimeExtendIndication::GCC_ConferenceTimeExtendIndication(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_ConferenceTimeExtendIndication::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "timeToExtend = " << setprecision(indent) << m_timeToExtend << '\n';
  strm << setw(indent+23) << "nodeSpecificTimeFlag = " << setprecision(indent) << m_nodeSpecificTimeFlag << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_ConferenceTimeExtendIndication::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_ConferenceTimeExtendIndication), PInvalidCast);
#endif
  const GCC_ConferenceTimeExtendIndication & other = (const GCC_ConferenceTimeExtendIndication &)obj;

  Comparison result;

  if ((result = m_timeToExtend.Compare(other.m_timeToExtend)) != EqualTo)
    return result;
  if ((result = m_nodeSpecificTimeFlag.Compare(other.m_nodeSpecificTimeFlag)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_ConferenceTimeExtendIndication::GetDataLength() const
{
  PINDEX length = 0;
  length += m_timeToExtend.GetObjectLength();
  length += m_nodeSpecificTimeFlag.GetObjectLength();
  return length;
}


BOOL GCC_ConferenceTimeExtendIndication::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_timeToExtend.Decode(strm))
    return FALSE;
  if (!m_nodeSpecificTimeFlag.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_ConferenceTimeExtendIndication::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_timeToExtend.Encode(strm);
  m_nodeSpecificTimeFlag.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_ConferenceTimeExtendIndication::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferenceTimeExtendIndication::Class()), PInvalidCast);
#endif
  return new GCC_ConferenceTimeExtendIndication(*this);
}


//
// ConferenceAssistanceIndication
//

GCC_ConferenceAssistanceIndication::GCC_ConferenceAssistanceIndication(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_ConferenceAssistanceIndication::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_userData))
    strm << setw(indent+11) << "userData = " << setprecision(indent) << m_userData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_ConferenceAssistanceIndication::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_ConferenceAssistanceIndication), PInvalidCast);
#endif
  const GCC_ConferenceAssistanceIndication & other = (const GCC_ConferenceAssistanceIndication &)obj;

  Comparison result;

  if ((result = m_userData.Compare(other.m_userData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_ConferenceAssistanceIndication::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_userData))
    length += m_userData.GetObjectLength();
  return length;
}


BOOL GCC_ConferenceAssistanceIndication::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_userData) && !m_userData.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_ConferenceAssistanceIndication::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_userData))
    m_userData.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_ConferenceAssistanceIndication::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferenceAssistanceIndication::Class()), PInvalidCast);
#endif
  return new GCC_ConferenceAssistanceIndication(*this);
}


//
// TextMessageIndication
//

GCC_TextMessageIndication::GCC_TextMessageIndication(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_TextMessageIndication::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+10) << "message = " << setprecision(indent) << m_message << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_TextMessageIndication::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_TextMessageIndication), PInvalidCast);
#endif
  const GCC_TextMessageIndication & other = (const GCC_TextMessageIndication &)obj;

  Comparison result;

  if ((result = m_message.Compare(other.m_message)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_TextMessageIndication::GetDataLength() const
{
  PINDEX length = 0;
  length += m_message.GetObjectLength();
  return length;
}


BOOL GCC_TextMessageIndication::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_message.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_TextMessageIndication::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_message.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_TextMessageIndication::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_TextMessageIndication::Class()), PInvalidCast);
#endif
  return new GCC_TextMessageIndication(*this);
}


//
// NonStandardPDU
//

GCC_NonStandardPDU::GCC_NonStandardPDU(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_NonStandardPDU::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+7) << "data = " << setprecision(indent) << m_data << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_NonStandardPDU::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_NonStandardPDU), PInvalidCast);
#endif
  const GCC_NonStandardPDU & other = (const GCC_NonStandardPDU &)obj;

  Comparison result;

  if ((result = m_data.Compare(other.m_data)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_NonStandardPDU::GetDataLength() const
{
  PINDEX length = 0;
  length += m_data.GetObjectLength();
  return length;
}


BOOL GCC_NonStandardPDU::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_data.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_NonStandardPDU::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_data.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_NonStandardPDU::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_NonStandardPDU::Class()), PInvalidCast);
#endif
  return new GCC_NonStandardPDU(*this);
}


//
// ConnectData
//

GCC_ConnectData::GCC_ConnectData(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_ConnectData::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "t124Identifier = " << setprecision(indent) << m_t124Identifier << '\n';
  strm << setw(indent+13) << "connectPDU = " << setprecision(indent) << m_connectPDU << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_ConnectData::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_ConnectData), PInvalidCast);
#endif
  const GCC_ConnectData & other = (const GCC_ConnectData &)obj;

  Comparison result;

  if ((result = m_t124Identifier.Compare(other.m_t124Identifier)) != EqualTo)
    return result;
  if ((result = m_connectPDU.Compare(other.m_connectPDU)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_ConnectData::GetDataLength() const
{
  PINDEX length = 0;
  length += m_t124Identifier.GetObjectLength();
  length += m_connectPDU.GetObjectLength();
  return length;
}


BOOL GCC_ConnectData::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_t124Identifier.Decode(strm))
    return FALSE;
  if (!m_connectPDU.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_ConnectData::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_t124Identifier.Encode(strm);
  m_connectPDU.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_ConnectData::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConnectData::Class()), PInvalidCast);
#endif
  return new GCC_ConnectData(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_GCC_ConnectGCCPDU[]={
      {"conferenceCreateRequest",0}
     ,{"conferenceCreateResponse",1}
     ,{"conferenceQueryRequest",2}
     ,{"conferenceQueryResponse",3}
     ,{"conferenceJoinRequest",4}
     ,{"conferenceJoinResponse",5}
     ,{"conferenceInviteRequest",6}
     ,{"conferenceInviteResponse",7}
};
#endif
//
// ConnectGCCPDU
//

GCC_ConnectGCCPDU::GCC_ConnectGCCPDU(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 8, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_GCC_ConnectGCCPDU,8
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_ConnectGCCPDU::operator GCC_ConferenceCreateRequest &() const
#else
GCC_ConnectGCCPDU::operator GCC_ConferenceCreateRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceCreateRequest), PInvalidCast);
#endif
  return *(GCC_ConferenceCreateRequest *)choice;
}


GCC_ConnectGCCPDU::operator const GCC_ConferenceCreateRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceCreateRequest), PInvalidCast);
#endif
  return *(GCC_ConferenceCreateRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_ConnectGCCPDU::operator GCC_ConferenceCreateResponse &() const
#else
GCC_ConnectGCCPDU::operator GCC_ConferenceCreateResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceCreateResponse), PInvalidCast);
#endif
  return *(GCC_ConferenceCreateResponse *)choice;
}


GCC_ConnectGCCPDU::operator const GCC_ConferenceCreateResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceCreateResponse), PInvalidCast);
#endif
  return *(GCC_ConferenceCreateResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_ConnectGCCPDU::operator GCC_ConferenceQueryRequest &() const
#else
GCC_ConnectGCCPDU::operator GCC_ConferenceQueryRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceQueryRequest), PInvalidCast);
#endif
  return *(GCC_ConferenceQueryRequest *)choice;
}


GCC_ConnectGCCPDU::operator const GCC_ConferenceQueryRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceQueryRequest), PInvalidCast);
#endif
  return *(GCC_ConferenceQueryRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_ConnectGCCPDU::operator GCC_ConferenceQueryResponse &() const
#else
GCC_ConnectGCCPDU::operator GCC_ConferenceQueryResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceQueryResponse), PInvalidCast);
#endif
  return *(GCC_ConferenceQueryResponse *)choice;
}


GCC_ConnectGCCPDU::operator const GCC_ConferenceQueryResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceQueryResponse), PInvalidCast);
#endif
  return *(GCC_ConferenceQueryResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_ConnectGCCPDU::operator GCC_ConferenceJoinRequest &() const
#else
GCC_ConnectGCCPDU::operator GCC_ConferenceJoinRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceJoinRequest), PInvalidCast);
#endif
  return *(GCC_ConferenceJoinRequest *)choice;
}


GCC_ConnectGCCPDU::operator const GCC_ConferenceJoinRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceJoinRequest), PInvalidCast);
#endif
  return *(GCC_ConferenceJoinRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_ConnectGCCPDU::operator GCC_ConferenceJoinResponse &() const
#else
GCC_ConnectGCCPDU::operator GCC_ConferenceJoinResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceJoinResponse), PInvalidCast);
#endif
  return *(GCC_ConferenceJoinResponse *)choice;
}


GCC_ConnectGCCPDU::operator const GCC_ConferenceJoinResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceJoinResponse), PInvalidCast);
#endif
  return *(GCC_ConferenceJoinResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_ConnectGCCPDU::operator GCC_ConferenceInviteRequest &() const
#else
GCC_ConnectGCCPDU::operator GCC_ConferenceInviteRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceInviteRequest), PInvalidCast);
#endif
  return *(GCC_ConferenceInviteRequest *)choice;
}


GCC_ConnectGCCPDU::operator const GCC_ConferenceInviteRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceInviteRequest), PInvalidCast);
#endif
  return *(GCC_ConferenceInviteRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_ConnectGCCPDU::operator GCC_ConferenceInviteResponse &() const
#else
GCC_ConnectGCCPDU::operator GCC_ConferenceInviteResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceInviteResponse), PInvalidCast);
#endif
  return *(GCC_ConferenceInviteResponse *)choice;
}


GCC_ConnectGCCPDU::operator const GCC_ConferenceInviteResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceInviteResponse), PInvalidCast);
#endif
  return *(GCC_ConferenceInviteResponse *)choice;
}


BOOL GCC_ConnectGCCPDU::CreateObject()
{
  switch (tag) {
    case e_conferenceCreateRequest :
      choice = new GCC_ConferenceCreateRequest();
      return TRUE;
    case e_conferenceCreateResponse :
      choice = new GCC_ConferenceCreateResponse();
      return TRUE;
    case e_conferenceQueryRequest :
      choice = new GCC_ConferenceQueryRequest();
      return TRUE;
    case e_conferenceQueryResponse :
      choice = new GCC_ConferenceQueryResponse();
      return TRUE;
    case e_conferenceJoinRequest :
      choice = new GCC_ConferenceJoinRequest();
      return TRUE;
    case e_conferenceJoinResponse :
      choice = new GCC_ConferenceJoinResponse();
      return TRUE;
    case e_conferenceInviteRequest :
      choice = new GCC_ConferenceInviteRequest();
      return TRUE;
    case e_conferenceInviteResponse :
      choice = new GCC_ConferenceInviteResponse();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * GCC_ConnectGCCPDU::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConnectGCCPDU::Class()), PInvalidCast);
#endif
  return new GCC_ConnectGCCPDU(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_GCC_GCCPDU[]={
      {"request",0}
     ,{"response",1}
     ,{"indication",2}
};
#endif
//
// GCCPDU
//

GCC_GCCPDU::GCC_GCCPDU(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_GCC_GCCPDU,3
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_GCCPDU::operator GCC_RequestPDU &() const
#else
GCC_GCCPDU::operator GCC_RequestPDU &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_RequestPDU), PInvalidCast);
#endif
  return *(GCC_RequestPDU *)choice;
}


GCC_GCCPDU::operator const GCC_RequestPDU &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_RequestPDU), PInvalidCast);
#endif
  return *(GCC_RequestPDU *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_GCCPDU::operator GCC_ResponsePDU &() const
#else
GCC_GCCPDU::operator GCC_ResponsePDU &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ResponsePDU), PInvalidCast);
#endif
  return *(GCC_ResponsePDU *)choice;
}


GCC_GCCPDU::operator const GCC_ResponsePDU &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ResponsePDU), PInvalidCast);
#endif
  return *(GCC_ResponsePDU *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_GCCPDU::operator GCC_IndicationPDU &() const
#else
GCC_GCCPDU::operator GCC_IndicationPDU &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_IndicationPDU), PInvalidCast);
#endif
  return *(GCC_IndicationPDU *)choice;
}


GCC_GCCPDU::operator const GCC_IndicationPDU &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_IndicationPDU), PInvalidCast);
#endif
  return *(GCC_IndicationPDU *)choice;
}


BOOL GCC_GCCPDU::CreateObject()
{
  switch (tag) {
    case e_request :
      choice = new GCC_RequestPDU();
      return TRUE;
    case e_response :
      choice = new GCC_ResponsePDU();
      return TRUE;
    case e_indication :
      choice = new GCC_IndicationPDU();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * GCC_GCCPDU::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_GCCPDU::Class()), PInvalidCast);
#endif
  return new GCC_GCCPDU(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_GCC_RequestPDU[]={
      {"conferenceJoinRequest",0}
     ,{"conferenceAddRequest",1}
     ,{"conferenceLockRequest",2}
     ,{"conferenceUnlockRequest",3}
     ,{"conferenceTerminateRequest",4}
     ,{"conferenceEjectUserRequest",5}
     ,{"conferenceTransferRequest",6}
     ,{"registryRegisterChannelRequest",7}
     ,{"registryAssignTokenRequest",8}
     ,{"registrySetParameterRequest",9}
     ,{"registryRetrieveEntryRequest",10}
     ,{"registryDeleteEntryRequest",11}
     ,{"registryMonitorEntryRequest",12}
     ,{"registryAllocateHandleRequest",13}
     ,{"nonStandardRequest",14}
};
#endif
//
// RequestPDU
//

GCC_RequestPDU::GCC_RequestPDU(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 15, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_GCC_RequestPDU,15
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_RequestPDU::operator GCC_ConferenceJoinRequest &() const
#else
GCC_RequestPDU::operator GCC_ConferenceJoinRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceJoinRequest), PInvalidCast);
#endif
  return *(GCC_ConferenceJoinRequest *)choice;
}


GCC_RequestPDU::operator const GCC_ConferenceJoinRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceJoinRequest), PInvalidCast);
#endif
  return *(GCC_ConferenceJoinRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_RequestPDU::operator GCC_ConferenceAddRequest &() const
#else
GCC_RequestPDU::operator GCC_ConferenceAddRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceAddRequest), PInvalidCast);
#endif
  return *(GCC_ConferenceAddRequest *)choice;
}


GCC_RequestPDU::operator const GCC_ConferenceAddRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceAddRequest), PInvalidCast);
#endif
  return *(GCC_ConferenceAddRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_RequestPDU::operator GCC_ConferenceLockRequest &() const
#else
GCC_RequestPDU::operator GCC_ConferenceLockRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceLockRequest), PInvalidCast);
#endif
  return *(GCC_ConferenceLockRequest *)choice;
}


GCC_RequestPDU::operator const GCC_ConferenceLockRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceLockRequest), PInvalidCast);
#endif
  return *(GCC_ConferenceLockRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_RequestPDU::operator GCC_ConferenceUnlockRequest &() const
#else
GCC_RequestPDU::operator GCC_ConferenceUnlockRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceUnlockRequest), PInvalidCast);
#endif
  return *(GCC_ConferenceUnlockRequest *)choice;
}


GCC_RequestPDU::operator const GCC_ConferenceUnlockRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceUnlockRequest), PInvalidCast);
#endif
  return *(GCC_ConferenceUnlockRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_RequestPDU::operator GCC_ConferenceTerminateRequest &() const
#else
GCC_RequestPDU::operator GCC_ConferenceTerminateRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceTerminateRequest), PInvalidCast);
#endif
  return *(GCC_ConferenceTerminateRequest *)choice;
}


GCC_RequestPDU::operator const GCC_ConferenceTerminateRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceTerminateRequest), PInvalidCast);
#endif
  return *(GCC_ConferenceTerminateRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_RequestPDU::operator GCC_ConferenceEjectUserRequest &() const
#else
GCC_RequestPDU::operator GCC_ConferenceEjectUserRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceEjectUserRequest), PInvalidCast);
#endif
  return *(GCC_ConferenceEjectUserRequest *)choice;
}


GCC_RequestPDU::operator const GCC_ConferenceEjectUserRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceEjectUserRequest), PInvalidCast);
#endif
  return *(GCC_ConferenceEjectUserRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_RequestPDU::operator GCC_ConferenceTransferRequest &() const
#else
GCC_RequestPDU::operator GCC_ConferenceTransferRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceTransferRequest), PInvalidCast);
#endif
  return *(GCC_ConferenceTransferRequest *)choice;
}


GCC_RequestPDU::operator const GCC_ConferenceTransferRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceTransferRequest), PInvalidCast);
#endif
  return *(GCC_ConferenceTransferRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_RequestPDU::operator GCC_RegistryRegisterChannelRequest &() const
#else
GCC_RequestPDU::operator GCC_RegistryRegisterChannelRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_RegistryRegisterChannelRequest), PInvalidCast);
#endif
  return *(GCC_RegistryRegisterChannelRequest *)choice;
}


GCC_RequestPDU::operator const GCC_RegistryRegisterChannelRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_RegistryRegisterChannelRequest), PInvalidCast);
#endif
  return *(GCC_RegistryRegisterChannelRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_RequestPDU::operator GCC_RegistryAssignTokenRequest &() const
#else
GCC_RequestPDU::operator GCC_RegistryAssignTokenRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_RegistryAssignTokenRequest), PInvalidCast);
#endif
  return *(GCC_RegistryAssignTokenRequest *)choice;
}


GCC_RequestPDU::operator const GCC_RegistryAssignTokenRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_RegistryAssignTokenRequest), PInvalidCast);
#endif
  return *(GCC_RegistryAssignTokenRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_RequestPDU::operator GCC_RegistrySetParameterRequest &() const
#else
GCC_RequestPDU::operator GCC_RegistrySetParameterRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_RegistrySetParameterRequest), PInvalidCast);
#endif
  return *(GCC_RegistrySetParameterRequest *)choice;
}


GCC_RequestPDU::operator const GCC_RegistrySetParameterRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_RegistrySetParameterRequest), PInvalidCast);
#endif
  return *(GCC_RegistrySetParameterRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_RequestPDU::operator GCC_RegistryRetrieveEntryRequest &() const
#else
GCC_RequestPDU::operator GCC_RegistryRetrieveEntryRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_RegistryRetrieveEntryRequest), PInvalidCast);
#endif
  return *(GCC_RegistryRetrieveEntryRequest *)choice;
}


GCC_RequestPDU::operator const GCC_RegistryRetrieveEntryRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_RegistryRetrieveEntryRequest), PInvalidCast);
#endif
  return *(GCC_RegistryRetrieveEntryRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_RequestPDU::operator GCC_RegistryDeleteEntryRequest &() const
#else
GCC_RequestPDU::operator GCC_RegistryDeleteEntryRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_RegistryDeleteEntryRequest), PInvalidCast);
#endif
  return *(GCC_RegistryDeleteEntryRequest *)choice;
}


GCC_RequestPDU::operator const GCC_RegistryDeleteEntryRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_RegistryDeleteEntryRequest), PInvalidCast);
#endif
  return *(GCC_RegistryDeleteEntryRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_RequestPDU::operator GCC_RegistryMonitorEntryRequest &() const
#else
GCC_RequestPDU::operator GCC_RegistryMonitorEntryRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_RegistryMonitorEntryRequest), PInvalidCast);
#endif
  return *(GCC_RegistryMonitorEntryRequest *)choice;
}


GCC_RequestPDU::operator const GCC_RegistryMonitorEntryRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_RegistryMonitorEntryRequest), PInvalidCast);
#endif
  return *(GCC_RegistryMonitorEntryRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_RequestPDU::operator GCC_RegistryAllocateHandleRequest &() const
#else
GCC_RequestPDU::operator GCC_RegistryAllocateHandleRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_RegistryAllocateHandleRequest), PInvalidCast);
#endif
  return *(GCC_RegistryAllocateHandleRequest *)choice;
}


GCC_RequestPDU::operator const GCC_RegistryAllocateHandleRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_RegistryAllocateHandleRequest), PInvalidCast);
#endif
  return *(GCC_RegistryAllocateHandleRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_RequestPDU::operator GCC_NonStandardPDU &() const
#else
GCC_RequestPDU::operator GCC_NonStandardPDU &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_NonStandardPDU), PInvalidCast);
#endif
  return *(GCC_NonStandardPDU *)choice;
}


GCC_RequestPDU::operator const GCC_NonStandardPDU &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_NonStandardPDU), PInvalidCast);
#endif
  return *(GCC_NonStandardPDU *)choice;
}


BOOL GCC_RequestPDU::CreateObject()
{
  switch (tag) {
    case e_conferenceJoinRequest :
      choice = new GCC_ConferenceJoinRequest();
      return TRUE;
    case e_conferenceAddRequest :
      choice = new GCC_ConferenceAddRequest();
      return TRUE;
    case e_conferenceLockRequest :
      choice = new GCC_ConferenceLockRequest();
      return TRUE;
    case e_conferenceUnlockRequest :
      choice = new GCC_ConferenceUnlockRequest();
      return TRUE;
    case e_conferenceTerminateRequest :
      choice = new GCC_ConferenceTerminateRequest();
      return TRUE;
    case e_conferenceEjectUserRequest :
      choice = new GCC_ConferenceEjectUserRequest();
      return TRUE;
    case e_conferenceTransferRequest :
      choice = new GCC_ConferenceTransferRequest();
      return TRUE;
    case e_registryRegisterChannelRequest :
      choice = new GCC_RegistryRegisterChannelRequest();
      return TRUE;
    case e_registryAssignTokenRequest :
      choice = new GCC_RegistryAssignTokenRequest();
      return TRUE;
    case e_registrySetParameterRequest :
      choice = new GCC_RegistrySetParameterRequest();
      return TRUE;
    case e_registryRetrieveEntryRequest :
      choice = new GCC_RegistryRetrieveEntryRequest();
      return TRUE;
    case e_registryDeleteEntryRequest :
      choice = new GCC_RegistryDeleteEntryRequest();
      return TRUE;
    case e_registryMonitorEntryRequest :
      choice = new GCC_RegistryMonitorEntryRequest();
      return TRUE;
    case e_registryAllocateHandleRequest :
      choice = new GCC_RegistryAllocateHandleRequest();
      return TRUE;
    case e_nonStandardRequest :
      choice = new GCC_NonStandardPDU();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * GCC_RequestPDU::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_RequestPDU::Class()), PInvalidCast);
#endif
  return new GCC_RequestPDU(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_GCC_ResponsePDU[]={
      {"conferenceJoinResponse",0}
     ,{"conferenceAddResponse",1}
     ,{"conferenceLockResponse",2}
     ,{"conferenceUnlockResponse",3}
     ,{"conferenceTerminateResponse",4}
     ,{"conferenceEjectUserResponse",5}
     ,{"conferenceTransferResponse",6}
     ,{"registryResponse",7}
     ,{"registryAllocateHandleResponse",8}
     ,{"functionNotSupportedResponse",9}
     ,{"nonStandardResponse",10}
};
#endif
//
// ResponsePDU
//

GCC_ResponsePDU::GCC_ResponsePDU(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 11, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_GCC_ResponsePDU,11
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_ResponsePDU::operator GCC_ConferenceJoinResponse &() const
#else
GCC_ResponsePDU::operator GCC_ConferenceJoinResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceJoinResponse), PInvalidCast);
#endif
  return *(GCC_ConferenceJoinResponse *)choice;
}


GCC_ResponsePDU::operator const GCC_ConferenceJoinResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceJoinResponse), PInvalidCast);
#endif
  return *(GCC_ConferenceJoinResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_ResponsePDU::operator GCC_ConferenceAddResponse &() const
#else
GCC_ResponsePDU::operator GCC_ConferenceAddResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceAddResponse), PInvalidCast);
#endif
  return *(GCC_ConferenceAddResponse *)choice;
}


GCC_ResponsePDU::operator const GCC_ConferenceAddResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceAddResponse), PInvalidCast);
#endif
  return *(GCC_ConferenceAddResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_ResponsePDU::operator GCC_ConferenceLockResponse &() const
#else
GCC_ResponsePDU::operator GCC_ConferenceLockResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceLockResponse), PInvalidCast);
#endif
  return *(GCC_ConferenceLockResponse *)choice;
}


GCC_ResponsePDU::operator const GCC_ConferenceLockResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceLockResponse), PInvalidCast);
#endif
  return *(GCC_ConferenceLockResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_ResponsePDU::operator GCC_ConferenceUnlockResponse &() const
#else
GCC_ResponsePDU::operator GCC_ConferenceUnlockResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceUnlockResponse), PInvalidCast);
#endif
  return *(GCC_ConferenceUnlockResponse *)choice;
}


GCC_ResponsePDU::operator const GCC_ConferenceUnlockResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceUnlockResponse), PInvalidCast);
#endif
  return *(GCC_ConferenceUnlockResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_ResponsePDU::operator GCC_ConferenceTerminateResponse &() const
#else
GCC_ResponsePDU::operator GCC_ConferenceTerminateResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceTerminateResponse), PInvalidCast);
#endif
  return *(GCC_ConferenceTerminateResponse *)choice;
}


GCC_ResponsePDU::operator const GCC_ConferenceTerminateResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceTerminateResponse), PInvalidCast);
#endif
  return *(GCC_ConferenceTerminateResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_ResponsePDU::operator GCC_ConferenceEjectUserResponse &() const
#else
GCC_ResponsePDU::operator GCC_ConferenceEjectUserResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceEjectUserResponse), PInvalidCast);
#endif
  return *(GCC_ConferenceEjectUserResponse *)choice;
}


GCC_ResponsePDU::operator const GCC_ConferenceEjectUserResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceEjectUserResponse), PInvalidCast);
#endif
  return *(GCC_ConferenceEjectUserResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_ResponsePDU::operator GCC_ConferenceTransferResponse &() const
#else
GCC_ResponsePDU::operator GCC_ConferenceTransferResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceTransferResponse), PInvalidCast);
#endif
  return *(GCC_ConferenceTransferResponse *)choice;
}


GCC_ResponsePDU::operator const GCC_ConferenceTransferResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceTransferResponse), PInvalidCast);
#endif
  return *(GCC_ConferenceTransferResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_ResponsePDU::operator GCC_RegistryResponse &() const
#else
GCC_ResponsePDU::operator GCC_RegistryResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_RegistryResponse), PInvalidCast);
#endif
  return *(GCC_RegistryResponse *)choice;
}


GCC_ResponsePDU::operator const GCC_RegistryResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_RegistryResponse), PInvalidCast);
#endif
  return *(GCC_RegistryResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_ResponsePDU::operator GCC_RegistryAllocateHandleResponse &() const
#else
GCC_ResponsePDU::operator GCC_RegistryAllocateHandleResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_RegistryAllocateHandleResponse), PInvalidCast);
#endif
  return *(GCC_RegistryAllocateHandleResponse *)choice;
}


GCC_ResponsePDU::operator const GCC_RegistryAllocateHandleResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_RegistryAllocateHandleResponse), PInvalidCast);
#endif
  return *(GCC_RegistryAllocateHandleResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_ResponsePDU::operator GCC_FunctionNotSupportedResponse &() const
#else
GCC_ResponsePDU::operator GCC_FunctionNotSupportedResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_FunctionNotSupportedResponse), PInvalidCast);
#endif
  return *(GCC_FunctionNotSupportedResponse *)choice;
}


GCC_ResponsePDU::operator const GCC_FunctionNotSupportedResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_FunctionNotSupportedResponse), PInvalidCast);
#endif
  return *(GCC_FunctionNotSupportedResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_ResponsePDU::operator GCC_NonStandardPDU &() const
#else
GCC_ResponsePDU::operator GCC_NonStandardPDU &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_NonStandardPDU), PInvalidCast);
#endif
  return *(GCC_NonStandardPDU *)choice;
}


GCC_ResponsePDU::operator const GCC_NonStandardPDU &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_NonStandardPDU), PInvalidCast);
#endif
  return *(GCC_NonStandardPDU *)choice;
}


BOOL GCC_ResponsePDU::CreateObject()
{
  switch (tag) {
    case e_conferenceJoinResponse :
      choice = new GCC_ConferenceJoinResponse();
      return TRUE;
    case e_conferenceAddResponse :
      choice = new GCC_ConferenceAddResponse();
      return TRUE;
    case e_conferenceLockResponse :
      choice = new GCC_ConferenceLockResponse();
      return TRUE;
    case e_conferenceUnlockResponse :
      choice = new GCC_ConferenceUnlockResponse();
      return TRUE;
    case e_conferenceTerminateResponse :
      choice = new GCC_ConferenceTerminateResponse();
      return TRUE;
    case e_conferenceEjectUserResponse :
      choice = new GCC_ConferenceEjectUserResponse();
      return TRUE;
    case e_conferenceTransferResponse :
      choice = new GCC_ConferenceTransferResponse();
      return TRUE;
    case e_registryResponse :
      choice = new GCC_RegistryResponse();
      return TRUE;
    case e_registryAllocateHandleResponse :
      choice = new GCC_RegistryAllocateHandleResponse();
      return TRUE;
    case e_functionNotSupportedResponse :
      choice = new GCC_FunctionNotSupportedResponse();
      return TRUE;
    case e_nonStandardResponse :
      choice = new GCC_NonStandardPDU();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * GCC_ResponsePDU::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ResponsePDU::Class()), PInvalidCast);
#endif
  return new GCC_ResponsePDU(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_GCC_IndicationPDU[]={
      {"userIDIndication",0}
     ,{"conferenceLockIndication",1}
     ,{"conferenceUnlockIndication",2}
     ,{"conferenceTerminateIndication",3}
     ,{"conferenceEjectUserIndication",4}
     ,{"conferenceTransferIndication",5}
     ,{"rosterUpdateIndication",6}
     ,{"applicationInvokeIndication",7}
     ,{"registryMonitorEntryIndication",8}
     ,{"conductorAssignIndication",9}
     ,{"conductorReleaseIndication",10}
     ,{"conductorPermissionAskIndication",11}
     ,{"conductorPermissionGrantIndication",12}
     ,{"conferenceTimeRemainingIndication",13}
     ,{"conferenceTimeInquireIndication",14}
     ,{"conferenceTimeExtendIndication",15}
     ,{"conferenceAssistanceIndication",16}
     ,{"textMessageIndication",17}
     ,{"nonStandardIndication",18}
};
#endif
//
// IndicationPDU
//

GCC_IndicationPDU::GCC_IndicationPDU(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 19, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_GCC_IndicationPDU,19
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_IndicationPDU::operator GCC_UserIDIndication &() const
#else
GCC_IndicationPDU::operator GCC_UserIDIndication &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_UserIDIndication), PInvalidCast);
#endif
  return *(GCC_UserIDIndication *)choice;
}


GCC_IndicationPDU::operator const GCC_UserIDIndication &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_UserIDIndication), PInvalidCast);
#endif
  return *(GCC_UserIDIndication *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_IndicationPDU::operator GCC_ConferenceLockIndication &() const
#else
GCC_IndicationPDU::operator GCC_ConferenceLockIndication &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceLockIndication), PInvalidCast);
#endif
  return *(GCC_ConferenceLockIndication *)choice;
}


GCC_IndicationPDU::operator const GCC_ConferenceLockIndication &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceLockIndication), PInvalidCast);
#endif
  return *(GCC_ConferenceLockIndication *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_IndicationPDU::operator GCC_ConferenceUnlockIndication &() const
#else
GCC_IndicationPDU::operator GCC_ConferenceUnlockIndication &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceUnlockIndication), PInvalidCast);
#endif
  return *(GCC_ConferenceUnlockIndication *)choice;
}


GCC_IndicationPDU::operator const GCC_ConferenceUnlockIndication &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceUnlockIndication), PInvalidCast);
#endif
  return *(GCC_ConferenceUnlockIndication *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_IndicationPDU::operator GCC_ConferenceTerminateIndication &() const
#else
GCC_IndicationPDU::operator GCC_ConferenceTerminateIndication &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceTerminateIndication), PInvalidCast);
#endif
  return *(GCC_ConferenceTerminateIndication *)choice;
}


GCC_IndicationPDU::operator const GCC_ConferenceTerminateIndication &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceTerminateIndication), PInvalidCast);
#endif
  return *(GCC_ConferenceTerminateIndication *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_IndicationPDU::operator GCC_ConferenceEjectUserIndication &() const
#else
GCC_IndicationPDU::operator GCC_ConferenceEjectUserIndication &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceEjectUserIndication), PInvalidCast);
#endif
  return *(GCC_ConferenceEjectUserIndication *)choice;
}


GCC_IndicationPDU::operator const GCC_ConferenceEjectUserIndication &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceEjectUserIndication), PInvalidCast);
#endif
  return *(GCC_ConferenceEjectUserIndication *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_IndicationPDU::operator GCC_ConferenceTransferIndication &() const
#else
GCC_IndicationPDU::operator GCC_ConferenceTransferIndication &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceTransferIndication), PInvalidCast);
#endif
  return *(GCC_ConferenceTransferIndication *)choice;
}


GCC_IndicationPDU::operator const GCC_ConferenceTransferIndication &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceTransferIndication), PInvalidCast);
#endif
  return *(GCC_ConferenceTransferIndication *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_IndicationPDU::operator GCC_RosterUpdateIndication &() const
#else
GCC_IndicationPDU::operator GCC_RosterUpdateIndication &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_RosterUpdateIndication), PInvalidCast);
#endif
  return *(GCC_RosterUpdateIndication *)choice;
}


GCC_IndicationPDU::operator const GCC_RosterUpdateIndication &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_RosterUpdateIndication), PInvalidCast);
#endif
  return *(GCC_RosterUpdateIndication *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_IndicationPDU::operator GCC_ApplicationInvokeIndication &() const
#else
GCC_IndicationPDU::operator GCC_ApplicationInvokeIndication &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ApplicationInvokeIndication), PInvalidCast);
#endif
  return *(GCC_ApplicationInvokeIndication *)choice;
}


GCC_IndicationPDU::operator const GCC_ApplicationInvokeIndication &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ApplicationInvokeIndication), PInvalidCast);
#endif
  return *(GCC_ApplicationInvokeIndication *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_IndicationPDU::operator GCC_RegistryMonitorEntryIndication &() const
#else
GCC_IndicationPDU::operator GCC_RegistryMonitorEntryIndication &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_RegistryMonitorEntryIndication), PInvalidCast);
#endif
  return *(GCC_RegistryMonitorEntryIndication *)choice;
}


GCC_IndicationPDU::operator const GCC_RegistryMonitorEntryIndication &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_RegistryMonitorEntryIndication), PInvalidCast);
#endif
  return *(GCC_RegistryMonitorEntryIndication *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_IndicationPDU::operator GCC_ConductorAssignIndication &() const
#else
GCC_IndicationPDU::operator GCC_ConductorAssignIndication &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConductorAssignIndication), PInvalidCast);
#endif
  return *(GCC_ConductorAssignIndication *)choice;
}


GCC_IndicationPDU::operator const GCC_ConductorAssignIndication &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConductorAssignIndication), PInvalidCast);
#endif
  return *(GCC_ConductorAssignIndication *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_IndicationPDU::operator GCC_ConductorReleaseIndication &() const
#else
GCC_IndicationPDU::operator GCC_ConductorReleaseIndication &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConductorReleaseIndication), PInvalidCast);
#endif
  return *(GCC_ConductorReleaseIndication *)choice;
}


GCC_IndicationPDU::operator const GCC_ConductorReleaseIndication &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConductorReleaseIndication), PInvalidCast);
#endif
  return *(GCC_ConductorReleaseIndication *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_IndicationPDU::operator GCC_ConductorPermissionAskIndication &() const
#else
GCC_IndicationPDU::operator GCC_ConductorPermissionAskIndication &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConductorPermissionAskIndication), PInvalidCast);
#endif
  return *(GCC_ConductorPermissionAskIndication *)choice;
}


GCC_IndicationPDU::operator const GCC_ConductorPermissionAskIndication &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConductorPermissionAskIndication), PInvalidCast);
#endif
  return *(GCC_ConductorPermissionAskIndication *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_IndicationPDU::operator GCC_ConductorPermissionGrantIndication &() const
#else
GCC_IndicationPDU::operator GCC_ConductorPermissionGrantIndication &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConductorPermissionGrantIndication), PInvalidCast);
#endif
  return *(GCC_ConductorPermissionGrantIndication *)choice;
}


GCC_IndicationPDU::operator const GCC_ConductorPermissionGrantIndication &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConductorPermissionGrantIndication), PInvalidCast);
#endif
  return *(GCC_ConductorPermissionGrantIndication *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_IndicationPDU::operator GCC_ConferenceTimeRemainingIndication &() const
#else
GCC_IndicationPDU::operator GCC_ConferenceTimeRemainingIndication &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceTimeRemainingIndication), PInvalidCast);
#endif
  return *(GCC_ConferenceTimeRemainingIndication *)choice;
}


GCC_IndicationPDU::operator const GCC_ConferenceTimeRemainingIndication &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceTimeRemainingIndication), PInvalidCast);
#endif
  return *(GCC_ConferenceTimeRemainingIndication *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_IndicationPDU::operator GCC_ConferenceTimeInquireIndication &() const
#else
GCC_IndicationPDU::operator GCC_ConferenceTimeInquireIndication &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceTimeInquireIndication), PInvalidCast);
#endif
  return *(GCC_ConferenceTimeInquireIndication *)choice;
}


GCC_IndicationPDU::operator const GCC_ConferenceTimeInquireIndication &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceTimeInquireIndication), PInvalidCast);
#endif
  return *(GCC_ConferenceTimeInquireIndication *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_IndicationPDU::operator GCC_ConferenceTimeExtendIndication &() const
#else
GCC_IndicationPDU::operator GCC_ConferenceTimeExtendIndication &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceTimeExtendIndication), PInvalidCast);
#endif
  return *(GCC_ConferenceTimeExtendIndication *)choice;
}


GCC_IndicationPDU::operator const GCC_ConferenceTimeExtendIndication &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceTimeExtendIndication), PInvalidCast);
#endif
  return *(GCC_ConferenceTimeExtendIndication *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_IndicationPDU::operator GCC_ConferenceAssistanceIndication &() const
#else
GCC_IndicationPDU::operator GCC_ConferenceAssistanceIndication &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceAssistanceIndication), PInvalidCast);
#endif
  return *(GCC_ConferenceAssistanceIndication *)choice;
}


GCC_IndicationPDU::operator const GCC_ConferenceAssistanceIndication &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ConferenceAssistanceIndication), PInvalidCast);
#endif
  return *(GCC_ConferenceAssistanceIndication *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_IndicationPDU::operator GCC_TextMessageIndication &() const
#else
GCC_IndicationPDU::operator GCC_TextMessageIndication &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_TextMessageIndication), PInvalidCast);
#endif
  return *(GCC_TextMessageIndication *)choice;
}


GCC_IndicationPDU::operator const GCC_TextMessageIndication &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_TextMessageIndication), PInvalidCast);
#endif
  return *(GCC_TextMessageIndication *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_IndicationPDU::operator GCC_NonStandardPDU &() const
#else
GCC_IndicationPDU::operator GCC_NonStandardPDU &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_NonStandardPDU), PInvalidCast);
#endif
  return *(GCC_NonStandardPDU *)choice;
}


GCC_IndicationPDU::operator const GCC_NonStandardPDU &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_NonStandardPDU), PInvalidCast);
#endif
  return *(GCC_NonStandardPDU *)choice;
}


BOOL GCC_IndicationPDU::CreateObject()
{
  switch (tag) {
    case e_userIDIndication :
      choice = new GCC_UserIDIndication();
      return TRUE;
    case e_conferenceLockIndication :
      choice = new GCC_ConferenceLockIndication();
      return TRUE;
    case e_conferenceUnlockIndication :
      choice = new GCC_ConferenceUnlockIndication();
      return TRUE;
    case e_conferenceTerminateIndication :
      choice = new GCC_ConferenceTerminateIndication();
      return TRUE;
    case e_conferenceEjectUserIndication :
      choice = new GCC_ConferenceEjectUserIndication();
      return TRUE;
    case e_conferenceTransferIndication :
      choice = new GCC_ConferenceTransferIndication();
      return TRUE;
    case e_rosterUpdateIndication :
      choice = new GCC_RosterUpdateIndication();
      return TRUE;
    case e_applicationInvokeIndication :
      choice = new GCC_ApplicationInvokeIndication();
      return TRUE;
    case e_registryMonitorEntryIndication :
      choice = new GCC_RegistryMonitorEntryIndication();
      return TRUE;
    case e_conductorAssignIndication :
      choice = new GCC_ConductorAssignIndication();
      return TRUE;
    case e_conductorReleaseIndication :
      choice = new GCC_ConductorReleaseIndication();
      return TRUE;
    case e_conductorPermissionAskIndication :
      choice = new GCC_ConductorPermissionAskIndication();
      return TRUE;
    case e_conductorPermissionGrantIndication :
      choice = new GCC_ConductorPermissionGrantIndication();
      return TRUE;
    case e_conferenceTimeRemainingIndication :
      choice = new GCC_ConferenceTimeRemainingIndication();
      return TRUE;
    case e_conferenceTimeInquireIndication :
      choice = new GCC_ConferenceTimeInquireIndication();
      return TRUE;
    case e_conferenceTimeExtendIndication :
      choice = new GCC_ConferenceTimeExtendIndication();
      return TRUE;
    case e_conferenceAssistanceIndication :
      choice = new GCC_ConferenceAssistanceIndication();
      return TRUE;
    case e_textMessageIndication :
      choice = new GCC_TextMessageIndication();
      return TRUE;
    case e_nonStandardIndication :
      choice = new GCC_NonStandardPDU();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * GCC_IndicationPDU::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_IndicationPDU::Class()), PInvalidCast);
#endif
  return new GCC_IndicationPDU(*this);
}


//
// UserData_subtype
//

GCC_UserData_subtype::GCC_UserData_subtype(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_UserData_subtype::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+6) << "key = " << setprecision(indent) << m_key << '\n';
  if (HasOptionalField(e_value))
    strm << setw(indent+8) << "value = " << setprecision(indent) << m_value << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_UserData_subtype::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_UserData_subtype), PInvalidCast);
#endif
  const GCC_UserData_subtype & other = (const GCC_UserData_subtype &)obj;

  Comparison result;

  if ((result = m_key.Compare(other.m_key)) != EqualTo)
    return result;
  if ((result = m_value.Compare(other.m_value)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_UserData_subtype::GetDataLength() const
{
  PINDEX length = 0;
  length += m_key.GetObjectLength();
  if (HasOptionalField(e_value))
    length += m_value.GetObjectLength();
  return length;
}


BOOL GCC_UserData_subtype::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_key.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_value) && !m_value.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_UserData_subtype::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_key.Encode(strm);
  if (HasOptionalField(e_value))
    m_value.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_UserData_subtype::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_UserData_subtype::Class()), PInvalidCast);
#endif
  return new GCC_UserData_subtype(*this);
}


//
// ArrayOf_ChallengeItem
//

GCC_ArrayOf_ChallengeItem::GCC_ArrayOf_ChallengeItem(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * GCC_ArrayOf_ChallengeItem::CreateObject() const
{
  return new GCC_ChallengeItem;
}


GCC_ChallengeItem & GCC_ArrayOf_ChallengeItem::operator[](PINDEX i) const
{
  return (GCC_ChallengeItem &)array[i];
}


PObject * GCC_ArrayOf_ChallengeItem::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ArrayOf_ChallengeItem::Class()), PInvalidCast);
#endif
  return new GCC_ArrayOf_ChallengeItem(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_GCC_NetworkAddress_subtype[]={
      {"aggregatedChannel",0}
     ,{"transportConnection",1}
     ,{"nonStandard",2}
};
#endif
//
// NetworkAddress_subtype
//

GCC_NetworkAddress_subtype::GCC_NetworkAddress_subtype(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_GCC_NetworkAddress_subtype,3
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_NetworkAddress_subtype::operator GCC_NetworkAddress_subtype_aggregatedChannel &() const
#else
GCC_NetworkAddress_subtype::operator GCC_NetworkAddress_subtype_aggregatedChannel &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_NetworkAddress_subtype_aggregatedChannel), PInvalidCast);
#endif
  return *(GCC_NetworkAddress_subtype_aggregatedChannel *)choice;
}


GCC_NetworkAddress_subtype::operator const GCC_NetworkAddress_subtype_aggregatedChannel &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_NetworkAddress_subtype_aggregatedChannel), PInvalidCast);
#endif
  return *(GCC_NetworkAddress_subtype_aggregatedChannel *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_NetworkAddress_subtype::operator GCC_NetworkAddress_subtype_transportConnection &() const
#else
GCC_NetworkAddress_subtype::operator GCC_NetworkAddress_subtype_transportConnection &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_NetworkAddress_subtype_transportConnection), PInvalidCast);
#endif
  return *(GCC_NetworkAddress_subtype_transportConnection *)choice;
}


GCC_NetworkAddress_subtype::operator const GCC_NetworkAddress_subtype_transportConnection &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_NetworkAddress_subtype_transportConnection), PInvalidCast);
#endif
  return *(GCC_NetworkAddress_subtype_transportConnection *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_NetworkAddress_subtype::operator GCC_NonStandardParameter &() const
#else
GCC_NetworkAddress_subtype::operator GCC_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_NonStandardParameter), PInvalidCast);
#endif
  return *(GCC_NonStandardParameter *)choice;
}


GCC_NetworkAddress_subtype::operator const GCC_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_NonStandardParameter), PInvalidCast);
#endif
  return *(GCC_NonStandardParameter *)choice;
}


BOOL GCC_NetworkAddress_subtype::CreateObject()
{
  switch (tag) {
    case e_aggregatedChannel :
      choice = new GCC_NetworkAddress_subtype_aggregatedChannel();
      return TRUE;
    case e_transportConnection :
      choice = new GCC_NetworkAddress_subtype_transportConnection();
      return TRUE;
    case e_nonStandard :
      choice = new GCC_NonStandardParameter();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * GCC_NetworkAddress_subtype::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_NetworkAddress_subtype::Class()), PInvalidCast);
#endif
  return new GCC_NetworkAddress_subtype(*this);
}


//
// ArrayOf_TextString
//

GCC_ArrayOf_TextString::GCC_ArrayOf_TextString(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * GCC_ArrayOf_TextString::CreateObject() const
{
  return new GCC_TextString;
}


GCC_TextString & GCC_ArrayOf_TextString::operator[](PINDEX i) const
{
  return (GCC_TextString &)array[i];
}


PObject * GCC_ArrayOf_TextString::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ArrayOf_TextString::Class()), PInvalidCast);
#endif
  return new GCC_ArrayOf_TextString(*this);
}


//
// ApplicationRecord_nonCollapsingCapabilities
//

GCC_ApplicationRecord_nonCollapsingCapabilities::GCC_ApplicationRecord_nonCollapsingCapabilities(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * GCC_ApplicationRecord_nonCollapsingCapabilities::CreateObject() const
{
  return new GCC_ApplicationRecord_nonCollapsingCapabilities_subtype;
}


GCC_ApplicationRecord_nonCollapsingCapabilities_subtype & GCC_ApplicationRecord_nonCollapsingCapabilities::operator[](PINDEX i) const
{
  return (GCC_ApplicationRecord_nonCollapsingCapabilities_subtype &)array[i];
}


PObject * GCC_ApplicationRecord_nonCollapsingCapabilities::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ApplicationRecord_nonCollapsingCapabilities::Class()), PInvalidCast);
#endif
  return new GCC_ApplicationRecord_nonCollapsingCapabilities(*this);
}


//
// ApplicationInvokeSpecifier_expectedCapabilitySet
//

GCC_ApplicationInvokeSpecifier_expectedCapabilitySet::GCC_ApplicationInvokeSpecifier_expectedCapabilitySet(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * GCC_ApplicationInvokeSpecifier_expectedCapabilitySet::CreateObject() const
{
  return new GCC_ApplicationInvokeSpecifier_expectedCapabilitySet_subtype;
}


GCC_ApplicationInvokeSpecifier_expectedCapabilitySet_subtype & GCC_ApplicationInvokeSpecifier_expectedCapabilitySet::operator[](PINDEX i) const
{
  return (GCC_ApplicationInvokeSpecifier_expectedCapabilitySet_subtype &)array[i];
}


PObject * GCC_ApplicationInvokeSpecifier_expectedCapabilitySet::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ApplicationInvokeSpecifier_expectedCapabilitySet::Class()), PInvalidCast);
#endif
  return new GCC_ApplicationInvokeSpecifier_expectedCapabilitySet(*this);
}


//
// RegistryEntryOwner_owned
//

GCC_RegistryEntryOwner_owned::GCC_RegistryEntryOwner_owned(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_RegistryEntryOwner_owned::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+9) << "nodeID = " << setprecision(indent) << m_nodeID << '\n';
  strm << setw(indent+11) << "entityID = " << setprecision(indent) << m_entityID << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_RegistryEntryOwner_owned::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_RegistryEntryOwner_owned), PInvalidCast);
#endif
  const GCC_RegistryEntryOwner_owned & other = (const GCC_RegistryEntryOwner_owned &)obj;

  Comparison result;

  if ((result = m_nodeID.Compare(other.m_nodeID)) != EqualTo)
    return result;
  if ((result = m_entityID.Compare(other.m_entityID)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_RegistryEntryOwner_owned::GetDataLength() const
{
  PINDEX length = 0;
  length += m_nodeID.GetObjectLength();
  length += m_entityID.GetObjectLength();
  return length;
}


BOOL GCC_RegistryEntryOwner_owned::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_nodeID.Decode(strm))
    return FALSE;
  if (!m_entityID.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_RegistryEntryOwner_owned::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_nodeID.Encode(strm);
  m_entityID.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_RegistryEntryOwner_owned::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_RegistryEntryOwner_owned::Class()), PInvalidCast);
#endif
  return new GCC_RegistryEntryOwner_owned(*this);
}


//
// ArrayOf_Privilege
//

GCC_ArrayOf_Privilege::GCC_ArrayOf_Privilege(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * GCC_ArrayOf_Privilege::CreateObject() const
{
  return new GCC_Privilege;
}


GCC_Privilege & GCC_ArrayOf_Privilege::operator[](PINDEX i) const
{
  return (GCC_Privilege &)array[i];
}


PObject * GCC_ArrayOf_Privilege::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ArrayOf_Privilege::Class()), PInvalidCast);
#endif
  return new GCC_ArrayOf_Privilege(*this);
}


#ifndef PASN_NOPRINTON
const static PASN_Names Names_GCC_ConferenceCreateResponse_result[]={
        {"success",0}
       ,{"userRejected",1}
       ,{"resourcesNotAvailable",2}
       ,{"rejectedForSymmetryBreaking",3}
       ,{"lockedConferenceNotSupported",4}
};
#endif
//
// ConferenceCreateResponse_result
//

GCC_ConferenceCreateResponse_result::GCC_ConferenceCreateResponse_result(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_GCC_ConferenceCreateResponse_result,5
#endif
    )
{
}


GCC_ConferenceCreateResponse_result & GCC_ConferenceCreateResponse_result::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * GCC_ConferenceCreateResponse_result::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferenceCreateResponse_result::Class()), PInvalidCast);
#endif
  return new GCC_ConferenceCreateResponse_result(*this);
}


//
// ArrayOf_ConferenceDescriptor
//

GCC_ArrayOf_ConferenceDescriptor::GCC_ArrayOf_ConferenceDescriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * GCC_ArrayOf_ConferenceDescriptor::CreateObject() const
{
  return new GCC_ConferenceDescriptor;
}


GCC_ConferenceDescriptor & GCC_ArrayOf_ConferenceDescriptor::operator[](PINDEX i) const
{
  return (GCC_ConferenceDescriptor &)array[i];
}


PObject * GCC_ArrayOf_ConferenceDescriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ArrayOf_ConferenceDescriptor::Class()), PInvalidCast);
#endif
  return new GCC_ArrayOf_ConferenceDescriptor(*this);
}


#ifndef PASN_NOPRINTON
const static PASN_Names Names_GCC_ConferenceQueryResponse_result[]={
        {"success",0}
       ,{"userRejected",1}
};
#endif
//
// ConferenceQueryResponse_result
//

GCC_ConferenceQueryResponse_result::GCC_ConferenceQueryResponse_result(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 1, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_GCC_ConferenceQueryResponse_result,2
#endif
    )
{
}


GCC_ConferenceQueryResponse_result & GCC_ConferenceQueryResponse_result::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * GCC_ConferenceQueryResponse_result::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferenceQueryResponse_result::Class()), PInvalidCast);
#endif
  return new GCC_ConferenceQueryResponse_result(*this);
}


#ifndef PASN_NOPRINTON
const static PASN_Names Names_GCC_ConferenceJoinResponse_result[]={
        {"success",0}
       ,{"userRejected",1}
       ,{"invalidConference",2}
       ,{"invalidPassword",3}
       ,{"invalidConvenerPassword",4}
       ,{"challengeResponseRequired",5}
       ,{"invalidChallengeResponse",6}
};
#endif
//
// ConferenceJoinResponse_result
//

GCC_ConferenceJoinResponse_result::GCC_ConferenceJoinResponse_result(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 6, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_GCC_ConferenceJoinResponse_result,7
#endif
    )
{
}


GCC_ConferenceJoinResponse_result & GCC_ConferenceJoinResponse_result::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * GCC_ConferenceJoinResponse_result::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferenceJoinResponse_result::Class()), PInvalidCast);
#endif
  return new GCC_ConferenceJoinResponse_result(*this);
}


#ifndef PASN_NOPRINTON
const static PASN_Names Names_GCC_ConferenceInviteResponse_result[]={
        {"success",0}
       ,{"userRejected",1}
};
#endif
//
// ConferenceInviteResponse_result
//

GCC_ConferenceInviteResponse_result::GCC_ConferenceInviteResponse_result(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 1, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_GCC_ConferenceInviteResponse_result,2
#endif
    )
{
}


GCC_ConferenceInviteResponse_result & GCC_ConferenceInviteResponse_result::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * GCC_ConferenceInviteResponse_result::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferenceInviteResponse_result::Class()), PInvalidCast);
#endif
  return new GCC_ConferenceInviteResponse_result(*this);
}


#ifndef PASN_NOPRINTON
const static PASN_Names Names_GCC_ConferenceAddResponse_result[]={
        {"success",0}
       ,{"invalidRequester",1}
       ,{"invalidNetworkType",2}
       ,{"invalidNetworkAddress",3}
       ,{"addedNodeBusy",4}
       ,{"networkBusy",5}
       ,{"noPortsAvailable",6}
       ,{"connectionUnsuccessful",7}
};
#endif
//
// ConferenceAddResponse_result
//

GCC_ConferenceAddResponse_result::GCC_ConferenceAddResponse_result(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 7, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_GCC_ConferenceAddResponse_result,8
#endif
    )
{
}


GCC_ConferenceAddResponse_result & GCC_ConferenceAddResponse_result::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * GCC_ConferenceAddResponse_result::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferenceAddResponse_result::Class()), PInvalidCast);
#endif
  return new GCC_ConferenceAddResponse_result(*this);
}


#ifndef PASN_NOPRINTON
const static PASN_Names Names_GCC_ConferenceLockResponse_result[]={
        {"success",0}
       ,{"invalidRequester",1}
       ,{"alreadyLocked",2}
};
#endif
//
// ConferenceLockResponse_result
//

GCC_ConferenceLockResponse_result::GCC_ConferenceLockResponse_result(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_GCC_ConferenceLockResponse_result,3
#endif
    )
{
}


GCC_ConferenceLockResponse_result & GCC_ConferenceLockResponse_result::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * GCC_ConferenceLockResponse_result::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferenceLockResponse_result::Class()), PInvalidCast);
#endif
  return new GCC_ConferenceLockResponse_result(*this);
}


#ifndef PASN_NOPRINTON
const static PASN_Names Names_GCC_ConferenceUnlockResponse_result[]={
        {"success",0}
       ,{"invalidRequester",1}
       ,{"alreadyUnlocked",2}
};
#endif
//
// ConferenceUnlockResponse_result
//

GCC_ConferenceUnlockResponse_result::GCC_ConferenceUnlockResponse_result(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_GCC_ConferenceUnlockResponse_result,3
#endif
    )
{
}


GCC_ConferenceUnlockResponse_result & GCC_ConferenceUnlockResponse_result::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * GCC_ConferenceUnlockResponse_result::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferenceUnlockResponse_result::Class()), PInvalidCast);
#endif
  return new GCC_ConferenceUnlockResponse_result(*this);
}


#ifndef PASN_NOPRINTON
const static PASN_Names Names_GCC_ConferenceTerminateRequest_reason[]={
        {"userInitiated",0}
       ,{"timedConferenceTermination",1}
};
#endif
//
// ConferenceTerminateRequest_reason
//

GCC_ConferenceTerminateRequest_reason::GCC_ConferenceTerminateRequest_reason(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 1, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_GCC_ConferenceTerminateRequest_reason,2
#endif
    )
{
}


GCC_ConferenceTerminateRequest_reason & GCC_ConferenceTerminateRequest_reason::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * GCC_ConferenceTerminateRequest_reason::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferenceTerminateRequest_reason::Class()), PInvalidCast);
#endif
  return new GCC_ConferenceTerminateRequest_reason(*this);
}


#ifndef PASN_NOPRINTON
const static PASN_Names Names_GCC_ConferenceTerminateResponse_result[]={
        {"success",0}
       ,{"invalidRequester",1}
};
#endif
//
// ConferenceTerminateResponse_result
//

GCC_ConferenceTerminateResponse_result::GCC_ConferenceTerminateResponse_result(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 1, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_GCC_ConferenceTerminateResponse_result,2
#endif
    )
{
}


GCC_ConferenceTerminateResponse_result & GCC_ConferenceTerminateResponse_result::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * GCC_ConferenceTerminateResponse_result::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferenceTerminateResponse_result::Class()), PInvalidCast);
#endif
  return new GCC_ConferenceTerminateResponse_result(*this);
}


#ifndef PASN_NOPRINTON
const static PASN_Names Names_GCC_ConferenceTerminateIndication_reason[]={
        {"userInitiated",0}
       ,{"timedConferenceTermination",1}
};
#endif
//
// ConferenceTerminateIndication_reason
//

GCC_ConferenceTerminateIndication_reason::GCC_ConferenceTerminateIndication_reason(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 1, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_GCC_ConferenceTerminateIndication_reason,2
#endif
    )
{
}


GCC_ConferenceTerminateIndication_reason & GCC_ConferenceTerminateIndication_reason::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * GCC_ConferenceTerminateIndication_reason::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferenceTerminateIndication_reason::Class()), PInvalidCast);
#endif
  return new GCC_ConferenceTerminateIndication_reason(*this);
}


#ifndef PASN_NOPRINTON
const static PASN_Names Names_GCC_ConferenceEjectUserRequest_reason[]={
        {"userInitiated",0}
};
#endif
//
// ConferenceEjectUserRequest_reason
//

GCC_ConferenceEjectUserRequest_reason::GCC_ConferenceEjectUserRequest_reason(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 0, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_GCC_ConferenceEjectUserRequest_reason,1
#endif
    )
{
}


GCC_ConferenceEjectUserRequest_reason & GCC_ConferenceEjectUserRequest_reason::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * GCC_ConferenceEjectUserRequest_reason::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferenceEjectUserRequest_reason::Class()), PInvalidCast);
#endif
  return new GCC_ConferenceEjectUserRequest_reason(*this);
}


#ifndef PASN_NOPRINTON
const static PASN_Names Names_GCC_ConferenceEjectUserResponse_result[]={
        {"success",0}
       ,{"invalidRequester",1}
       ,{"invalidNode",2}
};
#endif
//
// ConferenceEjectUserResponse_result
//

GCC_ConferenceEjectUserResponse_result::GCC_ConferenceEjectUserResponse_result(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_GCC_ConferenceEjectUserResponse_result,3
#endif
    )
{
}


GCC_ConferenceEjectUserResponse_result & GCC_ConferenceEjectUserResponse_result::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * GCC_ConferenceEjectUserResponse_result::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferenceEjectUserResponse_result::Class()), PInvalidCast);
#endif
  return new GCC_ConferenceEjectUserResponse_result(*this);
}


#ifndef PASN_NOPRINTON
const static PASN_Names Names_GCC_ConferenceEjectUserIndication_reason[]={
        {"userInitiated",0}
       ,{"higherNodeDisconnected",1}
       ,{"higherNodeEjected",2}
};
#endif
//
// ConferenceEjectUserIndication_reason
//

GCC_ConferenceEjectUserIndication_reason::GCC_ConferenceEjectUserIndication_reason(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_GCC_ConferenceEjectUserIndication_reason,3
#endif
    )
{
}


GCC_ConferenceEjectUserIndication_reason & GCC_ConferenceEjectUserIndication_reason::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * GCC_ConferenceEjectUserIndication_reason::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferenceEjectUserIndication_reason::Class()), PInvalidCast);
#endif
  return new GCC_ConferenceEjectUserIndication_reason(*this);
}


//
// ArrayOf_UserID
//

GCC_ArrayOf_UserID::GCC_ArrayOf_UserID(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * GCC_ArrayOf_UserID::CreateObject() const
{
  return new GCC_UserID;
}


GCC_UserID & GCC_ArrayOf_UserID::operator[](PINDEX i) const
{
  return (GCC_UserID &)array[i];
}


PObject * GCC_ArrayOf_UserID::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ArrayOf_UserID::Class()), PInvalidCast);
#endif
  return new GCC_ArrayOf_UserID(*this);
}


#ifndef PASN_NOPRINTON
const static PASN_Names Names_GCC_ConferenceTransferResponse_result[]={
        {"success",0}
       ,{"invalidRequester",1}
};
#endif
//
// ConferenceTransferResponse_result
//

GCC_ConferenceTransferResponse_result::GCC_ConferenceTransferResponse_result(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 1, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_GCC_ConferenceTransferResponse_result,2
#endif
    )
{
}


GCC_ConferenceTransferResponse_result & GCC_ConferenceTransferResponse_result::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * GCC_ConferenceTransferResponse_result::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferenceTransferResponse_result::Class()), PInvalidCast);
#endif
  return new GCC_ConferenceTransferResponse_result(*this);
}


//
// RosterUpdateIndication_applicationInformation
//

GCC_RosterUpdateIndication_applicationInformation::GCC_RosterUpdateIndication_applicationInformation(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


PASN_Object * GCC_RosterUpdateIndication_applicationInformation::CreateObject() const
{
  return new GCC_RosterUpdateIndication_applicationInformation_subtype;
}


GCC_RosterUpdateIndication_applicationInformation_subtype & GCC_RosterUpdateIndication_applicationInformation::operator[](PINDEX i) const
{
  return (GCC_RosterUpdateIndication_applicationInformation_subtype &)array[i];
}


PObject * GCC_RosterUpdateIndication_applicationInformation::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_RosterUpdateIndication_applicationInformation::Class()), PInvalidCast);
#endif
  return new GCC_RosterUpdateIndication_applicationInformation(*this);
}


//
// ArrayOf_ApplicationInvokeSpecifier
//

GCC_ArrayOf_ApplicationInvokeSpecifier::GCC_ArrayOf_ApplicationInvokeSpecifier(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * GCC_ArrayOf_ApplicationInvokeSpecifier::CreateObject() const
{
  return new GCC_ApplicationInvokeSpecifier;
}


GCC_ApplicationInvokeSpecifier & GCC_ArrayOf_ApplicationInvokeSpecifier::operator[](PINDEX i) const
{
  return (GCC_ApplicationInvokeSpecifier &)array[i];
}


PObject * GCC_ArrayOf_ApplicationInvokeSpecifier::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ArrayOf_ApplicationInvokeSpecifier::Class()), PInvalidCast);
#endif
  return new GCC_ArrayOf_ApplicationInvokeSpecifier(*this);
}


#ifndef PASN_NOPRINTON
const static PASN_Names Names_GCC_RegistryAllocateHandleResponse_result[]={
        {"successful",0}
       ,{"noHandlesAvailable",1}
};
#endif
//
// RegistryAllocateHandleResponse_result
//

GCC_RegistryAllocateHandleResponse_result::GCC_RegistryAllocateHandleResponse_result(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 1, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_GCC_RegistryAllocateHandleResponse_result,2
#endif
    )
{
}


GCC_RegistryAllocateHandleResponse_result & GCC_RegistryAllocateHandleResponse_result::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * GCC_RegistryAllocateHandleResponse_result::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_RegistryAllocateHandleResponse_result::Class()), PInvalidCast);
#endif
  return new GCC_RegistryAllocateHandleResponse_result(*this);
}


#ifndef PASN_NOPRINTON
const static PASN_Names Names_GCC_RegistryResponse_primitiveType[]={
        {"registerChannel",0}
       ,{"assignToken",1}
       ,{"setParameter",2}
       ,{"retrieveEntry",3}
       ,{"deleteEntry",4}
       ,{"monitorEntry",5}
};
#endif
//
// RegistryResponse_primitiveType
//

GCC_RegistryResponse_primitiveType::GCC_RegistryResponse_primitiveType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 5, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_GCC_RegistryResponse_primitiveType,6
#endif
    )
{
}


GCC_RegistryResponse_primitiveType & GCC_RegistryResponse_primitiveType::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * GCC_RegistryResponse_primitiveType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_RegistryResponse_primitiveType::Class()), PInvalidCast);
#endif
  return new GCC_RegistryResponse_primitiveType(*this);
}


#ifndef PASN_NOPRINTON
const static PASN_Names Names_GCC_RegistryResponse_result[]={
        {"successful",0}
       ,{"belongsToOther",1}
       ,{"tooManyEntries",2}
       ,{"inconsistentType",3}
       ,{"entryNotFound",4}
       ,{"entryAlreadyExists",5}
       ,{"invalidRequester",6}
};
#endif
//
// RegistryResponse_result
//

GCC_RegistryResponse_result::GCC_RegistryResponse_result(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 6, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_GCC_RegistryResponse_result,7
#endif
    )
{
}


GCC_RegistryResponse_result & GCC_RegistryResponse_result::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * GCC_RegistryResponse_result::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_RegistryResponse_result::Class()), PInvalidCast);
#endif
  return new GCC_RegistryResponse_result(*this);
}


//
// NetworkAddress_subtype_transportConnection
//

GCC_NetworkAddress_subtype_transportConnection::GCC_NetworkAddress_subtype_transportConnection(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, FALSE, 0)
{
  m_nsapAddress.SetConstraints(PASN_Object::FixedConstraint, 1, 20);
}


#ifndef PASN_NOPRINTON
void GCC_NetworkAddress_subtype_transportConnection::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+14) << "nsapAddress = " << setprecision(indent) << m_nsapAddress << '\n';
  if (HasOptionalField(e_transportSelector))
    strm << setw(indent+20) << "transportSelector = " << setprecision(indent) << m_transportSelector << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_NetworkAddress_subtype_transportConnection::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_NetworkAddress_subtype_transportConnection), PInvalidCast);
#endif
  const GCC_NetworkAddress_subtype_transportConnection & other = (const GCC_NetworkAddress_subtype_transportConnection &)obj;

  Comparison result;

  if ((result = m_nsapAddress.Compare(other.m_nsapAddress)) != EqualTo)
    return result;
  if ((result = m_transportSelector.Compare(other.m_transportSelector)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_NetworkAddress_subtype_transportConnection::GetDataLength() const
{
  PINDEX length = 0;
  length += m_nsapAddress.GetObjectLength();
  if (HasOptionalField(e_transportSelector))
    length += m_transportSelector.GetObjectLength();
  return length;
}


BOOL GCC_NetworkAddress_subtype_transportConnection::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_nsapAddress.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_transportSelector) && !m_transportSelector.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_NetworkAddress_subtype_transportConnection::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_nsapAddress.Encode(strm);
  if (HasOptionalField(e_transportSelector))
    m_transportSelector.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_NetworkAddress_subtype_transportConnection::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_NetworkAddress_subtype_transportConnection::Class()), PInvalidCast);
#endif
  return new GCC_NetworkAddress_subtype_transportConnection(*this);
}


//
// ApplicationRecord_nonCollapsingCapabilities_subtype
//

GCC_ApplicationRecord_nonCollapsingCapabilities_subtype::GCC_ApplicationRecord_nonCollapsingCapabilities_subtype(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_ApplicationRecord_nonCollapsingCapabilities_subtype::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "capabilityID = " << setprecision(indent) << m_capabilityID << '\n';
  if (HasOptionalField(e_applicationData))
    strm << setw(indent+18) << "applicationData = " << setprecision(indent) << m_applicationData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_ApplicationRecord_nonCollapsingCapabilities_subtype::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_ApplicationRecord_nonCollapsingCapabilities_subtype), PInvalidCast);
#endif
  const GCC_ApplicationRecord_nonCollapsingCapabilities_subtype & other = (const GCC_ApplicationRecord_nonCollapsingCapabilities_subtype &)obj;

  Comparison result;

  if ((result = m_capabilityID.Compare(other.m_capabilityID)) != EqualTo)
    return result;
  if ((result = m_applicationData.Compare(other.m_applicationData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_ApplicationRecord_nonCollapsingCapabilities_subtype::GetDataLength() const
{
  PINDEX length = 0;
  length += m_capabilityID.GetObjectLength();
  if (HasOptionalField(e_applicationData))
    length += m_applicationData.GetObjectLength();
  return length;
}


BOOL GCC_ApplicationRecord_nonCollapsingCapabilities_subtype::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_capabilityID.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_applicationData) && !m_applicationData.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_ApplicationRecord_nonCollapsingCapabilities_subtype::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_capabilityID.Encode(strm);
  if (HasOptionalField(e_applicationData))
    m_applicationData.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_ApplicationRecord_nonCollapsingCapabilities_subtype::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ApplicationRecord_nonCollapsingCapabilities_subtype::Class()), PInvalidCast);
#endif
  return new GCC_ApplicationRecord_nonCollapsingCapabilities_subtype(*this);
}


//
// ApplicationInvokeSpecifier_expectedCapabilitySet_subtype
//

GCC_ApplicationInvokeSpecifier_expectedCapabilitySet_subtype::GCC_ApplicationInvokeSpecifier_expectedCapabilitySet_subtype(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_ApplicationInvokeSpecifier_expectedCapabilitySet_subtype::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "capabilityID = " << setprecision(indent) << m_capabilityID << '\n';
  strm << setw(indent+18) << "capabilityClass = " << setprecision(indent) << m_capabilityClass << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_ApplicationInvokeSpecifier_expectedCapabilitySet_subtype::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_ApplicationInvokeSpecifier_expectedCapabilitySet_subtype), PInvalidCast);
#endif
  const GCC_ApplicationInvokeSpecifier_expectedCapabilitySet_subtype & other = (const GCC_ApplicationInvokeSpecifier_expectedCapabilitySet_subtype &)obj;

  Comparison result;

  if ((result = m_capabilityID.Compare(other.m_capabilityID)) != EqualTo)
    return result;
  if ((result = m_capabilityClass.Compare(other.m_capabilityClass)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_ApplicationInvokeSpecifier_expectedCapabilitySet_subtype::GetDataLength() const
{
  PINDEX length = 0;
  length += m_capabilityID.GetObjectLength();
  length += m_capabilityClass.GetObjectLength();
  return length;
}


BOOL GCC_ApplicationInvokeSpecifier_expectedCapabilitySet_subtype::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_capabilityID.Decode(strm))
    return FALSE;
  if (!m_capabilityClass.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_ApplicationInvokeSpecifier_expectedCapabilitySet_subtype::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_capabilityID.Encode(strm);
  m_capabilityClass.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_ApplicationInvokeSpecifier_expectedCapabilitySet_subtype::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ApplicationInvokeSpecifier_expectedCapabilitySet_subtype::Class()), PInvalidCast);
#endif
  return new GCC_ApplicationInvokeSpecifier_expectedCapabilitySet_subtype(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_GCC_RosterUpdateIndication_nodeInformation_nodeRecordList[]={
      {"noChange",0}
     ,{"refresh",1}
     ,{"update",2}
};
#endif
//
// RosterUpdateIndication_nodeInformation_nodeRecordList
//

GCC_RosterUpdateIndication_nodeInformation_nodeRecordList::GCC_RosterUpdateIndication_nodeInformation_nodeRecordList(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_GCC_RosterUpdateIndication_nodeInformation_nodeRecordList,3
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_RosterUpdateIndication_nodeInformation_nodeRecordList::operator GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_refresh &() const
#else
GCC_RosterUpdateIndication_nodeInformation_nodeRecordList::operator GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_refresh &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_refresh), PInvalidCast);
#endif
  return *(GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_refresh *)choice;
}


GCC_RosterUpdateIndication_nodeInformation_nodeRecordList::operator const GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_refresh &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_refresh), PInvalidCast);
#endif
  return *(GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_refresh *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_RosterUpdateIndication_nodeInformation_nodeRecordList::operator GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_update &() const
#else
GCC_RosterUpdateIndication_nodeInformation_nodeRecordList::operator GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_update &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_update), PInvalidCast);
#endif
  return *(GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_update *)choice;
}


GCC_RosterUpdateIndication_nodeInformation_nodeRecordList::operator const GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_update &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_update), PInvalidCast);
#endif
  return *(GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_update *)choice;
}


BOOL GCC_RosterUpdateIndication_nodeInformation_nodeRecordList::CreateObject()
{
  switch (tag) {
    case e_noChange :
      choice = new PASN_Null();
      return TRUE;
    case e_refresh :
      choice = new GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_refresh();
      return TRUE;
    case e_update :
      choice = new GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_update();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * GCC_RosterUpdateIndication_nodeInformation_nodeRecordList::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_RosterUpdateIndication_nodeInformation_nodeRecordList::Class()), PInvalidCast);
#endif
  return new GCC_RosterUpdateIndication_nodeInformation_nodeRecordList(*this);
}


//
// NetworkAddress_subtype_aggregatedChannel_transferModes
//

GCC_NetworkAddress_subtype_aggregatedChannel_transferModes::GCC_NetworkAddress_subtype_aggregatedChannel_transferModes(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_NetworkAddress_subtype_aggregatedChannel_transferModes::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+9) << "speech = " << setprecision(indent) << m_speech << '\n';
  strm << setw(indent+13) << "voice_band = " << setprecision(indent) << m_voice_band << '\n';
  strm << setw(indent+14) << "digital_56k = " << setprecision(indent) << m_digital_56k << '\n';
  strm << setw(indent+14) << "digital_64k = " << setprecision(indent) << m_digital_64k << '\n';
  strm << setw(indent+15) << "digital_128k = " << setprecision(indent) << m_digital_128k << '\n';
  strm << setw(indent+15) << "digital_192k = " << setprecision(indent) << m_digital_192k << '\n';
  strm << setw(indent+15) << "digital_256k = " << setprecision(indent) << m_digital_256k << '\n';
  strm << setw(indent+15) << "digital_320k = " << setprecision(indent) << m_digital_320k << '\n';
  strm << setw(indent+15) << "digital_384k = " << setprecision(indent) << m_digital_384k << '\n';
  strm << setw(indent+15) << "digital_512k = " << setprecision(indent) << m_digital_512k << '\n';
  strm << setw(indent+15) << "digital_768k = " << setprecision(indent) << m_digital_768k << '\n';
  strm << setw(indent+16) << "digital_1152k = " << setprecision(indent) << m_digital_1152k << '\n';
  strm << setw(indent+16) << "digital_1472k = " << setprecision(indent) << m_digital_1472k << '\n';
  strm << setw(indent+16) << "digital_1536k = " << setprecision(indent) << m_digital_1536k << '\n';
  strm << setw(indent+16) << "digital_1920k = " << setprecision(indent) << m_digital_1920k << '\n';
  strm << setw(indent+14) << "packet_mode = " << setprecision(indent) << m_packet_mode << '\n';
  strm << setw(indent+13) << "frame_mode = " << setprecision(indent) << m_frame_mode << '\n';
  strm << setw(indent+6) << "atm = " << setprecision(indent) << m_atm << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_NetworkAddress_subtype_aggregatedChannel_transferModes::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_NetworkAddress_subtype_aggregatedChannel_transferModes), PInvalidCast);
#endif
  const GCC_NetworkAddress_subtype_aggregatedChannel_transferModes & other = (const GCC_NetworkAddress_subtype_aggregatedChannel_transferModes &)obj;

  Comparison result;

  if ((result = m_speech.Compare(other.m_speech)) != EqualTo)
    return result;
  if ((result = m_voice_band.Compare(other.m_voice_band)) != EqualTo)
    return result;
  if ((result = m_digital_56k.Compare(other.m_digital_56k)) != EqualTo)
    return result;
  if ((result = m_digital_64k.Compare(other.m_digital_64k)) != EqualTo)
    return result;
  if ((result = m_digital_128k.Compare(other.m_digital_128k)) != EqualTo)
    return result;
  if ((result = m_digital_192k.Compare(other.m_digital_192k)) != EqualTo)
    return result;
  if ((result = m_digital_256k.Compare(other.m_digital_256k)) != EqualTo)
    return result;
  if ((result = m_digital_320k.Compare(other.m_digital_320k)) != EqualTo)
    return result;
  if ((result = m_digital_384k.Compare(other.m_digital_384k)) != EqualTo)
    return result;
  if ((result = m_digital_512k.Compare(other.m_digital_512k)) != EqualTo)
    return result;
  if ((result = m_digital_768k.Compare(other.m_digital_768k)) != EqualTo)
    return result;
  if ((result = m_digital_1152k.Compare(other.m_digital_1152k)) != EqualTo)
    return result;
  if ((result = m_digital_1472k.Compare(other.m_digital_1472k)) != EqualTo)
    return result;
  if ((result = m_digital_1536k.Compare(other.m_digital_1536k)) != EqualTo)
    return result;
  if ((result = m_digital_1920k.Compare(other.m_digital_1920k)) != EqualTo)
    return result;
  if ((result = m_packet_mode.Compare(other.m_packet_mode)) != EqualTo)
    return result;
  if ((result = m_frame_mode.Compare(other.m_frame_mode)) != EqualTo)
    return result;
  if ((result = m_atm.Compare(other.m_atm)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_NetworkAddress_subtype_aggregatedChannel_transferModes::GetDataLength() const
{
  PINDEX length = 0;
  length += m_speech.GetObjectLength();
  length += m_voice_band.GetObjectLength();
  length += m_digital_56k.GetObjectLength();
  length += m_digital_64k.GetObjectLength();
  length += m_digital_128k.GetObjectLength();
  length += m_digital_192k.GetObjectLength();
  length += m_digital_256k.GetObjectLength();
  length += m_digital_320k.GetObjectLength();
  length += m_digital_384k.GetObjectLength();
  length += m_digital_512k.GetObjectLength();
  length += m_digital_768k.GetObjectLength();
  length += m_digital_1152k.GetObjectLength();
  length += m_digital_1472k.GetObjectLength();
  length += m_digital_1536k.GetObjectLength();
  length += m_digital_1920k.GetObjectLength();
  length += m_packet_mode.GetObjectLength();
  length += m_frame_mode.GetObjectLength();
  length += m_atm.GetObjectLength();
  return length;
}


BOOL GCC_NetworkAddress_subtype_aggregatedChannel_transferModes::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_speech.Decode(strm))
    return FALSE;
  if (!m_voice_band.Decode(strm))
    return FALSE;
  if (!m_digital_56k.Decode(strm))
    return FALSE;
  if (!m_digital_64k.Decode(strm))
    return FALSE;
  if (!m_digital_128k.Decode(strm))
    return FALSE;
  if (!m_digital_192k.Decode(strm))
    return FALSE;
  if (!m_digital_256k.Decode(strm))
    return FALSE;
  if (!m_digital_320k.Decode(strm))
    return FALSE;
  if (!m_digital_384k.Decode(strm))
    return FALSE;
  if (!m_digital_512k.Decode(strm))
    return FALSE;
  if (!m_digital_768k.Decode(strm))
    return FALSE;
  if (!m_digital_1152k.Decode(strm))
    return FALSE;
  if (!m_digital_1472k.Decode(strm))
    return FALSE;
  if (!m_digital_1536k.Decode(strm))
    return FALSE;
  if (!m_digital_1920k.Decode(strm))
    return FALSE;
  if (!m_packet_mode.Decode(strm))
    return FALSE;
  if (!m_frame_mode.Decode(strm))
    return FALSE;
  if (!m_atm.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_NetworkAddress_subtype_aggregatedChannel_transferModes::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_speech.Encode(strm);
  m_voice_band.Encode(strm);
  m_digital_56k.Encode(strm);
  m_digital_64k.Encode(strm);
  m_digital_128k.Encode(strm);
  m_digital_192k.Encode(strm);
  m_digital_256k.Encode(strm);
  m_digital_320k.Encode(strm);
  m_digital_384k.Encode(strm);
  m_digital_512k.Encode(strm);
  m_digital_768k.Encode(strm);
  m_digital_1152k.Encode(strm);
  m_digital_1472k.Encode(strm);
  m_digital_1536k.Encode(strm);
  m_digital_1920k.Encode(strm);
  m_packet_mode.Encode(strm);
  m_frame_mode.Encode(strm);
  m_atm.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_NetworkAddress_subtype_aggregatedChannel_transferModes::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_NetworkAddress_subtype_aggregatedChannel_transferModes::Class()), PInvalidCast);
#endif
  return new GCC_NetworkAddress_subtype_aggregatedChannel_transferModes(*this);
}


//
// NetworkAddress_subtype_aggregatedChannel_highLayerCompatibility
//

GCC_NetworkAddress_subtype_aggregatedChannel_highLayerCompatibility::GCC_NetworkAddress_subtype_aggregatedChannel_highLayerCompatibility(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_NetworkAddress_subtype_aggregatedChannel_highLayerCompatibility::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "telephony3kHz = " << setprecision(indent) << m_telephony3kHz << '\n';
  strm << setw(indent+16) << "telephony7kHz = " << setprecision(indent) << m_telephony7kHz << '\n';
  strm << setw(indent+17) << "videotelephony = " << setprecision(indent) << m_videotelephony << '\n';
  strm << setw(indent+18) << "videoconference = " << setprecision(indent) << m_videoconference << '\n';
  strm << setw(indent+15) << "audiographic = " << setprecision(indent) << m_audiographic << '\n';
  strm << setw(indent+14) << "audiovisual = " << setprecision(indent) << m_audiovisual << '\n';
  strm << setw(indent+13) << "multimedia = " << setprecision(indent) << m_multimedia << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_NetworkAddress_subtype_aggregatedChannel_highLayerCompatibility::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_NetworkAddress_subtype_aggregatedChannel_highLayerCompatibility), PInvalidCast);
#endif
  const GCC_NetworkAddress_subtype_aggregatedChannel_highLayerCompatibility & other = (const GCC_NetworkAddress_subtype_aggregatedChannel_highLayerCompatibility &)obj;

  Comparison result;

  if ((result = m_telephony3kHz.Compare(other.m_telephony3kHz)) != EqualTo)
    return result;
  if ((result = m_telephony7kHz.Compare(other.m_telephony7kHz)) != EqualTo)
    return result;
  if ((result = m_videotelephony.Compare(other.m_videotelephony)) != EqualTo)
    return result;
  if ((result = m_videoconference.Compare(other.m_videoconference)) != EqualTo)
    return result;
  if ((result = m_audiographic.Compare(other.m_audiographic)) != EqualTo)
    return result;
  if ((result = m_audiovisual.Compare(other.m_audiovisual)) != EqualTo)
    return result;
  if ((result = m_multimedia.Compare(other.m_multimedia)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_NetworkAddress_subtype_aggregatedChannel_highLayerCompatibility::GetDataLength() const
{
  PINDEX length = 0;
  length += m_telephony3kHz.GetObjectLength();
  length += m_telephony7kHz.GetObjectLength();
  length += m_videotelephony.GetObjectLength();
  length += m_videoconference.GetObjectLength();
  length += m_audiographic.GetObjectLength();
  length += m_audiovisual.GetObjectLength();
  length += m_multimedia.GetObjectLength();
  return length;
}


BOOL GCC_NetworkAddress_subtype_aggregatedChannel_highLayerCompatibility::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_telephony3kHz.Decode(strm))
    return FALSE;
  if (!m_telephony7kHz.Decode(strm))
    return FALSE;
  if (!m_videotelephony.Decode(strm))
    return FALSE;
  if (!m_videoconference.Decode(strm))
    return FALSE;
  if (!m_audiographic.Decode(strm))
    return FALSE;
  if (!m_audiovisual.Decode(strm))
    return FALSE;
  if (!m_multimedia.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_NetworkAddress_subtype_aggregatedChannel_highLayerCompatibility::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_telephony3kHz.Encode(strm);
  m_telephony7kHz.Encode(strm);
  m_videotelephony.Encode(strm);
  m_videoconference.Encode(strm);
  m_audiographic.Encode(strm);
  m_audiovisual.Encode(strm);
  m_multimedia.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_NetworkAddress_subtype_aggregatedChannel_highLayerCompatibility::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_NetworkAddress_subtype_aggregatedChannel_highLayerCompatibility::Class()), PInvalidCast);
#endif
  return new GCC_NetworkAddress_subtype_aggregatedChannel_highLayerCompatibility(*this);
}


//
// RosterUpdateIndication_nodeInformation_nodeRecordList_refresh
//

GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_refresh::GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_refresh(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 65536);
}


PASN_Object * GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_refresh::CreateObject() const
{
  return new GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_refresh_subtype;
}


GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_refresh_subtype & GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_refresh::operator[](PINDEX i) const
{
  return (GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_refresh_subtype &)array[i];
}


PObject * GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_refresh::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_refresh::Class()), PInvalidCast);
#endif
  return new GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_refresh(*this);
}


//
// RosterUpdateIndication_nodeInformation_nodeRecordList_update
//

GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_update::GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_update(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 65536);
}


PASN_Object * GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_update::CreateObject() const
{
  return new GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_update_subtype;
}


GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_update_subtype & GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_update::operator[](PINDEX i) const
{
  return (GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_update_subtype &)array[i];
}


PObject * GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_update::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_update::Class()), PInvalidCast);
#endif
  return new GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_update(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList[]={
      {"noChange",0}
     ,{"refresh",1}
     ,{"update",2}
};
#endif
//
// RosterUpdateIndication_applicationInformation_subtype_applicationRecordList
//

GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList::GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList,3
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList::operator GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_refresh &() const
#else
GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList::operator GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_refresh &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_refresh), PInvalidCast);
#endif
  return *(GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_refresh *)choice;
}


GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList::operator const GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_refresh &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_refresh), PInvalidCast);
#endif
  return *(GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_refresh *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList::operator GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_update &() const
#else
GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList::operator GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_update &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_update), PInvalidCast);
#endif
  return *(GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_update *)choice;
}


GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList::operator const GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_update &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_update), PInvalidCast);
#endif
  return *(GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_update *)choice;
}


BOOL GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList::CreateObject()
{
  switch (tag) {
    case e_noChange :
      choice = new PASN_Null();
      return TRUE;
    case e_refresh :
      choice = new GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_refresh();
      return TRUE;
    case e_update :
      choice = new GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_update();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList::Class()), PInvalidCast);
#endif
  return new GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_GCC_RosterUpdateIndication_applicationInformation_subtype_applicationCapabilitiesList[]={
      {"noChange",0}
     ,{"refresh",1}
};
#endif
//
// RosterUpdateIndication_applicationInformation_subtype_applicationCapabilitiesList
//

GCC_RosterUpdateIndication_applicationInformation_subtype_applicationCapabilitiesList::GCC_RosterUpdateIndication_applicationInformation_subtype_applicationCapabilitiesList(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_GCC_RosterUpdateIndication_applicationInformation_subtype_applicationCapabilitiesList,2
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_RosterUpdateIndication_applicationInformation_subtype_applicationCapabilitiesList::operator GCC_RosterUpdateIndication_applicationInformation_subtype_applicationCapabilitiesList_refresh &() const
#else
GCC_RosterUpdateIndication_applicationInformation_subtype_applicationCapabilitiesList::operator GCC_RosterUpdateIndication_applicationInformation_subtype_applicationCapabilitiesList_refresh &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_RosterUpdateIndication_applicationInformation_subtype_applicationCapabilitiesList_refresh), PInvalidCast);
#endif
  return *(GCC_RosterUpdateIndication_applicationInformation_subtype_applicationCapabilitiesList_refresh *)choice;
}


GCC_RosterUpdateIndication_applicationInformation_subtype_applicationCapabilitiesList::operator const GCC_RosterUpdateIndication_applicationInformation_subtype_applicationCapabilitiesList_refresh &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_RosterUpdateIndication_applicationInformation_subtype_applicationCapabilitiesList_refresh), PInvalidCast);
#endif
  return *(GCC_RosterUpdateIndication_applicationInformation_subtype_applicationCapabilitiesList_refresh *)choice;
}


BOOL GCC_RosterUpdateIndication_applicationInformation_subtype_applicationCapabilitiesList::CreateObject()
{
  switch (tag) {
    case e_noChange :
      choice = new PASN_Null();
      return TRUE;
    case e_refresh :
      choice = new GCC_RosterUpdateIndication_applicationInformation_subtype_applicationCapabilitiesList_refresh();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * GCC_RosterUpdateIndication_applicationInformation_subtype_applicationCapabilitiesList::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_RosterUpdateIndication_applicationInformation_subtype_applicationCapabilitiesList::Class()), PInvalidCast);
#endif
  return new GCC_RosterUpdateIndication_applicationInformation_subtype_applicationCapabilitiesList(*this);
}


//
// RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_refresh
//

GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_refresh::GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_refresh(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


PASN_Object * GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_refresh::CreateObject() const
{
  return new GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_refresh_subtype;
}


GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_refresh_subtype & GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_refresh::operator[](PINDEX i) const
{
  return (GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_refresh_subtype &)array[i];
}


PObject * GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_refresh::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_refresh::Class()), PInvalidCast);
#endif
  return new GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_refresh(*this);
}


//
// RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_update
//

GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_update::GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_update(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 65536);
}


PASN_Object * GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_update::CreateObject() const
{
  return new GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_update_subtype;
}


GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_update_subtype & GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_update::operator[](PINDEX i) const
{
  return (GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_update_subtype &)array[i];
}


PObject * GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_update::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_update::Class()), PInvalidCast);
#endif
  return new GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_update(*this);
}


//
// RosterUpdateIndication_applicationInformation_subtype_applicationCapabilitiesList_refresh
//

GCC_RosterUpdateIndication_applicationInformation_subtype_applicationCapabilitiesList_refresh::GCC_RosterUpdateIndication_applicationInformation_subtype_applicationCapabilitiesList_refresh(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * GCC_RosterUpdateIndication_applicationInformation_subtype_applicationCapabilitiesList_refresh::CreateObject() const
{
  return new GCC_RosterUpdateIndication_applicationInformation_subtype_applicationCapabilitiesList_refresh_subtype;
}


GCC_RosterUpdateIndication_applicationInformation_subtype_applicationCapabilitiesList_refresh_subtype & GCC_RosterUpdateIndication_applicationInformation_subtype_applicationCapabilitiesList_refresh::operator[](PINDEX i) const
{
  return (GCC_RosterUpdateIndication_applicationInformation_subtype_applicationCapabilitiesList_refresh_subtype &)array[i];
}


PObject * GCC_RosterUpdateIndication_applicationInformation_subtype_applicationCapabilitiesList_refresh::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_RosterUpdateIndication_applicationInformation_subtype_applicationCapabilitiesList_refresh::Class()), PInvalidCast);
#endif
  return new GCC_RosterUpdateIndication_applicationInformation_subtype_applicationCapabilitiesList_refresh(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_update_subtype_nodeUpdate[]={
      {"addRecord",0}
     ,{"replaceRecord",1}
     ,{"removeRecord",2}
};
#endif
//
// RosterUpdateIndication_nodeInformation_nodeRecordList_update_subtype_nodeUpdate
//

GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_update_subtype_nodeUpdate::GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_update_subtype_nodeUpdate(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_update_subtype_nodeUpdate,3
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_update_subtype_nodeUpdate::operator GCC_NodeRecord &() const
#else
GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_update_subtype_nodeUpdate::operator GCC_NodeRecord &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_NodeRecord), PInvalidCast);
#endif
  return *(GCC_NodeRecord *)choice;
}


GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_update_subtype_nodeUpdate::operator const GCC_NodeRecord &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_NodeRecord), PInvalidCast);
#endif
  return *(GCC_NodeRecord *)choice;
}


BOOL GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_update_subtype_nodeUpdate::CreateObject()
{
  switch (tag) {
    case e_addRecord :
    case e_replaceRecord :
      choice = new GCC_NodeRecord();
      return TRUE;
    case e_removeRecord :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_update_subtype_nodeUpdate::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_update_subtype_nodeUpdate::Class()), PInvalidCast);
#endif
  return new GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_update_subtype_nodeUpdate(*this);
}


//
// RosterUpdateIndication_applicationInformation_subtype_applicationCapabilitiesList_refresh_subtype
//

GCC_RosterUpdateIndication_applicationInformation_subtype_applicationCapabilitiesList_refresh_subtype::GCC_RosterUpdateIndication_applicationInformation_subtype_applicationCapabilitiesList_refresh_subtype(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_numberOfEntities.SetConstraints(PASN_Object::FixedConstraint, 1, 65536);
}


#ifndef PASN_NOPRINTON
void GCC_RosterUpdateIndication_applicationInformation_subtype_applicationCapabilitiesList_refresh_subtype::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "capabilityID = " << setprecision(indent) << m_capabilityID << '\n';
  strm << setw(indent+18) << "capabilityClass = " << setprecision(indent) << m_capabilityClass << '\n';
  strm << setw(indent+19) << "numberOfEntities = " << setprecision(indent) << m_numberOfEntities << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_RosterUpdateIndication_applicationInformation_subtype_applicationCapabilitiesList_refresh_subtype::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_RosterUpdateIndication_applicationInformation_subtype_applicationCapabilitiesList_refresh_subtype), PInvalidCast);
#endif
  const GCC_RosterUpdateIndication_applicationInformation_subtype_applicationCapabilitiesList_refresh_subtype & other = (const GCC_RosterUpdateIndication_applicationInformation_subtype_applicationCapabilitiesList_refresh_subtype &)obj;

  Comparison result;

  if ((result = m_capabilityID.Compare(other.m_capabilityID)) != EqualTo)
    return result;
  if ((result = m_capabilityClass.Compare(other.m_capabilityClass)) != EqualTo)
    return result;
  if ((result = m_numberOfEntities.Compare(other.m_numberOfEntities)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_RosterUpdateIndication_applicationInformation_subtype_applicationCapabilitiesList_refresh_subtype::GetDataLength() const
{
  PINDEX length = 0;
  length += m_capabilityID.GetObjectLength();
  length += m_capabilityClass.GetObjectLength();
  length += m_numberOfEntities.GetObjectLength();
  return length;
}


BOOL GCC_RosterUpdateIndication_applicationInformation_subtype_applicationCapabilitiesList_refresh_subtype::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_capabilityID.Decode(strm))
    return FALSE;
  if (!m_capabilityClass.Decode(strm))
    return FALSE;
  if (!m_numberOfEntities.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_RosterUpdateIndication_applicationInformation_subtype_applicationCapabilitiesList_refresh_subtype::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_capabilityID.Encode(strm);
  m_capabilityClass.Encode(strm);
  m_numberOfEntities.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_RosterUpdateIndication_applicationInformation_subtype_applicationCapabilitiesList_refresh_subtype::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_RosterUpdateIndication_applicationInformation_subtype_applicationCapabilitiesList_refresh_subtype::Class()), PInvalidCast);
#endif
  return new GCC_RosterUpdateIndication_applicationInformation_subtype_applicationCapabilitiesList_refresh_subtype(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_update_subtype_applicationUpdate[]={
      {"addRecord",0}
     ,{"replaceRecord",1}
     ,{"removeRecord",2}
};
#endif
//
// RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_update_subtype_applicationUpdate
//

GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_update_subtype_applicationUpdate::GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_update_subtype_applicationUpdate(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_update_subtype_applicationUpdate,3
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_update_subtype_applicationUpdate::operator GCC_ApplicationRecord &() const
#else
GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_update_subtype_applicationUpdate::operator GCC_ApplicationRecord &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ApplicationRecord), PInvalidCast);
#endif
  return *(GCC_ApplicationRecord *)choice;
}


GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_update_subtype_applicationUpdate::operator const GCC_ApplicationRecord &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), GCC_ApplicationRecord), PInvalidCast);
#endif
  return *(GCC_ApplicationRecord *)choice;
}


BOOL GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_update_subtype_applicationUpdate::CreateObject()
{
  switch (tag) {
    case e_addRecord :
    case e_replaceRecord :
      choice = new GCC_ApplicationRecord();
      return TRUE;
    case e_removeRecord :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_update_subtype_applicationUpdate::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_update_subtype_applicationUpdate::Class()), PInvalidCast);
#endif
  return new GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_update_subtype_applicationUpdate(*this);
}


//
// ChallengeRequest
//

GCC_ChallengeRequest::GCC_ChallengeRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_ChallengeRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "challengeTag = " << setprecision(indent) << m_challengeTag << '\n';
  strm << setw(indent+15) << "challengeSet = " << setprecision(indent) << m_challengeSet << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_ChallengeRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_ChallengeRequest), PInvalidCast);
#endif
  const GCC_ChallengeRequest & other = (const GCC_ChallengeRequest &)obj;

  Comparison result;

  if ((result = m_challengeTag.Compare(other.m_challengeTag)) != EqualTo)
    return result;
  if ((result = m_challengeSet.Compare(other.m_challengeSet)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_ChallengeRequest::GetDataLength() const
{
  PINDEX length = 0;
  length += m_challengeTag.GetObjectLength();
  length += m_challengeSet.GetObjectLength();
  return length;
}


BOOL GCC_ChallengeRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_challengeTag.Decode(strm))
    return FALSE;
  if (!m_challengeSet.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_ChallengeRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_challengeTag.Encode(strm);
  m_challengeSet.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_ChallengeRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ChallengeRequest::Class()), PInvalidCast);
#endif
  return new GCC_ChallengeRequest(*this);
}


//
// NodeRecord
//

GCC_NodeRecord::GCC_NodeRecord(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 7, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_NodeRecord::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_superiorNode))
    strm << setw(indent+15) << "superiorNode = " << setprecision(indent) << m_superiorNode << '\n';
  strm << setw(indent+11) << "nodeType = " << setprecision(indent) << m_nodeType << '\n';
  strm << setw(indent+17) << "nodeProperties = " << setprecision(indent) << m_nodeProperties << '\n';
  if (HasOptionalField(e_nodeName))
    strm << setw(indent+11) << "nodeName = " << setprecision(indent) << m_nodeName << '\n';
  if (HasOptionalField(e_participantsList))
    strm << setw(indent+19) << "participantsList = " << setprecision(indent) << m_participantsList << '\n';
  if (HasOptionalField(e_siteInformation))
    strm << setw(indent+18) << "siteInformation = " << setprecision(indent) << m_siteInformation << '\n';
  if (HasOptionalField(e_networkAddress))
    strm << setw(indent+17) << "networkAddress = " << setprecision(indent) << m_networkAddress << '\n';
  if (HasOptionalField(e_alternativeNodeID))
    strm << setw(indent+20) << "alternativeNodeID = " << setprecision(indent) << m_alternativeNodeID << '\n';
  if (HasOptionalField(e_userData))
    strm << setw(indent+11) << "userData = " << setprecision(indent) << m_userData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_NodeRecord::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_NodeRecord), PInvalidCast);
#endif
  const GCC_NodeRecord & other = (const GCC_NodeRecord &)obj;

  Comparison result;

  if ((result = m_superiorNode.Compare(other.m_superiorNode)) != EqualTo)
    return result;
  if ((result = m_nodeType.Compare(other.m_nodeType)) != EqualTo)
    return result;
  if ((result = m_nodeProperties.Compare(other.m_nodeProperties)) != EqualTo)
    return result;
  if ((result = m_nodeName.Compare(other.m_nodeName)) != EqualTo)
    return result;
  if ((result = m_participantsList.Compare(other.m_participantsList)) != EqualTo)
    return result;
  if ((result = m_siteInformation.Compare(other.m_siteInformation)) != EqualTo)
    return result;
  if ((result = m_networkAddress.Compare(other.m_networkAddress)) != EqualTo)
    return result;
  if ((result = m_alternativeNodeID.Compare(other.m_alternativeNodeID)) != EqualTo)
    return result;
  if ((result = m_userData.Compare(other.m_userData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_NodeRecord::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_superiorNode))
    length += m_superiorNode.GetObjectLength();
  length += m_nodeType.GetObjectLength();
  length += m_nodeProperties.GetObjectLength();
  if (HasOptionalField(e_nodeName))
    length += m_nodeName.GetObjectLength();
  if (HasOptionalField(e_participantsList))
    length += m_participantsList.GetObjectLength();
  if (HasOptionalField(e_siteInformation))
    length += m_siteInformation.GetObjectLength();
  if (HasOptionalField(e_networkAddress))
    length += m_networkAddress.GetObjectLength();
  if (HasOptionalField(e_alternativeNodeID))
    length += m_alternativeNodeID.GetObjectLength();
  if (HasOptionalField(e_userData))
    length += m_userData.GetObjectLength();
  return length;
}


BOOL GCC_NodeRecord::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_superiorNode) && !m_superiorNode.Decode(strm))
    return FALSE;
  if (!m_nodeType.Decode(strm))
    return FALSE;
  if (!m_nodeProperties.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_nodeName) && !m_nodeName.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_participantsList) && !m_participantsList.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_siteInformation) && !m_siteInformation.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_networkAddress) && !m_networkAddress.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_alternativeNodeID) && !m_alternativeNodeID.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_userData) && !m_userData.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_NodeRecord::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_superiorNode))
    m_superiorNode.Encode(strm);
  m_nodeType.Encode(strm);
  m_nodeProperties.Encode(strm);
  if (HasOptionalField(e_nodeName))
    m_nodeName.Encode(strm);
  if (HasOptionalField(e_participantsList))
    m_participantsList.Encode(strm);
  if (HasOptionalField(e_siteInformation))
    m_siteInformation.Encode(strm);
  if (HasOptionalField(e_networkAddress))
    m_networkAddress.Encode(strm);
  if (HasOptionalField(e_alternativeNodeID))
    m_alternativeNodeID.Encode(strm);
  if (HasOptionalField(e_userData))
    m_userData.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_NodeRecord::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_NodeRecord::Class()), PInvalidCast);
#endif
  return new GCC_NodeRecord(*this);
}


//
// ApplicationRecord
//

GCC_ApplicationRecord::GCC_ApplicationRecord(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_ApplicationRecord::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+20) << "applicationActive = " << setprecision(indent) << m_applicationActive << '\n';
  strm << setw(indent+29) << "conductingOperationCapable = " << setprecision(indent) << m_conductingOperationCapable << '\n';
  if (HasOptionalField(e_startupChannel))
    strm << setw(indent+17) << "startupChannel = " << setprecision(indent) << m_startupChannel << '\n';
  if (HasOptionalField(e_applicationUserID))
    strm << setw(indent+20) << "applicationUserID = " << setprecision(indent) << m_applicationUserID << '\n';
  if (HasOptionalField(e_nonCollapsingCapabilities))
    strm << setw(indent+28) << "nonCollapsingCapabilities = " << setprecision(indent) << m_nonCollapsingCapabilities << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_ApplicationRecord::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_ApplicationRecord), PInvalidCast);
#endif
  const GCC_ApplicationRecord & other = (const GCC_ApplicationRecord &)obj;

  Comparison result;

  if ((result = m_applicationActive.Compare(other.m_applicationActive)) != EqualTo)
    return result;
  if ((result = m_conductingOperationCapable.Compare(other.m_conductingOperationCapable)) != EqualTo)
    return result;
  if ((result = m_startupChannel.Compare(other.m_startupChannel)) != EqualTo)
    return result;
  if ((result = m_applicationUserID.Compare(other.m_applicationUserID)) != EqualTo)
    return result;
  if ((result = m_nonCollapsingCapabilities.Compare(other.m_nonCollapsingCapabilities)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_ApplicationRecord::GetDataLength() const
{
  PINDEX length = 0;
  length += m_applicationActive.GetObjectLength();
  length += m_conductingOperationCapable.GetObjectLength();
  if (HasOptionalField(e_startupChannel))
    length += m_startupChannel.GetObjectLength();
  if (HasOptionalField(e_applicationUserID))
    length += m_applicationUserID.GetObjectLength();
  if (HasOptionalField(e_nonCollapsingCapabilities))
    length += m_nonCollapsingCapabilities.GetObjectLength();
  return length;
}


BOOL GCC_ApplicationRecord::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_applicationActive.Decode(strm))
    return FALSE;
  if (!m_conductingOperationCapable.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_startupChannel) && !m_startupChannel.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_applicationUserID) && !m_applicationUserID.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_nonCollapsingCapabilities) && !m_nonCollapsingCapabilities.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_ApplicationRecord::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_applicationActive.Encode(strm);
  m_conductingOperationCapable.Encode(strm);
  if (HasOptionalField(e_startupChannel))
    m_startupChannel.Encode(strm);
  if (HasOptionalField(e_applicationUserID))
    m_applicationUserID.Encode(strm);
  if (HasOptionalField(e_nonCollapsingCapabilities))
    m_nonCollapsingCapabilities.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_ApplicationRecord::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ApplicationRecord::Class()), PInvalidCast);
#endif
  return new GCC_ApplicationRecord(*this);
}


//
// ApplicationInvokeSpecifier
//

GCC_ApplicationInvokeSpecifier::GCC_ApplicationInvokeSpecifier(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_ApplicationInvokeSpecifier::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+13) << "sessionKey = " << setprecision(indent) << m_sessionKey << '\n';
  if (HasOptionalField(e_expectedCapabilitySet))
    strm << setw(indent+24) << "expectedCapabilitySet = " << setprecision(indent) << m_expectedCapabilitySet << '\n';
  if (HasOptionalField(e_startupChannel))
    strm << setw(indent+17) << "startupChannel = " << setprecision(indent) << m_startupChannel << '\n';
  strm << setw(indent+16) << "mandatoryFlag = " << setprecision(indent) << m_mandatoryFlag << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_ApplicationInvokeSpecifier::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_ApplicationInvokeSpecifier), PInvalidCast);
#endif
  const GCC_ApplicationInvokeSpecifier & other = (const GCC_ApplicationInvokeSpecifier &)obj;

  Comparison result;

  if ((result = m_sessionKey.Compare(other.m_sessionKey)) != EqualTo)
    return result;
  if ((result = m_expectedCapabilitySet.Compare(other.m_expectedCapabilitySet)) != EqualTo)
    return result;
  if ((result = m_startupChannel.Compare(other.m_startupChannel)) != EqualTo)
    return result;
  if ((result = m_mandatoryFlag.Compare(other.m_mandatoryFlag)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_ApplicationInvokeSpecifier::GetDataLength() const
{
  PINDEX length = 0;
  length += m_sessionKey.GetObjectLength();
  if (HasOptionalField(e_expectedCapabilitySet))
    length += m_expectedCapabilitySet.GetObjectLength();
  if (HasOptionalField(e_startupChannel))
    length += m_startupChannel.GetObjectLength();
  length += m_mandatoryFlag.GetObjectLength();
  return length;
}


BOOL GCC_ApplicationInvokeSpecifier::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_sessionKey.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_expectedCapabilitySet) && !m_expectedCapabilitySet.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_startupChannel) && !m_startupChannel.Decode(strm))
    return FALSE;
  if (!m_mandatoryFlag.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_ApplicationInvokeSpecifier::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_sessionKey.Encode(strm);
  if (HasOptionalField(e_expectedCapabilitySet))
    m_expectedCapabilitySet.Encode(strm);
  if (HasOptionalField(e_startupChannel))
    m_startupChannel.Encode(strm);
  m_mandatoryFlag.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_ApplicationInvokeSpecifier::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ApplicationInvokeSpecifier::Class()), PInvalidCast);
#endif
  return new GCC_ApplicationInvokeSpecifier(*this);
}


//
// ConferenceCreateRequest
//

GCC_ConferenceCreateRequest::GCC_ConferenceCreateRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 8, TRUE, 1)
{
}


#ifndef PASN_NOPRINTON
void GCC_ConferenceCreateRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "conferenceName = " << setprecision(indent) << m_conferenceName << '\n';
  if (HasOptionalField(e_convenerPassword))
    strm << setw(indent+19) << "convenerPassword = " << setprecision(indent) << m_convenerPassword << '\n';
  if (HasOptionalField(e_password))
    strm << setw(indent+11) << "password = " << setprecision(indent) << m_password << '\n';
  strm << setw(indent+19) << "lockedConference = " << setprecision(indent) << m_lockedConference << '\n';
  strm << setw(indent+19) << "listedConference = " << setprecision(indent) << m_listedConference << '\n';
  strm << setw(indent+24) << "conductibleConference = " << setprecision(indent) << m_conductibleConference << '\n';
  strm << setw(indent+20) << "terminationMethod = " << setprecision(indent) << m_terminationMethod << '\n';
  if (HasOptionalField(e_conductorPrivileges))
    strm << setw(indent+22) << "conductorPrivileges = " << setprecision(indent) << m_conductorPrivileges << '\n';
  if (HasOptionalField(e_conductedPrivileges))
    strm << setw(indent+22) << "conductedPrivileges = " << setprecision(indent) << m_conductedPrivileges << '\n';
  if (HasOptionalField(e_nonConductedPrivileges))
    strm << setw(indent+25) << "nonConductedPrivileges = " << setprecision(indent) << m_nonConductedPrivileges << '\n';
  if (HasOptionalField(e_conferenceDescription))
    strm << setw(indent+24) << "conferenceDescription = " << setprecision(indent) << m_conferenceDescription << '\n';
  if (HasOptionalField(e_callerIdentifier))
    strm << setw(indent+19) << "callerIdentifier = " << setprecision(indent) << m_callerIdentifier << '\n';
  if (HasOptionalField(e_userData))
    strm << setw(indent+11) << "userData = " << setprecision(indent) << m_userData << '\n';
  if (HasOptionalField(e_conferencePriority))
    strm << setw(indent+21) << "conferencePriority = " << setprecision(indent) << m_conferencePriority << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_ConferenceCreateRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_ConferenceCreateRequest), PInvalidCast);
#endif
  const GCC_ConferenceCreateRequest & other = (const GCC_ConferenceCreateRequest &)obj;

  Comparison result;

  if ((result = m_conferenceName.Compare(other.m_conferenceName)) != EqualTo)
    return result;
  if ((result = m_convenerPassword.Compare(other.m_convenerPassword)) != EqualTo)
    return result;
  if ((result = m_password.Compare(other.m_password)) != EqualTo)
    return result;
  if ((result = m_lockedConference.Compare(other.m_lockedConference)) != EqualTo)
    return result;
  if ((result = m_listedConference.Compare(other.m_listedConference)) != EqualTo)
    return result;
  if ((result = m_conductibleConference.Compare(other.m_conductibleConference)) != EqualTo)
    return result;
  if ((result = m_terminationMethod.Compare(other.m_terminationMethod)) != EqualTo)
    return result;
  if ((result = m_conductorPrivileges.Compare(other.m_conductorPrivileges)) != EqualTo)
    return result;
  if ((result = m_conductedPrivileges.Compare(other.m_conductedPrivileges)) != EqualTo)
    return result;
  if ((result = m_nonConductedPrivileges.Compare(other.m_nonConductedPrivileges)) != EqualTo)
    return result;
  if ((result = m_conferenceDescription.Compare(other.m_conferenceDescription)) != EqualTo)
    return result;
  if ((result = m_callerIdentifier.Compare(other.m_callerIdentifier)) != EqualTo)
    return result;
  if ((result = m_userData.Compare(other.m_userData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_ConferenceCreateRequest::GetDataLength() const
{
  PINDEX length = 0;
  length += m_conferenceName.GetObjectLength();
  if (HasOptionalField(e_convenerPassword))
    length += m_convenerPassword.GetObjectLength();
  if (HasOptionalField(e_password))
    length += m_password.GetObjectLength();
  length += m_lockedConference.GetObjectLength();
  length += m_listedConference.GetObjectLength();
  length += m_conductibleConference.GetObjectLength();
  length += m_terminationMethod.GetObjectLength();
  if (HasOptionalField(e_conductorPrivileges))
    length += m_conductorPrivileges.GetObjectLength();
  if (HasOptionalField(e_conductedPrivileges))
    length += m_conductedPrivileges.GetObjectLength();
  if (HasOptionalField(e_nonConductedPrivileges))
    length += m_nonConductedPrivileges.GetObjectLength();
  if (HasOptionalField(e_conferenceDescription))
    length += m_conferenceDescription.GetObjectLength();
  if (HasOptionalField(e_callerIdentifier))
    length += m_callerIdentifier.GetObjectLength();
  if (HasOptionalField(e_userData))
    length += m_userData.GetObjectLength();
  return length;
}


BOOL GCC_ConferenceCreateRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_conferenceName.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_convenerPassword) && !m_convenerPassword.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_password) && !m_password.Decode(strm))
    return FALSE;
  if (!m_lockedConference.Decode(strm))
    return FALSE;
  if (!m_listedConference.Decode(strm))
    return FALSE;
  if (!m_conductibleConference.Decode(strm))
    return FALSE;
  if (!m_terminationMethod.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_conductorPrivileges) && !m_conductorPrivileges.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_conductedPrivileges) && !m_conductedPrivileges.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_nonConductedPrivileges) && !m_nonConductedPrivileges.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_conferenceDescription) && !m_conferenceDescription.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_callerIdentifier) && !m_callerIdentifier.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_userData) && !m_userData.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_conferencePriority, m_conferencePriority))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_ConferenceCreateRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_conferenceName.Encode(strm);
  if (HasOptionalField(e_convenerPassword))
    m_convenerPassword.Encode(strm);
  if (HasOptionalField(e_password))
    m_password.Encode(strm);
  m_lockedConference.Encode(strm);
  m_listedConference.Encode(strm);
  m_conductibleConference.Encode(strm);
  m_terminationMethod.Encode(strm);
  if (HasOptionalField(e_conductorPrivileges))
    m_conductorPrivileges.Encode(strm);
  if (HasOptionalField(e_conductedPrivileges))
    m_conductedPrivileges.Encode(strm);
  if (HasOptionalField(e_nonConductedPrivileges))
    m_nonConductedPrivileges.Encode(strm);
  if (HasOptionalField(e_conferenceDescription))
    m_conferenceDescription.Encode(strm);
  if (HasOptionalField(e_callerIdentifier))
    m_callerIdentifier.Encode(strm);
  if (HasOptionalField(e_userData))
    m_userData.Encode(strm);
  KnownExtensionEncode(strm, e_conferencePriority, m_conferencePriority);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_ConferenceCreateRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferenceCreateRequest::Class()), PInvalidCast);
#endif
  return new GCC_ConferenceCreateRequest(*this);
}


//
// ConferenceCreateResponse
//

GCC_ConferenceCreateResponse::GCC_ConferenceCreateResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_ConferenceCreateResponse::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+9) << "nodeID = " << setprecision(indent) << m_nodeID << '\n';
  strm << setw(indent+6) << "tag = " << setprecision(indent) << m_tag << '\n';
  strm << setw(indent+9) << "result = " << setprecision(indent) << m_result << '\n';
  if (HasOptionalField(e_userData))
    strm << setw(indent+11) << "userData = " << setprecision(indent) << m_userData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_ConferenceCreateResponse::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_ConferenceCreateResponse), PInvalidCast);
#endif
  const GCC_ConferenceCreateResponse & other = (const GCC_ConferenceCreateResponse &)obj;

  Comparison result;

  if ((result = m_nodeID.Compare(other.m_nodeID)) != EqualTo)
    return result;
  if ((result = m_tag.Compare(other.m_tag)) != EqualTo)
    return result;
  if ((result = m_result.Compare(other.m_result)) != EqualTo)
    return result;
  if ((result = m_userData.Compare(other.m_userData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_ConferenceCreateResponse::GetDataLength() const
{
  PINDEX length = 0;
  length += m_nodeID.GetObjectLength();
  length += m_tag.GetObjectLength();
  length += m_result.GetObjectLength();
  if (HasOptionalField(e_userData))
    length += m_userData.GetObjectLength();
  return length;
}


BOOL GCC_ConferenceCreateResponse::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_nodeID.Decode(strm))
    return FALSE;
  if (!m_tag.Decode(strm))
    return FALSE;
  if (!m_result.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_userData) && !m_userData.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_ConferenceCreateResponse::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_nodeID.Encode(strm);
  m_tag.Encode(strm);
  m_result.Encode(strm);
  if (HasOptionalField(e_userData))
    m_userData.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_ConferenceCreateResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferenceCreateResponse::Class()), PInvalidCast);
#endif
  return new GCC_ConferenceCreateResponse(*this);
}


//
// ConferenceQueryResponse
//

GCC_ConferenceQueryResponse::GCC_ConferenceQueryResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 2)
{
}


#ifndef PASN_NOPRINTON
void GCC_ConferenceQueryResponse::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "nodeType = " << setprecision(indent) << m_nodeType << '\n';
  if (HasOptionalField(e_asymmetryIndicator))
    strm << setw(indent+21) << "asymmetryIndicator = " << setprecision(indent) << m_asymmetryIndicator << '\n';
  strm << setw(indent+17) << "conferenceList = " << setprecision(indent) << m_conferenceList << '\n';
  strm << setw(indent+9) << "result = " << setprecision(indent) << m_result << '\n';
  if (HasOptionalField(e_userData))
    strm << setw(indent+11) << "userData = " << setprecision(indent) << m_userData << '\n';
  if (HasOptionalField(e_waitForInvitationFlag))
    strm << setw(indent+24) << "waitForInvitationFlag = " << setprecision(indent) << m_waitForInvitationFlag << '\n';
  if (HasOptionalField(e_noUnlistedConferenceFlag))
    strm << setw(indent+27) << "noUnlistedConferenceFlag = " << setprecision(indent) << m_noUnlistedConferenceFlag << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_ConferenceQueryResponse::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_ConferenceQueryResponse), PInvalidCast);
#endif
  const GCC_ConferenceQueryResponse & other = (const GCC_ConferenceQueryResponse &)obj;

  Comparison result;

  if ((result = m_nodeType.Compare(other.m_nodeType)) != EqualTo)
    return result;
  if ((result = m_asymmetryIndicator.Compare(other.m_asymmetryIndicator)) != EqualTo)
    return result;
  if ((result = m_conferenceList.Compare(other.m_conferenceList)) != EqualTo)
    return result;
  if ((result = m_result.Compare(other.m_result)) != EqualTo)
    return result;
  if ((result = m_userData.Compare(other.m_userData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_ConferenceQueryResponse::GetDataLength() const
{
  PINDEX length = 0;
  length += m_nodeType.GetObjectLength();
  if (HasOptionalField(e_asymmetryIndicator))
    length += m_asymmetryIndicator.GetObjectLength();
  length += m_conferenceList.GetObjectLength();
  length += m_result.GetObjectLength();
  if (HasOptionalField(e_userData))
    length += m_userData.GetObjectLength();
  return length;
}


BOOL GCC_ConferenceQueryResponse::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_nodeType.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_asymmetryIndicator) && !m_asymmetryIndicator.Decode(strm))
    return FALSE;
  if (!m_conferenceList.Decode(strm))
    return FALSE;
  if (!m_result.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_userData) && !m_userData.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_waitForInvitationFlag, m_waitForInvitationFlag))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_noUnlistedConferenceFlag, m_noUnlistedConferenceFlag))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_ConferenceQueryResponse::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_nodeType.Encode(strm);
  if (HasOptionalField(e_asymmetryIndicator))
    m_asymmetryIndicator.Encode(strm);
  m_conferenceList.Encode(strm);
  m_result.Encode(strm);
  if (HasOptionalField(e_userData))
    m_userData.Encode(strm);
  KnownExtensionEncode(strm, e_waitForInvitationFlag, m_waitForInvitationFlag);
  KnownExtensionEncode(strm, e_noUnlistedConferenceFlag, m_noUnlistedConferenceFlag);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_ConferenceQueryResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferenceQueryResponse::Class()), PInvalidCast);
#endif
  return new GCC_ConferenceQueryResponse(*this);
}


//
// ConferenceJoinResponse
//

GCC_ConferenceJoinResponse::GCC_ConferenceJoinResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 8, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_ConferenceJoinResponse::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nodeID))
    strm << setw(indent+9) << "nodeID = " << setprecision(indent) << m_nodeID << '\n';
  strm << setw(indent+12) << "topNodeID = " << setprecision(indent) << m_topNodeID << '\n';
  strm << setw(indent+6) << "tag = " << setprecision(indent) << m_tag << '\n';
  if (HasOptionalField(e_conferenceNameAlias))
    strm << setw(indent+22) << "conferenceNameAlias = " << setprecision(indent) << m_conferenceNameAlias << '\n';
  strm << setw(indent+29) << "passwordInTheClearRequired = " << setprecision(indent) << m_passwordInTheClearRequired << '\n';
  strm << setw(indent+19) << "lockedConference = " << setprecision(indent) << m_lockedConference << '\n';
  strm << setw(indent+19) << "listedConference = " << setprecision(indent) << m_listedConference << '\n';
  strm << setw(indent+24) << "conductibleConference = " << setprecision(indent) << m_conductibleConference << '\n';
  strm << setw(indent+20) << "terminationMethod = " << setprecision(indent) << m_terminationMethod << '\n';
  if (HasOptionalField(e_conductorPrivileges))
    strm << setw(indent+22) << "conductorPrivileges = " << setprecision(indent) << m_conductorPrivileges << '\n';
  if (HasOptionalField(e_conductedPrivileges))
    strm << setw(indent+22) << "conductedPrivileges = " << setprecision(indent) << m_conductedPrivileges << '\n';
  if (HasOptionalField(e_nonConductedPrivileges))
    strm << setw(indent+25) << "nonConductedPrivileges = " << setprecision(indent) << m_nonConductedPrivileges << '\n';
  if (HasOptionalField(e_conferenceDescription))
    strm << setw(indent+24) << "conferenceDescription = " << setprecision(indent) << m_conferenceDescription << '\n';
  if (HasOptionalField(e_password))
    strm << setw(indent+11) << "password = " << setprecision(indent) << m_password << '\n';
  strm << setw(indent+9) << "result = " << setprecision(indent) << m_result << '\n';
  if (HasOptionalField(e_userData))
    strm << setw(indent+11) << "userData = " << setprecision(indent) << m_userData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_ConferenceJoinResponse::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_ConferenceJoinResponse), PInvalidCast);
#endif
  const GCC_ConferenceJoinResponse & other = (const GCC_ConferenceJoinResponse &)obj;

  Comparison result;

  if ((result = m_nodeID.Compare(other.m_nodeID)) != EqualTo)
    return result;
  if ((result = m_topNodeID.Compare(other.m_topNodeID)) != EqualTo)
    return result;
  if ((result = m_tag.Compare(other.m_tag)) != EqualTo)
    return result;
  if ((result = m_conferenceNameAlias.Compare(other.m_conferenceNameAlias)) != EqualTo)
    return result;
  if ((result = m_passwordInTheClearRequired.Compare(other.m_passwordInTheClearRequired)) != EqualTo)
    return result;
  if ((result = m_lockedConference.Compare(other.m_lockedConference)) != EqualTo)
    return result;
  if ((result = m_listedConference.Compare(other.m_listedConference)) != EqualTo)
    return result;
  if ((result = m_conductibleConference.Compare(other.m_conductibleConference)) != EqualTo)
    return result;
  if ((result = m_terminationMethod.Compare(other.m_terminationMethod)) != EqualTo)
    return result;
  if ((result = m_conductorPrivileges.Compare(other.m_conductorPrivileges)) != EqualTo)
    return result;
  if ((result = m_conductedPrivileges.Compare(other.m_conductedPrivileges)) != EqualTo)
    return result;
  if ((result = m_nonConductedPrivileges.Compare(other.m_nonConductedPrivileges)) != EqualTo)
    return result;
  if ((result = m_conferenceDescription.Compare(other.m_conferenceDescription)) != EqualTo)
    return result;
  if ((result = m_password.Compare(other.m_password)) != EqualTo)
    return result;
  if ((result = m_result.Compare(other.m_result)) != EqualTo)
    return result;
  if ((result = m_userData.Compare(other.m_userData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_ConferenceJoinResponse::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_nodeID))
    length += m_nodeID.GetObjectLength();
  length += m_topNodeID.GetObjectLength();
  length += m_tag.GetObjectLength();
  if (HasOptionalField(e_conferenceNameAlias))
    length += m_conferenceNameAlias.GetObjectLength();
  length += m_passwordInTheClearRequired.GetObjectLength();
  length += m_lockedConference.GetObjectLength();
  length += m_listedConference.GetObjectLength();
  length += m_conductibleConference.GetObjectLength();
  length += m_terminationMethod.GetObjectLength();
  if (HasOptionalField(e_conductorPrivileges))
    length += m_conductorPrivileges.GetObjectLength();
  if (HasOptionalField(e_conductedPrivileges))
    length += m_conductedPrivileges.GetObjectLength();
  if (HasOptionalField(e_nonConductedPrivileges))
    length += m_nonConductedPrivileges.GetObjectLength();
  if (HasOptionalField(e_conferenceDescription))
    length += m_conferenceDescription.GetObjectLength();
  if (HasOptionalField(e_password))
    length += m_password.GetObjectLength();
  length += m_result.GetObjectLength();
  if (HasOptionalField(e_userData))
    length += m_userData.GetObjectLength();
  return length;
}


BOOL GCC_ConferenceJoinResponse::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_nodeID) && !m_nodeID.Decode(strm))
    return FALSE;
  if (!m_topNodeID.Decode(strm))
    return FALSE;
  if (!m_tag.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_conferenceNameAlias) && !m_conferenceNameAlias.Decode(strm))
    return FALSE;
  if (!m_passwordInTheClearRequired.Decode(strm))
    return FALSE;
  if (!m_lockedConference.Decode(strm))
    return FALSE;
  if (!m_listedConference.Decode(strm))
    return FALSE;
  if (!m_conductibleConference.Decode(strm))
    return FALSE;
  if (!m_terminationMethod.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_conductorPrivileges) && !m_conductorPrivileges.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_conductedPrivileges) && !m_conductedPrivileges.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_nonConductedPrivileges) && !m_nonConductedPrivileges.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_conferenceDescription) && !m_conferenceDescription.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_password) && !m_password.Decode(strm))
    return FALSE;
  if (!m_result.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_userData) && !m_userData.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_ConferenceJoinResponse::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nodeID))
    m_nodeID.Encode(strm);
  m_topNodeID.Encode(strm);
  m_tag.Encode(strm);
  if (HasOptionalField(e_conferenceNameAlias))
    m_conferenceNameAlias.Encode(strm);
  m_passwordInTheClearRequired.Encode(strm);
  m_lockedConference.Encode(strm);
  m_listedConference.Encode(strm);
  m_conductibleConference.Encode(strm);
  m_terminationMethod.Encode(strm);
  if (HasOptionalField(e_conductorPrivileges))
    m_conductorPrivileges.Encode(strm);
  if (HasOptionalField(e_conductedPrivileges))
    m_conductedPrivileges.Encode(strm);
  if (HasOptionalField(e_nonConductedPrivileges))
    m_nonConductedPrivileges.Encode(strm);
  if (HasOptionalField(e_conferenceDescription))
    m_conferenceDescription.Encode(strm);
  if (HasOptionalField(e_password))
    m_password.Encode(strm);
  m_result.Encode(strm);
  if (HasOptionalField(e_userData))
    m_userData.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_ConferenceJoinResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferenceJoinResponse::Class()), PInvalidCast);
#endif
  return new GCC_ConferenceJoinResponse(*this);
}


//
// ConferenceInviteRequest
//

GCC_ConferenceInviteRequest::GCC_ConferenceInviteRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 6, TRUE, 1)
{
}


#ifndef PASN_NOPRINTON
void GCC_ConferenceInviteRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "conferenceName = " << setprecision(indent) << m_conferenceName << '\n';
  strm << setw(indent+9) << "nodeID = " << setprecision(indent) << m_nodeID << '\n';
  strm << setw(indent+12) << "topNodeID = " << setprecision(indent) << m_topNodeID << '\n';
  strm << setw(indent+6) << "tag = " << setprecision(indent) << m_tag << '\n';
  strm << setw(indent+29) << "passwordInTheClearRequired = " << setprecision(indent) << m_passwordInTheClearRequired << '\n';
  strm << setw(indent+19) << "lockedConference = " << setprecision(indent) << m_lockedConference << '\n';
  strm << setw(indent+19) << "listedConference = " << setprecision(indent) << m_listedConference << '\n';
  strm << setw(indent+24) << "conductibleConference = " << setprecision(indent) << m_conductibleConference << '\n';
  strm << setw(indent+20) << "terminationMethod = " << setprecision(indent) << m_terminationMethod << '\n';
  if (HasOptionalField(e_conductorPrivileges))
    strm << setw(indent+22) << "conductorPrivileges = " << setprecision(indent) << m_conductorPrivileges << '\n';
  if (HasOptionalField(e_conductedPrivileges))
    strm << setw(indent+22) << "conductedPrivileges = " << setprecision(indent) << m_conductedPrivileges << '\n';
  if (HasOptionalField(e_nonConductedPrivileges))
    strm << setw(indent+25) << "nonConductedPrivileges = " << setprecision(indent) << m_nonConductedPrivileges << '\n';
  if (HasOptionalField(e_conferenceDescription))
    strm << setw(indent+24) << "conferenceDescription = " << setprecision(indent) << m_conferenceDescription << '\n';
  if (HasOptionalField(e_callerIdentifier))
    strm << setw(indent+19) << "callerIdentifier = " << setprecision(indent) << m_callerIdentifier << '\n';
  if (HasOptionalField(e_userData))
    strm << setw(indent+11) << "userData = " << setprecision(indent) << m_userData << '\n';
  if (HasOptionalField(e_conferencePriority))
    strm << setw(indent+21) << "conferencePriority = " << setprecision(indent) << m_conferencePriority << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_ConferenceInviteRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_ConferenceInviteRequest), PInvalidCast);
#endif
  const GCC_ConferenceInviteRequest & other = (const GCC_ConferenceInviteRequest &)obj;

  Comparison result;

  if ((result = m_conferenceName.Compare(other.m_conferenceName)) != EqualTo)
    return result;
  if ((result = m_nodeID.Compare(other.m_nodeID)) != EqualTo)
    return result;
  if ((result = m_topNodeID.Compare(other.m_topNodeID)) != EqualTo)
    return result;
  if ((result = m_tag.Compare(other.m_tag)) != EqualTo)
    return result;
  if ((result = m_passwordInTheClearRequired.Compare(other.m_passwordInTheClearRequired)) != EqualTo)
    return result;
  if ((result = m_lockedConference.Compare(other.m_lockedConference)) != EqualTo)
    return result;
  if ((result = m_listedConference.Compare(other.m_listedConference)) != EqualTo)
    return result;
  if ((result = m_conductibleConference.Compare(other.m_conductibleConference)) != EqualTo)
    return result;
  if ((result = m_terminationMethod.Compare(other.m_terminationMethod)) != EqualTo)
    return result;
  if ((result = m_conductorPrivileges.Compare(other.m_conductorPrivileges)) != EqualTo)
    return result;
  if ((result = m_conductedPrivileges.Compare(other.m_conductedPrivileges)) != EqualTo)
    return result;
  if ((result = m_nonConductedPrivileges.Compare(other.m_nonConductedPrivileges)) != EqualTo)
    return result;
  if ((result = m_conferenceDescription.Compare(other.m_conferenceDescription)) != EqualTo)
    return result;
  if ((result = m_callerIdentifier.Compare(other.m_callerIdentifier)) != EqualTo)
    return result;
  if ((result = m_userData.Compare(other.m_userData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_ConferenceInviteRequest::GetDataLength() const
{
  PINDEX length = 0;
  length += m_conferenceName.GetObjectLength();
  length += m_nodeID.GetObjectLength();
  length += m_topNodeID.GetObjectLength();
  length += m_tag.GetObjectLength();
  length += m_passwordInTheClearRequired.GetObjectLength();
  length += m_lockedConference.GetObjectLength();
  length += m_listedConference.GetObjectLength();
  length += m_conductibleConference.GetObjectLength();
  length += m_terminationMethod.GetObjectLength();
  if (HasOptionalField(e_conductorPrivileges))
    length += m_conductorPrivileges.GetObjectLength();
  if (HasOptionalField(e_conductedPrivileges))
    length += m_conductedPrivileges.GetObjectLength();
  if (HasOptionalField(e_nonConductedPrivileges))
    length += m_nonConductedPrivileges.GetObjectLength();
  if (HasOptionalField(e_conferenceDescription))
    length += m_conferenceDescription.GetObjectLength();
  if (HasOptionalField(e_callerIdentifier))
    length += m_callerIdentifier.GetObjectLength();
  if (HasOptionalField(e_userData))
    length += m_userData.GetObjectLength();
  return length;
}


BOOL GCC_ConferenceInviteRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_conferenceName.Decode(strm))
    return FALSE;
  if (!m_nodeID.Decode(strm))
    return FALSE;
  if (!m_topNodeID.Decode(strm))
    return FALSE;
  if (!m_tag.Decode(strm))
    return FALSE;
  if (!m_passwordInTheClearRequired.Decode(strm))
    return FALSE;
  if (!m_lockedConference.Decode(strm))
    return FALSE;
  if (!m_listedConference.Decode(strm))
    return FALSE;
  if (!m_conductibleConference.Decode(strm))
    return FALSE;
  if (!m_terminationMethod.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_conductorPrivileges) && !m_conductorPrivileges.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_conductedPrivileges) && !m_conductedPrivileges.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_nonConductedPrivileges) && !m_nonConductedPrivileges.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_conferenceDescription) && !m_conferenceDescription.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_callerIdentifier) && !m_callerIdentifier.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_userData) && !m_userData.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_conferencePriority, m_conferencePriority))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_ConferenceInviteRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_conferenceName.Encode(strm);
  m_nodeID.Encode(strm);
  m_topNodeID.Encode(strm);
  m_tag.Encode(strm);
  m_passwordInTheClearRequired.Encode(strm);
  m_lockedConference.Encode(strm);
  m_listedConference.Encode(strm);
  m_conductibleConference.Encode(strm);
  m_terminationMethod.Encode(strm);
  if (HasOptionalField(e_conductorPrivileges))
    m_conductorPrivileges.Encode(strm);
  if (HasOptionalField(e_conductedPrivileges))
    m_conductedPrivileges.Encode(strm);
  if (HasOptionalField(e_nonConductedPrivileges))
    m_nonConductedPrivileges.Encode(strm);
  if (HasOptionalField(e_conferenceDescription))
    m_conferenceDescription.Encode(strm);
  if (HasOptionalField(e_callerIdentifier))
    m_callerIdentifier.Encode(strm);
  if (HasOptionalField(e_userData))
    m_userData.Encode(strm);
  KnownExtensionEncode(strm, e_conferencePriority, m_conferencePriority);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_ConferenceInviteRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferenceInviteRequest::Class()), PInvalidCast);
#endif
  return new GCC_ConferenceInviteRequest(*this);
}


//
// ConferenceInviteResponse
//

GCC_ConferenceInviteResponse::GCC_ConferenceInviteResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_ConferenceInviteResponse::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+9) << "result = " << setprecision(indent) << m_result << '\n';
  if (HasOptionalField(e_userData))
    strm << setw(indent+11) << "userData = " << setprecision(indent) << m_userData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_ConferenceInviteResponse::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_ConferenceInviteResponse), PInvalidCast);
#endif
  const GCC_ConferenceInviteResponse & other = (const GCC_ConferenceInviteResponse &)obj;

  Comparison result;

  if ((result = m_result.Compare(other.m_result)) != EqualTo)
    return result;
  if ((result = m_userData.Compare(other.m_userData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_ConferenceInviteResponse::GetDataLength() const
{
  PINDEX length = 0;
  length += m_result.GetObjectLength();
  if (HasOptionalField(e_userData))
    length += m_userData.GetObjectLength();
  return length;
}


BOOL GCC_ConferenceInviteResponse::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_result.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_userData) && !m_userData.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_ConferenceInviteResponse::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_result.Encode(strm);
  if (HasOptionalField(e_userData))
    m_userData.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_ConferenceInviteResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferenceInviteResponse::Class()), PInvalidCast);
#endif
  return new GCC_ConferenceInviteResponse(*this);
}


//
// ConferenceAddResponse
//

GCC_ConferenceAddResponse::GCC_ConferenceAddResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_ConferenceAddResponse::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+6) << "tag = " << setprecision(indent) << m_tag << '\n';
  strm << setw(indent+9) << "result = " << setprecision(indent) << m_result << '\n';
  if (HasOptionalField(e_userData))
    strm << setw(indent+11) << "userData = " << setprecision(indent) << m_userData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_ConferenceAddResponse::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_ConferenceAddResponse), PInvalidCast);
#endif
  const GCC_ConferenceAddResponse & other = (const GCC_ConferenceAddResponse &)obj;

  Comparison result;

  if ((result = m_tag.Compare(other.m_tag)) != EqualTo)
    return result;
  if ((result = m_result.Compare(other.m_result)) != EqualTo)
    return result;
  if ((result = m_userData.Compare(other.m_userData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_ConferenceAddResponse::GetDataLength() const
{
  PINDEX length = 0;
  length += m_tag.GetObjectLength();
  length += m_result.GetObjectLength();
  if (HasOptionalField(e_userData))
    length += m_userData.GetObjectLength();
  return length;
}


BOOL GCC_ConferenceAddResponse::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_tag.Decode(strm))
    return FALSE;
  if (!m_result.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_userData) && !m_userData.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_ConferenceAddResponse::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_tag.Encode(strm);
  m_result.Encode(strm);
  if (HasOptionalField(e_userData))
    m_userData.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_ConferenceAddResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferenceAddResponse::Class()), PInvalidCast);
#endif
  return new GCC_ConferenceAddResponse(*this);
}


//
// ConferenceLockResponse
//

GCC_ConferenceLockResponse::GCC_ConferenceLockResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_ConferenceLockResponse::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+9) << "result = " << setprecision(indent) << m_result << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_ConferenceLockResponse::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_ConferenceLockResponse), PInvalidCast);
#endif
  const GCC_ConferenceLockResponse & other = (const GCC_ConferenceLockResponse &)obj;

  Comparison result;

  if ((result = m_result.Compare(other.m_result)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_ConferenceLockResponse::GetDataLength() const
{
  PINDEX length = 0;
  length += m_result.GetObjectLength();
  return length;
}


BOOL GCC_ConferenceLockResponse::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_result.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_ConferenceLockResponse::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_result.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_ConferenceLockResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferenceLockResponse::Class()), PInvalidCast);
#endif
  return new GCC_ConferenceLockResponse(*this);
}


//
// ConferenceUnlockResponse
//

GCC_ConferenceUnlockResponse::GCC_ConferenceUnlockResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_ConferenceUnlockResponse::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+9) << "result = " << setprecision(indent) << m_result << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_ConferenceUnlockResponse::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_ConferenceUnlockResponse), PInvalidCast);
#endif
  const GCC_ConferenceUnlockResponse & other = (const GCC_ConferenceUnlockResponse &)obj;

  Comparison result;

  if ((result = m_result.Compare(other.m_result)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_ConferenceUnlockResponse::GetDataLength() const
{
  PINDEX length = 0;
  length += m_result.GetObjectLength();
  return length;
}


BOOL GCC_ConferenceUnlockResponse::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_result.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_ConferenceUnlockResponse::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_result.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_ConferenceUnlockResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferenceUnlockResponse::Class()), PInvalidCast);
#endif
  return new GCC_ConferenceUnlockResponse(*this);
}


//
// ConferenceTerminateRequest
//

GCC_ConferenceTerminateRequest::GCC_ConferenceTerminateRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_ConferenceTerminateRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+9) << "reason = " << setprecision(indent) << m_reason << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_ConferenceTerminateRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_ConferenceTerminateRequest), PInvalidCast);
#endif
  const GCC_ConferenceTerminateRequest & other = (const GCC_ConferenceTerminateRequest &)obj;

  Comparison result;

  if ((result = m_reason.Compare(other.m_reason)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_ConferenceTerminateRequest::GetDataLength() const
{
  PINDEX length = 0;
  length += m_reason.GetObjectLength();
  return length;
}


BOOL GCC_ConferenceTerminateRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_reason.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_ConferenceTerminateRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_reason.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_ConferenceTerminateRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferenceTerminateRequest::Class()), PInvalidCast);
#endif
  return new GCC_ConferenceTerminateRequest(*this);
}


//
// ConferenceTerminateResponse
//

GCC_ConferenceTerminateResponse::GCC_ConferenceTerminateResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_ConferenceTerminateResponse::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+9) << "result = " << setprecision(indent) << m_result << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_ConferenceTerminateResponse::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_ConferenceTerminateResponse), PInvalidCast);
#endif
  const GCC_ConferenceTerminateResponse & other = (const GCC_ConferenceTerminateResponse &)obj;

  Comparison result;

  if ((result = m_result.Compare(other.m_result)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_ConferenceTerminateResponse::GetDataLength() const
{
  PINDEX length = 0;
  length += m_result.GetObjectLength();
  return length;
}


BOOL GCC_ConferenceTerminateResponse::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_result.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_ConferenceTerminateResponse::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_result.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_ConferenceTerminateResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferenceTerminateResponse::Class()), PInvalidCast);
#endif
  return new GCC_ConferenceTerminateResponse(*this);
}


//
// ConferenceTerminateIndication
//

GCC_ConferenceTerminateIndication::GCC_ConferenceTerminateIndication(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_ConferenceTerminateIndication::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+9) << "reason = " << setprecision(indent) << m_reason << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_ConferenceTerminateIndication::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_ConferenceTerminateIndication), PInvalidCast);
#endif
  const GCC_ConferenceTerminateIndication & other = (const GCC_ConferenceTerminateIndication &)obj;

  Comparison result;

  if ((result = m_reason.Compare(other.m_reason)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_ConferenceTerminateIndication::GetDataLength() const
{
  PINDEX length = 0;
  length += m_reason.GetObjectLength();
  return length;
}


BOOL GCC_ConferenceTerminateIndication::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_reason.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_ConferenceTerminateIndication::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_reason.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_ConferenceTerminateIndication::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferenceTerminateIndication::Class()), PInvalidCast);
#endif
  return new GCC_ConferenceTerminateIndication(*this);
}


//
// ConferenceEjectUserRequest
//

GCC_ConferenceEjectUserRequest::GCC_ConferenceEjectUserRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_ConferenceEjectUserRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+14) << "nodeToEject = " << setprecision(indent) << m_nodeToEject << '\n';
  strm << setw(indent+9) << "reason = " << setprecision(indent) << m_reason << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_ConferenceEjectUserRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_ConferenceEjectUserRequest), PInvalidCast);
#endif
  const GCC_ConferenceEjectUserRequest & other = (const GCC_ConferenceEjectUserRequest &)obj;

  Comparison result;

  if ((result = m_nodeToEject.Compare(other.m_nodeToEject)) != EqualTo)
    return result;
  if ((result = m_reason.Compare(other.m_reason)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_ConferenceEjectUserRequest::GetDataLength() const
{
  PINDEX length = 0;
  length += m_nodeToEject.GetObjectLength();
  length += m_reason.GetObjectLength();
  return length;
}


BOOL GCC_ConferenceEjectUserRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_nodeToEject.Decode(strm))
    return FALSE;
  if (!m_reason.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_ConferenceEjectUserRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_nodeToEject.Encode(strm);
  m_reason.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_ConferenceEjectUserRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferenceEjectUserRequest::Class()), PInvalidCast);
#endif
  return new GCC_ConferenceEjectUserRequest(*this);
}


//
// ConferenceEjectUserResponse
//

GCC_ConferenceEjectUserResponse::GCC_ConferenceEjectUserResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_ConferenceEjectUserResponse::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+14) << "nodeToEject = " << setprecision(indent) << m_nodeToEject << '\n';
  strm << setw(indent+9) << "result = " << setprecision(indent) << m_result << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_ConferenceEjectUserResponse::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_ConferenceEjectUserResponse), PInvalidCast);
#endif
  const GCC_ConferenceEjectUserResponse & other = (const GCC_ConferenceEjectUserResponse &)obj;

  Comparison result;

  if ((result = m_nodeToEject.Compare(other.m_nodeToEject)) != EqualTo)
    return result;
  if ((result = m_result.Compare(other.m_result)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_ConferenceEjectUserResponse::GetDataLength() const
{
  PINDEX length = 0;
  length += m_nodeToEject.GetObjectLength();
  length += m_result.GetObjectLength();
  return length;
}


BOOL GCC_ConferenceEjectUserResponse::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_nodeToEject.Decode(strm))
    return FALSE;
  if (!m_result.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_ConferenceEjectUserResponse::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_nodeToEject.Encode(strm);
  m_result.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_ConferenceEjectUserResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferenceEjectUserResponse::Class()), PInvalidCast);
#endif
  return new GCC_ConferenceEjectUserResponse(*this);
}


//
// ConferenceEjectUserIndication
//

GCC_ConferenceEjectUserIndication::GCC_ConferenceEjectUserIndication(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_ConferenceEjectUserIndication::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+14) << "nodeToEject = " << setprecision(indent) << m_nodeToEject << '\n';
  strm << setw(indent+9) << "reason = " << setprecision(indent) << m_reason << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_ConferenceEjectUserIndication::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_ConferenceEjectUserIndication), PInvalidCast);
#endif
  const GCC_ConferenceEjectUserIndication & other = (const GCC_ConferenceEjectUserIndication &)obj;

  Comparison result;

  if ((result = m_nodeToEject.Compare(other.m_nodeToEject)) != EqualTo)
    return result;
  if ((result = m_reason.Compare(other.m_reason)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_ConferenceEjectUserIndication::GetDataLength() const
{
  PINDEX length = 0;
  length += m_nodeToEject.GetObjectLength();
  length += m_reason.GetObjectLength();
  return length;
}


BOOL GCC_ConferenceEjectUserIndication::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_nodeToEject.Decode(strm))
    return FALSE;
  if (!m_reason.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_ConferenceEjectUserIndication::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_nodeToEject.Encode(strm);
  m_reason.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_ConferenceEjectUserIndication::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferenceEjectUserIndication::Class()), PInvalidCast);
#endif
  return new GCC_ConferenceEjectUserIndication(*this);
}


//
// ConferenceTransferRequest
//

GCC_ConferenceTransferRequest::GCC_ConferenceTransferRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 4, TRUE, 0)
{
  m_transferringNodes.SetConstraints(PASN_Object::FixedConstraint, 1, 65536);
}


#ifndef PASN_NOPRINTON
void GCC_ConferenceTransferRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "conferenceName = " << setprecision(indent) << m_conferenceName << '\n';
  if (HasOptionalField(e_conferenceNameModifier))
    strm << setw(indent+25) << "conferenceNameModifier = " << setprecision(indent) << m_conferenceNameModifier << '\n';
  if (HasOptionalField(e_networkAddress))
    strm << setw(indent+17) << "networkAddress = " << setprecision(indent) << m_networkAddress << '\n';
  if (HasOptionalField(e_transferringNodes))
    strm << setw(indent+20) << "transferringNodes = " << setprecision(indent) << m_transferringNodes << '\n';
  if (HasOptionalField(e_password))
    strm << setw(indent+11) << "password = " << setprecision(indent) << m_password << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_ConferenceTransferRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_ConferenceTransferRequest), PInvalidCast);
#endif
  const GCC_ConferenceTransferRequest & other = (const GCC_ConferenceTransferRequest &)obj;

  Comparison result;

  if ((result = m_conferenceName.Compare(other.m_conferenceName)) != EqualTo)
    return result;
  if ((result = m_conferenceNameModifier.Compare(other.m_conferenceNameModifier)) != EqualTo)
    return result;
  if ((result = m_networkAddress.Compare(other.m_networkAddress)) != EqualTo)
    return result;
  if ((result = m_transferringNodes.Compare(other.m_transferringNodes)) != EqualTo)
    return result;
  if ((result = m_password.Compare(other.m_password)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_ConferenceTransferRequest::GetDataLength() const
{
  PINDEX length = 0;
  length += m_conferenceName.GetObjectLength();
  if (HasOptionalField(e_conferenceNameModifier))
    length += m_conferenceNameModifier.GetObjectLength();
  if (HasOptionalField(e_networkAddress))
    length += m_networkAddress.GetObjectLength();
  if (HasOptionalField(e_transferringNodes))
    length += m_transferringNodes.GetObjectLength();
  if (HasOptionalField(e_password))
    length += m_password.GetObjectLength();
  return length;
}


BOOL GCC_ConferenceTransferRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_conferenceName.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_conferenceNameModifier) && !m_conferenceNameModifier.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_networkAddress) && !m_networkAddress.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_transferringNodes) && !m_transferringNodes.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_password) && !m_password.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_ConferenceTransferRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_conferenceName.Encode(strm);
  if (HasOptionalField(e_conferenceNameModifier))
    m_conferenceNameModifier.Encode(strm);
  if (HasOptionalField(e_networkAddress))
    m_networkAddress.Encode(strm);
  if (HasOptionalField(e_transferringNodes))
    m_transferringNodes.Encode(strm);
  if (HasOptionalField(e_password))
    m_password.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_ConferenceTransferRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferenceTransferRequest::Class()), PInvalidCast);
#endif
  return new GCC_ConferenceTransferRequest(*this);
}


//
// ConferenceTransferResponse
//

GCC_ConferenceTransferResponse::GCC_ConferenceTransferResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
  m_transferringNodes.SetConstraints(PASN_Object::FixedConstraint, 1, 65536);
}


#ifndef PASN_NOPRINTON
void GCC_ConferenceTransferResponse::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "conferenceName = " << setprecision(indent) << m_conferenceName << '\n';
  if (HasOptionalField(e_conferenceNameModifier))
    strm << setw(indent+25) << "conferenceNameModifier = " << setprecision(indent) << m_conferenceNameModifier << '\n';
  if (HasOptionalField(e_transferringNodes))
    strm << setw(indent+20) << "transferringNodes = " << setprecision(indent) << m_transferringNodes << '\n';
  strm << setw(indent+9) << "result = " << setprecision(indent) << m_result << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_ConferenceTransferResponse::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_ConferenceTransferResponse), PInvalidCast);
#endif
  const GCC_ConferenceTransferResponse & other = (const GCC_ConferenceTransferResponse &)obj;

  Comparison result;

  if ((result = m_conferenceName.Compare(other.m_conferenceName)) != EqualTo)
    return result;
  if ((result = m_conferenceNameModifier.Compare(other.m_conferenceNameModifier)) != EqualTo)
    return result;
  if ((result = m_transferringNodes.Compare(other.m_transferringNodes)) != EqualTo)
    return result;
  if ((result = m_result.Compare(other.m_result)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_ConferenceTransferResponse::GetDataLength() const
{
  PINDEX length = 0;
  length += m_conferenceName.GetObjectLength();
  if (HasOptionalField(e_conferenceNameModifier))
    length += m_conferenceNameModifier.GetObjectLength();
  if (HasOptionalField(e_transferringNodes))
    length += m_transferringNodes.GetObjectLength();
  length += m_result.GetObjectLength();
  return length;
}


BOOL GCC_ConferenceTransferResponse::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_conferenceName.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_conferenceNameModifier) && !m_conferenceNameModifier.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_transferringNodes) && !m_transferringNodes.Decode(strm))
    return FALSE;
  if (!m_result.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_ConferenceTransferResponse::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_conferenceName.Encode(strm);
  if (HasOptionalField(e_conferenceNameModifier))
    m_conferenceNameModifier.Encode(strm);
  if (HasOptionalField(e_transferringNodes))
    m_transferringNodes.Encode(strm);
  m_result.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_ConferenceTransferResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferenceTransferResponse::Class()), PInvalidCast);
#endif
  return new GCC_ConferenceTransferResponse(*this);
}


//
// ConferenceTransferIndication
//

GCC_ConferenceTransferIndication::GCC_ConferenceTransferIndication(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 4, TRUE, 0)
{
  m_transferringNodes.SetConstraints(PASN_Object::FixedConstraint, 1, 65536);
}


#ifndef PASN_NOPRINTON
void GCC_ConferenceTransferIndication::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "conferenceName = " << setprecision(indent) << m_conferenceName << '\n';
  if (HasOptionalField(e_conferenceNameModifier))
    strm << setw(indent+25) << "conferenceNameModifier = " << setprecision(indent) << m_conferenceNameModifier << '\n';
  if (HasOptionalField(e_networkAddress))
    strm << setw(indent+17) << "networkAddress = " << setprecision(indent) << m_networkAddress << '\n';
  if (HasOptionalField(e_transferringNodes))
    strm << setw(indent+20) << "transferringNodes = " << setprecision(indent) << m_transferringNodes << '\n';
  if (HasOptionalField(e_password))
    strm << setw(indent+11) << "password = " << setprecision(indent) << m_password << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_ConferenceTransferIndication::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_ConferenceTransferIndication), PInvalidCast);
#endif
  const GCC_ConferenceTransferIndication & other = (const GCC_ConferenceTransferIndication &)obj;

  Comparison result;

  if ((result = m_conferenceName.Compare(other.m_conferenceName)) != EqualTo)
    return result;
  if ((result = m_conferenceNameModifier.Compare(other.m_conferenceNameModifier)) != EqualTo)
    return result;
  if ((result = m_networkAddress.Compare(other.m_networkAddress)) != EqualTo)
    return result;
  if ((result = m_transferringNodes.Compare(other.m_transferringNodes)) != EqualTo)
    return result;
  if ((result = m_password.Compare(other.m_password)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_ConferenceTransferIndication::GetDataLength() const
{
  PINDEX length = 0;
  length += m_conferenceName.GetObjectLength();
  if (HasOptionalField(e_conferenceNameModifier))
    length += m_conferenceNameModifier.GetObjectLength();
  if (HasOptionalField(e_networkAddress))
    length += m_networkAddress.GetObjectLength();
  if (HasOptionalField(e_transferringNodes))
    length += m_transferringNodes.GetObjectLength();
  if (HasOptionalField(e_password))
    length += m_password.GetObjectLength();
  return length;
}


BOOL GCC_ConferenceTransferIndication::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_conferenceName.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_conferenceNameModifier) && !m_conferenceNameModifier.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_networkAddress) && !m_networkAddress.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_transferringNodes) && !m_transferringNodes.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_password) && !m_password.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_ConferenceTransferIndication::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_conferenceName.Encode(strm);
  if (HasOptionalField(e_conferenceNameModifier))
    m_conferenceNameModifier.Encode(strm);
  if (HasOptionalField(e_networkAddress))
    m_networkAddress.Encode(strm);
  if (HasOptionalField(e_transferringNodes))
    m_transferringNodes.Encode(strm);
  if (HasOptionalField(e_password))
    m_password.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_ConferenceTransferIndication::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConferenceTransferIndication::Class()), PInvalidCast);
#endif
  return new GCC_ConferenceTransferIndication(*this);
}


//
// ApplicationInvokeIndication
//

GCC_ApplicationInvokeIndication::GCC_ApplicationInvokeIndication(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_applicationProtocolEntiyList.SetConstraints(PASN_Object::FixedConstraint, 1, 65536);
  m_destinationNodes.SetConstraints(PASN_Object::FixedConstraint, 1, 65536);
}


#ifndef PASN_NOPRINTON
void GCC_ApplicationInvokeIndication::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+31) << "applicationProtocolEntiyList = " << setprecision(indent) << m_applicationProtocolEntiyList << '\n';
  if (HasOptionalField(e_destinationNodes))
    strm << setw(indent+19) << "destinationNodes = " << setprecision(indent) << m_destinationNodes << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_ApplicationInvokeIndication::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_ApplicationInvokeIndication), PInvalidCast);
#endif
  const GCC_ApplicationInvokeIndication & other = (const GCC_ApplicationInvokeIndication &)obj;

  Comparison result;

  if ((result = m_applicationProtocolEntiyList.Compare(other.m_applicationProtocolEntiyList)) != EqualTo)
    return result;
  if ((result = m_destinationNodes.Compare(other.m_destinationNodes)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_ApplicationInvokeIndication::GetDataLength() const
{
  PINDEX length = 0;
  length += m_applicationProtocolEntiyList.GetObjectLength();
  if (HasOptionalField(e_destinationNodes))
    length += m_destinationNodes.GetObjectLength();
  return length;
}


BOOL GCC_ApplicationInvokeIndication::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_applicationProtocolEntiyList.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_destinationNodes) && !m_destinationNodes.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_ApplicationInvokeIndication::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_applicationProtocolEntiyList.Encode(strm);
  if (HasOptionalField(e_destinationNodes))
    m_destinationNodes.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_ApplicationInvokeIndication::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ApplicationInvokeIndication::Class()), PInvalidCast);
#endif
  return new GCC_ApplicationInvokeIndication(*this);
}


//
// RegistryAllocateHandleResponse
//

GCC_RegistryAllocateHandleResponse::GCC_RegistryAllocateHandleResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_numberOfHandles.SetConstraints(PASN_Object::FixedConstraint, 1, 1024);
}


#ifndef PASN_NOPRINTON
void GCC_RegistryAllocateHandleResponse::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "entityID = " << setprecision(indent) << m_entityID << '\n';
  strm << setw(indent+18) << "numberOfHandles = " << setprecision(indent) << m_numberOfHandles << '\n';
  strm << setw(indent+14) << "firstHandle = " << setprecision(indent) << m_firstHandle << '\n';
  strm << setw(indent+9) << "result = " << setprecision(indent) << m_result << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_RegistryAllocateHandleResponse::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_RegistryAllocateHandleResponse), PInvalidCast);
#endif
  const GCC_RegistryAllocateHandleResponse & other = (const GCC_RegistryAllocateHandleResponse &)obj;

  Comparison result;

  if ((result = m_entityID.Compare(other.m_entityID)) != EqualTo)
    return result;
  if ((result = m_numberOfHandles.Compare(other.m_numberOfHandles)) != EqualTo)
    return result;
  if ((result = m_firstHandle.Compare(other.m_firstHandle)) != EqualTo)
    return result;
  if ((result = m_result.Compare(other.m_result)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_RegistryAllocateHandleResponse::GetDataLength() const
{
  PINDEX length = 0;
  length += m_entityID.GetObjectLength();
  length += m_numberOfHandles.GetObjectLength();
  length += m_firstHandle.GetObjectLength();
  length += m_result.GetObjectLength();
  return length;
}


BOOL GCC_RegistryAllocateHandleResponse::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_entityID.Decode(strm))
    return FALSE;
  if (!m_numberOfHandles.Decode(strm))
    return FALSE;
  if (!m_firstHandle.Decode(strm))
    return FALSE;
  if (!m_result.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_RegistryAllocateHandleResponse::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_entityID.Encode(strm);
  m_numberOfHandles.Encode(strm);
  m_firstHandle.Encode(strm);
  m_result.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_RegistryAllocateHandleResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_RegistryAllocateHandleResponse::Class()), PInvalidCast);
#endif
  return new GCC_RegistryAllocateHandleResponse(*this);
}


//
// RegistryResponse
//

GCC_RegistryResponse::GCC_RegistryResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_RegistryResponse::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "entityID = " << setprecision(indent) << m_entityID << '\n';
  strm << setw(indent+16) << "primitiveType = " << setprecision(indent) << m_primitiveType << '\n';
  strm << setw(indent+6) << "key = " << setprecision(indent) << m_key << '\n';
  strm << setw(indent+7) << "item = " << setprecision(indent) << m_item << '\n';
  strm << setw(indent+8) << "owner = " << setprecision(indent) << m_owner << '\n';
  if (HasOptionalField(e_modificationRights))
    strm << setw(indent+21) << "modificationRights = " << setprecision(indent) << m_modificationRights << '\n';
  strm << setw(indent+9) << "result = " << setprecision(indent) << m_result << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_RegistryResponse::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_RegistryResponse), PInvalidCast);
#endif
  const GCC_RegistryResponse & other = (const GCC_RegistryResponse &)obj;

  Comparison result;

  if ((result = m_entityID.Compare(other.m_entityID)) != EqualTo)
    return result;
  if ((result = m_primitiveType.Compare(other.m_primitiveType)) != EqualTo)
    return result;
  if ((result = m_key.Compare(other.m_key)) != EqualTo)
    return result;
  if ((result = m_item.Compare(other.m_item)) != EqualTo)
    return result;
  if ((result = m_owner.Compare(other.m_owner)) != EqualTo)
    return result;
  if ((result = m_modificationRights.Compare(other.m_modificationRights)) != EqualTo)
    return result;
  if ((result = m_result.Compare(other.m_result)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_RegistryResponse::GetDataLength() const
{
  PINDEX length = 0;
  length += m_entityID.GetObjectLength();
  length += m_primitiveType.GetObjectLength();
  length += m_key.GetObjectLength();
  length += m_item.GetObjectLength();
  length += m_owner.GetObjectLength();
  if (HasOptionalField(e_modificationRights))
    length += m_modificationRights.GetObjectLength();
  length += m_result.GetObjectLength();
  return length;
}


BOOL GCC_RegistryResponse::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_entityID.Decode(strm))
    return FALSE;
  if (!m_primitiveType.Decode(strm))
    return FALSE;
  if (!m_key.Decode(strm))
    return FALSE;
  if (!m_item.Decode(strm))
    return FALSE;
  if (!m_owner.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_modificationRights) && !m_modificationRights.Decode(strm))
    return FALSE;
  if (!m_result.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_RegistryResponse::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_entityID.Encode(strm);
  m_primitiveType.Encode(strm);
  m_key.Encode(strm);
  m_item.Encode(strm);
  m_owner.Encode(strm);
  if (HasOptionalField(e_modificationRights))
    m_modificationRights.Encode(strm);
  m_result.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_RegistryResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_RegistryResponse::Class()), PInvalidCast);
#endif
  return new GCC_RegistryResponse(*this);
}


//
// ConductorPermissionGrantIndication
//

GCC_ConductorPermissionGrantIndication::GCC_ConductorPermissionGrantIndication(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_permissionList.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
  m_waitingList.SetConstraints(PASN_Object::FixedConstraint, 1, 65536);
}


#ifndef PASN_NOPRINTON
void GCC_ConductorPermissionGrantIndication::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "permissionList = " << setprecision(indent) << m_permissionList << '\n';
  if (HasOptionalField(e_waitingList))
    strm << setw(indent+14) << "waitingList = " << setprecision(indent) << m_waitingList << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_ConductorPermissionGrantIndication::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_ConductorPermissionGrantIndication), PInvalidCast);
#endif
  const GCC_ConductorPermissionGrantIndication & other = (const GCC_ConductorPermissionGrantIndication &)obj;

  Comparison result;

  if ((result = m_permissionList.Compare(other.m_permissionList)) != EqualTo)
    return result;
  if ((result = m_waitingList.Compare(other.m_waitingList)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_ConductorPermissionGrantIndication::GetDataLength() const
{
  PINDEX length = 0;
  length += m_permissionList.GetObjectLength();
  if (HasOptionalField(e_waitingList))
    length += m_waitingList.GetObjectLength();
  return length;
}


BOOL GCC_ConductorPermissionGrantIndication::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_permissionList.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_waitingList) && !m_waitingList.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_ConductorPermissionGrantIndication::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_permissionList.Encode(strm);
  if (HasOptionalField(e_waitingList))
    m_waitingList.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_ConductorPermissionGrantIndication::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_ConductorPermissionGrantIndication::Class()), PInvalidCast);
#endif
  return new GCC_ConductorPermissionGrantIndication(*this);
}


//
// FunctionNotSupportedResponse
//

GCC_FunctionNotSupportedResponse::GCC_FunctionNotSupportedResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_FunctionNotSupportedResponse::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+10) << "request = " << setprecision(indent) << m_request << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_FunctionNotSupportedResponse::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_FunctionNotSupportedResponse), PInvalidCast);
#endif
  const GCC_FunctionNotSupportedResponse & other = (const GCC_FunctionNotSupportedResponse &)obj;

  Comparison result;

  if ((result = m_request.Compare(other.m_request)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_FunctionNotSupportedResponse::GetDataLength() const
{
  PINDEX length = 0;
  length += m_request.GetObjectLength();
  return length;
}


BOOL GCC_FunctionNotSupportedResponse::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_request.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_FunctionNotSupportedResponse::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_request.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_FunctionNotSupportedResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_FunctionNotSupportedResponse::Class()), PInvalidCast);
#endif
  return new GCC_FunctionNotSupportedResponse(*this);
}


//
// PasswordChallengeRequestResponse_challengeRequestResponse
//

GCC_PasswordChallengeRequestResponse_challengeRequestResponse::GCC_PasswordChallengeRequestResponse_challengeRequestResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_PasswordChallengeRequestResponse_challengeRequestResponse::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_challengeRequest))
    strm << setw(indent+19) << "challengeRequest = " << setprecision(indent) << m_challengeRequest << '\n';
  if (HasOptionalField(e_challengeResponse))
    strm << setw(indent+20) << "challengeResponse = " << setprecision(indent) << m_challengeResponse << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_PasswordChallengeRequestResponse_challengeRequestResponse::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_PasswordChallengeRequestResponse_challengeRequestResponse), PInvalidCast);
#endif
  const GCC_PasswordChallengeRequestResponse_challengeRequestResponse & other = (const GCC_PasswordChallengeRequestResponse_challengeRequestResponse &)obj;

  Comparison result;

  if ((result = m_challengeRequest.Compare(other.m_challengeRequest)) != EqualTo)
    return result;
  if ((result = m_challengeResponse.Compare(other.m_challengeResponse)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_PasswordChallengeRequestResponse_challengeRequestResponse::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_challengeRequest))
    length += m_challengeRequest.GetObjectLength();
  if (HasOptionalField(e_challengeResponse))
    length += m_challengeResponse.GetObjectLength();
  return length;
}


BOOL GCC_PasswordChallengeRequestResponse_challengeRequestResponse::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_challengeRequest) && !m_challengeRequest.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_challengeResponse) && !m_challengeResponse.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_PasswordChallengeRequestResponse_challengeRequestResponse::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_challengeRequest))
    m_challengeRequest.Encode(strm);
  if (HasOptionalField(e_challengeResponse))
    m_challengeResponse.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_PasswordChallengeRequestResponse_challengeRequestResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_PasswordChallengeRequestResponse_challengeRequestResponse::Class()), PInvalidCast);
#endif
  return new GCC_PasswordChallengeRequestResponse_challengeRequestResponse(*this);
}


//
// RosterUpdateIndication_nodeInformation
//

GCC_RosterUpdateIndication_nodeInformation::GCC_RosterUpdateIndication_nodeInformation(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_rosterInstanceNumber.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void GCC_RosterUpdateIndication_nodeInformation::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "nodeRecordList = " << setprecision(indent) << m_nodeRecordList << '\n';
  strm << setw(indent+23) << "rosterInstanceNumber = " << setprecision(indent) << m_rosterInstanceNumber << '\n';
  strm << setw(indent+13) << "nodesAdded = " << setprecision(indent) << m_nodesAdded << '\n';
  strm << setw(indent+15) << "nodesRemoved = " << setprecision(indent) << m_nodesRemoved << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_RosterUpdateIndication_nodeInformation::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_RosterUpdateIndication_nodeInformation), PInvalidCast);
#endif
  const GCC_RosterUpdateIndication_nodeInformation & other = (const GCC_RosterUpdateIndication_nodeInformation &)obj;

  Comparison result;

  if ((result = m_nodeRecordList.Compare(other.m_nodeRecordList)) != EqualTo)
    return result;
  if ((result = m_rosterInstanceNumber.Compare(other.m_rosterInstanceNumber)) != EqualTo)
    return result;
  if ((result = m_nodesAdded.Compare(other.m_nodesAdded)) != EqualTo)
    return result;
  if ((result = m_nodesRemoved.Compare(other.m_nodesRemoved)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_RosterUpdateIndication_nodeInformation::GetDataLength() const
{
  PINDEX length = 0;
  length += m_nodeRecordList.GetObjectLength();
  length += m_rosterInstanceNumber.GetObjectLength();
  length += m_nodesAdded.GetObjectLength();
  length += m_nodesRemoved.GetObjectLength();
  return length;
}


BOOL GCC_RosterUpdateIndication_nodeInformation::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_nodeRecordList.Decode(strm))
    return FALSE;
  if (!m_rosterInstanceNumber.Decode(strm))
    return FALSE;
  if (!m_nodesAdded.Decode(strm))
    return FALSE;
  if (!m_nodesRemoved.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_RosterUpdateIndication_nodeInformation::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_nodeRecordList.Encode(strm);
  m_rosterInstanceNumber.Encode(strm);
  m_nodesAdded.Encode(strm);
  m_nodesRemoved.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_RosterUpdateIndication_nodeInformation::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_RosterUpdateIndication_nodeInformation::Class()), PInvalidCast);
#endif
  return new GCC_RosterUpdateIndication_nodeInformation(*this);
}


//
// NetworkAddress_subtype_aggregatedChannel
//

GCC_NetworkAddress_subtype_aggregatedChannel::GCC_NetworkAddress_subtype_aggregatedChannel(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_NetworkAddress_subtype_aggregatedChannel::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "transferModes = " << setprecision(indent) << m_transferModes << '\n';
  strm << setw(indent+22) << "internationalNumber = " << setprecision(indent) << m_internationalNumber << '\n';
  if (HasOptionalField(e_subAddress))
    strm << setw(indent+13) << "subAddress = " << setprecision(indent) << m_subAddress << '\n';
  if (HasOptionalField(e_extraDialing))
    strm << setw(indent+15) << "extraDialing = " << setprecision(indent) << m_extraDialing << '\n';
  if (HasOptionalField(e_highLayerCompatibility))
    strm << setw(indent+25) << "highLayerCompatibility = " << setprecision(indent) << m_highLayerCompatibility << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_NetworkAddress_subtype_aggregatedChannel::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_NetworkAddress_subtype_aggregatedChannel), PInvalidCast);
#endif
  const GCC_NetworkAddress_subtype_aggregatedChannel & other = (const GCC_NetworkAddress_subtype_aggregatedChannel &)obj;

  Comparison result;

  if ((result = m_transferModes.Compare(other.m_transferModes)) != EqualTo)
    return result;
  if ((result = m_internationalNumber.Compare(other.m_internationalNumber)) != EqualTo)
    return result;
  if ((result = m_subAddress.Compare(other.m_subAddress)) != EqualTo)
    return result;
  if ((result = m_extraDialing.Compare(other.m_extraDialing)) != EqualTo)
    return result;
  if ((result = m_highLayerCompatibility.Compare(other.m_highLayerCompatibility)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_NetworkAddress_subtype_aggregatedChannel::GetDataLength() const
{
  PINDEX length = 0;
  length += m_transferModes.GetObjectLength();
  length += m_internationalNumber.GetObjectLength();
  if (HasOptionalField(e_subAddress))
    length += m_subAddress.GetObjectLength();
  if (HasOptionalField(e_extraDialing))
    length += m_extraDialing.GetObjectLength();
  if (HasOptionalField(e_highLayerCompatibility))
    length += m_highLayerCompatibility.GetObjectLength();
  return length;
}


BOOL GCC_NetworkAddress_subtype_aggregatedChannel::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_transferModes.Decode(strm))
    return FALSE;
  if (!m_internationalNumber.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_subAddress) && !m_subAddress.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_extraDialing) && !m_extraDialing.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_highLayerCompatibility) && !m_highLayerCompatibility.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_NetworkAddress_subtype_aggregatedChannel::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_transferModes.Encode(strm);
  m_internationalNumber.Encode(strm);
  if (HasOptionalField(e_subAddress))
    m_subAddress.Encode(strm);
  if (HasOptionalField(e_extraDialing))
    m_extraDialing.Encode(strm);
  if (HasOptionalField(e_highLayerCompatibility))
    m_highLayerCompatibility.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_NetworkAddress_subtype_aggregatedChannel::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_NetworkAddress_subtype_aggregatedChannel::Class()), PInvalidCast);
#endif
  return new GCC_NetworkAddress_subtype_aggregatedChannel(*this);
}


//
// RosterUpdateIndication_applicationInformation_subtype
//

GCC_RosterUpdateIndication_applicationInformation_subtype::GCC_RosterUpdateIndication_applicationInformation_subtype(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_rosterInstanceNumber.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void GCC_RosterUpdateIndication_applicationInformation_subtype::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+13) << "sessionKey = " << setprecision(indent) << m_sessionKey << '\n';
  strm << setw(indent+24) << "applicationRecordList = " << setprecision(indent) << m_applicationRecordList << '\n';
  strm << setw(indent+30) << "applicationCapabilitiesList = " << setprecision(indent) << m_applicationCapabilitiesList << '\n';
  strm << setw(indent+23) << "rosterInstanceNumber = " << setprecision(indent) << m_rosterInstanceNumber << '\n';
  strm << setw(indent+20) << "peerEntitiesAdded = " << setprecision(indent) << m_peerEntitiesAdded << '\n';
  strm << setw(indent+22) << "peerEntitiesRemoved = " << setprecision(indent) << m_peerEntitiesRemoved << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_RosterUpdateIndication_applicationInformation_subtype::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_RosterUpdateIndication_applicationInformation_subtype), PInvalidCast);
#endif
  const GCC_RosterUpdateIndication_applicationInformation_subtype & other = (const GCC_RosterUpdateIndication_applicationInformation_subtype &)obj;

  Comparison result;

  if ((result = m_sessionKey.Compare(other.m_sessionKey)) != EqualTo)
    return result;
  if ((result = m_applicationRecordList.Compare(other.m_applicationRecordList)) != EqualTo)
    return result;
  if ((result = m_applicationCapabilitiesList.Compare(other.m_applicationCapabilitiesList)) != EqualTo)
    return result;
  if ((result = m_rosterInstanceNumber.Compare(other.m_rosterInstanceNumber)) != EqualTo)
    return result;
  if ((result = m_peerEntitiesAdded.Compare(other.m_peerEntitiesAdded)) != EqualTo)
    return result;
  if ((result = m_peerEntitiesRemoved.Compare(other.m_peerEntitiesRemoved)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_RosterUpdateIndication_applicationInformation_subtype::GetDataLength() const
{
  PINDEX length = 0;
  length += m_sessionKey.GetObjectLength();
  length += m_applicationRecordList.GetObjectLength();
  length += m_applicationCapabilitiesList.GetObjectLength();
  length += m_rosterInstanceNumber.GetObjectLength();
  length += m_peerEntitiesAdded.GetObjectLength();
  length += m_peerEntitiesRemoved.GetObjectLength();
  return length;
}


BOOL GCC_RosterUpdateIndication_applicationInformation_subtype::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_sessionKey.Decode(strm))
    return FALSE;
  if (!m_applicationRecordList.Decode(strm))
    return FALSE;
  if (!m_applicationCapabilitiesList.Decode(strm))
    return FALSE;
  if (!m_rosterInstanceNumber.Decode(strm))
    return FALSE;
  if (!m_peerEntitiesAdded.Decode(strm))
    return FALSE;
  if (!m_peerEntitiesRemoved.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_RosterUpdateIndication_applicationInformation_subtype::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_sessionKey.Encode(strm);
  m_applicationRecordList.Encode(strm);
  m_applicationCapabilitiesList.Encode(strm);
  m_rosterInstanceNumber.Encode(strm);
  m_peerEntitiesAdded.Encode(strm);
  m_peerEntitiesRemoved.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_RosterUpdateIndication_applicationInformation_subtype::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_RosterUpdateIndication_applicationInformation_subtype::Class()), PInvalidCast);
#endif
  return new GCC_RosterUpdateIndication_applicationInformation_subtype(*this);
}


//
// RosterUpdateIndication_nodeInformation_nodeRecordList_refresh_subtype
//

GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_refresh_subtype::GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_refresh_subtype(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_refresh_subtype::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+9) << "nodeID = " << setprecision(indent) << m_nodeID << '\n';
  strm << setw(indent+13) << "nodeRecord = " << setprecision(indent) << m_nodeRecord << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_refresh_subtype::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_refresh_subtype), PInvalidCast);
#endif
  const GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_refresh_subtype & other = (const GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_refresh_subtype &)obj;

  Comparison result;

  if ((result = m_nodeID.Compare(other.m_nodeID)) != EqualTo)
    return result;
  if ((result = m_nodeRecord.Compare(other.m_nodeRecord)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_refresh_subtype::GetDataLength() const
{
  PINDEX length = 0;
  length += m_nodeID.GetObjectLength();
  length += m_nodeRecord.GetObjectLength();
  return length;
}


BOOL GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_refresh_subtype::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_nodeID.Decode(strm))
    return FALSE;
  if (!m_nodeRecord.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_refresh_subtype::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_nodeID.Encode(strm);
  m_nodeRecord.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_refresh_subtype::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_refresh_subtype::Class()), PInvalidCast);
#endif
  return new GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_refresh_subtype(*this);
}


//
// RosterUpdateIndication_nodeInformation_nodeRecordList_update_subtype
//

GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_update_subtype::GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_update_subtype(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_update_subtype::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+9) << "nodeID = " << setprecision(indent) << m_nodeID << '\n';
  strm << setw(indent+13) << "nodeUpdate = " << setprecision(indent) << m_nodeUpdate << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_update_subtype::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_update_subtype), PInvalidCast);
#endif
  const GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_update_subtype & other = (const GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_update_subtype &)obj;

  Comparison result;

  if ((result = m_nodeID.Compare(other.m_nodeID)) != EqualTo)
    return result;
  if ((result = m_nodeUpdate.Compare(other.m_nodeUpdate)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_update_subtype::GetDataLength() const
{
  PINDEX length = 0;
  length += m_nodeID.GetObjectLength();
  length += m_nodeUpdate.GetObjectLength();
  return length;
}


BOOL GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_update_subtype::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_nodeID.Decode(strm))
    return FALSE;
  if (!m_nodeUpdate.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_update_subtype::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_nodeID.Encode(strm);
  m_nodeUpdate.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_update_subtype::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_update_subtype::Class()), PInvalidCast);
#endif
  return new GCC_RosterUpdateIndication_nodeInformation_nodeRecordList_update_subtype(*this);
}


//
// RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_refresh_subtype
//

GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_refresh_subtype::GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_refresh_subtype(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_refresh_subtype::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+9) << "nodeID = " << setprecision(indent) << m_nodeID << '\n';
  strm << setw(indent+11) << "entityID = " << setprecision(indent) << m_entityID << '\n';
  strm << setw(indent+20) << "applicationRecord = " << setprecision(indent) << m_applicationRecord << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_refresh_subtype::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_refresh_subtype), PInvalidCast);
#endif
  const GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_refresh_subtype & other = (const GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_refresh_subtype &)obj;

  Comparison result;

  if ((result = m_nodeID.Compare(other.m_nodeID)) != EqualTo)
    return result;
  if ((result = m_entityID.Compare(other.m_entityID)) != EqualTo)
    return result;
  if ((result = m_applicationRecord.Compare(other.m_applicationRecord)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_refresh_subtype::GetDataLength() const
{
  PINDEX length = 0;
  length += m_nodeID.GetObjectLength();
  length += m_entityID.GetObjectLength();
  length += m_applicationRecord.GetObjectLength();
  return length;
}


BOOL GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_refresh_subtype::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_nodeID.Decode(strm))
    return FALSE;
  if (!m_entityID.Decode(strm))
    return FALSE;
  if (!m_applicationRecord.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_refresh_subtype::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_nodeID.Encode(strm);
  m_entityID.Encode(strm);
  m_applicationRecord.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_refresh_subtype::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_refresh_subtype::Class()), PInvalidCast);
#endif
  return new GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_refresh_subtype(*this);
}


//
// RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_update_subtype
//

GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_update_subtype::GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_update_subtype(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_update_subtype::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+9) << "nodeID = " << setprecision(indent) << m_nodeID << '\n';
  strm << setw(indent+11) << "entityID = " << setprecision(indent) << m_entityID << '\n';
  strm << setw(indent+20) << "applicationUpdate = " << setprecision(indent) << m_applicationUpdate << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_update_subtype::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_update_subtype), PInvalidCast);
#endif
  const GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_update_subtype & other = (const GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_update_subtype &)obj;

  Comparison result;

  if ((result = m_nodeID.Compare(other.m_nodeID)) != EqualTo)
    return result;
  if ((result = m_entityID.Compare(other.m_entityID)) != EqualTo)
    return result;
  if ((result = m_applicationUpdate.Compare(other.m_applicationUpdate)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_update_subtype::GetDataLength() const
{
  PINDEX length = 0;
  length += m_nodeID.GetObjectLength();
  length += m_entityID.GetObjectLength();
  length += m_applicationUpdate.GetObjectLength();
  return length;
}


BOOL GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_update_subtype::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_nodeID.Decode(strm))
    return FALSE;
  if (!m_entityID.Decode(strm))
    return FALSE;
  if (!m_applicationUpdate.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_update_subtype::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_nodeID.Encode(strm);
  m_entityID.Encode(strm);
  m_applicationUpdate.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_update_subtype::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_update_subtype::Class()), PInvalidCast);
#endif
  return new GCC_RosterUpdateIndication_applicationInformation_subtype_applicationRecordList_update_subtype(*this);
}


//
// RosterUpdateIndication
//

GCC_RosterUpdateIndication::GCC_RosterUpdateIndication(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void GCC_RosterUpdateIndication::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+14) << "fullRefresh = " << setprecision(indent) << m_fullRefresh << '\n';
  strm << setw(indent+18) << "nodeInformation = " << setprecision(indent) << m_nodeInformation << '\n';
  strm << setw(indent+25) << "applicationInformation = " << setprecision(indent) << m_applicationInformation << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison GCC_RosterUpdateIndication::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, GCC_RosterUpdateIndication), PInvalidCast);
#endif
  const GCC_RosterUpdateIndication & other = (const GCC_RosterUpdateIndication &)obj;

  Comparison result;

  if ((result = m_fullRefresh.Compare(other.m_fullRefresh)) != EqualTo)
    return result;
  if ((result = m_nodeInformation.Compare(other.m_nodeInformation)) != EqualTo)
    return result;
  if ((result = m_applicationInformation.Compare(other.m_applicationInformation)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX GCC_RosterUpdateIndication::GetDataLength() const
{
  PINDEX length = 0;
  length += m_fullRefresh.GetObjectLength();
  length += m_nodeInformation.GetObjectLength();
  length += m_applicationInformation.GetObjectLength();
  return length;
}


BOOL GCC_RosterUpdateIndication::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_fullRefresh.Decode(strm))
    return FALSE;
  if (!m_nodeInformation.Decode(strm))
    return FALSE;
  if (!m_applicationInformation.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void GCC_RosterUpdateIndication::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_fullRefresh.Encode(strm);
  m_nodeInformation.Encode(strm);
  m_applicationInformation.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * GCC_RosterUpdateIndication::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(GCC_RosterUpdateIndication::Class()), PInvalidCast);
#endif
  return new GCC_RosterUpdateIndication(*this);
}


#endif // if ! H323_DISABLE_GCC


// End of gccpdu.cxx
