//
// h248.cxx
//
// Code automatically generated by asnparse.
//

#ifdef P_USE_PRAGMA
#pragma implementation "h248.h"
#endif

#include <ptlib.h>
#include "h248.h"

#define new PNEW


#if ! H323_DISABLE_H248

//
// SecurityParmIndex
//

H248_SecurityParmIndex::H248_SecurityParmIndex(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_OctetString(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 4);
}


H248_SecurityParmIndex::H248_SecurityParmIndex(const char * v)
{
  SetValue(v);
}


H248_SecurityParmIndex::H248_SecurityParmIndex(const PString & v)
{
  SetValue(v);
}


H248_SecurityParmIndex::H248_SecurityParmIndex(const PBYTEArray & v)
{
  SetValue(v);
}


H248_SecurityParmIndex & H248_SecurityParmIndex::operator=(const char * v)
{
  SetValue(v);
  return *this;
}


H248_SecurityParmIndex & H248_SecurityParmIndex::operator=(const PString & v)
{
  SetValue(v);
  return *this;
}


H248_SecurityParmIndex & H248_SecurityParmIndex::operator=(const PBYTEArray & v)
{
  SetValue(v);
  return *this;
}


PObject * H248_SecurityParmIndex::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_SecurityParmIndex::Class()), PInvalidCast);
#endif
  return new H248_SecurityParmIndex(*this);
}


//
// SequenceNum
//

H248_SequenceNum::H248_SequenceNum(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_OctetString(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 4);
}


H248_SequenceNum::H248_SequenceNum(const char * v)
{
  SetValue(v);
}


H248_SequenceNum::H248_SequenceNum(const PString & v)
{
  SetValue(v);
}


H248_SequenceNum::H248_SequenceNum(const PBYTEArray & v)
{
  SetValue(v);
}


H248_SequenceNum & H248_SequenceNum::operator=(const char * v)
{
  SetValue(v);
  return *this;
}


H248_SequenceNum & H248_SequenceNum::operator=(const PString & v)
{
  SetValue(v);
  return *this;
}


H248_SequenceNum & H248_SequenceNum::operator=(const PBYTEArray & v)
{
  SetValue(v);
  return *this;
}


PObject * H248_SequenceNum::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_SequenceNum::Class()), PInvalidCast);
#endif
  return new H248_SequenceNum(*this);
}


//
// AuthData
//

H248_AuthData::H248_AuthData(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_OctetString(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 12, 32);
}


H248_AuthData::H248_AuthData(const char * v)
{
  SetValue(v);
}


H248_AuthData::H248_AuthData(const PString & v)
{
  SetValue(v);
}


H248_AuthData::H248_AuthData(const PBYTEArray & v)
{
  SetValue(v);
}


H248_AuthData & H248_AuthData::operator=(const char * v)
{
  SetValue(v);
  return *this;
}


H248_AuthData & H248_AuthData::operator=(const PString & v)
{
  SetValue(v);
  return *this;
}


H248_AuthData & H248_AuthData::operator=(const PBYTEArray & v)
{
  SetValue(v);
  return *this;
}


PObject * H248_AuthData::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_AuthData::Class()), PInvalidCast);
#endif
  return new H248_AuthData(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H248_MId[]={
      {"ip4Address",0}
     ,{"ip6Address",1}
     ,{"domainName",2}
     ,{"deviceName",3}
     ,{"mtpAddress",4}
};
#endif
//
// MId
//

H248_MId::H248_MId(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 5, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H248_MId,5
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_MId::operator H248_IP4Address &() const
#else
H248_MId::operator H248_IP4Address &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_IP4Address), PInvalidCast);
#endif
  return *(H248_IP4Address *)choice;
}


H248_MId::operator const H248_IP4Address &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_IP4Address), PInvalidCast);
#endif
  return *(H248_IP4Address *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_MId::operator H248_IP6Address &() const
#else
H248_MId::operator H248_IP6Address &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_IP6Address), PInvalidCast);
#endif
  return *(H248_IP6Address *)choice;
}


H248_MId::operator const H248_IP6Address &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_IP6Address), PInvalidCast);
#endif
  return *(H248_IP6Address *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_MId::operator H248_DomainName &() const
#else
H248_MId::operator H248_DomainName &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_DomainName), PInvalidCast);
#endif
  return *(H248_DomainName *)choice;
}


H248_MId::operator const H248_DomainName &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_DomainName), PInvalidCast);
#endif
  return *(H248_DomainName *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_MId::operator H248_PathName &() const
#else
H248_MId::operator H248_PathName &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_PathName), PInvalidCast);
#endif
  return *(H248_PathName *)choice;
}


H248_MId::operator const H248_PathName &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_PathName), PInvalidCast);
#endif
  return *(H248_PathName *)choice;
}


BOOL H248_MId::CreateObject()
{
  switch (tag) {
    case e_ip4Address :
      choice = new H248_IP4Address();
      return TRUE;
    case e_ip6Address :
      choice = new H248_IP6Address();
      return TRUE;
    case e_domainName :
      choice = new H248_DomainName();
      return TRUE;
    case e_deviceName :
      choice = new H248_PathName();
      return TRUE;
    case e_mtpAddress :
      choice = new PASN_OctetString();
      choice->SetConstraints(PASN_Object::FixedConstraint, 2, 4);
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H248_MId::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_MId::Class()), PInvalidCast);
#endif
  return new H248_MId(*this);
}


//
// DomainName
//

H248_DomainName::H248_DomainName(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, FALSE, 0)
{
  m_portNumber.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void H248_DomainName::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+7) << "name = " << setprecision(indent) << m_name << '\n';
  if (HasOptionalField(e_portNumber))
    strm << setw(indent+13) << "portNumber = " << setprecision(indent) << m_portNumber << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_DomainName::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_DomainName), PInvalidCast);
#endif
  const H248_DomainName & other = (const H248_DomainName &)obj;

  Comparison result;

  if ((result = m_name.Compare(other.m_name)) != EqualTo)
    return result;
  if ((result = m_portNumber.Compare(other.m_portNumber)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_DomainName::GetDataLength() const
{
  PINDEX length = 0;
  length += m_name.GetObjectLength();
  if (HasOptionalField(e_portNumber))
    length += m_portNumber.GetObjectLength();
  return length;
}


BOOL H248_DomainName::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_name.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_portNumber) && !m_portNumber.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_DomainName::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_name.Encode(strm);
  if (HasOptionalField(e_portNumber))
    m_portNumber.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_DomainName::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_DomainName::Class()), PInvalidCast);
#endif
  return new H248_DomainName(*this);
}


//
// IP4Address
//

H248_IP4Address::H248_IP4Address(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, FALSE, 0)
{
  m_address.SetConstraints(PASN_Object::FixedConstraint, 4);
  m_portNumber.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void H248_IP4Address::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+10) << "address = " << setprecision(indent) << m_address << '\n';
  if (HasOptionalField(e_portNumber))
    strm << setw(indent+13) << "portNumber = " << setprecision(indent) << m_portNumber << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_IP4Address::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_IP4Address), PInvalidCast);
#endif
  const H248_IP4Address & other = (const H248_IP4Address &)obj;

  Comparison result;

  if ((result = m_address.Compare(other.m_address)) != EqualTo)
    return result;
  if ((result = m_portNumber.Compare(other.m_portNumber)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_IP4Address::GetDataLength() const
{
  PINDEX length = 0;
  length += m_address.GetObjectLength();
  if (HasOptionalField(e_portNumber))
    length += m_portNumber.GetObjectLength();
  return length;
}


BOOL H248_IP4Address::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_address.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_portNumber) && !m_portNumber.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_IP4Address::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_address.Encode(strm);
  if (HasOptionalField(e_portNumber))
    m_portNumber.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_IP4Address::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_IP4Address::Class()), PInvalidCast);
#endif
  return new H248_IP4Address(*this);
}


//
// IP6Address
//

H248_IP6Address::H248_IP6Address(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, FALSE, 0)
{
  m_address.SetConstraints(PASN_Object::FixedConstraint, 16);
  m_portNumber.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void H248_IP6Address::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+10) << "address = " << setprecision(indent) << m_address << '\n';
  if (HasOptionalField(e_portNumber))
    strm << setw(indent+13) << "portNumber = " << setprecision(indent) << m_portNumber << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_IP6Address::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_IP6Address), PInvalidCast);
#endif
  const H248_IP6Address & other = (const H248_IP6Address &)obj;

  Comparison result;

  if ((result = m_address.Compare(other.m_address)) != EqualTo)
    return result;
  if ((result = m_portNumber.Compare(other.m_portNumber)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_IP6Address::GetDataLength() const
{
  PINDEX length = 0;
  length += m_address.GetObjectLength();
  if (HasOptionalField(e_portNumber))
    length += m_portNumber.GetObjectLength();
  return length;
}


BOOL H248_IP6Address::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_address.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_portNumber) && !m_portNumber.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_IP6Address::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_address.Encode(strm);
  if (HasOptionalField(e_portNumber))
    m_portNumber.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_IP6Address::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_IP6Address::Class()), PInvalidCast);
#endif
  return new H248_IP6Address(*this);
}


//
// PathName
//

H248_PathName::H248_PathName(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_IA5String(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 64);
}


H248_PathName & H248_PathName::operator=(const char * v)
{
  SetValue(v);
  return *this;
}


H248_PathName & H248_PathName::operator=(const PString & v)
{
  SetValue(v);
  return *this;
}


PObject * H248_PathName::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_PathName::Class()), PInvalidCast);
#endif
  return new H248_PathName(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H248_Transaction[]={
      {"transactionRequest",0}
     ,{"transactionPending",1}
     ,{"transactionReply",2}
     ,{"transactionResponseAck",3}
};
#endif
//
// Transaction
//

H248_Transaction::H248_Transaction(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H248_Transaction,4
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_Transaction::operator H248_TransactionRequest &() const
#else
H248_Transaction::operator H248_TransactionRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_TransactionRequest), PInvalidCast);
#endif
  return *(H248_TransactionRequest *)choice;
}


H248_Transaction::operator const H248_TransactionRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_TransactionRequest), PInvalidCast);
#endif
  return *(H248_TransactionRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_Transaction::operator H248_TransactionPending &() const
#else
H248_Transaction::operator H248_TransactionPending &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_TransactionPending), PInvalidCast);
#endif
  return *(H248_TransactionPending *)choice;
}


H248_Transaction::operator const H248_TransactionPending &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_TransactionPending), PInvalidCast);
#endif
  return *(H248_TransactionPending *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_Transaction::operator H248_TransactionReply &() const
#else
H248_Transaction::operator H248_TransactionReply &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_TransactionReply), PInvalidCast);
#endif
  return *(H248_TransactionReply *)choice;
}


H248_Transaction::operator const H248_TransactionReply &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_TransactionReply), PInvalidCast);
#endif
  return *(H248_TransactionReply *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_Transaction::operator H248_TransactionResponseAck &() const
#else
H248_Transaction::operator H248_TransactionResponseAck &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_TransactionResponseAck), PInvalidCast);
#endif
  return *(H248_TransactionResponseAck *)choice;
}


H248_Transaction::operator const H248_TransactionResponseAck &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_TransactionResponseAck), PInvalidCast);
#endif
  return *(H248_TransactionResponseAck *)choice;
}


BOOL H248_Transaction::CreateObject()
{
  switch (tag) {
    case e_transactionRequest :
      choice = new H248_TransactionRequest();
      return TRUE;
    case e_transactionPending :
      choice = new H248_TransactionPending();
      return TRUE;
    case e_transactionReply :
      choice = new H248_TransactionReply();
      return TRUE;
    case e_transactionResponseAck :
      choice = new H248_TransactionResponseAck();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H248_Transaction::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_Transaction::Class()), PInvalidCast);
#endif
  return new H248_Transaction(*this);
}


//
// TransactionId
//

H248_TransactionId::H248_TransactionId(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 0, 4294967295U);
}


H248_TransactionId & H248_TransactionId::operator=(int v)
{
  SetValue(v);
  return *this;
}


H248_TransactionId & H248_TransactionId::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H248_TransactionId::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_TransactionId::Class()), PInvalidCast);
#endif
  return new H248_TransactionId(*this);
}


//
// TransactionPending
//

H248_TransactionPending::H248_TransactionPending(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_TransactionPending::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "transactionId = " << setprecision(indent) << m_transactionId << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_TransactionPending::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_TransactionPending), PInvalidCast);
#endif
  const H248_TransactionPending & other = (const H248_TransactionPending &)obj;

  Comparison result;

  if ((result = m_transactionId.Compare(other.m_transactionId)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_TransactionPending::GetDataLength() const
{
  PINDEX length = 0;
  length += m_transactionId.GetObjectLength();
  return length;
}


BOOL H248_TransactionPending::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_transactionId.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_TransactionPending::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_transactionId.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_TransactionPending::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_TransactionPending::Class()), PInvalidCast);
#endif
  return new H248_TransactionPending(*this);
}


//
// TransactionResponseAck
//

H248_TransactionResponseAck::H248_TransactionResponseAck(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H248_TransactionResponseAck::CreateObject() const
{
  return new H248_TransactionAck;
}


H248_TransactionAck & H248_TransactionResponseAck::operator[](PINDEX i) const
{
  return (H248_TransactionAck &)array[i];
}


PObject * H248_TransactionResponseAck::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_TransactionResponseAck::Class()), PInvalidCast);
#endif
  return new H248_TransactionResponseAck(*this);
}


//
// TransactionAck
//

H248_TransactionAck::H248_TransactionAck(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_TransactionAck::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "firstAck = " << setprecision(indent) << m_firstAck << '\n';
  if (HasOptionalField(e_lastAck))
    strm << setw(indent+10) << "lastAck = " << setprecision(indent) << m_lastAck << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_TransactionAck::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_TransactionAck), PInvalidCast);
#endif
  const H248_TransactionAck & other = (const H248_TransactionAck &)obj;

  Comparison result;

  if ((result = m_firstAck.Compare(other.m_firstAck)) != EqualTo)
    return result;
  if ((result = m_lastAck.Compare(other.m_lastAck)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_TransactionAck::GetDataLength() const
{
  PINDEX length = 0;
  length += m_firstAck.GetObjectLength();
  if (HasOptionalField(e_lastAck))
    length += m_lastAck.GetObjectLength();
  return length;
}


BOOL H248_TransactionAck::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_firstAck.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_lastAck) && !m_lastAck.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_TransactionAck::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_firstAck.Encode(strm);
  if (HasOptionalField(e_lastAck))
    m_lastAck.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_TransactionAck::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_TransactionAck::Class()), PInvalidCast);
#endif
  return new H248_TransactionAck(*this);
}


//
// ErrorCode
//

H248_ErrorCode::H248_ErrorCode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


H248_ErrorCode & H248_ErrorCode::operator=(int v)
{
  SetValue(v);
  return *this;
}


H248_ErrorCode & H248_ErrorCode::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H248_ErrorCode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_ErrorCode::Class()), PInvalidCast);
#endif
  return new H248_ErrorCode(*this);
}


//
// ErrorText
//

H248_ErrorText::H248_ErrorText(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_IA5String(tag, tagClass)
{
}


H248_ErrorText & H248_ErrorText::operator=(const char * v)
{
  SetValue(v);
  return *this;
}


H248_ErrorText & H248_ErrorText::operator=(const PString & v)
{
  SetValue(v);
  return *this;
}


PObject * H248_ErrorText::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_ErrorText::Class()), PInvalidCast);
#endif
  return new H248_ErrorText(*this);
}


//
// ContextID
//

H248_ContextID::H248_ContextID(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 0, 4294967295U);
}


H248_ContextID & H248_ContextID::operator=(int v)
{
  SetValue(v);
  return *this;
}


H248_ContextID & H248_ContextID::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H248_ContextID::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_ContextID::Class()), PInvalidCast);
#endif
  return new H248_ContextID(*this);
}


//
// ContextAttrAuditRequest
//

H248_ContextAttrAuditRequest::H248_ContextAttrAuditRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_ContextAttrAuditRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_topology))
    strm << setw(indent+11) << "topology = " << setprecision(indent) << m_topology << '\n';
  if (HasOptionalField(e_emergency))
    strm << setw(indent+12) << "emergency = " << setprecision(indent) << m_emergency << '\n';
  if (HasOptionalField(e_priority))
    strm << setw(indent+11) << "priority = " << setprecision(indent) << m_priority << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_ContextAttrAuditRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_ContextAttrAuditRequest), PInvalidCast);
#endif
  const H248_ContextAttrAuditRequest & other = (const H248_ContextAttrAuditRequest &)obj;

  Comparison result;

  if ((result = m_topology.Compare(other.m_topology)) != EqualTo)
    return result;
  if ((result = m_emergency.Compare(other.m_emergency)) != EqualTo)
    return result;
  if ((result = m_priority.Compare(other.m_priority)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_ContextAttrAuditRequest::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_topology))
    length += m_topology.GetObjectLength();
  if (HasOptionalField(e_emergency))
    length += m_emergency.GetObjectLength();
  if (HasOptionalField(e_priority))
    length += m_priority.GetObjectLength();
  return length;
}


BOOL H248_ContextAttrAuditRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_topology) && !m_topology.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_emergency) && !m_emergency.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_priority) && !m_priority.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_ContextAttrAuditRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_topology))
    m_topology.Encode(strm);
  if (HasOptionalField(e_emergency))
    m_emergency.Encode(strm);
  if (HasOptionalField(e_priority))
    m_priority.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_ContextAttrAuditRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_ContextAttrAuditRequest::Class()), PInvalidCast);
#endif
  return new H248_ContextAttrAuditRequest(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H248_Command[]={
      {"addReq",0}
     ,{"moveReq",1}
     ,{"modReq",2}
     ,{"subtractReq",3}
     ,{"auditCapRequest",4}
     ,{"auditValueRequest",5}
     ,{"notifyReq",6}
     ,{"serviceChangeReq",7}
};
#endif
//
// Command
//

H248_Command::H248_Command(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 8, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H248_Command,8
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_Command::operator H248_AmmRequest &() const
#else
H248_Command::operator H248_AmmRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_AmmRequest), PInvalidCast);
#endif
  return *(H248_AmmRequest *)choice;
}


H248_Command::operator const H248_AmmRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_AmmRequest), PInvalidCast);
#endif
  return *(H248_AmmRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_Command::operator H248_SubtractRequest &() const
#else
H248_Command::operator H248_SubtractRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_SubtractRequest), PInvalidCast);
#endif
  return *(H248_SubtractRequest *)choice;
}


H248_Command::operator const H248_SubtractRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_SubtractRequest), PInvalidCast);
#endif
  return *(H248_SubtractRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_Command::operator H248_AuditRequest &() const
#else
H248_Command::operator H248_AuditRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_AuditRequest), PInvalidCast);
#endif
  return *(H248_AuditRequest *)choice;
}


H248_Command::operator const H248_AuditRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_AuditRequest), PInvalidCast);
#endif
  return *(H248_AuditRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_Command::operator H248_NotifyRequest &() const
#else
H248_Command::operator H248_NotifyRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_NotifyRequest), PInvalidCast);
#endif
  return *(H248_NotifyRequest *)choice;
}


H248_Command::operator const H248_NotifyRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_NotifyRequest), PInvalidCast);
#endif
  return *(H248_NotifyRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_Command::operator H248_ServiceChangeRequest &() const
#else
H248_Command::operator H248_ServiceChangeRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_ServiceChangeRequest), PInvalidCast);
#endif
  return *(H248_ServiceChangeRequest *)choice;
}


H248_Command::operator const H248_ServiceChangeRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_ServiceChangeRequest), PInvalidCast);
#endif
  return *(H248_ServiceChangeRequest *)choice;
}


BOOL H248_Command::CreateObject()
{
  switch (tag) {
    case e_addReq :
    case e_moveReq :
    case e_modReq :
      choice = new H248_AmmRequest();
      return TRUE;
    case e_subtractReq :
      choice = new H248_SubtractRequest();
      return TRUE;
    case e_auditCapRequest :
    case e_auditValueRequest :
      choice = new H248_AuditRequest();
      return TRUE;
    case e_notifyReq :
      choice = new H248_NotifyRequest();
      return TRUE;
    case e_serviceChangeReq :
      choice = new H248_ServiceChangeRequest();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H248_Command::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_Command::Class()), PInvalidCast);
#endif
  return new H248_Command(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H248_CommandReply[]={
      {"addReply",0}
     ,{"moveReply",1}
     ,{"modReply",2}
     ,{"subtractReply",3}
     ,{"auditCapReply",4}
     ,{"auditValueReply",5}
     ,{"notifyReply",6}
     ,{"serviceChangeReply",7}
};
#endif
//
// CommandReply
//

H248_CommandReply::H248_CommandReply(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 8, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H248_CommandReply,8
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_CommandReply::operator H248_AmmsReply &() const
#else
H248_CommandReply::operator H248_AmmsReply &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_AmmsReply), PInvalidCast);
#endif
  return *(H248_AmmsReply *)choice;
}


H248_CommandReply::operator const H248_AmmsReply &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_AmmsReply), PInvalidCast);
#endif
  return *(H248_AmmsReply *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_CommandReply::operator H248_AuditReply &() const
#else
H248_CommandReply::operator H248_AuditReply &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_AuditReply), PInvalidCast);
#endif
  return *(H248_AuditReply *)choice;
}


H248_CommandReply::operator const H248_AuditReply &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_AuditReply), PInvalidCast);
#endif
  return *(H248_AuditReply *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_CommandReply::operator H248_NotifyReply &() const
#else
H248_CommandReply::operator H248_NotifyReply &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_NotifyReply), PInvalidCast);
#endif
  return *(H248_NotifyReply *)choice;
}


H248_CommandReply::operator const H248_NotifyReply &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_NotifyReply), PInvalidCast);
#endif
  return *(H248_NotifyReply *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_CommandReply::operator H248_ServiceChangeReply &() const
#else
H248_CommandReply::operator H248_ServiceChangeReply &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_ServiceChangeReply), PInvalidCast);
#endif
  return *(H248_ServiceChangeReply *)choice;
}


H248_CommandReply::operator const H248_ServiceChangeReply &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_ServiceChangeReply), PInvalidCast);
#endif
  return *(H248_ServiceChangeReply *)choice;
}


BOOL H248_CommandReply::CreateObject()
{
  switch (tag) {
    case e_addReply :
    case e_moveReply :
    case e_modReply :
    case e_subtractReply :
      choice = new H248_AmmsReply();
      return TRUE;
    case e_auditCapReply :
    case e_auditValueReply :
      choice = new H248_AuditReply();
      return TRUE;
    case e_notifyReply :
      choice = new H248_NotifyReply();
      return TRUE;
    case e_serviceChangeReply :
      choice = new H248_ServiceChangeReply();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H248_CommandReply::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_CommandReply::Class()), PInvalidCast);
#endif
  return new H248_CommandReply(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H248_AmmDescriptor[]={
      {"mediaDescriptor",0}
     ,{"modemDescriptor",1}
     ,{"muxDescriptor",2}
     ,{"eventsDescriptor",3}
     ,{"eventBufferDescriptor",4}
     ,{"signalsDescriptor",5}
     ,{"digitMapDescriptor",6}
     ,{"auditDescriptor",7}
};
#endif
//
// AmmDescriptor
//

H248_AmmDescriptor::H248_AmmDescriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 8, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H248_AmmDescriptor,8
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_AmmDescriptor::operator H248_MediaDescriptor &() const
#else
H248_AmmDescriptor::operator H248_MediaDescriptor &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_MediaDescriptor), PInvalidCast);
#endif
  return *(H248_MediaDescriptor *)choice;
}


H248_AmmDescriptor::operator const H248_MediaDescriptor &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_MediaDescriptor), PInvalidCast);
#endif
  return *(H248_MediaDescriptor *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_AmmDescriptor::operator H248_ModemDescriptor &() const
#else
H248_AmmDescriptor::operator H248_ModemDescriptor &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_ModemDescriptor), PInvalidCast);
#endif
  return *(H248_ModemDescriptor *)choice;
}


H248_AmmDescriptor::operator const H248_ModemDescriptor &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_ModemDescriptor), PInvalidCast);
#endif
  return *(H248_ModemDescriptor *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_AmmDescriptor::operator H248_MuxDescriptor &() const
#else
H248_AmmDescriptor::operator H248_MuxDescriptor &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_MuxDescriptor), PInvalidCast);
#endif
  return *(H248_MuxDescriptor *)choice;
}


H248_AmmDescriptor::operator const H248_MuxDescriptor &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_MuxDescriptor), PInvalidCast);
#endif
  return *(H248_MuxDescriptor *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_AmmDescriptor::operator H248_EventsDescriptor &() const
#else
H248_AmmDescriptor::operator H248_EventsDescriptor &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_EventsDescriptor), PInvalidCast);
#endif
  return *(H248_EventsDescriptor *)choice;
}


H248_AmmDescriptor::operator const H248_EventsDescriptor &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_EventsDescriptor), PInvalidCast);
#endif
  return *(H248_EventsDescriptor *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_AmmDescriptor::operator H248_EventBufferDescriptor &() const
#else
H248_AmmDescriptor::operator H248_EventBufferDescriptor &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_EventBufferDescriptor), PInvalidCast);
#endif
  return *(H248_EventBufferDescriptor *)choice;
}


H248_AmmDescriptor::operator const H248_EventBufferDescriptor &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_EventBufferDescriptor), PInvalidCast);
#endif
  return *(H248_EventBufferDescriptor *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_AmmDescriptor::operator H248_SignalsDescriptor &() const
#else
H248_AmmDescriptor::operator H248_SignalsDescriptor &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_SignalsDescriptor), PInvalidCast);
#endif
  return *(H248_SignalsDescriptor *)choice;
}


H248_AmmDescriptor::operator const H248_SignalsDescriptor &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_SignalsDescriptor), PInvalidCast);
#endif
  return *(H248_SignalsDescriptor *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_AmmDescriptor::operator H248_DigitMapDescriptor &() const
#else
H248_AmmDescriptor::operator H248_DigitMapDescriptor &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_DigitMapDescriptor), PInvalidCast);
#endif
  return *(H248_DigitMapDescriptor *)choice;
}


H248_AmmDescriptor::operator const H248_DigitMapDescriptor &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_DigitMapDescriptor), PInvalidCast);
#endif
  return *(H248_DigitMapDescriptor *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_AmmDescriptor::operator H248_AuditDescriptor &() const
#else
H248_AmmDescriptor::operator H248_AuditDescriptor &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_AuditDescriptor), PInvalidCast);
#endif
  return *(H248_AuditDescriptor *)choice;
}


H248_AmmDescriptor::operator const H248_AuditDescriptor &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_AuditDescriptor), PInvalidCast);
#endif
  return *(H248_AuditDescriptor *)choice;
}


BOOL H248_AmmDescriptor::CreateObject()
{
  switch (tag) {
    case e_mediaDescriptor :
      choice = new H248_MediaDescriptor();
      return TRUE;
    case e_modemDescriptor :
      choice = new H248_ModemDescriptor();
      return TRUE;
    case e_muxDescriptor :
      choice = new H248_MuxDescriptor();
      return TRUE;
    case e_eventsDescriptor :
      choice = new H248_EventsDescriptor();
      return TRUE;
    case e_eventBufferDescriptor :
      choice = new H248_EventBufferDescriptor();
      return TRUE;
    case e_signalsDescriptor :
      choice = new H248_SignalsDescriptor();
      return TRUE;
    case e_digitMapDescriptor :
      choice = new H248_DigitMapDescriptor();
      return TRUE;
    case e_auditDescriptor :
      choice = new H248_AuditDescriptor();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H248_AmmDescriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_AmmDescriptor::Class()), PInvalidCast);
#endif
  return new H248_AmmDescriptor(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H248_AuditReply[]={
      {"contextAuditResult",0}
     ,{"error",1}
     ,{"auditResult",2}
};
#endif
//
// AuditReply
//

H248_AuditReply::H248_AuditReply(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H248_AuditReply,3
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_AuditReply::operator H248_TerminationIDList &() const
#else
H248_AuditReply::operator H248_TerminationIDList &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_TerminationIDList), PInvalidCast);
#endif
  return *(H248_TerminationIDList *)choice;
}


H248_AuditReply::operator const H248_TerminationIDList &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_TerminationIDList), PInvalidCast);
#endif
  return *(H248_TerminationIDList *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_AuditReply::operator H248_ErrorDescriptor &() const
#else
H248_AuditReply::operator H248_ErrorDescriptor &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_ErrorDescriptor), PInvalidCast);
#endif
  return *(H248_ErrorDescriptor *)choice;
}


H248_AuditReply::operator const H248_ErrorDescriptor &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_ErrorDescriptor), PInvalidCast);
#endif
  return *(H248_ErrorDescriptor *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_AuditReply::operator H248_AuditResult &() const
#else
H248_AuditReply::operator H248_AuditResult &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_AuditResult), PInvalidCast);
#endif
  return *(H248_AuditResult *)choice;
}


H248_AuditReply::operator const H248_AuditResult &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_AuditResult), PInvalidCast);
#endif
  return *(H248_AuditResult *)choice;
}


BOOL H248_AuditReply::CreateObject()
{
  switch (tag) {
    case e_contextAuditResult :
      choice = new H248_TerminationIDList();
      return TRUE;
    case e_error :
      choice = new H248_ErrorDescriptor();
      return TRUE;
    case e_auditResult :
      choice = new H248_AuditResult();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H248_AuditReply::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_AuditReply::Class()), PInvalidCast);
#endif
  return new H248_AuditReply(*this);
}


//
// TerminationAudit
//

H248_TerminationAudit::H248_TerminationAudit(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H248_TerminationAudit::CreateObject() const
{
  return new H248_AuditReturnParameter;
}


H248_AuditReturnParameter & H248_TerminationAudit::operator[](PINDEX i) const
{
  return (H248_AuditReturnParameter &)array[i];
}


PObject * H248_TerminationAudit::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_TerminationAudit::Class()), PInvalidCast);
#endif
  return new H248_TerminationAudit(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H248_AuditReturnParameter[]={
      {"errorDescriptor",0}
     ,{"mediaDescriptor",1}
     ,{"modemDescriptor",2}
     ,{"muxDescriptor",3}
     ,{"eventsDescriptor",4}
     ,{"eventBufferDescriptor",5}
     ,{"signalsDescriptor",6}
     ,{"digitMapDescriptor",7}
     ,{"observedEventsDescriptor",8}
     ,{"statisticsDescriptor",9}
     ,{"packagesDescriptor",10}
     ,{"emptyDescriptors",11}
};
#endif
//
// AuditReturnParameter
//

H248_AuditReturnParameter::H248_AuditReturnParameter(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 12, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H248_AuditReturnParameter,12
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_AuditReturnParameter::operator H248_ErrorDescriptor &() const
#else
H248_AuditReturnParameter::operator H248_ErrorDescriptor &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_ErrorDescriptor), PInvalidCast);
#endif
  return *(H248_ErrorDescriptor *)choice;
}


H248_AuditReturnParameter::operator const H248_ErrorDescriptor &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_ErrorDescriptor), PInvalidCast);
#endif
  return *(H248_ErrorDescriptor *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_AuditReturnParameter::operator H248_MediaDescriptor &() const
#else
H248_AuditReturnParameter::operator H248_MediaDescriptor &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_MediaDescriptor), PInvalidCast);
#endif
  return *(H248_MediaDescriptor *)choice;
}


H248_AuditReturnParameter::operator const H248_MediaDescriptor &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_MediaDescriptor), PInvalidCast);
#endif
  return *(H248_MediaDescriptor *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_AuditReturnParameter::operator H248_ModemDescriptor &() const
#else
H248_AuditReturnParameter::operator H248_ModemDescriptor &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_ModemDescriptor), PInvalidCast);
#endif
  return *(H248_ModemDescriptor *)choice;
}


H248_AuditReturnParameter::operator const H248_ModemDescriptor &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_ModemDescriptor), PInvalidCast);
#endif
  return *(H248_ModemDescriptor *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_AuditReturnParameter::operator H248_MuxDescriptor &() const
#else
H248_AuditReturnParameter::operator H248_MuxDescriptor &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_MuxDescriptor), PInvalidCast);
#endif
  return *(H248_MuxDescriptor *)choice;
}


H248_AuditReturnParameter::operator const H248_MuxDescriptor &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_MuxDescriptor), PInvalidCast);
#endif
  return *(H248_MuxDescriptor *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_AuditReturnParameter::operator H248_EventsDescriptor &() const
#else
H248_AuditReturnParameter::operator H248_EventsDescriptor &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_EventsDescriptor), PInvalidCast);
#endif
  return *(H248_EventsDescriptor *)choice;
}


H248_AuditReturnParameter::operator const H248_EventsDescriptor &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_EventsDescriptor), PInvalidCast);
#endif
  return *(H248_EventsDescriptor *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_AuditReturnParameter::operator H248_EventBufferDescriptor &() const
#else
H248_AuditReturnParameter::operator H248_EventBufferDescriptor &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_EventBufferDescriptor), PInvalidCast);
#endif
  return *(H248_EventBufferDescriptor *)choice;
}


H248_AuditReturnParameter::operator const H248_EventBufferDescriptor &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_EventBufferDescriptor), PInvalidCast);
#endif
  return *(H248_EventBufferDescriptor *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_AuditReturnParameter::operator H248_SignalsDescriptor &() const
#else
H248_AuditReturnParameter::operator H248_SignalsDescriptor &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_SignalsDescriptor), PInvalidCast);
#endif
  return *(H248_SignalsDescriptor *)choice;
}


H248_AuditReturnParameter::operator const H248_SignalsDescriptor &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_SignalsDescriptor), PInvalidCast);
#endif
  return *(H248_SignalsDescriptor *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_AuditReturnParameter::operator H248_DigitMapDescriptor &() const
#else
H248_AuditReturnParameter::operator H248_DigitMapDescriptor &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_DigitMapDescriptor), PInvalidCast);
#endif
  return *(H248_DigitMapDescriptor *)choice;
}


H248_AuditReturnParameter::operator const H248_DigitMapDescriptor &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_DigitMapDescriptor), PInvalidCast);
#endif
  return *(H248_DigitMapDescriptor *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_AuditReturnParameter::operator H248_ObservedEventsDescriptor &() const
#else
H248_AuditReturnParameter::operator H248_ObservedEventsDescriptor &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_ObservedEventsDescriptor), PInvalidCast);
#endif
  return *(H248_ObservedEventsDescriptor *)choice;
}


H248_AuditReturnParameter::operator const H248_ObservedEventsDescriptor &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_ObservedEventsDescriptor), PInvalidCast);
#endif
  return *(H248_ObservedEventsDescriptor *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_AuditReturnParameter::operator H248_StatisticsDescriptor &() const
#else
H248_AuditReturnParameter::operator H248_StatisticsDescriptor &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_StatisticsDescriptor), PInvalidCast);
#endif
  return *(H248_StatisticsDescriptor *)choice;
}


H248_AuditReturnParameter::operator const H248_StatisticsDescriptor &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_StatisticsDescriptor), PInvalidCast);
#endif
  return *(H248_StatisticsDescriptor *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_AuditReturnParameter::operator H248_PackagesDescriptor &() const
#else
H248_AuditReturnParameter::operator H248_PackagesDescriptor &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_PackagesDescriptor), PInvalidCast);
#endif
  return *(H248_PackagesDescriptor *)choice;
}


H248_AuditReturnParameter::operator const H248_PackagesDescriptor &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_PackagesDescriptor), PInvalidCast);
#endif
  return *(H248_PackagesDescriptor *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_AuditReturnParameter::operator H248_AuditDescriptor &() const
#else
H248_AuditReturnParameter::operator H248_AuditDescriptor &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_AuditDescriptor), PInvalidCast);
#endif
  return *(H248_AuditDescriptor *)choice;
}


H248_AuditReturnParameter::operator const H248_AuditDescriptor &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_AuditDescriptor), PInvalidCast);
#endif
  return *(H248_AuditDescriptor *)choice;
}


BOOL H248_AuditReturnParameter::CreateObject()
{
  switch (tag) {
    case e_errorDescriptor :
      choice = new H248_ErrorDescriptor();
      return TRUE;
    case e_mediaDescriptor :
      choice = new H248_MediaDescriptor();
      return TRUE;
    case e_modemDescriptor :
      choice = new H248_ModemDescriptor();
      return TRUE;
    case e_muxDescriptor :
      choice = new H248_MuxDescriptor();
      return TRUE;
    case e_eventsDescriptor :
      choice = new H248_EventsDescriptor();
      return TRUE;
    case e_eventBufferDescriptor :
      choice = new H248_EventBufferDescriptor();
      return TRUE;
    case e_signalsDescriptor :
      choice = new H248_SignalsDescriptor();
      return TRUE;
    case e_digitMapDescriptor :
      choice = new H248_DigitMapDescriptor();
      return TRUE;
    case e_observedEventsDescriptor :
      choice = new H248_ObservedEventsDescriptor();
      return TRUE;
    case e_statisticsDescriptor :
      choice = new H248_StatisticsDescriptor();
      return TRUE;
    case e_packagesDescriptor :
      choice = new H248_PackagesDescriptor();
      return TRUE;
    case e_emptyDescriptors :
      choice = new H248_AuditDescriptor();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H248_AuditReturnParameter::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_AuditReturnParameter::Class()), PInvalidCast);
#endif
  return new H248_AuditReturnParameter(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H248_IndAuditParameter[]={
      {"indaudmediaDescriptor",0}
     ,{"indaudeventsDescriptor",1}
     ,{"indaudeventBufferDescriptor",2}
     ,{"indaudsignalsDescriptor",3}
     ,{"indauddigitMapDescriptor",4}
     ,{"indaudstatisticsDescriptor",5}
     ,{"indaudpackagesDescriptor",6}
};
#endif
//
// IndAuditParameter
//

H248_IndAuditParameter::H248_IndAuditParameter(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 7, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H248_IndAuditParameter,7
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_IndAuditParameter::operator H248_IndAudMediaDescriptor &() const
#else
H248_IndAuditParameter::operator H248_IndAudMediaDescriptor &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_IndAudMediaDescriptor), PInvalidCast);
#endif
  return *(H248_IndAudMediaDescriptor *)choice;
}


H248_IndAuditParameter::operator const H248_IndAudMediaDescriptor &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_IndAudMediaDescriptor), PInvalidCast);
#endif
  return *(H248_IndAudMediaDescriptor *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_IndAuditParameter::operator H248_IndAudEventsDescriptor &() const
#else
H248_IndAuditParameter::operator H248_IndAudEventsDescriptor &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_IndAudEventsDescriptor), PInvalidCast);
#endif
  return *(H248_IndAudEventsDescriptor *)choice;
}


H248_IndAuditParameter::operator const H248_IndAudEventsDescriptor &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_IndAudEventsDescriptor), PInvalidCast);
#endif
  return *(H248_IndAudEventsDescriptor *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_IndAuditParameter::operator H248_IndAudEventBufferDescriptor &() const
#else
H248_IndAuditParameter::operator H248_IndAudEventBufferDescriptor &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_IndAudEventBufferDescriptor), PInvalidCast);
#endif
  return *(H248_IndAudEventBufferDescriptor *)choice;
}


H248_IndAuditParameter::operator const H248_IndAudEventBufferDescriptor &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_IndAudEventBufferDescriptor), PInvalidCast);
#endif
  return *(H248_IndAudEventBufferDescriptor *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_IndAuditParameter::operator H248_IndAudSignalsDescriptor &() const
#else
H248_IndAuditParameter::operator H248_IndAudSignalsDescriptor &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_IndAudSignalsDescriptor), PInvalidCast);
#endif
  return *(H248_IndAudSignalsDescriptor *)choice;
}


H248_IndAuditParameter::operator const H248_IndAudSignalsDescriptor &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_IndAudSignalsDescriptor), PInvalidCast);
#endif
  return *(H248_IndAudSignalsDescriptor *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_IndAuditParameter::operator H248_IndAudDigitMapDescriptor &() const
#else
H248_IndAuditParameter::operator H248_IndAudDigitMapDescriptor &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_IndAudDigitMapDescriptor), PInvalidCast);
#endif
  return *(H248_IndAudDigitMapDescriptor *)choice;
}


H248_IndAuditParameter::operator const H248_IndAudDigitMapDescriptor &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_IndAudDigitMapDescriptor), PInvalidCast);
#endif
  return *(H248_IndAudDigitMapDescriptor *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_IndAuditParameter::operator H248_IndAudStatisticsDescriptor &() const
#else
H248_IndAuditParameter::operator H248_IndAudStatisticsDescriptor &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_IndAudStatisticsDescriptor), PInvalidCast);
#endif
  return *(H248_IndAudStatisticsDescriptor *)choice;
}


H248_IndAuditParameter::operator const H248_IndAudStatisticsDescriptor &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_IndAudStatisticsDescriptor), PInvalidCast);
#endif
  return *(H248_IndAudStatisticsDescriptor *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_IndAuditParameter::operator H248_IndAudPackagesDescriptor &() const
#else
H248_IndAuditParameter::operator H248_IndAudPackagesDescriptor &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_IndAudPackagesDescriptor), PInvalidCast);
#endif
  return *(H248_IndAudPackagesDescriptor *)choice;
}


H248_IndAuditParameter::operator const H248_IndAudPackagesDescriptor &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_IndAudPackagesDescriptor), PInvalidCast);
#endif
  return *(H248_IndAudPackagesDescriptor *)choice;
}


BOOL H248_IndAuditParameter::CreateObject()
{
  switch (tag) {
    case e_indaudmediaDescriptor :
      choice = new H248_IndAudMediaDescriptor();
      return TRUE;
    case e_indaudeventsDescriptor :
      choice = new H248_IndAudEventsDescriptor();
      return TRUE;
    case e_indaudeventBufferDescriptor :
      choice = new H248_IndAudEventBufferDescriptor();
      return TRUE;
    case e_indaudsignalsDescriptor :
      choice = new H248_IndAudSignalsDescriptor();
      return TRUE;
    case e_indauddigitMapDescriptor :
      choice = new H248_IndAudDigitMapDescriptor();
      return TRUE;
    case e_indaudstatisticsDescriptor :
      choice = new H248_IndAudStatisticsDescriptor();
      return TRUE;
    case e_indaudpackagesDescriptor :
      choice = new H248_IndAudPackagesDescriptor();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H248_IndAuditParameter::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_IndAuditParameter::Class()), PInvalidCast);
#endif
  return new H248_IndAuditParameter(*this);
}


//
// IndAudPropertyGroup
//

H248_IndAudPropertyGroup::H248_IndAudPropertyGroup(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H248_IndAudPropertyGroup::CreateObject() const
{
  return new H248_IndAudPropertyParm;
}


H248_IndAudPropertyParm & H248_IndAudPropertyGroup::operator[](PINDEX i) const
{
  return (H248_IndAudPropertyParm &)array[i];
}


PObject * H248_IndAudPropertyGroup::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_IndAudPropertyGroup::Class()), PInvalidCast);
#endif
  return new H248_IndAudPropertyGroup(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H248_IndAudSignalsDescriptor[]={
      {"signal",0}
     ,{"seqSigList",1}
};
#endif
//
// IndAudSignalsDescriptor
//

H248_IndAudSignalsDescriptor::H248_IndAudSignalsDescriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H248_IndAudSignalsDescriptor,2
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_IndAudSignalsDescriptor::operator H248_IndAudSignal &() const
#else
H248_IndAudSignalsDescriptor::operator H248_IndAudSignal &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_IndAudSignal), PInvalidCast);
#endif
  return *(H248_IndAudSignal *)choice;
}


H248_IndAudSignalsDescriptor::operator const H248_IndAudSignal &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_IndAudSignal), PInvalidCast);
#endif
  return *(H248_IndAudSignal *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_IndAudSignalsDescriptor::operator H248_IndAudSeqSigList &() const
#else
H248_IndAudSignalsDescriptor::operator H248_IndAudSeqSigList &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_IndAudSeqSigList), PInvalidCast);
#endif
  return *(H248_IndAudSeqSigList *)choice;
}


H248_IndAudSignalsDescriptor::operator const H248_IndAudSeqSigList &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_IndAudSeqSigList), PInvalidCast);
#endif
  return *(H248_IndAudSeqSigList *)choice;
}


BOOL H248_IndAudSignalsDescriptor::CreateObject()
{
  switch (tag) {
    case e_signal :
      choice = new H248_IndAudSignal();
      return TRUE;
    case e_seqSigList :
      choice = new H248_IndAudSeqSigList();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H248_IndAudSignalsDescriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_IndAudSignalsDescriptor::Class()), PInvalidCast);
#endif
  return new H248_IndAudSignalsDescriptor(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H248_ServiceChangeResult[]={
      {"errorDescriptor",0}
     ,{"serviceChangeResParms",1}
};
#endif
//
// ServiceChangeResult
//

H248_ServiceChangeResult::H248_ServiceChangeResult(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H248_ServiceChangeResult,2
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_ServiceChangeResult::operator H248_ErrorDescriptor &() const
#else
H248_ServiceChangeResult::operator H248_ErrorDescriptor &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_ErrorDescriptor), PInvalidCast);
#endif
  return *(H248_ErrorDescriptor *)choice;
}


H248_ServiceChangeResult::operator const H248_ErrorDescriptor &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_ErrorDescriptor), PInvalidCast);
#endif
  return *(H248_ErrorDescriptor *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_ServiceChangeResult::operator H248_ServiceChangeResParm &() const
#else
H248_ServiceChangeResult::operator H248_ServiceChangeResParm &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_ServiceChangeResParm), PInvalidCast);
#endif
  return *(H248_ServiceChangeResParm *)choice;
}


H248_ServiceChangeResult::operator const H248_ServiceChangeResParm &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_ServiceChangeResParm), PInvalidCast);
#endif
  return *(H248_ServiceChangeResParm *)choice;
}


BOOL H248_ServiceChangeResult::CreateObject()
{
  switch (tag) {
    case e_errorDescriptor :
      choice = new H248_ErrorDescriptor();
      return TRUE;
    case e_serviceChangeResParms :
      choice = new H248_ServiceChangeResParm();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H248_ServiceChangeResult::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_ServiceChangeResult::Class()), PInvalidCast);
#endif
  return new H248_ServiceChangeResult(*this);
}


//
// WildcardField
//

H248_WildcardField::H248_WildcardField(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_OctetString(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1);
}


H248_WildcardField::H248_WildcardField(const char * v)
{
  SetValue(v);
}


H248_WildcardField::H248_WildcardField(const PString & v)
{
  SetValue(v);
}


H248_WildcardField::H248_WildcardField(const PBYTEArray & v)
{
  SetValue(v);
}


H248_WildcardField & H248_WildcardField::operator=(const char * v)
{
  SetValue(v);
  return *this;
}


H248_WildcardField & H248_WildcardField::operator=(const PString & v)
{
  SetValue(v);
  return *this;
}


H248_WildcardField & H248_WildcardField::operator=(const PBYTEArray & v)
{
  SetValue(v);
  return *this;
}


PObject * H248_WildcardField::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_WildcardField::Class()), PInvalidCast);
#endif
  return new H248_WildcardField(*this);
}


//
// TerminationIDList
//

H248_TerminationIDList::H248_TerminationIDList(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H248_TerminationIDList::CreateObject() const
{
  return new H248_TerminationID;
}


H248_TerminationID & H248_TerminationIDList::operator[](PINDEX i) const
{
  return (H248_TerminationID &)array[i];
}


PObject * H248_TerminationIDList::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_TerminationIDList::Class()), PInvalidCast);
#endif
  return new H248_TerminationIDList(*this);
}


#ifndef PASN_NOPRINTON
const static PASN_Names Names_H248_StreamMode[]={
        {"sendOnly",0}
       ,{"recvOnly",1}
       ,{"sendRecv",2}
       ,{"inactive",3}
       ,{"loopBack",4}
};
#endif
//
// StreamMode
//

H248_StreamMode::H248_StreamMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H248_StreamMode,5
#endif
    )
{
}


H248_StreamMode & H248_StreamMode::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H248_StreamMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_StreamMode::Class()), PInvalidCast);
#endif
  return new H248_StreamMode(*this);
}


//
// Name
//

H248_Name::H248_Name(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_OctetString(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 2);
}


H248_Name::H248_Name(const char * v)
{
  SetValue(v);
}


H248_Name::H248_Name(const PString & v)
{
  SetValue(v);
}


H248_Name::H248_Name(const PBYTEArray & v)
{
  SetValue(v);
}


H248_Name & H248_Name::operator=(const char * v)
{
  SetValue(v);
  return *this;
}


H248_Name & H248_Name::operator=(const PString & v)
{
  SetValue(v);
  return *this;
}


H248_Name & H248_Name::operator=(const PBYTEArray & v)
{
  SetValue(v);
  return *this;
}


PObject * H248_Name::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_Name::Class()), PInvalidCast);
#endif
  return new H248_Name(*this);
}


//
// PkgdName
//

H248_PkgdName::H248_PkgdName(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_OctetString(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 4);
}


H248_PkgdName::H248_PkgdName(const char * v)
{
  SetValue(v);
}


H248_PkgdName::H248_PkgdName(const PString & v)
{
  SetValue(v);
}


H248_PkgdName::H248_PkgdName(const PBYTEArray & v)
{
  SetValue(v);
}


H248_PkgdName & H248_PkgdName::operator=(const char * v)
{
  SetValue(v);
  return *this;
}


H248_PkgdName & H248_PkgdName::operator=(const PString & v)
{
  SetValue(v);
  return *this;
}


H248_PkgdName & H248_PkgdName::operator=(const PBYTEArray & v)
{
  SetValue(v);
  return *this;
}


PObject * H248_PkgdName::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_PkgdName::Class()), PInvalidCast);
#endif
  return new H248_PkgdName(*this);
}


#ifndef PASN_NOPRINTON
const static PASN_Names Names_H248_Relation[]={
        {"greaterThan",0}
       ,{"smallerThan",1}
       ,{"unequalTo",2}
};
#endif
//
// Relation
//

H248_Relation::H248_Relation(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H248_Relation,3
#endif
    )
{
}


H248_Relation & H248_Relation::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H248_Relation::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_Relation::Class()), PInvalidCast);
#endif
  return new H248_Relation(*this);
}


//
// PropertyGroup
//

H248_PropertyGroup::H248_PropertyGroup(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H248_PropertyGroup::CreateObject() const
{
  return new H248_PropertyParm;
}


H248_PropertyParm & H248_PropertyGroup::operator[](PINDEX i) const
{
  return (H248_PropertyParm &)array[i];
}


PObject * H248_PropertyGroup::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_PropertyGroup::Class()), PInvalidCast);
#endif
  return new H248_PropertyGroup(*this);
}


#ifndef PASN_NOPRINTON
const static PASN_Names Names_H248_EventBufferControl[]={
        {"off",0}
       ,{"lockStep",1}
};
#endif
//
// EventBufferControl
//

H248_EventBufferControl::H248_EventBufferControl(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 1, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H248_EventBufferControl,2
#endif
    )
{
}


H248_EventBufferControl & H248_EventBufferControl::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H248_EventBufferControl::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_EventBufferControl::Class()), PInvalidCast);
#endif
  return new H248_EventBufferControl(*this);
}


#ifndef PASN_NOPRINTON
const static PASN_Names Names_H248_ServiceState[]={
        {"test",0}
       ,{"outOfSvc",1}
       ,{"inSvc",2}
};
#endif
//
// ServiceState
//

H248_ServiceState::H248_ServiceState(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H248_ServiceState,3
#endif
    )
{
}


H248_ServiceState & H248_ServiceState::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H248_ServiceState::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_ServiceState::Class()), PInvalidCast);
#endif
  return new H248_ServiceState(*this);
}


#ifndef PASN_NOPRINTON
const static PASN_Names Names_H248_MuxType[]={
        {"h221",0}
       ,{"h223",1}
       ,{"h226",2}
       ,{"v76",3}
       ,{"nx64k",4}
};
#endif
//
// MuxType
//

H248_MuxType::H248_MuxType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H248_MuxType,5
#endif
    )
{
}


H248_MuxType & H248_MuxType::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H248_MuxType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_MuxType::Class()), PInvalidCast);
#endif
  return new H248_MuxType(*this);
}


//
// StreamID
//

H248_StreamID::H248_StreamID(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


H248_StreamID & H248_StreamID::operator=(int v)
{
  SetValue(v);
  return *this;
}


H248_StreamID & H248_StreamID::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H248_StreamID::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_StreamID::Class()), PInvalidCast);
#endif
  return new H248_StreamID(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H248_EventDM[]={
      {"digitMapName",0}
     ,{"digitMapValue",1}
};
#endif
//
// EventDM
//

H248_EventDM::H248_EventDM(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H248_EventDM,2
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_EventDM::operator H248_DigitMapName &() const
#else
H248_EventDM::operator H248_DigitMapName &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_DigitMapName), PInvalidCast);
#endif
  return *(H248_DigitMapName *)choice;
}


H248_EventDM::operator const H248_DigitMapName &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_DigitMapName), PInvalidCast);
#endif
  return *(H248_DigitMapName *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_EventDM::operator H248_DigitMapValue &() const
#else
H248_EventDM::operator H248_DigitMapValue &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_DigitMapValue), PInvalidCast);
#endif
  return *(H248_DigitMapValue *)choice;
}


H248_EventDM::operator const H248_DigitMapValue &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_DigitMapValue), PInvalidCast);
#endif
  return *(H248_DigitMapValue *)choice;
}


BOOL H248_EventDM::CreateObject()
{
  switch (tag) {
    case e_digitMapName :
      choice = new H248_DigitMapName();
      return TRUE;
    case e_digitMapValue :
      choice = new H248_DigitMapValue();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H248_EventDM::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_EventDM::Class()), PInvalidCast);
#endif
  return new H248_EventDM(*this);
}


//
// EventBufferDescriptor
//

H248_EventBufferDescriptor::H248_EventBufferDescriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H248_EventBufferDescriptor::CreateObject() const
{
  return new H248_EventSpec;
}


H248_EventSpec & H248_EventBufferDescriptor::operator[](PINDEX i) const
{
  return (H248_EventSpec &)array[i];
}


PObject * H248_EventBufferDescriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_EventBufferDescriptor::Class()), PInvalidCast);
#endif
  return new H248_EventBufferDescriptor(*this);
}


//
// SignalsDescriptor
//

H248_SignalsDescriptor::H248_SignalsDescriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H248_SignalsDescriptor::CreateObject() const
{
  return new H248_SignalRequest;
}


H248_SignalRequest & H248_SignalsDescriptor::operator[](PINDEX i) const
{
  return (H248_SignalRequest &)array[i];
}


PObject * H248_SignalsDescriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_SignalsDescriptor::Class()), PInvalidCast);
#endif
  return new H248_SignalsDescriptor(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H248_SignalRequest[]={
      {"signal",0}
     ,{"seqSigList",1}
};
#endif
//
// SignalRequest
//

H248_SignalRequest::H248_SignalRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H248_SignalRequest,2
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_SignalRequest::operator H248_Signal &() const
#else
H248_SignalRequest::operator H248_Signal &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_Signal), PInvalidCast);
#endif
  return *(H248_Signal *)choice;
}


H248_SignalRequest::operator const H248_Signal &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_Signal), PInvalidCast);
#endif
  return *(H248_Signal *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_SignalRequest::operator H248_SeqSigList &() const
#else
H248_SignalRequest::operator H248_SeqSigList &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_SeqSigList), PInvalidCast);
#endif
  return *(H248_SeqSigList *)choice;
}


H248_SignalRequest::operator const H248_SeqSigList &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_SeqSigList), PInvalidCast);
#endif
  return *(H248_SeqSigList *)choice;
}


BOOL H248_SignalRequest::CreateObject()
{
  switch (tag) {
    case e_signal :
      choice = new H248_Signal();
      return TRUE;
    case e_seqSigList :
      choice = new H248_SeqSigList();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H248_SignalRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_SignalRequest::Class()), PInvalidCast);
#endif
  return new H248_SignalRequest(*this);
}


#ifndef PASN_NOPRINTON
const static PASN_Names Names_H248_SignalType[]={
        {"brief",0}
       ,{"onOff",1}
       ,{"timeOut",2}
};
#endif
//
// SignalType
//

H248_SignalType::H248_SignalType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H248_SignalType,3
#endif
    )
{
}


H248_SignalType & H248_SignalType::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H248_SignalType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_SignalType::Class()), PInvalidCast);
#endif
  return new H248_SignalType(*this);
}


//
// SignalName
//

H248_SignalName::H248_SignalName(unsigned tag, PASN_Object::TagClass tagClass)
  : H248_PkgdName(tag, tagClass)
{
}


H248_SignalName::H248_SignalName(const char * v)
{
  SetValue(v);
}


H248_SignalName::H248_SignalName(const PString & v)
{
  SetValue(v);
}


H248_SignalName::H248_SignalName(const PBYTEArray & v)
{
  SetValue(v);
}


H248_SignalName & H248_SignalName::operator=(const char * v)
{
  SetValue(v);
  return *this;
}


H248_SignalName & H248_SignalName::operator=(const PString & v)
{
  SetValue(v);
  return *this;
}


H248_SignalName & H248_SignalName::operator=(const PBYTEArray & v)
{
  SetValue(v);
  return *this;
}


PObject * H248_SignalName::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_SignalName::Class()), PInvalidCast);
#endif
  return new H248_SignalName(*this);
}


//
// NotifyCompletion
//

H248_NotifyCompletion::H248_NotifyCompletion(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_BitString(tag, tagClass)
{
}


PObject * H248_NotifyCompletion::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_NotifyCompletion::Class()), PInvalidCast);
#endif
  return new H248_NotifyCompletion(*this);
}


//
// RequestID
//

H248_RequestID::H248_RequestID(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 0, 4294967295U);
}


H248_RequestID & H248_RequestID::operator=(int v)
{
  SetValue(v);
  return *this;
}


H248_RequestID & H248_RequestID::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H248_RequestID::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_RequestID::Class()), PInvalidCast);
#endif
  return new H248_RequestID(*this);
}


#ifndef PASN_NOPRINTON
const static PASN_Names Names_H248_ModemType[]={
        {"v18",0}
       ,{"v22",1}
       ,{"v22bis",2}
       ,{"v32",3}
       ,{"v32bis",4}
       ,{"v34",5}
       ,{"v90",6}
       ,{"v91",7}
       ,{"synchISDN",8}
};
#endif
//
// ModemType
//

H248_ModemType::H248_ModemType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 8, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H248_ModemType,9
#endif
    )
{
}


H248_ModemType & H248_ModemType::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H248_ModemType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_ModemType::Class()), PInvalidCast);
#endif
  return new H248_ModemType(*this);
}


//
// DigitMapName
//

H248_DigitMapName::H248_DigitMapName(unsigned tag, PASN_Object::TagClass tagClass)
  : H248_Name(tag, tagClass)
{
}


H248_DigitMapName::H248_DigitMapName(const char * v)
{
  SetValue(v);
}


H248_DigitMapName::H248_DigitMapName(const PString & v)
{
  SetValue(v);
}


H248_DigitMapName::H248_DigitMapName(const PBYTEArray & v)
{
  SetValue(v);
}


H248_DigitMapName & H248_DigitMapName::operator=(const char * v)
{
  SetValue(v);
  return *this;
}


H248_DigitMapName & H248_DigitMapName::operator=(const PString & v)
{
  SetValue(v);
  return *this;
}


H248_DigitMapName & H248_DigitMapName::operator=(const PBYTEArray & v)
{
  SetValue(v);
  return *this;
}


PObject * H248_DigitMapName::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_DigitMapName::Class()), PInvalidCast);
#endif
  return new H248_DigitMapName(*this);
}


//
// DigitMapValue
//

H248_DigitMapValue::H248_DigitMapValue(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 1)
{
  m_startTimer.SetConstraints(PASN_Object::FixedConstraint, 0, 99);
  m_shortTimer.SetConstraints(PASN_Object::FixedConstraint, 0, 99);
  m_longTimer.SetConstraints(PASN_Object::FixedConstraint, 0, 99);
  m_durationTimer.SetConstraints(PASN_Object::FixedConstraint, 0, 99);
}


#ifndef PASN_NOPRINTON
void H248_DigitMapValue::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_startTimer))
    strm << setw(indent+13) << "startTimer = " << setprecision(indent) << m_startTimer << '\n';
  if (HasOptionalField(e_shortTimer))
    strm << setw(indent+13) << "shortTimer = " << setprecision(indent) << m_shortTimer << '\n';
  if (HasOptionalField(e_longTimer))
    strm << setw(indent+12) << "longTimer = " << setprecision(indent) << m_longTimer << '\n';
  strm << setw(indent+15) << "digitMapBody = " << setprecision(indent) << m_digitMapBody << '\n';
  if (HasOptionalField(e_durationTimer))
    strm << setw(indent+16) << "durationTimer = " << setprecision(indent) << m_durationTimer << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_DigitMapValue::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_DigitMapValue), PInvalidCast);
#endif
  const H248_DigitMapValue & other = (const H248_DigitMapValue &)obj;

  Comparison result;

  if ((result = m_startTimer.Compare(other.m_startTimer)) != EqualTo)
    return result;
  if ((result = m_shortTimer.Compare(other.m_shortTimer)) != EqualTo)
    return result;
  if ((result = m_longTimer.Compare(other.m_longTimer)) != EqualTo)
    return result;
  if ((result = m_digitMapBody.Compare(other.m_digitMapBody)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_DigitMapValue::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_startTimer))
    length += m_startTimer.GetObjectLength();
  if (HasOptionalField(e_shortTimer))
    length += m_shortTimer.GetObjectLength();
  if (HasOptionalField(e_longTimer))
    length += m_longTimer.GetObjectLength();
  length += m_digitMapBody.GetObjectLength();
  return length;
}


BOOL H248_DigitMapValue::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_startTimer) && !m_startTimer.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_shortTimer) && !m_shortTimer.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_longTimer) && !m_longTimer.Decode(strm))
    return FALSE;
  if (!m_digitMapBody.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_durationTimer, m_durationTimer))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_DigitMapValue::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_startTimer))
    m_startTimer.Encode(strm);
  if (HasOptionalField(e_shortTimer))
    m_shortTimer.Encode(strm);
  if (HasOptionalField(e_longTimer))
    m_longTimer.Encode(strm);
  m_digitMapBody.Encode(strm);
  KnownExtensionEncode(strm, e_durationTimer, m_durationTimer);

  UnknownExtensionsEncode(strm);
}


PObject * H248_DigitMapValue::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_DigitMapValue::Class()), PInvalidCast);
#endif
  return new H248_DigitMapValue(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H248_ServiceChangeAddress[]={
      {"portNumber",0}
     ,{"ip4Address",1}
     ,{"ip6Address",2}
     ,{"domainName",3}
     ,{"deviceName",4}
     ,{"mtpAddress",5}
};
#endif
//
// ServiceChangeAddress
//

H248_ServiceChangeAddress::H248_ServiceChangeAddress(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 6, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H248_ServiceChangeAddress,6
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_ServiceChangeAddress::operator H248_IP4Address &() const
#else
H248_ServiceChangeAddress::operator H248_IP4Address &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_IP4Address), PInvalidCast);
#endif
  return *(H248_IP4Address *)choice;
}


H248_ServiceChangeAddress::operator const H248_IP4Address &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_IP4Address), PInvalidCast);
#endif
  return *(H248_IP4Address *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_ServiceChangeAddress::operator H248_IP6Address &() const
#else
H248_ServiceChangeAddress::operator H248_IP6Address &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_IP6Address), PInvalidCast);
#endif
  return *(H248_IP6Address *)choice;
}


H248_ServiceChangeAddress::operator const H248_IP6Address &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_IP6Address), PInvalidCast);
#endif
  return *(H248_IP6Address *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_ServiceChangeAddress::operator H248_DomainName &() const
#else
H248_ServiceChangeAddress::operator H248_DomainName &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_DomainName), PInvalidCast);
#endif
  return *(H248_DomainName *)choice;
}


H248_ServiceChangeAddress::operator const H248_DomainName &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_DomainName), PInvalidCast);
#endif
  return *(H248_DomainName *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_ServiceChangeAddress::operator H248_PathName &() const
#else
H248_ServiceChangeAddress::operator H248_PathName &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_PathName), PInvalidCast);
#endif
  return *(H248_PathName *)choice;
}


H248_ServiceChangeAddress::operator const H248_PathName &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_PathName), PInvalidCast);
#endif
  return *(H248_PathName *)choice;
}


BOOL H248_ServiceChangeAddress::CreateObject()
{
  switch (tag) {
    case e_portNumber :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
      return TRUE;
    case e_ip4Address :
      choice = new H248_IP4Address();
      return TRUE;
    case e_ip6Address :
      choice = new H248_IP6Address();
      return TRUE;
    case e_domainName :
      choice = new H248_DomainName();
      return TRUE;
    case e_deviceName :
      choice = new H248_PathName();
      return TRUE;
    case e_mtpAddress :
      choice = new PASN_OctetString();
      choice->SetConstraints(PASN_Object::FixedConstraint, 2, 4);
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H248_ServiceChangeAddress::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_ServiceChangeAddress::Class()), PInvalidCast);
#endif
  return new H248_ServiceChangeAddress(*this);
}


#ifndef PASN_NOPRINTON
const static PASN_Names Names_H248_ServiceChangeMethod[]={
        {"failover",0}
       ,{"forced",1}
       ,{"graceful",2}
       ,{"restart",3}
       ,{"disconnected",4}
       ,{"handOff",5}
};
#endif
//
// ServiceChangeMethod
//

H248_ServiceChangeMethod::H248_ServiceChangeMethod(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 5, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H248_ServiceChangeMethod,6
#endif
    )
{
}


H248_ServiceChangeMethod & H248_ServiceChangeMethod::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H248_ServiceChangeMethod::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_ServiceChangeMethod::Class()), PInvalidCast);
#endif
  return new H248_ServiceChangeMethod(*this);
}


//
// ServiceChangeProfile
//

H248_ServiceChangeProfile::H248_ServiceChangeProfile(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
  m_profileName.SetConstraints(PASN_Object::FixedConstraint, 1, 67);
}


#ifndef PASN_NOPRINTON
void H248_ServiceChangeProfile::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+14) << "profileName = " << setprecision(indent) << m_profileName << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_ServiceChangeProfile::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_ServiceChangeProfile), PInvalidCast);
#endif
  const H248_ServiceChangeProfile & other = (const H248_ServiceChangeProfile &)obj;

  Comparison result;

  if ((result = m_profileName.Compare(other.m_profileName)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_ServiceChangeProfile::GetDataLength() const
{
  PINDEX length = 0;
  length += m_profileName.GetObjectLength();
  return length;
}


BOOL H248_ServiceChangeProfile::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_profileName.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_ServiceChangeProfile::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_profileName.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_ServiceChangeProfile::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_ServiceChangeProfile::Class()), PInvalidCast);
#endif
  return new H248_ServiceChangeProfile(*this);
}


//
// PackagesDescriptor
//

H248_PackagesDescriptor::H248_PackagesDescriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H248_PackagesDescriptor::CreateObject() const
{
  return new H248_PackagesItem;
}


H248_PackagesItem & H248_PackagesDescriptor::operator[](PINDEX i) const
{
  return (H248_PackagesItem &)array[i];
}


PObject * H248_PackagesDescriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_PackagesDescriptor::Class()), PInvalidCast);
#endif
  return new H248_PackagesDescriptor(*this);
}


//
// PackagesItem
//

H248_PackagesItem::H248_PackagesItem(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_packageVersion.SetConstraints(PASN_Object::FixedConstraint, 0, 99);
}


#ifndef PASN_NOPRINTON
void H248_PackagesItem::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+14) << "packageName = " << setprecision(indent) << m_packageName << '\n';
  strm << setw(indent+17) << "packageVersion = " << setprecision(indent) << m_packageVersion << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_PackagesItem::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_PackagesItem), PInvalidCast);
#endif
  const H248_PackagesItem & other = (const H248_PackagesItem &)obj;

  Comparison result;

  if ((result = m_packageName.Compare(other.m_packageName)) != EqualTo)
    return result;
  if ((result = m_packageVersion.Compare(other.m_packageVersion)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_PackagesItem::GetDataLength() const
{
  PINDEX length = 0;
  length += m_packageName.GetObjectLength();
  length += m_packageVersion.GetObjectLength();
  return length;
}


BOOL H248_PackagesItem::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_packageName.Decode(strm))
    return FALSE;
  if (!m_packageVersion.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_PackagesItem::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_packageName.Encode(strm);
  m_packageVersion.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_PackagesItem::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_PackagesItem::Class()), PInvalidCast);
#endif
  return new H248_PackagesItem(*this);
}


//
// StatisticsDescriptor
//

H248_StatisticsDescriptor::H248_StatisticsDescriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H248_StatisticsDescriptor::CreateObject() const
{
  return new H248_StatisticsParameter;
}


H248_StatisticsParameter & H248_StatisticsDescriptor::operator[](PINDEX i) const
{
  return (H248_StatisticsParameter &)array[i];
}


PObject * H248_StatisticsDescriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_StatisticsDescriptor::Class()), PInvalidCast);
#endif
  return new H248_StatisticsDescriptor(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H248_NonStandardIdentifier[]={
      {"object",0}
     ,{"h221NonStandard",1}
     ,{"experimental",2}
};
#endif
//
// NonStandardIdentifier
//

H248_NonStandardIdentifier::H248_NonStandardIdentifier(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H248_NonStandardIdentifier,3
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_NonStandardIdentifier::operator H248_H221NonStandard &() const
#else
H248_NonStandardIdentifier::operator H248_H221NonStandard &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_H221NonStandard), PInvalidCast);
#endif
  return *(H248_H221NonStandard *)choice;
}


H248_NonStandardIdentifier::operator const H248_H221NonStandard &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_H221NonStandard), PInvalidCast);
#endif
  return *(H248_H221NonStandard *)choice;
}


BOOL H248_NonStandardIdentifier::CreateObject()
{
  switch (tag) {
    case e_object :
      choice = new PASN_ObjectId();
      return TRUE;
    case e_h221NonStandard :
      choice = new H248_H221NonStandard();
      return TRUE;
    case e_experimental :
      choice = new PASN_IA5String();
      choice->SetConstraints(PASN_Object::FixedConstraint, 8);
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H248_NonStandardIdentifier::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_NonStandardIdentifier::Class()), PInvalidCast);
#endif
  return new H248_NonStandardIdentifier(*this);
}


//
// H221NonStandard
//

H248_H221NonStandard::H248_H221NonStandard(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_t35CountryCode1.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
  m_t35CountryCode2.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
  m_t35Extension.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
  m_manufacturerCode.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void H248_H221NonStandard::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+18) << "t35CountryCode1 = " << setprecision(indent) << m_t35CountryCode1 << '\n';
  strm << setw(indent+18) << "t35CountryCode2 = " << setprecision(indent) << m_t35CountryCode2 << '\n';
  strm << setw(indent+15) << "t35Extension = " << setprecision(indent) << m_t35Extension << '\n';
  strm << setw(indent+19) << "manufacturerCode = " << setprecision(indent) << m_manufacturerCode << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_H221NonStandard::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_H221NonStandard), PInvalidCast);
#endif
  const H248_H221NonStandard & other = (const H248_H221NonStandard &)obj;

  Comparison result;

  if ((result = m_t35CountryCode1.Compare(other.m_t35CountryCode1)) != EqualTo)
    return result;
  if ((result = m_t35CountryCode2.Compare(other.m_t35CountryCode2)) != EqualTo)
    return result;
  if ((result = m_t35Extension.Compare(other.m_t35Extension)) != EqualTo)
    return result;
  if ((result = m_manufacturerCode.Compare(other.m_manufacturerCode)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_H221NonStandard::GetDataLength() const
{
  PINDEX length = 0;
  length += m_t35CountryCode1.GetObjectLength();
  length += m_t35CountryCode2.GetObjectLength();
  length += m_t35Extension.GetObjectLength();
  length += m_manufacturerCode.GetObjectLength();
  return length;
}


BOOL H248_H221NonStandard::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_t35CountryCode1.Decode(strm))
    return FALSE;
  if (!m_t35CountryCode2.Decode(strm))
    return FALSE;
  if (!m_t35Extension.Decode(strm))
    return FALSE;
  if (!m_manufacturerCode.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_H221NonStandard::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_t35CountryCode1.Encode(strm);
  m_t35CountryCode2.Encode(strm);
  m_t35Extension.Encode(strm);
  m_manufacturerCode.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_H221NonStandard::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_H221NonStandard::Class()), PInvalidCast);
#endif
  return new H248_H221NonStandard(*this);
}


//
// TimeNotation
//

H248_TimeNotation::H248_TimeNotation(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
  m_date.SetConstraints(PASN_Object::FixedConstraint, 8);
  m_time.SetConstraints(PASN_Object::FixedConstraint, 8);
}


#ifndef PASN_NOPRINTON
void H248_TimeNotation::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+7) << "date = " << setprecision(indent) << m_date << '\n';
  strm << setw(indent+7) << "time = " << setprecision(indent) << m_time << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_TimeNotation::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_TimeNotation), PInvalidCast);
#endif
  const H248_TimeNotation & other = (const H248_TimeNotation &)obj;

  Comparison result;

  if ((result = m_date.Compare(other.m_date)) != EqualTo)
    return result;
  if ((result = m_time.Compare(other.m_time)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_TimeNotation::GetDataLength() const
{
  PINDEX length = 0;
  length += m_date.GetObjectLength();
  length += m_time.GetObjectLength();
  return length;
}


BOOL H248_TimeNotation::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_date.Decode(strm))
    return FALSE;
  if (!m_time.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_TimeNotation::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_date.Encode(strm);
  m_time.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_TimeNotation::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_TimeNotation::Class()), PInvalidCast);
#endif
  return new H248_TimeNotation(*this);
}


//
// Value
//

H248_Value::H248_Value(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H248_Value::CreateObject() const
{
  return new PASN_OctetString;
}


PASN_OctetString & H248_Value::operator[](PINDEX i) const
{
  return (PASN_OctetString &)array[i];
}


PObject * H248_Value::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_Value::Class()), PInvalidCast);
#endif
  return new H248_Value(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H248_Message_messageBody[]={
      {"messageError",0}
     ,{"transactions",1}
};
#endif
//
// Message_messageBody
//

H248_Message_messageBody::H248_Message_messageBody(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H248_Message_messageBody,2
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_Message_messageBody::operator H248_ErrorDescriptor &() const
#else
H248_Message_messageBody::operator H248_ErrorDescriptor &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_ErrorDescriptor), PInvalidCast);
#endif
  return *(H248_ErrorDescriptor *)choice;
}


H248_Message_messageBody::operator const H248_ErrorDescriptor &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_ErrorDescriptor), PInvalidCast);
#endif
  return *(H248_ErrorDescriptor *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_Message_messageBody::operator H248_ArrayOf_Transaction &() const
#else
H248_Message_messageBody::operator H248_ArrayOf_Transaction &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_ArrayOf_Transaction), PInvalidCast);
#endif
  return *(H248_ArrayOf_Transaction *)choice;
}


H248_Message_messageBody::operator const H248_ArrayOf_Transaction &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_ArrayOf_Transaction), PInvalidCast);
#endif
  return *(H248_ArrayOf_Transaction *)choice;
}


BOOL H248_Message_messageBody::CreateObject()
{
  switch (tag) {
    case e_messageError :
      choice = new H248_ErrorDescriptor();
      return TRUE;
    case e_transactions :
      choice = new H248_ArrayOf_Transaction();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H248_Message_messageBody::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_Message_messageBody::Class()), PInvalidCast);
#endif
  return new H248_Message_messageBody(*this);
}


//
// ArrayOf_ActionRequest
//

H248_ArrayOf_ActionRequest::H248_ArrayOf_ActionRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H248_ArrayOf_ActionRequest::CreateObject() const
{
  return new H248_ActionRequest;
}


H248_ActionRequest & H248_ArrayOf_ActionRequest::operator[](PINDEX i) const
{
  return (H248_ActionRequest &)array[i];
}


PObject * H248_ArrayOf_ActionRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_ArrayOf_ActionRequest::Class()), PInvalidCast);
#endif
  return new H248_ArrayOf_ActionRequest(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H248_TransactionReply_transactionResult[]={
      {"transactionError",0}
     ,{"actionReplies",1}
};
#endif
//
// TransactionReply_transactionResult
//

H248_TransactionReply_transactionResult::H248_TransactionReply_transactionResult(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H248_TransactionReply_transactionResult,2
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_TransactionReply_transactionResult::operator H248_ErrorDescriptor &() const
#else
H248_TransactionReply_transactionResult::operator H248_ErrorDescriptor &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_ErrorDescriptor), PInvalidCast);
#endif
  return *(H248_ErrorDescriptor *)choice;
}


H248_TransactionReply_transactionResult::operator const H248_ErrorDescriptor &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_ErrorDescriptor), PInvalidCast);
#endif
  return *(H248_ErrorDescriptor *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_TransactionReply_transactionResult::operator H248_ArrayOf_ActionReply &() const
#else
H248_TransactionReply_transactionResult::operator H248_ArrayOf_ActionReply &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_ArrayOf_ActionReply), PInvalidCast);
#endif
  return *(H248_ArrayOf_ActionReply *)choice;
}


H248_TransactionReply_transactionResult::operator const H248_ArrayOf_ActionReply &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_ArrayOf_ActionReply), PInvalidCast);
#endif
  return *(H248_ArrayOf_ActionReply *)choice;
}


BOOL H248_TransactionReply_transactionResult::CreateObject()
{
  switch (tag) {
    case e_transactionError :
      choice = new H248_ErrorDescriptor();
      return TRUE;
    case e_actionReplies :
      choice = new H248_ArrayOf_ActionReply();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H248_TransactionReply_transactionResult::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_TransactionReply_transactionResult::Class()), PInvalidCast);
#endif
  return new H248_TransactionReply_transactionResult(*this);
}


//
// ArrayOf_CommandRequest
//

H248_ArrayOf_CommandRequest::H248_ArrayOf_CommandRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H248_ArrayOf_CommandRequest::CreateObject() const
{
  return new H248_CommandRequest;
}


H248_CommandRequest & H248_ArrayOf_CommandRequest::operator[](PINDEX i) const
{
  return (H248_CommandRequest &)array[i];
}


PObject * H248_ArrayOf_CommandRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_ArrayOf_CommandRequest::Class()), PInvalidCast);
#endif
  return new H248_ArrayOf_CommandRequest(*this);
}


//
// ArrayOf_CommandReply
//

H248_ArrayOf_CommandReply::H248_ArrayOf_CommandReply(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H248_ArrayOf_CommandReply::CreateObject() const
{
  return new H248_CommandReply;
}


H248_CommandReply & H248_ArrayOf_CommandReply::operator[](PINDEX i) const
{
  return (H248_CommandReply &)array[i];
}


PObject * H248_ArrayOf_CommandReply::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_ArrayOf_CommandReply::Class()), PInvalidCast);
#endif
  return new H248_ArrayOf_CommandReply(*this);
}


//
// ArrayOf_TopologyRequest
//

H248_ArrayOf_TopologyRequest::H248_ArrayOf_TopologyRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H248_ArrayOf_TopologyRequest::CreateObject() const
{
  return new H248_TopologyRequest;
}


H248_TopologyRequest & H248_ArrayOf_TopologyRequest::operator[](PINDEX i) const
{
  return (H248_TopologyRequest &)array[i];
}


PObject * H248_ArrayOf_TopologyRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_ArrayOf_TopologyRequest::Class()), PInvalidCast);
#endif
  return new H248_ArrayOf_TopologyRequest(*this);
}


#ifndef PASN_NOPRINTON
const static PASN_Names Names_H248_TopologyRequest_topologyDirection[]={
        {"bothway",0}
       ,{"isolate",1}
       ,{"oneway",2}
};
#endif
//
// TopologyRequest_topologyDirection
//

H248_TopologyRequest_topologyDirection::H248_TopologyRequest_topologyDirection(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H248_TopologyRequest_topologyDirection,3
#endif
    )
{
}


H248_TopologyRequest_topologyDirection & H248_TopologyRequest_topologyDirection::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H248_TopologyRequest_topologyDirection::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_TopologyRequest_topologyDirection::Class()), PInvalidCast);
#endif
  return new H248_TopologyRequest_topologyDirection(*this);
}


//
// ArrayOf_AmmDescriptor
//

H248_ArrayOf_AmmDescriptor::H248_ArrayOf_AmmDescriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H248_ArrayOf_AmmDescriptor::CreateObject() const
{
  return new H248_AmmDescriptor;
}


H248_AmmDescriptor & H248_ArrayOf_AmmDescriptor::operator[](PINDEX i) const
{
  return (H248_AmmDescriptor &)array[i];
}


PObject * H248_ArrayOf_AmmDescriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_ArrayOf_AmmDescriptor::Class()), PInvalidCast);
#endif
  return new H248_ArrayOf_AmmDescriptor(*this);
}


//
// ArrayOf_IndAuditParameter
//

H248_ArrayOf_IndAuditParameter::H248_ArrayOf_IndAuditParameter(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H248_ArrayOf_IndAuditParameter::CreateObject() const
{
  return new H248_IndAuditParameter;
}


H248_IndAuditParameter & H248_ArrayOf_IndAuditParameter::operator[](PINDEX i) const
{
  return (H248_IndAuditParameter &)array[i];
}


PObject * H248_ArrayOf_IndAuditParameter::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_ArrayOf_IndAuditParameter::Class()), PInvalidCast);
#endif
  return new H248_ArrayOf_IndAuditParameter(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H248_IndAudMediaDescriptor_streams[]={
      {"oneStream",0}
     ,{"multiStream",1}
};
#endif
//
// IndAudMediaDescriptor_streams
//

H248_IndAudMediaDescriptor_streams::H248_IndAudMediaDescriptor_streams(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H248_IndAudMediaDescriptor_streams,2
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_IndAudMediaDescriptor_streams::operator H248_IndAudStreamParms &() const
#else
H248_IndAudMediaDescriptor_streams::operator H248_IndAudStreamParms &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_IndAudStreamParms), PInvalidCast);
#endif
  return *(H248_IndAudStreamParms *)choice;
}


H248_IndAudMediaDescriptor_streams::operator const H248_IndAudStreamParms &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_IndAudStreamParms), PInvalidCast);
#endif
  return *(H248_IndAudStreamParms *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_IndAudMediaDescriptor_streams::operator H248_ArrayOf_IndAudStreamDescriptor &() const
#else
H248_IndAudMediaDescriptor_streams::operator H248_ArrayOf_IndAudStreamDescriptor &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_ArrayOf_IndAudStreamDescriptor), PInvalidCast);
#endif
  return *(H248_ArrayOf_IndAudStreamDescriptor *)choice;
}


H248_IndAudMediaDescriptor_streams::operator const H248_ArrayOf_IndAudStreamDescriptor &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_ArrayOf_IndAudStreamDescriptor), PInvalidCast);
#endif
  return *(H248_ArrayOf_IndAudStreamDescriptor *)choice;
}


BOOL H248_IndAudMediaDescriptor_streams::CreateObject()
{
  switch (tag) {
    case e_oneStream :
      choice = new H248_IndAudStreamParms();
      return TRUE;
    case e_multiStream :
      choice = new H248_ArrayOf_IndAudStreamDescriptor();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H248_IndAudMediaDescriptor_streams::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_IndAudMediaDescriptor_streams::Class()), PInvalidCast);
#endif
  return new H248_IndAudMediaDescriptor_streams(*this);
}


//
// ArrayOf_IndAudPropertyParm
//

H248_ArrayOf_IndAudPropertyParm::H248_ArrayOf_IndAudPropertyParm(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H248_ArrayOf_IndAudPropertyParm::CreateObject() const
{
  return new H248_IndAudPropertyParm;
}


H248_IndAudPropertyParm & H248_ArrayOf_IndAudPropertyParm::operator[](PINDEX i) const
{
  return (H248_IndAudPropertyParm &)array[i];
}


PObject * H248_ArrayOf_IndAudPropertyParm::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_ArrayOf_IndAudPropertyParm::Class()), PInvalidCast);
#endif
  return new H248_ArrayOf_IndAudPropertyParm(*this);
}


//
// ArrayOf_ObservedEvent
//

H248_ArrayOf_ObservedEvent::H248_ArrayOf_ObservedEvent(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H248_ArrayOf_ObservedEvent::CreateObject() const
{
  return new H248_ObservedEvent;
}


H248_ObservedEvent & H248_ArrayOf_ObservedEvent::operator[](PINDEX i) const
{
  return (H248_ObservedEvent &)array[i];
}


PObject * H248_ArrayOf_ObservedEvent::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_ArrayOf_ObservedEvent::Class()), PInvalidCast);
#endif
  return new H248_ArrayOf_ObservedEvent(*this);
}


//
// ArrayOf_EventParameter
//

H248_ArrayOf_EventParameter::H248_ArrayOf_EventParameter(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H248_ArrayOf_EventParameter::CreateObject() const
{
  return new H248_EventParameter;
}


H248_EventParameter & H248_ArrayOf_EventParameter::operator[](PINDEX i) const
{
  return (H248_EventParameter &)array[i];
}


PObject * H248_ArrayOf_EventParameter::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_ArrayOf_EventParameter::Class()), PInvalidCast);
#endif
  return new H248_ArrayOf_EventParameter(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H248_EventParameter_extraInfo[]={
      {"relation",0}
     ,{"range",1}
     ,{"sublist",2}
};
#endif
//
// EventParameter_extraInfo
//

H248_EventParameter_extraInfo::H248_EventParameter_extraInfo(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H248_EventParameter_extraInfo,3
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_EventParameter_extraInfo::operator H248_Relation &() const
#else
H248_EventParameter_extraInfo::operator H248_Relation &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_Relation), PInvalidCast);
#endif
  return *(H248_Relation *)choice;
}


H248_EventParameter_extraInfo::operator const H248_Relation &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_Relation), PInvalidCast);
#endif
  return *(H248_Relation *)choice;
}


BOOL H248_EventParameter_extraInfo::CreateObject()
{
  switch (tag) {
    case e_relation :
      choice = new H248_Relation();
      return TRUE;
    case e_range :
    case e_sublist :
      choice = new PASN_Boolean();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H248_EventParameter_extraInfo::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_EventParameter_extraInfo::Class()), PInvalidCast);
#endif
  return new H248_EventParameter_extraInfo(*this);
}


//
// ArrayOf_WildcardField
//

H248_ArrayOf_WildcardField::H248_ArrayOf_WildcardField(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H248_ArrayOf_WildcardField::CreateObject() const
{
  return new H248_WildcardField;
}


H248_WildcardField & H248_ArrayOf_WildcardField::operator[](PINDEX i) const
{
  return (H248_WildcardField &)array[i];
}


PObject * H248_ArrayOf_WildcardField::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_ArrayOf_WildcardField::Class()), PInvalidCast);
#endif
  return new H248_ArrayOf_WildcardField(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H248_MediaDescriptor_streams[]={
      {"oneStream",0}
     ,{"multiStream",1}
};
#endif
//
// MediaDescriptor_streams
//

H248_MediaDescriptor_streams::H248_MediaDescriptor_streams(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H248_MediaDescriptor_streams,2
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_MediaDescriptor_streams::operator H248_StreamParms &() const
#else
H248_MediaDescriptor_streams::operator H248_StreamParms &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_StreamParms), PInvalidCast);
#endif
  return *(H248_StreamParms *)choice;
}


H248_MediaDescriptor_streams::operator const H248_StreamParms &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_StreamParms), PInvalidCast);
#endif
  return *(H248_StreamParms *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_MediaDescriptor_streams::operator H248_ArrayOf_StreamDescriptor &() const
#else
H248_MediaDescriptor_streams::operator H248_ArrayOf_StreamDescriptor &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_ArrayOf_StreamDescriptor), PInvalidCast);
#endif
  return *(H248_ArrayOf_StreamDescriptor *)choice;
}


H248_MediaDescriptor_streams::operator const H248_ArrayOf_StreamDescriptor &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_ArrayOf_StreamDescriptor), PInvalidCast);
#endif
  return *(H248_ArrayOf_StreamDescriptor *)choice;
}


BOOL H248_MediaDescriptor_streams::CreateObject()
{
  switch (tag) {
    case e_oneStream :
      choice = new H248_StreamParms();
      return TRUE;
    case e_multiStream :
      choice = new H248_ArrayOf_StreamDescriptor();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H248_MediaDescriptor_streams::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_MediaDescriptor_streams::Class()), PInvalidCast);
#endif
  return new H248_MediaDescriptor_streams(*this);
}


//
// ArrayOf_PropertyParm
//

H248_ArrayOf_PropertyParm::H248_ArrayOf_PropertyParm(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H248_ArrayOf_PropertyParm::CreateObject() const
{
  return new H248_PropertyParm;
}


H248_PropertyParm & H248_ArrayOf_PropertyParm::operator[](PINDEX i) const
{
  return (H248_PropertyParm &)array[i];
}


PObject * H248_ArrayOf_PropertyParm::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_ArrayOf_PropertyParm::Class()), PInvalidCast);
#endif
  return new H248_ArrayOf_PropertyParm(*this);
}


//
// ArrayOf_PASN_OctetString
//

H248_ArrayOf_PASN_OctetString::H248_ArrayOf_PASN_OctetString(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H248_ArrayOf_PASN_OctetString::CreateObject() const
{
  return new PASN_OctetString;
}


PASN_OctetString & H248_ArrayOf_PASN_OctetString::operator[](PINDEX i) const
{
  return (PASN_OctetString &)array[i];
}


PObject * H248_ArrayOf_PASN_OctetString::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_ArrayOf_PASN_OctetString::Class()), PInvalidCast);
#endif
  return new H248_ArrayOf_PASN_OctetString(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H248_PropertyParm_extraInfo[]={
      {"relation",0}
     ,{"range",1}
     ,{"sublist",2}
};
#endif
//
// PropertyParm_extraInfo
//

H248_PropertyParm_extraInfo::H248_PropertyParm_extraInfo(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H248_PropertyParm_extraInfo,3
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_PropertyParm_extraInfo::operator H248_Relation &() const
#else
H248_PropertyParm_extraInfo::operator H248_Relation &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_Relation), PInvalidCast);
#endif
  return *(H248_Relation *)choice;
}


H248_PropertyParm_extraInfo::operator const H248_Relation &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_Relation), PInvalidCast);
#endif
  return *(H248_Relation *)choice;
}


BOOL H248_PropertyParm_extraInfo::CreateObject()
{
  switch (tag) {
    case e_relation :
      choice = new H248_Relation();
      return TRUE;
    case e_range :
    case e_sublist :
      choice = new PASN_Boolean();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H248_PropertyParm_extraInfo::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_PropertyParm_extraInfo::Class()), PInvalidCast);
#endif
  return new H248_PropertyParm_extraInfo(*this);
}


//
// ArrayOf_PropertyGroup
//

H248_ArrayOf_PropertyGroup::H248_ArrayOf_PropertyGroup(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H248_ArrayOf_PropertyGroup::CreateObject() const
{
  return new H248_PropertyGroup;
}


H248_PropertyGroup & H248_ArrayOf_PropertyGroup::operator[](PINDEX i) const
{
  return (H248_PropertyGroup &)array[i];
}


PObject * H248_ArrayOf_PropertyGroup::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_ArrayOf_PropertyGroup::Class()), PInvalidCast);
#endif
  return new H248_ArrayOf_PropertyGroup(*this);
}


//
// ArrayOf_TerminationID
//

H248_ArrayOf_TerminationID::H248_ArrayOf_TerminationID(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H248_ArrayOf_TerminationID::CreateObject() const
{
  return new H248_TerminationID;
}


H248_TerminationID & H248_ArrayOf_TerminationID::operator[](PINDEX i) const
{
  return (H248_TerminationID &)array[i];
}


PObject * H248_ArrayOf_TerminationID::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_ArrayOf_TerminationID::Class()), PInvalidCast);
#endif
  return new H248_ArrayOf_TerminationID(*this);
}


//
// ArrayOf_RequestedEvent
//

H248_ArrayOf_RequestedEvent::H248_ArrayOf_RequestedEvent(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H248_ArrayOf_RequestedEvent::CreateObject() const
{
  return new H248_RequestedEvent;
}


H248_RequestedEvent & H248_ArrayOf_RequestedEvent::operator[](PINDEX i) const
{
  return (H248_RequestedEvent &)array[i];
}


PObject * H248_ArrayOf_RequestedEvent::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_ArrayOf_RequestedEvent::Class()), PInvalidCast);
#endif
  return new H248_ArrayOf_RequestedEvent(*this);
}


//
// ArrayOf_SecondRequestedEvent
//

H248_ArrayOf_SecondRequestedEvent::H248_ArrayOf_SecondRequestedEvent(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H248_ArrayOf_SecondRequestedEvent::CreateObject() const
{
  return new H248_SecondRequestedEvent;
}


H248_SecondRequestedEvent & H248_ArrayOf_SecondRequestedEvent::operator[](PINDEX i) const
{
  return (H248_SecondRequestedEvent &)array[i];
}


PObject * H248_ArrayOf_SecondRequestedEvent::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_ArrayOf_SecondRequestedEvent::Class()), PInvalidCast);
#endif
  return new H248_ArrayOf_SecondRequestedEvent(*this);
}


//
// ArrayOf_Signal
//

H248_ArrayOf_Signal::H248_ArrayOf_Signal(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H248_ArrayOf_Signal::CreateObject() const
{
  return new H248_Signal;
}


H248_Signal & H248_ArrayOf_Signal::operator[](PINDEX i) const
{
  return (H248_Signal &)array[i];
}


PObject * H248_ArrayOf_Signal::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_ArrayOf_Signal::Class()), PInvalidCast);
#endif
  return new H248_ArrayOf_Signal(*this);
}


//
// ArrayOf_SigParameter
//

H248_ArrayOf_SigParameter::H248_ArrayOf_SigParameter(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H248_ArrayOf_SigParameter::CreateObject() const
{
  return new H248_SigParameter;
}


H248_SigParameter & H248_ArrayOf_SigParameter::operator[](PINDEX i) const
{
  return (H248_SigParameter &)array[i];
}


PObject * H248_ArrayOf_SigParameter::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_ArrayOf_SigParameter::Class()), PInvalidCast);
#endif
  return new H248_ArrayOf_SigParameter(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H248_SigParameter_extraInfo[]={
      {"relation",0}
     ,{"range",1}
     ,{"sublist",2}
};
#endif
//
// SigParameter_extraInfo
//

H248_SigParameter_extraInfo::H248_SigParameter_extraInfo(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H248_SigParameter_extraInfo,3
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H248_SigParameter_extraInfo::operator H248_Relation &() const
#else
H248_SigParameter_extraInfo::operator H248_Relation &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_Relation), PInvalidCast);
#endif
  return *(H248_Relation *)choice;
}


H248_SigParameter_extraInfo::operator const H248_Relation &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H248_Relation), PInvalidCast);
#endif
  return *(H248_Relation *)choice;
}


BOOL H248_SigParameter_extraInfo::CreateObject()
{
  switch (tag) {
    case e_relation :
      choice = new H248_Relation();
      return TRUE;
    case e_range :
    case e_sublist :
      choice = new PASN_Boolean();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H248_SigParameter_extraInfo::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_SigParameter_extraInfo::Class()), PInvalidCast);
#endif
  return new H248_SigParameter_extraInfo(*this);
}


//
// ArrayOf_ModemType
//

H248_ArrayOf_ModemType::H248_ArrayOf_ModemType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H248_ArrayOf_ModemType::CreateObject() const
{
  return new H248_ModemType;
}


H248_ModemType & H248_ArrayOf_ModemType::operator[](PINDEX i) const
{
  return (H248_ModemType &)array[i];
}


PObject * H248_ArrayOf_ModemType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_ArrayOf_ModemType::Class()), PInvalidCast);
#endif
  return new H248_ArrayOf_ModemType(*this);
}


//
// ArrayOf_Transaction
//

H248_ArrayOf_Transaction::H248_ArrayOf_Transaction(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H248_ArrayOf_Transaction::CreateObject() const
{
  return new H248_Transaction;
}


H248_Transaction & H248_ArrayOf_Transaction::operator[](PINDEX i) const
{
  return (H248_Transaction &)array[i];
}


PObject * H248_ArrayOf_Transaction::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_ArrayOf_Transaction::Class()), PInvalidCast);
#endif
  return new H248_ArrayOf_Transaction(*this);
}


//
// ArrayOf_ActionReply
//

H248_ArrayOf_ActionReply::H248_ArrayOf_ActionReply(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H248_ArrayOf_ActionReply::CreateObject() const
{
  return new H248_ActionReply;
}


H248_ActionReply & H248_ArrayOf_ActionReply::operator[](PINDEX i) const
{
  return (H248_ActionReply &)array[i];
}


PObject * H248_ArrayOf_ActionReply::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_ArrayOf_ActionReply::Class()), PInvalidCast);
#endif
  return new H248_ArrayOf_ActionReply(*this);
}


//
// ArrayOf_IndAudStreamDescriptor
//

H248_ArrayOf_IndAudStreamDescriptor::H248_ArrayOf_IndAudStreamDescriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H248_ArrayOf_IndAudStreamDescriptor::CreateObject() const
{
  return new H248_IndAudStreamDescriptor;
}


H248_IndAudStreamDescriptor & H248_ArrayOf_IndAudStreamDescriptor::operator[](PINDEX i) const
{
  return (H248_IndAudStreamDescriptor &)array[i];
}


PObject * H248_ArrayOf_IndAudStreamDescriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_ArrayOf_IndAudStreamDescriptor::Class()), PInvalidCast);
#endif
  return new H248_ArrayOf_IndAudStreamDescriptor(*this);
}


//
// ArrayOf_StreamDescriptor
//

H248_ArrayOf_StreamDescriptor::H248_ArrayOf_StreamDescriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H248_ArrayOf_StreamDescriptor::CreateObject() const
{
  return new H248_StreamDescriptor;
}


H248_StreamDescriptor & H248_ArrayOf_StreamDescriptor::operator[](PINDEX i) const
{
  return (H248_StreamDescriptor &)array[i];
}


PObject * H248_ArrayOf_StreamDescriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_ArrayOf_StreamDescriptor::Class()), PInvalidCast);
#endif
  return new H248_ArrayOf_StreamDescriptor(*this);
}


//
// AuthenticationHeader
//

H248_AuthenticationHeader::H248_AuthenticationHeader(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_AuthenticationHeader::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "secParmIndex = " << setprecision(indent) << m_secParmIndex << '\n';
  strm << setw(indent+9) << "seqNum = " << setprecision(indent) << m_seqNum << '\n';
  strm << setw(indent+5) << "ad = " << setprecision(indent) << m_ad << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_AuthenticationHeader::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_AuthenticationHeader), PInvalidCast);
#endif
  const H248_AuthenticationHeader & other = (const H248_AuthenticationHeader &)obj;

  Comparison result;

  if ((result = m_secParmIndex.Compare(other.m_secParmIndex)) != EqualTo)
    return result;
  if ((result = m_seqNum.Compare(other.m_seqNum)) != EqualTo)
    return result;
  if ((result = m_ad.Compare(other.m_ad)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_AuthenticationHeader::GetDataLength() const
{
  PINDEX length = 0;
  length += m_secParmIndex.GetObjectLength();
  length += m_seqNum.GetObjectLength();
  length += m_ad.GetObjectLength();
  return length;
}


BOOL H248_AuthenticationHeader::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_secParmIndex.Decode(strm))
    return FALSE;
  if (!m_seqNum.Decode(strm))
    return FALSE;
  if (!m_ad.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_AuthenticationHeader::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_secParmIndex.Encode(strm);
  m_seqNum.Encode(strm);
  m_ad.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_AuthenticationHeader::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_AuthenticationHeader::Class()), PInvalidCast);
#endif
  return new H248_AuthenticationHeader(*this);
}


//
// Message
//

H248_Message::H248_Message(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_version.SetConstraints(PASN_Object::FixedConstraint, 0, 99);
}


#ifndef PASN_NOPRINTON
void H248_Message::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+10) << "version = " << setprecision(indent) << m_version << '\n';
  strm << setw(indent+6) << "mId = " << setprecision(indent) << m_mId << '\n';
  strm << setw(indent+14) << "messageBody = " << setprecision(indent) << m_messageBody << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_Message::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_Message), PInvalidCast);
#endif
  const H248_Message & other = (const H248_Message &)obj;

  Comparison result;

  if ((result = m_version.Compare(other.m_version)) != EqualTo)
    return result;
  if ((result = m_mId.Compare(other.m_mId)) != EqualTo)
    return result;
  if ((result = m_messageBody.Compare(other.m_messageBody)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_Message::GetDataLength() const
{
  PINDEX length = 0;
  length += m_version.GetObjectLength();
  length += m_mId.GetObjectLength();
  length += m_messageBody.GetObjectLength();
  return length;
}


BOOL H248_Message::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_version.Decode(strm))
    return FALSE;
  if (!m_mId.Decode(strm))
    return FALSE;
  if (!m_messageBody.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_Message::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_version.Encode(strm);
  m_mId.Encode(strm);
  m_messageBody.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_Message::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_Message::Class()), PInvalidCast);
#endif
  return new H248_Message(*this);
}


//
// TransactionRequest
//

H248_TransactionRequest::H248_TransactionRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_TransactionRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "transactionId = " << setprecision(indent) << m_transactionId << '\n';
  strm << setw(indent+10) << "actions = " << setprecision(indent) << m_actions << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_TransactionRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_TransactionRequest), PInvalidCast);
#endif
  const H248_TransactionRequest & other = (const H248_TransactionRequest &)obj;

  Comparison result;

  if ((result = m_transactionId.Compare(other.m_transactionId)) != EqualTo)
    return result;
  if ((result = m_actions.Compare(other.m_actions)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_TransactionRequest::GetDataLength() const
{
  PINDEX length = 0;
  length += m_transactionId.GetObjectLength();
  length += m_actions.GetObjectLength();
  return length;
}


BOOL H248_TransactionRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_transactionId.Decode(strm))
    return FALSE;
  if (!m_actions.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_TransactionRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_transactionId.Encode(strm);
  m_actions.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_TransactionRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_TransactionRequest::Class()), PInvalidCast);
#endif
  return new H248_TransactionRequest(*this);
}


//
// TransactionReply
//

H248_TransactionReply::H248_TransactionReply(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_TransactionReply::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "transactionId = " << setprecision(indent) << m_transactionId << '\n';
  if (HasOptionalField(e_immAckRequired))
    strm << setw(indent+17) << "immAckRequired = " << setprecision(indent) << m_immAckRequired << '\n';
  strm << setw(indent+20) << "transactionResult = " << setprecision(indent) << m_transactionResult << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_TransactionReply::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_TransactionReply), PInvalidCast);
#endif
  const H248_TransactionReply & other = (const H248_TransactionReply &)obj;

  Comparison result;

  if ((result = m_transactionId.Compare(other.m_transactionId)) != EqualTo)
    return result;
  if ((result = m_immAckRequired.Compare(other.m_immAckRequired)) != EqualTo)
    return result;
  if ((result = m_transactionResult.Compare(other.m_transactionResult)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_TransactionReply::GetDataLength() const
{
  PINDEX length = 0;
  length += m_transactionId.GetObjectLength();
  if (HasOptionalField(e_immAckRequired))
    length += m_immAckRequired.GetObjectLength();
  length += m_transactionResult.GetObjectLength();
  return length;
}


BOOL H248_TransactionReply::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_transactionId.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_immAckRequired) && !m_immAckRequired.Decode(strm))
    return FALSE;
  if (!m_transactionResult.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_TransactionReply::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_transactionId.Encode(strm);
  if (HasOptionalField(e_immAckRequired))
    m_immAckRequired.Encode(strm);
  m_transactionResult.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_TransactionReply::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_TransactionReply::Class()), PInvalidCast);
#endif
  return new H248_TransactionReply(*this);
}


//
// ErrorDescriptor
//

H248_ErrorDescriptor::H248_ErrorDescriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_ErrorDescriptor::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+12) << "errorCode = " << setprecision(indent) << m_errorCode << '\n';
  if (HasOptionalField(e_errorText))
    strm << setw(indent+12) << "errorText = " << setprecision(indent) << m_errorText << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_ErrorDescriptor::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_ErrorDescriptor), PInvalidCast);
#endif
  const H248_ErrorDescriptor & other = (const H248_ErrorDescriptor &)obj;

  Comparison result;

  if ((result = m_errorCode.Compare(other.m_errorCode)) != EqualTo)
    return result;
  if ((result = m_errorText.Compare(other.m_errorText)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_ErrorDescriptor::GetDataLength() const
{
  PINDEX length = 0;
  length += m_errorCode.GetObjectLength();
  if (HasOptionalField(e_errorText))
    length += m_errorText.GetObjectLength();
  return length;
}


BOOL H248_ErrorDescriptor::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_errorCode.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_errorText) && !m_errorText.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_ErrorDescriptor::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_errorCode.Encode(strm);
  if (HasOptionalField(e_errorText))
    m_errorText.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_ErrorDescriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_ErrorDescriptor::Class()), PInvalidCast);
#endif
  return new H248_ErrorDescriptor(*this);
}


//
// ContextRequest
//

H248_ContextRequest::H248_ContextRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 0)
{
  m_priority.SetConstraints(PASN_Object::FixedConstraint, 0, 15);
}


#ifndef PASN_NOPRINTON
void H248_ContextRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_priority))
    strm << setw(indent+11) << "priority = " << setprecision(indent) << m_priority << '\n';
  if (HasOptionalField(e_emergency))
    strm << setw(indent+12) << "emergency = " << setprecision(indent) << m_emergency << '\n';
  if (HasOptionalField(e_topologyReq))
    strm << setw(indent+14) << "topologyReq = " << setprecision(indent) << m_topologyReq << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_ContextRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_ContextRequest), PInvalidCast);
#endif
  const H248_ContextRequest & other = (const H248_ContextRequest &)obj;

  Comparison result;

  if ((result = m_priority.Compare(other.m_priority)) != EqualTo)
    return result;
  if ((result = m_emergency.Compare(other.m_emergency)) != EqualTo)
    return result;
  if ((result = m_topologyReq.Compare(other.m_topologyReq)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_ContextRequest::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_priority))
    length += m_priority.GetObjectLength();
  if (HasOptionalField(e_emergency))
    length += m_emergency.GetObjectLength();
  if (HasOptionalField(e_topologyReq))
    length += m_topologyReq.GetObjectLength();
  return length;
}


BOOL H248_ContextRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_priority) && !m_priority.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_emergency) && !m_emergency.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_topologyReq) && !m_topologyReq.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_ContextRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_priority))
    m_priority.Encode(strm);
  if (HasOptionalField(e_emergency))
    m_emergency.Encode(strm);
  if (HasOptionalField(e_topologyReq))
    m_topologyReq.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_ContextRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_ContextRequest::Class()), PInvalidCast);
#endif
  return new H248_ContextRequest(*this);
}


//
// CommandRequest
//

H248_CommandRequest::H248_CommandRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_CommandRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+10) << "command = " << setprecision(indent) << m_command << '\n';
  if (HasOptionalField(e_optional))
    strm << setw(indent+11) << "optional = " << setprecision(indent) << m_optional << '\n';
  if (HasOptionalField(e_wildcardReturn))
    strm << setw(indent+17) << "wildcardReturn = " << setprecision(indent) << m_wildcardReturn << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_CommandRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_CommandRequest), PInvalidCast);
#endif
  const H248_CommandRequest & other = (const H248_CommandRequest &)obj;

  Comparison result;

  if ((result = m_command.Compare(other.m_command)) != EqualTo)
    return result;
  if ((result = m_optional.Compare(other.m_optional)) != EqualTo)
    return result;
  if ((result = m_wildcardReturn.Compare(other.m_wildcardReturn)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_CommandRequest::GetDataLength() const
{
  PINDEX length = 0;
  length += m_command.GetObjectLength();
  if (HasOptionalField(e_optional))
    length += m_optional.GetObjectLength();
  if (HasOptionalField(e_wildcardReturn))
    length += m_wildcardReturn.GetObjectLength();
  return length;
}


BOOL H248_CommandRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_command.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_optional) && !m_optional.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_wildcardReturn) && !m_wildcardReturn.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_CommandRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_command.Encode(strm);
  if (HasOptionalField(e_optional))
    m_optional.Encode(strm);
  if (HasOptionalField(e_wildcardReturn))
    m_wildcardReturn.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_CommandRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_CommandRequest::Class()), PInvalidCast);
#endif
  return new H248_CommandRequest(*this);
}


//
// AmmRequest
//

H248_AmmRequest::H248_AmmRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_AmmRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "terminationID = " << setprecision(indent) << m_terminationID << '\n';
  strm << setw(indent+14) << "descriptors = " << setprecision(indent) << m_descriptors << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_AmmRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_AmmRequest), PInvalidCast);
#endif
  const H248_AmmRequest & other = (const H248_AmmRequest &)obj;

  Comparison result;

  if ((result = m_terminationID.Compare(other.m_terminationID)) != EqualTo)
    return result;
  if ((result = m_descriptors.Compare(other.m_descriptors)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_AmmRequest::GetDataLength() const
{
  PINDEX length = 0;
  length += m_terminationID.GetObjectLength();
  length += m_descriptors.GetObjectLength();
  return length;
}


BOOL H248_AmmRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_terminationID.Decode(strm))
    return FALSE;
  if (!m_descriptors.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_AmmRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_terminationID.Encode(strm);
  m_descriptors.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_AmmRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_AmmRequest::Class()), PInvalidCast);
#endif
  return new H248_AmmRequest(*this);
}


//
// AmmsReply
//

H248_AmmsReply::H248_AmmsReply(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_AmmsReply::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "terminationID = " << setprecision(indent) << m_terminationID << '\n';
  if (HasOptionalField(e_terminationAudit))
    strm << setw(indent+19) << "terminationAudit = " << setprecision(indent) << m_terminationAudit << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_AmmsReply::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_AmmsReply), PInvalidCast);
#endif
  const H248_AmmsReply & other = (const H248_AmmsReply &)obj;

  Comparison result;

  if ((result = m_terminationID.Compare(other.m_terminationID)) != EqualTo)
    return result;
  if ((result = m_terminationAudit.Compare(other.m_terminationAudit)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_AmmsReply::GetDataLength() const
{
  PINDEX length = 0;
  length += m_terminationID.GetObjectLength();
  if (HasOptionalField(e_terminationAudit))
    length += m_terminationAudit.GetObjectLength();
  return length;
}


BOOL H248_AmmsReply::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_terminationID.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_terminationAudit) && !m_terminationAudit.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_AmmsReply::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_terminationID.Encode(strm);
  if (HasOptionalField(e_terminationAudit))
    m_terminationAudit.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_AmmsReply::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_AmmsReply::Class()), PInvalidCast);
#endif
  return new H248_AmmsReply(*this);
}


//
// AuditDescriptor
//

H248_AuditDescriptor::H248_AuditDescriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 1)
{
}


#ifndef PASN_NOPRINTON
void H248_AuditDescriptor::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_auditToken))
    strm << setw(indent+13) << "auditToken = " << setprecision(indent) << m_auditToken << '\n';
  if (HasOptionalField(e_auditPropertyToken))
    strm << setw(indent+21) << "auditPropertyToken = " << setprecision(indent) << m_auditPropertyToken << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_AuditDescriptor::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_AuditDescriptor), PInvalidCast);
#endif
  const H248_AuditDescriptor & other = (const H248_AuditDescriptor &)obj;

  Comparison result;

  if ((result = m_auditToken.Compare(other.m_auditToken)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_AuditDescriptor::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_auditToken))
    length += m_auditToken.GetObjectLength();
  return length;
}


BOOL H248_AuditDescriptor::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_auditToken) && !m_auditToken.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_auditPropertyToken, m_auditPropertyToken))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_AuditDescriptor::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_auditToken))
    m_auditToken.Encode(strm);
  KnownExtensionEncode(strm, e_auditPropertyToken, m_auditPropertyToken);

  UnknownExtensionsEncode(strm);
}


PObject * H248_AuditDescriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_AuditDescriptor::Class()), PInvalidCast);
#endif
  return new H248_AuditDescriptor(*this);
}


//
// IndAudLocalControlDescriptor
//

H248_IndAudLocalControlDescriptor::H248_IndAudLocalControlDescriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 4, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_IndAudLocalControlDescriptor::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_streamMode))
    strm << setw(indent+13) << "streamMode = " << setprecision(indent) << m_streamMode << '\n';
  if (HasOptionalField(e_reserveValue))
    strm << setw(indent+15) << "reserveValue = " << setprecision(indent) << m_reserveValue << '\n';
  if (HasOptionalField(e_reserveGroup))
    strm << setw(indent+15) << "reserveGroup = " << setprecision(indent) << m_reserveGroup << '\n';
  if (HasOptionalField(e_propertyParms))
    strm << setw(indent+16) << "propertyParms = " << setprecision(indent) << m_propertyParms << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_IndAudLocalControlDescriptor::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_IndAudLocalControlDescriptor), PInvalidCast);
#endif
  const H248_IndAudLocalControlDescriptor & other = (const H248_IndAudLocalControlDescriptor &)obj;

  Comparison result;

  if ((result = m_streamMode.Compare(other.m_streamMode)) != EqualTo)
    return result;
  if ((result = m_reserveValue.Compare(other.m_reserveValue)) != EqualTo)
    return result;
  if ((result = m_reserveGroup.Compare(other.m_reserveGroup)) != EqualTo)
    return result;
  if ((result = m_propertyParms.Compare(other.m_propertyParms)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_IndAudLocalControlDescriptor::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_streamMode))
    length += m_streamMode.GetObjectLength();
  if (HasOptionalField(e_reserveValue))
    length += m_reserveValue.GetObjectLength();
  if (HasOptionalField(e_reserveGroup))
    length += m_reserveGroup.GetObjectLength();
  if (HasOptionalField(e_propertyParms))
    length += m_propertyParms.GetObjectLength();
  return length;
}


BOOL H248_IndAudLocalControlDescriptor::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_streamMode) && !m_streamMode.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_reserveValue) && !m_reserveValue.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_reserveGroup) && !m_reserveGroup.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_propertyParms) && !m_propertyParms.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_IndAudLocalControlDescriptor::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_streamMode))
    m_streamMode.Encode(strm);
  if (HasOptionalField(e_reserveValue))
    m_reserveValue.Encode(strm);
  if (HasOptionalField(e_reserveGroup))
    m_reserveGroup.Encode(strm);
  if (HasOptionalField(e_propertyParms))
    m_propertyParms.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_IndAudLocalControlDescriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_IndAudLocalControlDescriptor::Class()), PInvalidCast);
#endif
  return new H248_IndAudLocalControlDescriptor(*this);
}


//
// IndAudPropertyParm
//

H248_IndAudPropertyParm::H248_IndAudPropertyParm(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_IndAudPropertyParm::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+7) << "name = " << setprecision(indent) << m_name << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_IndAudPropertyParm::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_IndAudPropertyParm), PInvalidCast);
#endif
  const H248_IndAudPropertyParm & other = (const H248_IndAudPropertyParm &)obj;

  Comparison result;

  if ((result = m_name.Compare(other.m_name)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_IndAudPropertyParm::GetDataLength() const
{
  PINDEX length = 0;
  length += m_name.GetObjectLength();
  return length;
}


BOOL H248_IndAudPropertyParm::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_name.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_IndAudPropertyParm::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_name.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_IndAudPropertyParm::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_IndAudPropertyParm::Class()), PInvalidCast);
#endif
  return new H248_IndAudPropertyParm(*this);
}


//
// IndAudLocalRemoteDescriptor
//

H248_IndAudLocalRemoteDescriptor::H248_IndAudLocalRemoteDescriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_propGroupID.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void H248_IndAudLocalRemoteDescriptor::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_propGroupID))
    strm << setw(indent+14) << "propGroupID = " << setprecision(indent) << m_propGroupID << '\n';
  strm << setw(indent+11) << "propGrps = " << setprecision(indent) << m_propGrps << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_IndAudLocalRemoteDescriptor::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_IndAudLocalRemoteDescriptor), PInvalidCast);
#endif
  const H248_IndAudLocalRemoteDescriptor & other = (const H248_IndAudLocalRemoteDescriptor &)obj;

  Comparison result;

  if ((result = m_propGroupID.Compare(other.m_propGroupID)) != EqualTo)
    return result;
  if ((result = m_propGrps.Compare(other.m_propGrps)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_IndAudLocalRemoteDescriptor::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_propGroupID))
    length += m_propGroupID.GetObjectLength();
  length += m_propGrps.GetObjectLength();
  return length;
}


BOOL H248_IndAudLocalRemoteDescriptor::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_propGroupID) && !m_propGroupID.Decode(strm))
    return FALSE;
  if (!m_propGrps.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_IndAudLocalRemoteDescriptor::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_propGroupID))
    m_propGroupID.Encode(strm);
  m_propGrps.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_IndAudLocalRemoteDescriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_IndAudLocalRemoteDescriptor::Class()), PInvalidCast);
#endif
  return new H248_IndAudLocalRemoteDescriptor(*this);
}


//
// IndAudTerminationStateDescriptor
//

H248_IndAudTerminationStateDescriptor::H248_IndAudTerminationStateDescriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_IndAudTerminationStateDescriptor::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "propertyParms = " << setprecision(indent) << m_propertyParms << '\n';
  if (HasOptionalField(e_eventBufferControl))
    strm << setw(indent+21) << "eventBufferControl = " << setprecision(indent) << m_eventBufferControl << '\n';
  if (HasOptionalField(e_serviceState))
    strm << setw(indent+15) << "serviceState = " << setprecision(indent) << m_serviceState << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_IndAudTerminationStateDescriptor::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_IndAudTerminationStateDescriptor), PInvalidCast);
#endif
  const H248_IndAudTerminationStateDescriptor & other = (const H248_IndAudTerminationStateDescriptor &)obj;

  Comparison result;

  if ((result = m_propertyParms.Compare(other.m_propertyParms)) != EqualTo)
    return result;
  if ((result = m_eventBufferControl.Compare(other.m_eventBufferControl)) != EqualTo)
    return result;
  if ((result = m_serviceState.Compare(other.m_serviceState)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_IndAudTerminationStateDescriptor::GetDataLength() const
{
  PINDEX length = 0;
  length += m_propertyParms.GetObjectLength();
  if (HasOptionalField(e_eventBufferControl))
    length += m_eventBufferControl.GetObjectLength();
  if (HasOptionalField(e_serviceState))
    length += m_serviceState.GetObjectLength();
  return length;
}


BOOL H248_IndAudTerminationStateDescriptor::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_propertyParms.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_eventBufferControl) && !m_eventBufferControl.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_serviceState) && !m_serviceState.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_IndAudTerminationStateDescriptor::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_propertyParms.Encode(strm);
  if (HasOptionalField(e_eventBufferControl))
    m_eventBufferControl.Encode(strm);
  if (HasOptionalField(e_serviceState))
    m_serviceState.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_IndAudTerminationStateDescriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_IndAudTerminationStateDescriptor::Class()), PInvalidCast);
#endif
  return new H248_IndAudTerminationStateDescriptor(*this);
}


//
// IndAudEventsDescriptor
//

H248_IndAudEventsDescriptor::H248_IndAudEventsDescriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_IndAudEventsDescriptor::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_requestID))
    strm << setw(indent+12) << "requestID = " << setprecision(indent) << m_requestID << '\n';
  strm << setw(indent+11) << "pkgdName = " << setprecision(indent) << m_pkgdName << '\n';
  if (HasOptionalField(e_streamID))
    strm << setw(indent+11) << "streamID = " << setprecision(indent) << m_streamID << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_IndAudEventsDescriptor::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_IndAudEventsDescriptor), PInvalidCast);
#endif
  const H248_IndAudEventsDescriptor & other = (const H248_IndAudEventsDescriptor &)obj;

  Comparison result;

  if ((result = m_requestID.Compare(other.m_requestID)) != EqualTo)
    return result;
  if ((result = m_pkgdName.Compare(other.m_pkgdName)) != EqualTo)
    return result;
  if ((result = m_streamID.Compare(other.m_streamID)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_IndAudEventsDescriptor::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_requestID))
    length += m_requestID.GetObjectLength();
  length += m_pkgdName.GetObjectLength();
  if (HasOptionalField(e_streamID))
    length += m_streamID.GetObjectLength();
  return length;
}


BOOL H248_IndAudEventsDescriptor::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_requestID) && !m_requestID.Decode(strm))
    return FALSE;
  if (!m_pkgdName.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_streamID) && !m_streamID.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_IndAudEventsDescriptor::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_requestID))
    m_requestID.Encode(strm);
  m_pkgdName.Encode(strm);
  if (HasOptionalField(e_streamID))
    m_streamID.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_IndAudEventsDescriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_IndAudEventsDescriptor::Class()), PInvalidCast);
#endif
  return new H248_IndAudEventsDescriptor(*this);
}


//
// IndAudEventBufferDescriptor
//

H248_IndAudEventBufferDescriptor::H248_IndAudEventBufferDescriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_IndAudEventBufferDescriptor::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+12) << "eventName = " << setprecision(indent) << m_eventName << '\n';
  if (HasOptionalField(e_streamID))
    strm << setw(indent+11) << "streamID = " << setprecision(indent) << m_streamID << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_IndAudEventBufferDescriptor::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_IndAudEventBufferDescriptor), PInvalidCast);
#endif
  const H248_IndAudEventBufferDescriptor & other = (const H248_IndAudEventBufferDescriptor &)obj;

  Comparison result;

  if ((result = m_eventName.Compare(other.m_eventName)) != EqualTo)
    return result;
  if ((result = m_streamID.Compare(other.m_streamID)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_IndAudEventBufferDescriptor::GetDataLength() const
{
  PINDEX length = 0;
  length += m_eventName.GetObjectLength();
  if (HasOptionalField(e_streamID))
    length += m_streamID.GetObjectLength();
  return length;
}


BOOL H248_IndAudEventBufferDescriptor::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_eventName.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_streamID) && !m_streamID.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_IndAudEventBufferDescriptor::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_eventName.Encode(strm);
  if (HasOptionalField(e_streamID))
    m_streamID.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_IndAudEventBufferDescriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_IndAudEventBufferDescriptor::Class()), PInvalidCast);
#endif
  return new H248_IndAudEventBufferDescriptor(*this);
}


//
// IndAudSignal
//

H248_IndAudSignal::H248_IndAudSignal(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_IndAudSignal::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+13) << "signalName = " << setprecision(indent) << m_signalName << '\n';
  if (HasOptionalField(e_streamID))
    strm << setw(indent+11) << "streamID = " << setprecision(indent) << m_streamID << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_IndAudSignal::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_IndAudSignal), PInvalidCast);
#endif
  const H248_IndAudSignal & other = (const H248_IndAudSignal &)obj;

  Comparison result;

  if ((result = m_signalName.Compare(other.m_signalName)) != EqualTo)
    return result;
  if ((result = m_streamID.Compare(other.m_streamID)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_IndAudSignal::GetDataLength() const
{
  PINDEX length = 0;
  length += m_signalName.GetObjectLength();
  if (HasOptionalField(e_streamID))
    length += m_streamID.GetObjectLength();
  return length;
}


BOOL H248_IndAudSignal::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_signalName.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_streamID) && !m_streamID.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_IndAudSignal::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_signalName.Encode(strm);
  if (HasOptionalField(e_streamID))
    m_streamID.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_IndAudSignal::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_IndAudSignal::Class()), PInvalidCast);
#endif
  return new H248_IndAudSignal(*this);
}


//
// IndAudDigitMapDescriptor
//

H248_IndAudDigitMapDescriptor::H248_IndAudDigitMapDescriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_IndAudDigitMapDescriptor::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_digitMapName))
    strm << setw(indent+15) << "digitMapName = " << setprecision(indent) << m_digitMapName << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_IndAudDigitMapDescriptor::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_IndAudDigitMapDescriptor), PInvalidCast);
#endif
  const H248_IndAudDigitMapDescriptor & other = (const H248_IndAudDigitMapDescriptor &)obj;

  Comparison result;

  if ((result = m_digitMapName.Compare(other.m_digitMapName)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_IndAudDigitMapDescriptor::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_digitMapName))
    length += m_digitMapName.GetObjectLength();
  return length;
}


BOOL H248_IndAudDigitMapDescriptor::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_digitMapName) && !m_digitMapName.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_IndAudDigitMapDescriptor::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_digitMapName))
    m_digitMapName.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_IndAudDigitMapDescriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_IndAudDigitMapDescriptor::Class()), PInvalidCast);
#endif
  return new H248_IndAudDigitMapDescriptor(*this);
}


//
// IndAudStatisticsDescriptor
//

H248_IndAudStatisticsDescriptor::H248_IndAudStatisticsDescriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_IndAudStatisticsDescriptor::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "statName = " << setprecision(indent) << m_statName << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_IndAudStatisticsDescriptor::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_IndAudStatisticsDescriptor), PInvalidCast);
#endif
  const H248_IndAudStatisticsDescriptor & other = (const H248_IndAudStatisticsDescriptor &)obj;

  Comparison result;

  if ((result = m_statName.Compare(other.m_statName)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_IndAudStatisticsDescriptor::GetDataLength() const
{
  PINDEX length = 0;
  length += m_statName.GetObjectLength();
  return length;
}


BOOL H248_IndAudStatisticsDescriptor::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_statName.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_IndAudStatisticsDescriptor::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_statName.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_IndAudStatisticsDescriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_IndAudStatisticsDescriptor::Class()), PInvalidCast);
#endif
  return new H248_IndAudStatisticsDescriptor(*this);
}


//
// IndAudPackagesDescriptor
//

H248_IndAudPackagesDescriptor::H248_IndAudPackagesDescriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_packageVersion.SetConstraints(PASN_Object::FixedConstraint, 0, 99);
}


#ifndef PASN_NOPRINTON
void H248_IndAudPackagesDescriptor::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+14) << "packageName = " << setprecision(indent) << m_packageName << '\n';
  strm << setw(indent+17) << "packageVersion = " << setprecision(indent) << m_packageVersion << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_IndAudPackagesDescriptor::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_IndAudPackagesDescriptor), PInvalidCast);
#endif
  const H248_IndAudPackagesDescriptor & other = (const H248_IndAudPackagesDescriptor &)obj;

  Comparison result;

  if ((result = m_packageName.Compare(other.m_packageName)) != EqualTo)
    return result;
  if ((result = m_packageVersion.Compare(other.m_packageVersion)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_IndAudPackagesDescriptor::GetDataLength() const
{
  PINDEX length = 0;
  length += m_packageName.GetObjectLength();
  length += m_packageVersion.GetObjectLength();
  return length;
}


BOOL H248_IndAudPackagesDescriptor::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_packageName.Decode(strm))
    return FALSE;
  if (!m_packageVersion.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_IndAudPackagesDescriptor::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_packageName.Encode(strm);
  m_packageVersion.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_IndAudPackagesDescriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_IndAudPackagesDescriptor::Class()), PInvalidCast);
#endif
  return new H248_IndAudPackagesDescriptor(*this);
}


//
// NotifyReply
//

H248_NotifyReply::H248_NotifyReply(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_NotifyReply::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "terminationID = " << setprecision(indent) << m_terminationID << '\n';
  if (HasOptionalField(e_errorDescriptor))
    strm << setw(indent+18) << "errorDescriptor = " << setprecision(indent) << m_errorDescriptor << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_NotifyReply::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_NotifyReply), PInvalidCast);
#endif
  const H248_NotifyReply & other = (const H248_NotifyReply &)obj;

  Comparison result;

  if ((result = m_terminationID.Compare(other.m_terminationID)) != EqualTo)
    return result;
  if ((result = m_errorDescriptor.Compare(other.m_errorDescriptor)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_NotifyReply::GetDataLength() const
{
  PINDEX length = 0;
  length += m_terminationID.GetObjectLength();
  if (HasOptionalField(e_errorDescriptor))
    length += m_errorDescriptor.GetObjectLength();
  return length;
}


BOOL H248_NotifyReply::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_terminationID.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_errorDescriptor) && !m_errorDescriptor.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_NotifyReply::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_terminationID.Encode(strm);
  if (HasOptionalField(e_errorDescriptor))
    m_errorDescriptor.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_NotifyReply::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_NotifyReply::Class()), PInvalidCast);
#endif
  return new H248_NotifyReply(*this);
}


//
// ObservedEventsDescriptor
//

H248_ObservedEventsDescriptor::H248_ObservedEventsDescriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_ObservedEventsDescriptor::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+12) << "requestId = " << setprecision(indent) << m_requestId << '\n';
  strm << setw(indent+19) << "observedEventLst = " << setprecision(indent) << m_observedEventLst << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_ObservedEventsDescriptor::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_ObservedEventsDescriptor), PInvalidCast);
#endif
  const H248_ObservedEventsDescriptor & other = (const H248_ObservedEventsDescriptor &)obj;

  Comparison result;

  if ((result = m_requestId.Compare(other.m_requestId)) != EqualTo)
    return result;
  if ((result = m_observedEventLst.Compare(other.m_observedEventLst)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_ObservedEventsDescriptor::GetDataLength() const
{
  PINDEX length = 0;
  length += m_requestId.GetObjectLength();
  length += m_observedEventLst.GetObjectLength();
  return length;
}


BOOL H248_ObservedEventsDescriptor::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_requestId.Decode(strm))
    return FALSE;
  if (!m_observedEventLst.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_ObservedEventsDescriptor::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestId.Encode(strm);
  m_observedEventLst.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_ObservedEventsDescriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_ObservedEventsDescriptor::Class()), PInvalidCast);
#endif
  return new H248_ObservedEventsDescriptor(*this);
}


//
// EventName
//

H248_EventName::H248_EventName(unsigned tag, PASN_Object::TagClass tagClass)
  : H248_PkgdName(tag, tagClass)
{
}


H248_EventName::H248_EventName(const char * v)
{
  SetValue(v);
}


H248_EventName::H248_EventName(const PString & v)
{
  SetValue(v);
}


H248_EventName::H248_EventName(const PBYTEArray & v)
{
  SetValue(v);
}


H248_EventName & H248_EventName::operator=(const char * v)
{
  SetValue(v);
  return *this;
}


H248_EventName & H248_EventName::operator=(const PString & v)
{
  SetValue(v);
  return *this;
}


H248_EventName & H248_EventName::operator=(const PBYTEArray & v)
{
  SetValue(v);
  return *this;
}


PObject * H248_EventName::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_EventName::Class()), PInvalidCast);
#endif
  return new H248_EventName(*this);
}


//
// EventParameter
//

H248_EventParameter::H248_EventParameter(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_EventParameter::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+21) << "eventParameterName = " << setprecision(indent) << m_eventParameterName << '\n';
  strm << setw(indent+8) << "value = " << setprecision(indent) << m_value << '\n';
  if (HasOptionalField(e_extraInfo))
    strm << setw(indent+12) << "extraInfo = " << setprecision(indent) << m_extraInfo << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_EventParameter::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_EventParameter), PInvalidCast);
#endif
  const H248_EventParameter & other = (const H248_EventParameter &)obj;

  Comparison result;

  if ((result = m_eventParameterName.Compare(other.m_eventParameterName)) != EqualTo)
    return result;
  if ((result = m_value.Compare(other.m_value)) != EqualTo)
    return result;
  if ((result = m_extraInfo.Compare(other.m_extraInfo)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_EventParameter::GetDataLength() const
{
  PINDEX length = 0;
  length += m_eventParameterName.GetObjectLength();
  length += m_value.GetObjectLength();
  if (HasOptionalField(e_extraInfo))
    length += m_extraInfo.GetObjectLength();
  return length;
}


BOOL H248_EventParameter::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_eventParameterName.Decode(strm))
    return FALSE;
  if (!m_value.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_extraInfo) && !m_extraInfo.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_EventParameter::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_eventParameterName.Encode(strm);
  m_value.Encode(strm);
  if (HasOptionalField(e_extraInfo))
    m_extraInfo.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_EventParameter::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_EventParameter::Class()), PInvalidCast);
#endif
  return new H248_EventParameter(*this);
}


//
// ServiceChangeReply
//

H248_ServiceChangeReply::H248_ServiceChangeReply(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_ServiceChangeReply::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "terminationID = " << setprecision(indent) << m_terminationID << '\n';
  strm << setw(indent+22) << "serviceChangeResult = " << setprecision(indent) << m_serviceChangeResult << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_ServiceChangeReply::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_ServiceChangeReply), PInvalidCast);
#endif
  const H248_ServiceChangeReply & other = (const H248_ServiceChangeReply &)obj;

  Comparison result;

  if ((result = m_terminationID.Compare(other.m_terminationID)) != EqualTo)
    return result;
  if ((result = m_serviceChangeResult.Compare(other.m_serviceChangeResult)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_ServiceChangeReply::GetDataLength() const
{
  PINDEX length = 0;
  length += m_terminationID.GetObjectLength();
  length += m_serviceChangeResult.GetObjectLength();
  return length;
}


BOOL H248_ServiceChangeReply::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_terminationID.Decode(strm))
    return FALSE;
  if (!m_serviceChangeResult.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_ServiceChangeReply::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_terminationID.Encode(strm);
  m_serviceChangeResult.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_ServiceChangeReply::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_ServiceChangeReply::Class()), PInvalidCast);
#endif
  return new H248_ServiceChangeReply(*this);
}


//
// TerminationID
//

H248_TerminationID::H248_TerminationID(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_id.SetConstraints(PASN_Object::FixedConstraint, 1, 8);
}


#ifndef PASN_NOPRINTON
void H248_TerminationID::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "wildcard = " << setprecision(indent) << m_wildcard << '\n';
  strm << setw(indent+5) << "id = " << setprecision(indent) << m_id << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_TerminationID::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_TerminationID), PInvalidCast);
#endif
  const H248_TerminationID & other = (const H248_TerminationID &)obj;

  Comparison result;

  if ((result = m_wildcard.Compare(other.m_wildcard)) != EqualTo)
    return result;
  if ((result = m_id.Compare(other.m_id)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_TerminationID::GetDataLength() const
{
  PINDEX length = 0;
  length += m_wildcard.GetObjectLength();
  length += m_id.GetObjectLength();
  return length;
}


BOOL H248_TerminationID::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_wildcard.Decode(strm))
    return FALSE;
  if (!m_id.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_TerminationID::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_wildcard.Encode(strm);
  m_id.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_TerminationID::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_TerminationID::Class()), PInvalidCast);
#endif
  return new H248_TerminationID(*this);
}


//
// LocalControlDescriptor
//

H248_LocalControlDescriptor::H248_LocalControlDescriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_LocalControlDescriptor::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_streamMode))
    strm << setw(indent+13) << "streamMode = " << setprecision(indent) << m_streamMode << '\n';
  if (HasOptionalField(e_reserveValue))
    strm << setw(indent+15) << "reserveValue = " << setprecision(indent) << m_reserveValue << '\n';
  if (HasOptionalField(e_reserveGroup))
    strm << setw(indent+15) << "reserveGroup = " << setprecision(indent) << m_reserveGroup << '\n';
  strm << setw(indent+16) << "propertyParms = " << setprecision(indent) << m_propertyParms << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_LocalControlDescriptor::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_LocalControlDescriptor), PInvalidCast);
#endif
  const H248_LocalControlDescriptor & other = (const H248_LocalControlDescriptor &)obj;

  Comparison result;

  if ((result = m_streamMode.Compare(other.m_streamMode)) != EqualTo)
    return result;
  if ((result = m_reserveValue.Compare(other.m_reserveValue)) != EqualTo)
    return result;
  if ((result = m_reserveGroup.Compare(other.m_reserveGroup)) != EqualTo)
    return result;
  if ((result = m_propertyParms.Compare(other.m_propertyParms)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_LocalControlDescriptor::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_streamMode))
    length += m_streamMode.GetObjectLength();
  if (HasOptionalField(e_reserveValue))
    length += m_reserveValue.GetObjectLength();
  if (HasOptionalField(e_reserveGroup))
    length += m_reserveGroup.GetObjectLength();
  length += m_propertyParms.GetObjectLength();
  return length;
}


BOOL H248_LocalControlDescriptor::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_streamMode) && !m_streamMode.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_reserveValue) && !m_reserveValue.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_reserveGroup) && !m_reserveGroup.Decode(strm))
    return FALSE;
  if (!m_propertyParms.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_LocalControlDescriptor::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_streamMode))
    m_streamMode.Encode(strm);
  if (HasOptionalField(e_reserveValue))
    m_reserveValue.Encode(strm);
  if (HasOptionalField(e_reserveGroup))
    m_reserveGroup.Encode(strm);
  m_propertyParms.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_LocalControlDescriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_LocalControlDescriptor::Class()), PInvalidCast);
#endif
  return new H248_LocalControlDescriptor(*this);
}


//
// PropertyParm
//

H248_PropertyParm::H248_PropertyParm(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_PropertyParm::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+7) << "name = " << setprecision(indent) << m_name << '\n';
  strm << setw(indent+8) << "value = " << setprecision(indent) << m_value << '\n';
  if (HasOptionalField(e_extraInfo))
    strm << setw(indent+12) << "extraInfo = " << setprecision(indent) << m_extraInfo << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_PropertyParm::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_PropertyParm), PInvalidCast);
#endif
  const H248_PropertyParm & other = (const H248_PropertyParm &)obj;

  Comparison result;

  if ((result = m_name.Compare(other.m_name)) != EqualTo)
    return result;
  if ((result = m_value.Compare(other.m_value)) != EqualTo)
    return result;
  if ((result = m_extraInfo.Compare(other.m_extraInfo)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_PropertyParm::GetDataLength() const
{
  PINDEX length = 0;
  length += m_name.GetObjectLength();
  length += m_value.GetObjectLength();
  if (HasOptionalField(e_extraInfo))
    length += m_extraInfo.GetObjectLength();
  return length;
}


BOOL H248_PropertyParm::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_name.Decode(strm))
    return FALSE;
  if (!m_value.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_extraInfo) && !m_extraInfo.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_PropertyParm::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_name.Encode(strm);
  m_value.Encode(strm);
  if (HasOptionalField(e_extraInfo))
    m_extraInfo.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_PropertyParm::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_PropertyParm::Class()), PInvalidCast);
#endif
  return new H248_PropertyParm(*this);
}


//
// LocalRemoteDescriptor
//

H248_LocalRemoteDescriptor::H248_LocalRemoteDescriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_LocalRemoteDescriptor::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "propGrps = " << setprecision(indent) << m_propGrps << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_LocalRemoteDescriptor::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_LocalRemoteDescriptor), PInvalidCast);
#endif
  const H248_LocalRemoteDescriptor & other = (const H248_LocalRemoteDescriptor &)obj;

  Comparison result;

  if ((result = m_propGrps.Compare(other.m_propGrps)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_LocalRemoteDescriptor::GetDataLength() const
{
  PINDEX length = 0;
  length += m_propGrps.GetObjectLength();
  return length;
}


BOOL H248_LocalRemoteDescriptor::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_propGrps.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_LocalRemoteDescriptor::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_propGrps.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_LocalRemoteDescriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_LocalRemoteDescriptor::Class()), PInvalidCast);
#endif
  return new H248_LocalRemoteDescriptor(*this);
}


//
// TerminationStateDescriptor
//

H248_TerminationStateDescriptor::H248_TerminationStateDescriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_TerminationStateDescriptor::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "propertyParms = " << setprecision(indent) << m_propertyParms << '\n';
  if (HasOptionalField(e_eventBufferControl))
    strm << setw(indent+21) << "eventBufferControl = " << setprecision(indent) << m_eventBufferControl << '\n';
  if (HasOptionalField(e_serviceState))
    strm << setw(indent+15) << "serviceState = " << setprecision(indent) << m_serviceState << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_TerminationStateDescriptor::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_TerminationStateDescriptor), PInvalidCast);
#endif
  const H248_TerminationStateDescriptor & other = (const H248_TerminationStateDescriptor &)obj;

  Comparison result;

  if ((result = m_propertyParms.Compare(other.m_propertyParms)) != EqualTo)
    return result;
  if ((result = m_eventBufferControl.Compare(other.m_eventBufferControl)) != EqualTo)
    return result;
  if ((result = m_serviceState.Compare(other.m_serviceState)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_TerminationStateDescriptor::GetDataLength() const
{
  PINDEX length = 0;
  length += m_propertyParms.GetObjectLength();
  if (HasOptionalField(e_eventBufferControl))
    length += m_eventBufferControl.GetObjectLength();
  if (HasOptionalField(e_serviceState))
    length += m_serviceState.GetObjectLength();
  return length;
}


BOOL H248_TerminationStateDescriptor::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_propertyParms.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_eventBufferControl) && !m_eventBufferControl.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_serviceState) && !m_serviceState.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_TerminationStateDescriptor::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_propertyParms.Encode(strm);
  if (HasOptionalField(e_eventBufferControl))
    m_eventBufferControl.Encode(strm);
  if (HasOptionalField(e_serviceState))
    m_serviceState.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_TerminationStateDescriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_TerminationStateDescriptor::Class()), PInvalidCast);
#endif
  return new H248_TerminationStateDescriptor(*this);
}


//
// EventsDescriptor
//

H248_EventsDescriptor::H248_EventsDescriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_EventsDescriptor::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_requestID))
    strm << setw(indent+12) << "requestID = " << setprecision(indent) << m_requestID << '\n';
  strm << setw(indent+12) << "eventList = " << setprecision(indent) << m_eventList << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_EventsDescriptor::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_EventsDescriptor), PInvalidCast);
#endif
  const H248_EventsDescriptor & other = (const H248_EventsDescriptor &)obj;

  Comparison result;

  if ((result = m_requestID.Compare(other.m_requestID)) != EqualTo)
    return result;
  if ((result = m_eventList.Compare(other.m_eventList)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_EventsDescriptor::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_requestID))
    length += m_requestID.GetObjectLength();
  length += m_eventList.GetObjectLength();
  return length;
}


BOOL H248_EventsDescriptor::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_requestID) && !m_requestID.Decode(strm))
    return FALSE;
  if (!m_eventList.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_EventsDescriptor::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_requestID))
    m_requestID.Encode(strm);
  m_eventList.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_EventsDescriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_EventsDescriptor::Class()), PInvalidCast);
#endif
  return new H248_EventsDescriptor(*this);
}


//
// SecondEventsDescriptor
//

H248_SecondEventsDescriptor::H248_SecondEventsDescriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_SecondEventsDescriptor::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_requestID))
    strm << setw(indent+12) << "requestID = " << setprecision(indent) << m_requestID << '\n';
  strm << setw(indent+12) << "eventList = " << setprecision(indent) << m_eventList << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_SecondEventsDescriptor::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_SecondEventsDescriptor), PInvalidCast);
#endif
  const H248_SecondEventsDescriptor & other = (const H248_SecondEventsDescriptor &)obj;

  Comparison result;

  if ((result = m_requestID.Compare(other.m_requestID)) != EqualTo)
    return result;
  if ((result = m_eventList.Compare(other.m_eventList)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_SecondEventsDescriptor::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_requestID))
    length += m_requestID.GetObjectLength();
  length += m_eventList.GetObjectLength();
  return length;
}


BOOL H248_SecondEventsDescriptor::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_requestID) && !m_requestID.Decode(strm))
    return FALSE;
  if (!m_eventList.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_SecondEventsDescriptor::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_requestID))
    m_requestID.Encode(strm);
  m_eventList.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_SecondEventsDescriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_SecondEventsDescriptor::Class()), PInvalidCast);
#endif
  return new H248_SecondEventsDescriptor(*this);
}


//
// SecondRequestedActions
//

H248_SecondRequestedActions::H248_SecondRequestedActions(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_SecondRequestedActions::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_keepActive))
    strm << setw(indent+13) << "keepActive = " << setprecision(indent) << m_keepActive << '\n';
  if (HasOptionalField(e_eventDM))
    strm << setw(indent+10) << "eventDM = " << setprecision(indent) << m_eventDM << '\n';
  if (HasOptionalField(e_signalsDescriptor))
    strm << setw(indent+20) << "signalsDescriptor = " << setprecision(indent) << m_signalsDescriptor << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_SecondRequestedActions::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_SecondRequestedActions), PInvalidCast);
#endif
  const H248_SecondRequestedActions & other = (const H248_SecondRequestedActions &)obj;

  Comparison result;

  if ((result = m_keepActive.Compare(other.m_keepActive)) != EqualTo)
    return result;
  if ((result = m_eventDM.Compare(other.m_eventDM)) != EqualTo)
    return result;
  if ((result = m_signalsDescriptor.Compare(other.m_signalsDescriptor)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_SecondRequestedActions::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_keepActive))
    length += m_keepActive.GetObjectLength();
  if (HasOptionalField(e_eventDM))
    length += m_eventDM.GetObjectLength();
  if (HasOptionalField(e_signalsDescriptor))
    length += m_signalsDescriptor.GetObjectLength();
  return length;
}


BOOL H248_SecondRequestedActions::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_keepActive) && !m_keepActive.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_eventDM) && !m_eventDM.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_signalsDescriptor) && !m_signalsDescriptor.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_SecondRequestedActions::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_keepActive))
    m_keepActive.Encode(strm);
  if (HasOptionalField(e_eventDM))
    m_eventDM.Encode(strm);
  if (HasOptionalField(e_signalsDescriptor))
    m_signalsDescriptor.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_SecondRequestedActions::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_SecondRequestedActions::Class()), PInvalidCast);
#endif
  return new H248_SecondRequestedActions(*this);
}


//
// EventSpec
//

H248_EventSpec::H248_EventSpec(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_EventSpec::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+12) << "eventName = " << setprecision(indent) << m_eventName << '\n';
  if (HasOptionalField(e_streamID))
    strm << setw(indent+11) << "streamID = " << setprecision(indent) << m_streamID << '\n';
  strm << setw(indent+15) << "eventParList = " << setprecision(indent) << m_eventParList << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_EventSpec::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_EventSpec), PInvalidCast);
#endif
  const H248_EventSpec & other = (const H248_EventSpec &)obj;

  Comparison result;

  if ((result = m_eventName.Compare(other.m_eventName)) != EqualTo)
    return result;
  if ((result = m_streamID.Compare(other.m_streamID)) != EqualTo)
    return result;
  if ((result = m_eventParList.Compare(other.m_eventParList)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_EventSpec::GetDataLength() const
{
  PINDEX length = 0;
  length += m_eventName.GetObjectLength();
  if (HasOptionalField(e_streamID))
    length += m_streamID.GetObjectLength();
  length += m_eventParList.GetObjectLength();
  return length;
}


BOOL H248_EventSpec::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_eventName.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_streamID) && !m_streamID.Decode(strm))
    return FALSE;
  if (!m_eventParList.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_EventSpec::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_eventName.Encode(strm);
  if (HasOptionalField(e_streamID))
    m_streamID.Encode(strm);
  m_eventParList.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_EventSpec::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_EventSpec::Class()), PInvalidCast);
#endif
  return new H248_EventSpec(*this);
}


//
// SeqSigList
//

H248_SeqSigList::H248_SeqSigList(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
  m_id.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void H248_SeqSigList::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+5) << "id = " << setprecision(indent) << m_id << '\n';
  strm << setw(indent+13) << "signalList = " << setprecision(indent) << m_signalList << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_SeqSigList::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_SeqSigList), PInvalidCast);
#endif
  const H248_SeqSigList & other = (const H248_SeqSigList &)obj;

  Comparison result;

  if ((result = m_id.Compare(other.m_id)) != EqualTo)
    return result;
  if ((result = m_signalList.Compare(other.m_signalList)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_SeqSigList::GetDataLength() const
{
  PINDEX length = 0;
  length += m_id.GetObjectLength();
  length += m_signalList.GetObjectLength();
  return length;
}


BOOL H248_SeqSigList::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_id.Decode(strm))
    return FALSE;
  if (!m_signalList.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_SeqSigList::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_id.Encode(strm);
  m_signalList.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_SeqSigList::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_SeqSigList::Class()), PInvalidCast);
#endif
  return new H248_SeqSigList(*this);
}


//
// Signal
//

H248_Signal::H248_Signal(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 5, TRUE, 0)
{
  m_duration.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void H248_Signal::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+13) << "signalName = " << setprecision(indent) << m_signalName << '\n';
  if (HasOptionalField(e_streamID))
    strm << setw(indent+11) << "streamID = " << setprecision(indent) << m_streamID << '\n';
  if (HasOptionalField(e_sigType))
    strm << setw(indent+10) << "sigType = " << setprecision(indent) << m_sigType << '\n';
  if (HasOptionalField(e_duration))
    strm << setw(indent+11) << "duration = " << setprecision(indent) << m_duration << '\n';
  if (HasOptionalField(e_notifyCompletion))
    strm << setw(indent+19) << "notifyCompletion = " << setprecision(indent) << m_notifyCompletion << '\n';
  if (HasOptionalField(e_keepActive))
    strm << setw(indent+13) << "keepActive = " << setprecision(indent) << m_keepActive << '\n';
  strm << setw(indent+13) << "sigParList = " << setprecision(indent) << m_sigParList << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_Signal::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_Signal), PInvalidCast);
#endif
  const H248_Signal & other = (const H248_Signal &)obj;

  Comparison result;

  if ((result = m_signalName.Compare(other.m_signalName)) != EqualTo)
    return result;
  if ((result = m_streamID.Compare(other.m_streamID)) != EqualTo)
    return result;
  if ((result = m_sigType.Compare(other.m_sigType)) != EqualTo)
    return result;
  if ((result = m_duration.Compare(other.m_duration)) != EqualTo)
    return result;
  if ((result = m_notifyCompletion.Compare(other.m_notifyCompletion)) != EqualTo)
    return result;
  if ((result = m_keepActive.Compare(other.m_keepActive)) != EqualTo)
    return result;
  if ((result = m_sigParList.Compare(other.m_sigParList)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_Signal::GetDataLength() const
{
  PINDEX length = 0;
  length += m_signalName.GetObjectLength();
  if (HasOptionalField(e_streamID))
    length += m_streamID.GetObjectLength();
  if (HasOptionalField(e_sigType))
    length += m_sigType.GetObjectLength();
  if (HasOptionalField(e_duration))
    length += m_duration.GetObjectLength();
  if (HasOptionalField(e_notifyCompletion))
    length += m_notifyCompletion.GetObjectLength();
  if (HasOptionalField(e_keepActive))
    length += m_keepActive.GetObjectLength();
  length += m_sigParList.GetObjectLength();
  return length;
}


BOOL H248_Signal::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_signalName.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_streamID) && !m_streamID.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_sigType) && !m_sigType.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_duration) && !m_duration.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_notifyCompletion) && !m_notifyCompletion.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_keepActive) && !m_keepActive.Decode(strm))
    return FALSE;
  if (!m_sigParList.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_Signal::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_signalName.Encode(strm);
  if (HasOptionalField(e_streamID))
    m_streamID.Encode(strm);
  if (HasOptionalField(e_sigType))
    m_sigType.Encode(strm);
  if (HasOptionalField(e_duration))
    m_duration.Encode(strm);
  if (HasOptionalField(e_notifyCompletion))
    m_notifyCompletion.Encode(strm);
  if (HasOptionalField(e_keepActive))
    m_keepActive.Encode(strm);
  m_sigParList.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_Signal::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_Signal::Class()), PInvalidCast);
#endif
  return new H248_Signal(*this);
}


//
// SigParameter
//

H248_SigParameter::H248_SigParameter(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_SigParameter::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+19) << "sigParameterName = " << setprecision(indent) << m_sigParameterName << '\n';
  strm << setw(indent+8) << "value = " << setprecision(indent) << m_value << '\n';
  if (HasOptionalField(e_extraInfo))
    strm << setw(indent+12) << "extraInfo = " << setprecision(indent) << m_extraInfo << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_SigParameter::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_SigParameter), PInvalidCast);
#endif
  const H248_SigParameter & other = (const H248_SigParameter &)obj;

  Comparison result;

  if ((result = m_sigParameterName.Compare(other.m_sigParameterName)) != EqualTo)
    return result;
  if ((result = m_value.Compare(other.m_value)) != EqualTo)
    return result;
  if ((result = m_extraInfo.Compare(other.m_extraInfo)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_SigParameter::GetDataLength() const
{
  PINDEX length = 0;
  length += m_sigParameterName.GetObjectLength();
  length += m_value.GetObjectLength();
  if (HasOptionalField(e_extraInfo))
    length += m_extraInfo.GetObjectLength();
  return length;
}


BOOL H248_SigParameter::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_sigParameterName.Decode(strm))
    return FALSE;
  if (!m_value.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_extraInfo) && !m_extraInfo.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_SigParameter::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_sigParameterName.Encode(strm);
  m_value.Encode(strm);
  if (HasOptionalField(e_extraInfo))
    m_extraInfo.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_SigParameter::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_SigParameter::Class()), PInvalidCast);
#endif
  return new H248_SigParameter(*this);
}


//
// DigitMapDescriptor
//

H248_DigitMapDescriptor::H248_DigitMapDescriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_DigitMapDescriptor::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_digitMapName))
    strm << setw(indent+15) << "digitMapName = " << setprecision(indent) << m_digitMapName << '\n';
  if (HasOptionalField(e_digitMapValue))
    strm << setw(indent+16) << "digitMapValue = " << setprecision(indent) << m_digitMapValue << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_DigitMapDescriptor::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_DigitMapDescriptor), PInvalidCast);
#endif
  const H248_DigitMapDescriptor & other = (const H248_DigitMapDescriptor &)obj;

  Comparison result;

  if ((result = m_digitMapName.Compare(other.m_digitMapName)) != EqualTo)
    return result;
  if ((result = m_digitMapValue.Compare(other.m_digitMapValue)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_DigitMapDescriptor::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_digitMapName))
    length += m_digitMapName.GetObjectLength();
  if (HasOptionalField(e_digitMapValue))
    length += m_digitMapValue.GetObjectLength();
  return length;
}


BOOL H248_DigitMapDescriptor::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_digitMapName) && !m_digitMapName.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_digitMapValue) && !m_digitMapValue.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_DigitMapDescriptor::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_digitMapName))
    m_digitMapName.Encode(strm);
  if (HasOptionalField(e_digitMapValue))
    m_digitMapValue.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_DigitMapDescriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_DigitMapDescriptor::Class()), PInvalidCast);
#endif
  return new H248_DigitMapDescriptor(*this);
}


//
// ServiceChangeResParm
//

H248_ServiceChangeResParm::H248_ServiceChangeResParm(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 5, TRUE, 0)
{
  m_serviceChangeVersion.SetConstraints(PASN_Object::FixedConstraint, 0, 99);
}


#ifndef PASN_NOPRINTON
void H248_ServiceChangeResParm::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_serviceChangeMgcId))
    strm << setw(indent+21) << "serviceChangeMgcId = " << setprecision(indent) << m_serviceChangeMgcId << '\n';
  if (HasOptionalField(e_serviceChangeAddress))
    strm << setw(indent+23) << "serviceChangeAddress = " << setprecision(indent) << m_serviceChangeAddress << '\n';
  if (HasOptionalField(e_serviceChangeVersion))
    strm << setw(indent+23) << "serviceChangeVersion = " << setprecision(indent) << m_serviceChangeVersion << '\n';
  if (HasOptionalField(e_serviceChangeProfile))
    strm << setw(indent+23) << "serviceChangeProfile = " << setprecision(indent) << m_serviceChangeProfile << '\n';
  if (HasOptionalField(e_timestamp))
    strm << setw(indent+12) << "timestamp = " << setprecision(indent) << m_timestamp << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_ServiceChangeResParm::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_ServiceChangeResParm), PInvalidCast);
#endif
  const H248_ServiceChangeResParm & other = (const H248_ServiceChangeResParm &)obj;

  Comparison result;

  if ((result = m_serviceChangeMgcId.Compare(other.m_serviceChangeMgcId)) != EqualTo)
    return result;
  if ((result = m_serviceChangeAddress.Compare(other.m_serviceChangeAddress)) != EqualTo)
    return result;
  if ((result = m_serviceChangeVersion.Compare(other.m_serviceChangeVersion)) != EqualTo)
    return result;
  if ((result = m_serviceChangeProfile.Compare(other.m_serviceChangeProfile)) != EqualTo)
    return result;
  if ((result = m_timestamp.Compare(other.m_timestamp)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_ServiceChangeResParm::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_serviceChangeMgcId))
    length += m_serviceChangeMgcId.GetObjectLength();
  if (HasOptionalField(e_serviceChangeAddress))
    length += m_serviceChangeAddress.GetObjectLength();
  if (HasOptionalField(e_serviceChangeVersion))
    length += m_serviceChangeVersion.GetObjectLength();
  if (HasOptionalField(e_serviceChangeProfile))
    length += m_serviceChangeProfile.GetObjectLength();
  if (HasOptionalField(e_timestamp))
    length += m_timestamp.GetObjectLength();
  return length;
}


BOOL H248_ServiceChangeResParm::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_serviceChangeMgcId) && !m_serviceChangeMgcId.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_serviceChangeAddress) && !m_serviceChangeAddress.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_serviceChangeVersion) && !m_serviceChangeVersion.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_serviceChangeProfile) && !m_serviceChangeProfile.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_timestamp) && !m_timestamp.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_ServiceChangeResParm::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_serviceChangeMgcId))
    m_serviceChangeMgcId.Encode(strm);
  if (HasOptionalField(e_serviceChangeAddress))
    m_serviceChangeAddress.Encode(strm);
  if (HasOptionalField(e_serviceChangeVersion))
    m_serviceChangeVersion.Encode(strm);
  if (HasOptionalField(e_serviceChangeProfile))
    m_serviceChangeProfile.Encode(strm);
  if (HasOptionalField(e_timestamp))
    m_timestamp.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_ServiceChangeResParm::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_ServiceChangeResParm::Class()), PInvalidCast);
#endif
  return new H248_ServiceChangeResParm(*this);
}


//
// StatisticsParameter
//

H248_StatisticsParameter::H248_StatisticsParameter(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_StatisticsParameter::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "statName = " << setprecision(indent) << m_statName << '\n';
  if (HasOptionalField(e_statValue))
    strm << setw(indent+12) << "statValue = " << setprecision(indent) << m_statValue << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_StatisticsParameter::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_StatisticsParameter), PInvalidCast);
#endif
  const H248_StatisticsParameter & other = (const H248_StatisticsParameter &)obj;

  Comparison result;

  if ((result = m_statName.Compare(other.m_statName)) != EqualTo)
    return result;
  if ((result = m_statValue.Compare(other.m_statValue)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_StatisticsParameter::GetDataLength() const
{
  PINDEX length = 0;
  length += m_statName.GetObjectLength();
  if (HasOptionalField(e_statValue))
    length += m_statValue.GetObjectLength();
  return length;
}


BOOL H248_StatisticsParameter::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_statName.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_statValue) && !m_statValue.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_StatisticsParameter::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_statName.Encode(strm);
  if (HasOptionalField(e_statValue))
    m_statValue.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_StatisticsParameter::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_StatisticsParameter::Class()), PInvalidCast);
#endif
  return new H248_StatisticsParameter(*this);
}


//
// NonStandardData
//

H248_NonStandardData::H248_NonStandardData(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_NonStandardData::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+24) << "nonStandardIdentifier = " << setprecision(indent) << m_nonStandardIdentifier << '\n';
  strm << setw(indent+7) << "data = " << setprecision(indent) << m_data << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_NonStandardData::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_NonStandardData), PInvalidCast);
#endif
  const H248_NonStandardData & other = (const H248_NonStandardData &)obj;

  Comparison result;

  if ((result = m_nonStandardIdentifier.Compare(other.m_nonStandardIdentifier)) != EqualTo)
    return result;
  if ((result = m_data.Compare(other.m_data)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_NonStandardData::GetDataLength() const
{
  PINDEX length = 0;
  length += m_nonStandardIdentifier.GetObjectLength();
  length += m_data.GetObjectLength();
  return length;
}


BOOL H248_NonStandardData::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_nonStandardIdentifier.Decode(strm))
    return FALSE;
  if (!m_data.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_NonStandardData::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_nonStandardIdentifier.Encode(strm);
  m_data.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_NonStandardData::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_NonStandardData::Class()), PInvalidCast);
#endif
  return new H248_NonStandardData(*this);
}


//
// MegacoMessage
//

H248_MegacoMessage::H248_MegacoMessage(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_MegacoMessage::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_authHeader))
    strm << setw(indent+13) << "authHeader = " << setprecision(indent) << m_authHeader << '\n';
  strm << setw(indent+7) << "mess = " << setprecision(indent) << m_mess << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_MegacoMessage::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_MegacoMessage), PInvalidCast);
#endif
  const H248_MegacoMessage & other = (const H248_MegacoMessage &)obj;

  Comparison result;

  if ((result = m_authHeader.Compare(other.m_authHeader)) != EqualTo)
    return result;
  if ((result = m_mess.Compare(other.m_mess)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_MegacoMessage::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_authHeader))
    length += m_authHeader.GetObjectLength();
  length += m_mess.GetObjectLength();
  return length;
}


BOOL H248_MegacoMessage::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_authHeader) && !m_authHeader.Decode(strm))
    return FALSE;
  if (!m_mess.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_MegacoMessage::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_authHeader))
    m_authHeader.Encode(strm);
  m_mess.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_MegacoMessage::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_MegacoMessage::Class()), PInvalidCast);
#endif
  return new H248_MegacoMessage(*this);
}


//
// ActionRequest
//

H248_ActionRequest::H248_ActionRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_ActionRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+12) << "contextId = " << setprecision(indent) << m_contextId << '\n';
  if (HasOptionalField(e_contextRequest))
    strm << setw(indent+17) << "contextRequest = " << setprecision(indent) << m_contextRequest << '\n';
  if (HasOptionalField(e_contextAttrAuditReq))
    strm << setw(indent+22) << "contextAttrAuditReq = " << setprecision(indent) << m_contextAttrAuditReq << '\n';
  strm << setw(indent+18) << "commandRequests = " << setprecision(indent) << m_commandRequests << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_ActionRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_ActionRequest), PInvalidCast);
#endif
  const H248_ActionRequest & other = (const H248_ActionRequest &)obj;

  Comparison result;

  if ((result = m_contextId.Compare(other.m_contextId)) != EqualTo)
    return result;
  if ((result = m_contextRequest.Compare(other.m_contextRequest)) != EqualTo)
    return result;
  if ((result = m_contextAttrAuditReq.Compare(other.m_contextAttrAuditReq)) != EqualTo)
    return result;
  if ((result = m_commandRequests.Compare(other.m_commandRequests)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_ActionRequest::GetDataLength() const
{
  PINDEX length = 0;
  length += m_contextId.GetObjectLength();
  if (HasOptionalField(e_contextRequest))
    length += m_contextRequest.GetObjectLength();
  if (HasOptionalField(e_contextAttrAuditReq))
    length += m_contextAttrAuditReq.GetObjectLength();
  length += m_commandRequests.GetObjectLength();
  return length;
}


BOOL H248_ActionRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_contextId.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_contextRequest) && !m_contextRequest.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_contextAttrAuditReq) && !m_contextAttrAuditReq.Decode(strm))
    return FALSE;
  if (!m_commandRequests.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_ActionRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_contextId.Encode(strm);
  if (HasOptionalField(e_contextRequest))
    m_contextRequest.Encode(strm);
  if (HasOptionalField(e_contextAttrAuditReq))
    m_contextAttrAuditReq.Encode(strm);
  m_commandRequests.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_ActionRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_ActionRequest::Class()), PInvalidCast);
#endif
  return new H248_ActionRequest(*this);
}


//
// ActionReply
//

H248_ActionReply::H248_ActionReply(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_ActionReply::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+12) << "contextId = " << setprecision(indent) << m_contextId << '\n';
  if (HasOptionalField(e_errorDescriptor))
    strm << setw(indent+18) << "errorDescriptor = " << setprecision(indent) << m_errorDescriptor << '\n';
  if (HasOptionalField(e_contextReply))
    strm << setw(indent+15) << "contextReply = " << setprecision(indent) << m_contextReply << '\n';
  strm << setw(indent+15) << "commandReply = " << setprecision(indent) << m_commandReply << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_ActionReply::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_ActionReply), PInvalidCast);
#endif
  const H248_ActionReply & other = (const H248_ActionReply &)obj;

  Comparison result;

  if ((result = m_contextId.Compare(other.m_contextId)) != EqualTo)
    return result;
  if ((result = m_errorDescriptor.Compare(other.m_errorDescriptor)) != EqualTo)
    return result;
  if ((result = m_contextReply.Compare(other.m_contextReply)) != EqualTo)
    return result;
  if ((result = m_commandReply.Compare(other.m_commandReply)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_ActionReply::GetDataLength() const
{
  PINDEX length = 0;
  length += m_contextId.GetObjectLength();
  if (HasOptionalField(e_errorDescriptor))
    length += m_errorDescriptor.GetObjectLength();
  if (HasOptionalField(e_contextReply))
    length += m_contextReply.GetObjectLength();
  length += m_commandReply.GetObjectLength();
  return length;
}


BOOL H248_ActionReply::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_contextId.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_errorDescriptor) && !m_errorDescriptor.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_contextReply) && !m_contextReply.Decode(strm))
    return FALSE;
  if (!m_commandReply.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_ActionReply::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_contextId.Encode(strm);
  if (HasOptionalField(e_errorDescriptor))
    m_errorDescriptor.Encode(strm);
  if (HasOptionalField(e_contextReply))
    m_contextReply.Encode(strm);
  m_commandReply.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_ActionReply::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_ActionReply::Class()), PInvalidCast);
#endif
  return new H248_ActionReply(*this);
}


//
// TopologyRequest
//

H248_TopologyRequest::H248_TopologyRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 1)
{
}


#ifndef PASN_NOPRINTON
void H248_TopologyRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+18) << "terminationFrom = " << setprecision(indent) << m_terminationFrom << '\n';
  strm << setw(indent+16) << "terminationTo = " << setprecision(indent) << m_terminationTo << '\n';
  strm << setw(indent+20) << "topologyDirection = " << setprecision(indent) << m_topologyDirection << '\n';
  if (HasOptionalField(e_streamID))
    strm << setw(indent+11) << "streamID = " << setprecision(indent) << m_streamID << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_TopologyRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_TopologyRequest), PInvalidCast);
#endif
  const H248_TopologyRequest & other = (const H248_TopologyRequest &)obj;

  Comparison result;

  if ((result = m_terminationFrom.Compare(other.m_terminationFrom)) != EqualTo)
    return result;
  if ((result = m_terminationTo.Compare(other.m_terminationTo)) != EqualTo)
    return result;
  if ((result = m_topologyDirection.Compare(other.m_topologyDirection)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_TopologyRequest::GetDataLength() const
{
  PINDEX length = 0;
  length += m_terminationFrom.GetObjectLength();
  length += m_terminationTo.GetObjectLength();
  length += m_topologyDirection.GetObjectLength();
  return length;
}


BOOL H248_TopologyRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_terminationFrom.Decode(strm))
    return FALSE;
  if (!m_terminationTo.Decode(strm))
    return FALSE;
  if (!m_topologyDirection.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_streamID, m_streamID))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_TopologyRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_terminationFrom.Encode(strm);
  m_terminationTo.Encode(strm);
  m_topologyDirection.Encode(strm);
  KnownExtensionEncode(strm, e_streamID, m_streamID);

  UnknownExtensionsEncode(strm);
}


PObject * H248_TopologyRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_TopologyRequest::Class()), PInvalidCast);
#endif
  return new H248_TopologyRequest(*this);
}


//
// SubtractRequest
//

H248_SubtractRequest::H248_SubtractRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_SubtractRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "terminationID = " << setprecision(indent) << m_terminationID << '\n';
  if (HasOptionalField(e_auditDescriptor))
    strm << setw(indent+18) << "auditDescriptor = " << setprecision(indent) << m_auditDescriptor << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_SubtractRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_SubtractRequest), PInvalidCast);
#endif
  const H248_SubtractRequest & other = (const H248_SubtractRequest &)obj;

  Comparison result;

  if ((result = m_terminationID.Compare(other.m_terminationID)) != EqualTo)
    return result;
  if ((result = m_auditDescriptor.Compare(other.m_auditDescriptor)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_SubtractRequest::GetDataLength() const
{
  PINDEX length = 0;
  length += m_terminationID.GetObjectLength();
  if (HasOptionalField(e_auditDescriptor))
    length += m_auditDescriptor.GetObjectLength();
  return length;
}


BOOL H248_SubtractRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_terminationID.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_auditDescriptor) && !m_auditDescriptor.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_SubtractRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_terminationID.Encode(strm);
  if (HasOptionalField(e_auditDescriptor))
    m_auditDescriptor.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_SubtractRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_SubtractRequest::Class()), PInvalidCast);
#endif
  return new H248_SubtractRequest(*this);
}


//
// AuditRequest
//

H248_AuditRequest::H248_AuditRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_AuditRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "terminationID = " << setprecision(indent) << m_terminationID << '\n';
  strm << setw(indent+18) << "auditDescriptor = " << setprecision(indent) << m_auditDescriptor << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_AuditRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_AuditRequest), PInvalidCast);
#endif
  const H248_AuditRequest & other = (const H248_AuditRequest &)obj;

  Comparison result;

  if ((result = m_terminationID.Compare(other.m_terminationID)) != EqualTo)
    return result;
  if ((result = m_auditDescriptor.Compare(other.m_auditDescriptor)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_AuditRequest::GetDataLength() const
{
  PINDEX length = 0;
  length += m_terminationID.GetObjectLength();
  length += m_auditDescriptor.GetObjectLength();
  return length;
}


BOOL H248_AuditRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_terminationID.Decode(strm))
    return FALSE;
  if (!m_auditDescriptor.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_AuditRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_terminationID.Encode(strm);
  m_auditDescriptor.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_AuditRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_AuditRequest::Class()), PInvalidCast);
#endif
  return new H248_AuditRequest(*this);
}


//
// AuditResult
//

H248_AuditResult::H248_AuditResult(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_AuditResult::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "terminationID = " << setprecision(indent) << m_terminationID << '\n';
  strm << setw(indent+25) << "terminationAuditResult = " << setprecision(indent) << m_terminationAuditResult << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_AuditResult::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_AuditResult), PInvalidCast);
#endif
  const H248_AuditResult & other = (const H248_AuditResult &)obj;

  Comparison result;

  if ((result = m_terminationID.Compare(other.m_terminationID)) != EqualTo)
    return result;
  if ((result = m_terminationAuditResult.Compare(other.m_terminationAuditResult)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_AuditResult::GetDataLength() const
{
  PINDEX length = 0;
  length += m_terminationID.GetObjectLength();
  length += m_terminationAuditResult.GetObjectLength();
  return length;
}


BOOL H248_AuditResult::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_terminationID.Decode(strm))
    return FALSE;
  if (!m_terminationAuditResult.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_AuditResult::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_terminationID.Encode(strm);
  m_terminationAuditResult.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_AuditResult::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_AuditResult::Class()), PInvalidCast);
#endif
  return new H248_AuditResult(*this);
}


//
// IndAudMediaDescriptor
//

H248_IndAudMediaDescriptor::H248_IndAudMediaDescriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_IndAudMediaDescriptor::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_termStateDescr))
    strm << setw(indent+17) << "termStateDescr = " << setprecision(indent) << m_termStateDescr << '\n';
  if (HasOptionalField(e_streams))
    strm << setw(indent+10) << "streams = " << setprecision(indent) << m_streams << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_IndAudMediaDescriptor::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_IndAudMediaDescriptor), PInvalidCast);
#endif
  const H248_IndAudMediaDescriptor & other = (const H248_IndAudMediaDescriptor &)obj;

  Comparison result;

  if ((result = m_termStateDescr.Compare(other.m_termStateDescr)) != EqualTo)
    return result;
  if ((result = m_streams.Compare(other.m_streams)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_IndAudMediaDescriptor::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_termStateDescr))
    length += m_termStateDescr.GetObjectLength();
  if (HasOptionalField(e_streams))
    length += m_streams.GetObjectLength();
  return length;
}


BOOL H248_IndAudMediaDescriptor::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_termStateDescr) && !m_termStateDescr.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_streams) && !m_streams.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_IndAudMediaDescriptor::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_termStateDescr))
    m_termStateDescr.Encode(strm);
  if (HasOptionalField(e_streams))
    m_streams.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_IndAudMediaDescriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_IndAudMediaDescriptor::Class()), PInvalidCast);
#endif
  return new H248_IndAudMediaDescriptor(*this);
}


//
// IndAudStreamParms
//

H248_IndAudStreamParms::H248_IndAudStreamParms(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_IndAudStreamParms::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_localControlDescriptor))
    strm << setw(indent+25) << "localControlDescriptor = " << setprecision(indent) << m_localControlDescriptor << '\n';
  if (HasOptionalField(e_localDescriptor))
    strm << setw(indent+18) << "localDescriptor = " << setprecision(indent) << m_localDescriptor << '\n';
  if (HasOptionalField(e_remoteDescriptor))
    strm << setw(indent+19) << "remoteDescriptor = " << setprecision(indent) << m_remoteDescriptor << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_IndAudStreamParms::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_IndAudStreamParms), PInvalidCast);
#endif
  const H248_IndAudStreamParms & other = (const H248_IndAudStreamParms &)obj;

  Comparison result;

  if ((result = m_localControlDescriptor.Compare(other.m_localControlDescriptor)) != EqualTo)
    return result;
  if ((result = m_localDescriptor.Compare(other.m_localDescriptor)) != EqualTo)
    return result;
  if ((result = m_remoteDescriptor.Compare(other.m_remoteDescriptor)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_IndAudStreamParms::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_localControlDescriptor))
    length += m_localControlDescriptor.GetObjectLength();
  if (HasOptionalField(e_localDescriptor))
    length += m_localDescriptor.GetObjectLength();
  if (HasOptionalField(e_remoteDescriptor))
    length += m_remoteDescriptor.GetObjectLength();
  return length;
}


BOOL H248_IndAudStreamParms::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_localControlDescriptor) && !m_localControlDescriptor.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_localDescriptor) && !m_localDescriptor.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_remoteDescriptor) && !m_remoteDescriptor.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_IndAudStreamParms::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_localControlDescriptor))
    m_localControlDescriptor.Encode(strm);
  if (HasOptionalField(e_localDescriptor))
    m_localDescriptor.Encode(strm);
  if (HasOptionalField(e_remoteDescriptor))
    m_remoteDescriptor.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_IndAudStreamParms::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_IndAudStreamParms::Class()), PInvalidCast);
#endif
  return new H248_IndAudStreamParms(*this);
}


//
// IndAudSeqSigList
//

H248_IndAudSeqSigList::H248_IndAudSeqSigList(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, FALSE, 0)
{
  m_id.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void H248_IndAudSeqSigList::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+5) << "id = " << setprecision(indent) << m_id << '\n';
  if (HasOptionalField(e_signalList))
    strm << setw(indent+13) << "signalList = " << setprecision(indent) << m_signalList << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_IndAudSeqSigList::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_IndAudSeqSigList), PInvalidCast);
#endif
  const H248_IndAudSeqSigList & other = (const H248_IndAudSeqSigList &)obj;

  Comparison result;

  if ((result = m_id.Compare(other.m_id)) != EqualTo)
    return result;
  if ((result = m_signalList.Compare(other.m_signalList)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_IndAudSeqSigList::GetDataLength() const
{
  PINDEX length = 0;
  length += m_id.GetObjectLength();
  if (HasOptionalField(e_signalList))
    length += m_signalList.GetObjectLength();
  return length;
}


BOOL H248_IndAudSeqSigList::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_id.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_signalList) && !m_signalList.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_IndAudSeqSigList::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_id.Encode(strm);
  if (HasOptionalField(e_signalList))
    m_signalList.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_IndAudSeqSigList::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_IndAudSeqSigList::Class()), PInvalidCast);
#endif
  return new H248_IndAudSeqSigList(*this);
}


//
// NotifyRequest
//

H248_NotifyRequest::H248_NotifyRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_NotifyRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "terminationID = " << setprecision(indent) << m_terminationID << '\n';
  strm << setw(indent+27) << "observedEventsDescriptor = " << setprecision(indent) << m_observedEventsDescriptor << '\n';
  if (HasOptionalField(e_errorDescriptor))
    strm << setw(indent+18) << "errorDescriptor = " << setprecision(indent) << m_errorDescriptor << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_NotifyRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_NotifyRequest), PInvalidCast);
#endif
  const H248_NotifyRequest & other = (const H248_NotifyRequest &)obj;

  Comparison result;

  if ((result = m_terminationID.Compare(other.m_terminationID)) != EqualTo)
    return result;
  if ((result = m_observedEventsDescriptor.Compare(other.m_observedEventsDescriptor)) != EqualTo)
    return result;
  if ((result = m_errorDescriptor.Compare(other.m_errorDescriptor)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_NotifyRequest::GetDataLength() const
{
  PINDEX length = 0;
  length += m_terminationID.GetObjectLength();
  length += m_observedEventsDescriptor.GetObjectLength();
  if (HasOptionalField(e_errorDescriptor))
    length += m_errorDescriptor.GetObjectLength();
  return length;
}


BOOL H248_NotifyRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_terminationID.Decode(strm))
    return FALSE;
  if (!m_observedEventsDescriptor.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_errorDescriptor) && !m_errorDescriptor.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_NotifyRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_terminationID.Encode(strm);
  m_observedEventsDescriptor.Encode(strm);
  if (HasOptionalField(e_errorDescriptor))
    m_errorDescriptor.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_NotifyRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_NotifyRequest::Class()), PInvalidCast);
#endif
  return new H248_NotifyRequest(*this);
}


//
// ObservedEvent
//

H248_ObservedEvent::H248_ObservedEvent(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_ObservedEvent::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+12) << "eventName = " << setprecision(indent) << m_eventName << '\n';
  if (HasOptionalField(e_streamID))
    strm << setw(indent+11) << "streamID = " << setprecision(indent) << m_streamID << '\n';
  strm << setw(indent+15) << "eventParList = " << setprecision(indent) << m_eventParList << '\n';
  if (HasOptionalField(e_timeNotation))
    strm << setw(indent+15) << "timeNotation = " << setprecision(indent) << m_timeNotation << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_ObservedEvent::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_ObservedEvent), PInvalidCast);
#endif
  const H248_ObservedEvent & other = (const H248_ObservedEvent &)obj;

  Comparison result;

  if ((result = m_eventName.Compare(other.m_eventName)) != EqualTo)
    return result;
  if ((result = m_streamID.Compare(other.m_streamID)) != EqualTo)
    return result;
  if ((result = m_eventParList.Compare(other.m_eventParList)) != EqualTo)
    return result;
  if ((result = m_timeNotation.Compare(other.m_timeNotation)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_ObservedEvent::GetDataLength() const
{
  PINDEX length = 0;
  length += m_eventName.GetObjectLength();
  if (HasOptionalField(e_streamID))
    length += m_streamID.GetObjectLength();
  length += m_eventParList.GetObjectLength();
  if (HasOptionalField(e_timeNotation))
    length += m_timeNotation.GetObjectLength();
  return length;
}


BOOL H248_ObservedEvent::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_eventName.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_streamID) && !m_streamID.Decode(strm))
    return FALSE;
  if (!m_eventParList.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_timeNotation) && !m_timeNotation.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_ObservedEvent::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_eventName.Encode(strm);
  if (HasOptionalField(e_streamID))
    m_streamID.Encode(strm);
  m_eventParList.Encode(strm);
  if (HasOptionalField(e_timeNotation))
    m_timeNotation.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_ObservedEvent::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_ObservedEvent::Class()), PInvalidCast);
#endif
  return new H248_ObservedEvent(*this);
}


//
// MediaDescriptor
//

H248_MediaDescriptor::H248_MediaDescriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_MediaDescriptor::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_termStateDescr))
    strm << setw(indent+17) << "termStateDescr = " << setprecision(indent) << m_termStateDescr << '\n';
  if (HasOptionalField(e_streams))
    strm << setw(indent+10) << "streams = " << setprecision(indent) << m_streams << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_MediaDescriptor::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_MediaDescriptor), PInvalidCast);
#endif
  const H248_MediaDescriptor & other = (const H248_MediaDescriptor &)obj;

  Comparison result;

  if ((result = m_termStateDescr.Compare(other.m_termStateDescr)) != EqualTo)
    return result;
  if ((result = m_streams.Compare(other.m_streams)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_MediaDescriptor::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_termStateDescr))
    length += m_termStateDescr.GetObjectLength();
  if (HasOptionalField(e_streams))
    length += m_streams.GetObjectLength();
  return length;
}


BOOL H248_MediaDescriptor::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_termStateDescr) && !m_termStateDescr.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_streams) && !m_streams.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_MediaDescriptor::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_termStateDescr))
    m_termStateDescr.Encode(strm);
  if (HasOptionalField(e_streams))
    m_streams.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_MediaDescriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_MediaDescriptor::Class()), PInvalidCast);
#endif
  return new H248_MediaDescriptor(*this);
}


//
// StreamParms
//

H248_StreamParms::H248_StreamParms(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_StreamParms::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_localControlDescriptor))
    strm << setw(indent+25) << "localControlDescriptor = " << setprecision(indent) << m_localControlDescriptor << '\n';
  if (HasOptionalField(e_localDescriptor))
    strm << setw(indent+18) << "localDescriptor = " << setprecision(indent) << m_localDescriptor << '\n';
  if (HasOptionalField(e_remoteDescriptor))
    strm << setw(indent+19) << "remoteDescriptor = " << setprecision(indent) << m_remoteDescriptor << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_StreamParms::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_StreamParms), PInvalidCast);
#endif
  const H248_StreamParms & other = (const H248_StreamParms &)obj;

  Comparison result;

  if ((result = m_localControlDescriptor.Compare(other.m_localControlDescriptor)) != EqualTo)
    return result;
  if ((result = m_localDescriptor.Compare(other.m_localDescriptor)) != EqualTo)
    return result;
  if ((result = m_remoteDescriptor.Compare(other.m_remoteDescriptor)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_StreamParms::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_localControlDescriptor))
    length += m_localControlDescriptor.GetObjectLength();
  if (HasOptionalField(e_localDescriptor))
    length += m_localDescriptor.GetObjectLength();
  if (HasOptionalField(e_remoteDescriptor))
    length += m_remoteDescriptor.GetObjectLength();
  return length;
}


BOOL H248_StreamParms::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_localControlDescriptor) && !m_localControlDescriptor.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_localDescriptor) && !m_localDescriptor.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_remoteDescriptor) && !m_remoteDescriptor.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_StreamParms::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_localControlDescriptor))
    m_localControlDescriptor.Encode(strm);
  if (HasOptionalField(e_localDescriptor))
    m_localDescriptor.Encode(strm);
  if (HasOptionalField(e_remoteDescriptor))
    m_remoteDescriptor.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_StreamParms::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_StreamParms::Class()), PInvalidCast);
#endif
  return new H248_StreamParms(*this);
}


//
// MuxDescriptor
//

H248_MuxDescriptor::H248_MuxDescriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_MuxDescriptor::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+10) << "muxType = " << setprecision(indent) << m_muxType << '\n';
  strm << setw(indent+11) << "termList = " << setprecision(indent) << m_termList << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_MuxDescriptor::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_MuxDescriptor), PInvalidCast);
#endif
  const H248_MuxDescriptor & other = (const H248_MuxDescriptor &)obj;

  Comparison result;

  if ((result = m_muxType.Compare(other.m_muxType)) != EqualTo)
    return result;
  if ((result = m_termList.Compare(other.m_termList)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_MuxDescriptor::GetDataLength() const
{
  PINDEX length = 0;
  length += m_muxType.GetObjectLength();
  length += m_termList.GetObjectLength();
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  return length;
}


BOOL H248_MuxDescriptor::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_muxType.Decode(strm))
    return FALSE;
  if (!m_termList.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_MuxDescriptor::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_muxType.Encode(strm);
  m_termList.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_MuxDescriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_MuxDescriptor::Class()), PInvalidCast);
#endif
  return new H248_MuxDescriptor(*this);
}


//
// RequestedActions
//

H248_RequestedActions::H248_RequestedActions(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 4, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_RequestedActions::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_keepActive))
    strm << setw(indent+13) << "keepActive = " << setprecision(indent) << m_keepActive << '\n';
  if (HasOptionalField(e_eventDM))
    strm << setw(indent+10) << "eventDM = " << setprecision(indent) << m_eventDM << '\n';
  if (HasOptionalField(e_secondEvent))
    strm << setw(indent+14) << "secondEvent = " << setprecision(indent) << m_secondEvent << '\n';
  if (HasOptionalField(e_signalsDescriptor))
    strm << setw(indent+20) << "signalsDescriptor = " << setprecision(indent) << m_signalsDescriptor << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_RequestedActions::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_RequestedActions), PInvalidCast);
#endif
  const H248_RequestedActions & other = (const H248_RequestedActions &)obj;

  Comparison result;

  if ((result = m_keepActive.Compare(other.m_keepActive)) != EqualTo)
    return result;
  if ((result = m_eventDM.Compare(other.m_eventDM)) != EqualTo)
    return result;
  if ((result = m_secondEvent.Compare(other.m_secondEvent)) != EqualTo)
    return result;
  if ((result = m_signalsDescriptor.Compare(other.m_signalsDescriptor)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_RequestedActions::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_keepActive))
    length += m_keepActive.GetObjectLength();
  if (HasOptionalField(e_eventDM))
    length += m_eventDM.GetObjectLength();
  if (HasOptionalField(e_secondEvent))
    length += m_secondEvent.GetObjectLength();
  if (HasOptionalField(e_signalsDescriptor))
    length += m_signalsDescriptor.GetObjectLength();
  return length;
}


BOOL H248_RequestedActions::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_keepActive) && !m_keepActive.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_eventDM) && !m_eventDM.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_secondEvent) && !m_secondEvent.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_signalsDescriptor) && !m_signalsDescriptor.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_RequestedActions::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_keepActive))
    m_keepActive.Encode(strm);
  if (HasOptionalField(e_eventDM))
    m_eventDM.Encode(strm);
  if (HasOptionalField(e_secondEvent))
    m_secondEvent.Encode(strm);
  if (HasOptionalField(e_signalsDescriptor))
    m_signalsDescriptor.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_RequestedActions::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_RequestedActions::Class()), PInvalidCast);
#endif
  return new H248_RequestedActions(*this);
}


//
// SecondRequestedEvent
//

H248_SecondRequestedEvent::H248_SecondRequestedEvent(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_SecondRequestedEvent::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "pkgdName = " << setprecision(indent) << m_pkgdName << '\n';
  if (HasOptionalField(e_streamID))
    strm << setw(indent+11) << "streamID = " << setprecision(indent) << m_streamID << '\n';
  if (HasOptionalField(e_eventAction))
    strm << setw(indent+14) << "eventAction = " << setprecision(indent) << m_eventAction << '\n';
  strm << setw(indent+12) << "evParList = " << setprecision(indent) << m_evParList << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_SecondRequestedEvent::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_SecondRequestedEvent), PInvalidCast);
#endif
  const H248_SecondRequestedEvent & other = (const H248_SecondRequestedEvent &)obj;

  Comparison result;

  if ((result = m_pkgdName.Compare(other.m_pkgdName)) != EqualTo)
    return result;
  if ((result = m_streamID.Compare(other.m_streamID)) != EqualTo)
    return result;
  if ((result = m_eventAction.Compare(other.m_eventAction)) != EqualTo)
    return result;
  if ((result = m_evParList.Compare(other.m_evParList)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_SecondRequestedEvent::GetDataLength() const
{
  PINDEX length = 0;
  length += m_pkgdName.GetObjectLength();
  if (HasOptionalField(e_streamID))
    length += m_streamID.GetObjectLength();
  if (HasOptionalField(e_eventAction))
    length += m_eventAction.GetObjectLength();
  length += m_evParList.GetObjectLength();
  return length;
}


BOOL H248_SecondRequestedEvent::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_pkgdName.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_streamID) && !m_streamID.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_eventAction) && !m_eventAction.Decode(strm))
    return FALSE;
  if (!m_evParList.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_SecondRequestedEvent::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_pkgdName.Encode(strm);
  if (HasOptionalField(e_streamID))
    m_streamID.Encode(strm);
  if (HasOptionalField(e_eventAction))
    m_eventAction.Encode(strm);
  m_evParList.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_SecondRequestedEvent::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_SecondRequestedEvent::Class()), PInvalidCast);
#endif
  return new H248_SecondRequestedEvent(*this);
}


//
// ModemDescriptor
//

H248_ModemDescriptor::H248_ModemDescriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_ModemDescriptor::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+6) << "mtl = " << setprecision(indent) << m_mtl << '\n';
  strm << setw(indent+6) << "mpl = " << setprecision(indent) << m_mpl << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_ModemDescriptor::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_ModemDescriptor), PInvalidCast);
#endif
  const H248_ModemDescriptor & other = (const H248_ModemDescriptor &)obj;

  Comparison result;

  if ((result = m_mtl.Compare(other.m_mtl)) != EqualTo)
    return result;
  if ((result = m_mpl.Compare(other.m_mpl)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_ModemDescriptor::GetDataLength() const
{
  PINDEX length = 0;
  length += m_mtl.GetObjectLength();
  length += m_mpl.GetObjectLength();
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  return length;
}


BOOL H248_ModemDescriptor::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_mtl.Decode(strm))
    return FALSE;
  if (!m_mpl.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_ModemDescriptor::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_mtl.Encode(strm);
  m_mpl.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_ModemDescriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_ModemDescriptor::Class()), PInvalidCast);
#endif
  return new H248_ModemDescriptor(*this);
}


//
// ServiceChangeParm
//

H248_ServiceChangeParm::H248_ServiceChangeParm(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 7, TRUE, 1)
{
  m_serviceChangeVersion.SetConstraints(PASN_Object::FixedConstraint, 0, 99);
  m_serviceChangeDelay.SetConstraints(PASN_Object::FixedConstraint, 0, 4294967295U);
}


#ifndef PASN_NOPRINTON
void H248_ServiceChangeParm::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+22) << "serviceChangeMethod = " << setprecision(indent) << m_serviceChangeMethod << '\n';
  if (HasOptionalField(e_serviceChangeAddress))
    strm << setw(indent+23) << "serviceChangeAddress = " << setprecision(indent) << m_serviceChangeAddress << '\n';
  if (HasOptionalField(e_serviceChangeVersion))
    strm << setw(indent+23) << "serviceChangeVersion = " << setprecision(indent) << m_serviceChangeVersion << '\n';
  if (HasOptionalField(e_serviceChangeProfile))
    strm << setw(indent+23) << "serviceChangeProfile = " << setprecision(indent) << m_serviceChangeProfile << '\n';
  strm << setw(indent+22) << "serviceChangeReason = " << setprecision(indent) << m_serviceChangeReason << '\n';
  if (HasOptionalField(e_serviceChangeDelay))
    strm << setw(indent+21) << "serviceChangeDelay = " << setprecision(indent) << m_serviceChangeDelay << '\n';
  if (HasOptionalField(e_serviceChangeMgcId))
    strm << setw(indent+21) << "serviceChangeMgcId = " << setprecision(indent) << m_serviceChangeMgcId << '\n';
  if (HasOptionalField(e_timeStamp))
    strm << setw(indent+12) << "timeStamp = " << setprecision(indent) << m_timeStamp << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_serviceChangeInfo))
    strm << setw(indent+20) << "serviceChangeInfo = " << setprecision(indent) << m_serviceChangeInfo << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_ServiceChangeParm::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_ServiceChangeParm), PInvalidCast);
#endif
  const H248_ServiceChangeParm & other = (const H248_ServiceChangeParm &)obj;

  Comparison result;

  if ((result = m_serviceChangeMethod.Compare(other.m_serviceChangeMethod)) != EqualTo)
    return result;
  if ((result = m_serviceChangeAddress.Compare(other.m_serviceChangeAddress)) != EqualTo)
    return result;
  if ((result = m_serviceChangeVersion.Compare(other.m_serviceChangeVersion)) != EqualTo)
    return result;
  if ((result = m_serviceChangeProfile.Compare(other.m_serviceChangeProfile)) != EqualTo)
    return result;
  if ((result = m_serviceChangeReason.Compare(other.m_serviceChangeReason)) != EqualTo)
    return result;
  if ((result = m_serviceChangeDelay.Compare(other.m_serviceChangeDelay)) != EqualTo)
    return result;
  if ((result = m_serviceChangeMgcId.Compare(other.m_serviceChangeMgcId)) != EqualTo)
    return result;
  if ((result = m_timeStamp.Compare(other.m_timeStamp)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_ServiceChangeParm::GetDataLength() const
{
  PINDEX length = 0;
  length += m_serviceChangeMethod.GetObjectLength();
  if (HasOptionalField(e_serviceChangeAddress))
    length += m_serviceChangeAddress.GetObjectLength();
  if (HasOptionalField(e_serviceChangeVersion))
    length += m_serviceChangeVersion.GetObjectLength();
  if (HasOptionalField(e_serviceChangeProfile))
    length += m_serviceChangeProfile.GetObjectLength();
  length += m_serviceChangeReason.GetObjectLength();
  if (HasOptionalField(e_serviceChangeDelay))
    length += m_serviceChangeDelay.GetObjectLength();
  if (HasOptionalField(e_serviceChangeMgcId))
    length += m_serviceChangeMgcId.GetObjectLength();
  if (HasOptionalField(e_timeStamp))
    length += m_timeStamp.GetObjectLength();
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  return length;
}


BOOL H248_ServiceChangeParm::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_serviceChangeMethod.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_serviceChangeAddress) && !m_serviceChangeAddress.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_serviceChangeVersion) && !m_serviceChangeVersion.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_serviceChangeProfile) && !m_serviceChangeProfile.Decode(strm))
    return FALSE;
  if (!m_serviceChangeReason.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_serviceChangeDelay) && !m_serviceChangeDelay.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_serviceChangeMgcId) && !m_serviceChangeMgcId.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_timeStamp) && !m_timeStamp.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_serviceChangeInfo, m_serviceChangeInfo))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_ServiceChangeParm::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_serviceChangeMethod.Encode(strm);
  if (HasOptionalField(e_serviceChangeAddress))
    m_serviceChangeAddress.Encode(strm);
  if (HasOptionalField(e_serviceChangeVersion))
    m_serviceChangeVersion.Encode(strm);
  if (HasOptionalField(e_serviceChangeProfile))
    m_serviceChangeProfile.Encode(strm);
  m_serviceChangeReason.Encode(strm);
  if (HasOptionalField(e_serviceChangeDelay))
    m_serviceChangeDelay.Encode(strm);
  if (HasOptionalField(e_serviceChangeMgcId))
    m_serviceChangeMgcId.Encode(strm);
  if (HasOptionalField(e_timeStamp))
    m_timeStamp.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  KnownExtensionEncode(strm, e_serviceChangeInfo, m_serviceChangeInfo);

  UnknownExtensionsEncode(strm);
}


PObject * H248_ServiceChangeParm::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_ServiceChangeParm::Class()), PInvalidCast);
#endif
  return new H248_ServiceChangeParm(*this);
}


//
// IndAudStreamDescriptor
//

H248_IndAudStreamDescriptor::H248_IndAudStreamDescriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_IndAudStreamDescriptor::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "streamID = " << setprecision(indent) << m_streamID << '\n';
  strm << setw(indent+14) << "streamParms = " << setprecision(indent) << m_streamParms << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_IndAudStreamDescriptor::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_IndAudStreamDescriptor), PInvalidCast);
#endif
  const H248_IndAudStreamDescriptor & other = (const H248_IndAudStreamDescriptor &)obj;

  Comparison result;

  if ((result = m_streamID.Compare(other.m_streamID)) != EqualTo)
    return result;
  if ((result = m_streamParms.Compare(other.m_streamParms)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_IndAudStreamDescriptor::GetDataLength() const
{
  PINDEX length = 0;
  length += m_streamID.GetObjectLength();
  length += m_streamParms.GetObjectLength();
  return length;
}


BOOL H248_IndAudStreamDescriptor::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_streamID.Decode(strm))
    return FALSE;
  if (!m_streamParms.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_IndAudStreamDescriptor::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_streamID.Encode(strm);
  m_streamParms.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_IndAudStreamDescriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_IndAudStreamDescriptor::Class()), PInvalidCast);
#endif
  return new H248_IndAudStreamDescriptor(*this);
}


//
// ServiceChangeRequest
//

H248_ServiceChangeRequest::H248_ServiceChangeRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_ServiceChangeRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "terminationID = " << setprecision(indent) << m_terminationID << '\n';
  strm << setw(indent+21) << "serviceChangeParms = " << setprecision(indent) << m_serviceChangeParms << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_ServiceChangeRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_ServiceChangeRequest), PInvalidCast);
#endif
  const H248_ServiceChangeRequest & other = (const H248_ServiceChangeRequest &)obj;

  Comparison result;

  if ((result = m_terminationID.Compare(other.m_terminationID)) != EqualTo)
    return result;
  if ((result = m_serviceChangeParms.Compare(other.m_serviceChangeParms)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_ServiceChangeRequest::GetDataLength() const
{
  PINDEX length = 0;
  length += m_terminationID.GetObjectLength();
  length += m_serviceChangeParms.GetObjectLength();
  return length;
}


BOOL H248_ServiceChangeRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_terminationID.Decode(strm))
    return FALSE;
  if (!m_serviceChangeParms.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_ServiceChangeRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_terminationID.Encode(strm);
  m_serviceChangeParms.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_ServiceChangeRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_ServiceChangeRequest::Class()), PInvalidCast);
#endif
  return new H248_ServiceChangeRequest(*this);
}


//
// StreamDescriptor
//

H248_StreamDescriptor::H248_StreamDescriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_StreamDescriptor::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "streamID = " << setprecision(indent) << m_streamID << '\n';
  strm << setw(indent+14) << "streamParms = " << setprecision(indent) << m_streamParms << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_StreamDescriptor::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_StreamDescriptor), PInvalidCast);
#endif
  const H248_StreamDescriptor & other = (const H248_StreamDescriptor &)obj;

  Comparison result;

  if ((result = m_streamID.Compare(other.m_streamID)) != EqualTo)
    return result;
  if ((result = m_streamParms.Compare(other.m_streamParms)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_StreamDescriptor::GetDataLength() const
{
  PINDEX length = 0;
  length += m_streamID.GetObjectLength();
  length += m_streamParms.GetObjectLength();
  return length;
}


BOOL H248_StreamDescriptor::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_streamID.Decode(strm))
    return FALSE;
  if (!m_streamParms.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_StreamDescriptor::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_streamID.Encode(strm);
  m_streamParms.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_StreamDescriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_StreamDescriptor::Class()), PInvalidCast);
#endif
  return new H248_StreamDescriptor(*this);
}


//
// RequestedEvent
//

H248_RequestedEvent::H248_RequestedEvent(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H248_RequestedEvent::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "pkgdName = " << setprecision(indent) << m_pkgdName << '\n';
  if (HasOptionalField(e_streamID))
    strm << setw(indent+11) << "streamID = " << setprecision(indent) << m_streamID << '\n';
  if (HasOptionalField(e_eventAction))
    strm << setw(indent+14) << "eventAction = " << setprecision(indent) << m_eventAction << '\n';
  strm << setw(indent+12) << "evParList = " << setprecision(indent) << m_evParList << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H248_RequestedEvent::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H248_RequestedEvent), PInvalidCast);
#endif
  const H248_RequestedEvent & other = (const H248_RequestedEvent &)obj;

  Comparison result;

  if ((result = m_pkgdName.Compare(other.m_pkgdName)) != EqualTo)
    return result;
  if ((result = m_streamID.Compare(other.m_streamID)) != EqualTo)
    return result;
  if ((result = m_eventAction.Compare(other.m_eventAction)) != EqualTo)
    return result;
  if ((result = m_evParList.Compare(other.m_evParList)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H248_RequestedEvent::GetDataLength() const
{
  PINDEX length = 0;
  length += m_pkgdName.GetObjectLength();
  if (HasOptionalField(e_streamID))
    length += m_streamID.GetObjectLength();
  if (HasOptionalField(e_eventAction))
    length += m_eventAction.GetObjectLength();
  length += m_evParList.GetObjectLength();
  return length;
}


BOOL H248_RequestedEvent::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_pkgdName.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_streamID) && !m_streamID.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_eventAction) && !m_eventAction.Decode(strm))
    return FALSE;
  if (!m_evParList.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H248_RequestedEvent::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_pkgdName.Encode(strm);
  if (HasOptionalField(e_streamID))
    m_streamID.Encode(strm);
  if (HasOptionalField(e_eventAction))
    m_eventAction.Encode(strm);
  m_evParList.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H248_RequestedEvent::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H248_RequestedEvent::Class()), PInvalidCast);
#endif
  return new H248_RequestedEvent(*this);
}


#endif // if ! H323_DISABLE_H248


// End of h248.cxx
