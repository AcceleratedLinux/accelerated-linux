//
// h245_1.cxx
//
// Code automatically generated by asnparse.
//

#ifdef P_USE_PRAGMA
#pragma implementation "h245.h"
#endif

#include <ptlib.h>
#include "h245.h"

#define new PNEW


#if ! H323_DISABLE_H245


#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_MultimediaSystemControlMessage[]={
      {"request",0}
     ,{"response",1}
     ,{"command",2}
     ,{"indication",3}
};
#endif
//
// MultimediaSystemControlMessage
//

H245_MultimediaSystemControlMessage::H245_MultimediaSystemControlMessage(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_MultimediaSystemControlMessage,4
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultimediaSystemControlMessage::operator H245_RequestMessage &() const
#else
H245_MultimediaSystemControlMessage::operator H245_RequestMessage &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RequestMessage), PInvalidCast);
#endif
  return *(H245_RequestMessage *)choice;
}


H245_MultimediaSystemControlMessage::operator const H245_RequestMessage &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RequestMessage), PInvalidCast);
#endif
  return *(H245_RequestMessage *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultimediaSystemControlMessage::operator H245_ResponseMessage &() const
#else
H245_MultimediaSystemControlMessage::operator H245_ResponseMessage &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ResponseMessage), PInvalidCast);
#endif
  return *(H245_ResponseMessage *)choice;
}


H245_MultimediaSystemControlMessage::operator const H245_ResponseMessage &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ResponseMessage), PInvalidCast);
#endif
  return *(H245_ResponseMessage *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultimediaSystemControlMessage::operator H245_CommandMessage &() const
#else
H245_MultimediaSystemControlMessage::operator H245_CommandMessage &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_CommandMessage), PInvalidCast);
#endif
  return *(H245_CommandMessage *)choice;
}


H245_MultimediaSystemControlMessage::operator const H245_CommandMessage &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_CommandMessage), PInvalidCast);
#endif
  return *(H245_CommandMessage *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultimediaSystemControlMessage::operator H245_IndicationMessage &() const
#else
H245_MultimediaSystemControlMessage::operator H245_IndicationMessage &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_IndicationMessage), PInvalidCast);
#endif
  return *(H245_IndicationMessage *)choice;
}


H245_MultimediaSystemControlMessage::operator const H245_IndicationMessage &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_IndicationMessage), PInvalidCast);
#endif
  return *(H245_IndicationMessage *)choice;
}


BOOL H245_MultimediaSystemControlMessage::CreateObject()
{
  switch (tag) {
    case e_request :
      choice = new H245_RequestMessage();
      return TRUE;
    case e_response :
      choice = new H245_ResponseMessage();
      return TRUE;
    case e_command :
      choice = new H245_CommandMessage();
      return TRUE;
    case e_indication :
      choice = new H245_IndicationMessage();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_MultimediaSystemControlMessage::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultimediaSystemControlMessage::Class()), PInvalidCast);
#endif
  return new H245_MultimediaSystemControlMessage(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_RequestMessage[]={
      {"nonStandard",0}
     ,{"masterSlaveDetermination",1}
     ,{"terminalCapabilitySet",2}
     ,{"openLogicalChannel",3}
     ,{"closeLogicalChannel",4}
     ,{"requestChannelClose",5}
     ,{"multiplexEntrySend",6}
     ,{"requestMultiplexEntry",7}
     ,{"requestMode",8}
     ,{"roundTripDelayRequest",9}
     ,{"maintenanceLoopRequest",10}
     ,{"communicationModeRequest",11}
     ,{"conferenceRequest",12}
     ,{"multilinkRequest",13}
     ,{"logicalChannelRateRequest",14}
     ,{"genericRequest",15}
};
#endif
//
// RequestMessage
//

H245_RequestMessage::H245_RequestMessage(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 11, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_RequestMessage,16
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RequestMessage::operator H245_NonStandardMessage &() const
#else
H245_RequestMessage::operator H245_NonStandardMessage &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardMessage), PInvalidCast);
#endif
  return *(H245_NonStandardMessage *)choice;
}


H245_RequestMessage::operator const H245_NonStandardMessage &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardMessage), PInvalidCast);
#endif
  return *(H245_NonStandardMessage *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RequestMessage::operator H245_MasterSlaveDetermination &() const
#else
H245_RequestMessage::operator H245_MasterSlaveDetermination &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MasterSlaveDetermination), PInvalidCast);
#endif
  return *(H245_MasterSlaveDetermination *)choice;
}


H245_RequestMessage::operator const H245_MasterSlaveDetermination &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MasterSlaveDetermination), PInvalidCast);
#endif
  return *(H245_MasterSlaveDetermination *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RequestMessage::operator H245_TerminalCapabilitySet &() const
#else
H245_RequestMessage::operator H245_TerminalCapabilitySet &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_TerminalCapabilitySet), PInvalidCast);
#endif
  return *(H245_TerminalCapabilitySet *)choice;
}


H245_RequestMessage::operator const H245_TerminalCapabilitySet &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_TerminalCapabilitySet), PInvalidCast);
#endif
  return *(H245_TerminalCapabilitySet *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RequestMessage::operator H245_OpenLogicalChannel &() const
#else
H245_RequestMessage::operator H245_OpenLogicalChannel &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_OpenLogicalChannel), PInvalidCast);
#endif
  return *(H245_OpenLogicalChannel *)choice;
}


H245_RequestMessage::operator const H245_OpenLogicalChannel &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_OpenLogicalChannel), PInvalidCast);
#endif
  return *(H245_OpenLogicalChannel *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RequestMessage::operator H245_CloseLogicalChannel &() const
#else
H245_RequestMessage::operator H245_CloseLogicalChannel &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_CloseLogicalChannel), PInvalidCast);
#endif
  return *(H245_CloseLogicalChannel *)choice;
}


H245_RequestMessage::operator const H245_CloseLogicalChannel &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_CloseLogicalChannel), PInvalidCast);
#endif
  return *(H245_CloseLogicalChannel *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RequestMessage::operator H245_RequestChannelClose &() const
#else
H245_RequestMessage::operator H245_RequestChannelClose &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RequestChannelClose), PInvalidCast);
#endif
  return *(H245_RequestChannelClose *)choice;
}


H245_RequestMessage::operator const H245_RequestChannelClose &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RequestChannelClose), PInvalidCast);
#endif
  return *(H245_RequestChannelClose *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RequestMessage::operator H245_MultiplexEntrySend &() const
#else
H245_RequestMessage::operator H245_MultiplexEntrySend &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultiplexEntrySend), PInvalidCast);
#endif
  return *(H245_MultiplexEntrySend *)choice;
}


H245_RequestMessage::operator const H245_MultiplexEntrySend &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultiplexEntrySend), PInvalidCast);
#endif
  return *(H245_MultiplexEntrySend *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RequestMessage::operator H245_RequestMultiplexEntry &() const
#else
H245_RequestMessage::operator H245_RequestMultiplexEntry &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RequestMultiplexEntry), PInvalidCast);
#endif
  return *(H245_RequestMultiplexEntry *)choice;
}


H245_RequestMessage::operator const H245_RequestMultiplexEntry &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RequestMultiplexEntry), PInvalidCast);
#endif
  return *(H245_RequestMultiplexEntry *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RequestMessage::operator H245_RequestMode &() const
#else
H245_RequestMessage::operator H245_RequestMode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RequestMode), PInvalidCast);
#endif
  return *(H245_RequestMode *)choice;
}


H245_RequestMessage::operator const H245_RequestMode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RequestMode), PInvalidCast);
#endif
  return *(H245_RequestMode *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RequestMessage::operator H245_RoundTripDelayRequest &() const
#else
H245_RequestMessage::operator H245_RoundTripDelayRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RoundTripDelayRequest), PInvalidCast);
#endif
  return *(H245_RoundTripDelayRequest *)choice;
}


H245_RequestMessage::operator const H245_RoundTripDelayRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RoundTripDelayRequest), PInvalidCast);
#endif
  return *(H245_RoundTripDelayRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RequestMessage::operator H245_MaintenanceLoopRequest &() const
#else
H245_RequestMessage::operator H245_MaintenanceLoopRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MaintenanceLoopRequest), PInvalidCast);
#endif
  return *(H245_MaintenanceLoopRequest *)choice;
}


H245_RequestMessage::operator const H245_MaintenanceLoopRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MaintenanceLoopRequest), PInvalidCast);
#endif
  return *(H245_MaintenanceLoopRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RequestMessage::operator H245_CommunicationModeRequest &() const
#else
H245_RequestMessage::operator H245_CommunicationModeRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_CommunicationModeRequest), PInvalidCast);
#endif
  return *(H245_CommunicationModeRequest *)choice;
}


H245_RequestMessage::operator const H245_CommunicationModeRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_CommunicationModeRequest), PInvalidCast);
#endif
  return *(H245_CommunicationModeRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RequestMessage::operator H245_ConferenceRequest &() const
#else
H245_RequestMessage::operator H245_ConferenceRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ConferenceRequest), PInvalidCast);
#endif
  return *(H245_ConferenceRequest *)choice;
}


H245_RequestMessage::operator const H245_ConferenceRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ConferenceRequest), PInvalidCast);
#endif
  return *(H245_ConferenceRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RequestMessage::operator H245_MultilinkRequest &() const
#else
H245_RequestMessage::operator H245_MultilinkRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultilinkRequest), PInvalidCast);
#endif
  return *(H245_MultilinkRequest *)choice;
}


H245_RequestMessage::operator const H245_MultilinkRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultilinkRequest), PInvalidCast);
#endif
  return *(H245_MultilinkRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RequestMessage::operator H245_LogicalChannelRateRequest &() const
#else
H245_RequestMessage::operator H245_LogicalChannelRateRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_LogicalChannelRateRequest), PInvalidCast);
#endif
  return *(H245_LogicalChannelRateRequest *)choice;
}


H245_RequestMessage::operator const H245_LogicalChannelRateRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_LogicalChannelRateRequest), PInvalidCast);
#endif
  return *(H245_LogicalChannelRateRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RequestMessage::operator H245_GenericMessage &() const
#else
H245_RequestMessage::operator H245_GenericMessage &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_GenericMessage), PInvalidCast);
#endif
  return *(H245_GenericMessage *)choice;
}


H245_RequestMessage::operator const H245_GenericMessage &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_GenericMessage), PInvalidCast);
#endif
  return *(H245_GenericMessage *)choice;
}


BOOL H245_RequestMessage::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardMessage();
      return TRUE;
    case e_masterSlaveDetermination :
      choice = new H245_MasterSlaveDetermination();
      return TRUE;
    case e_terminalCapabilitySet :
      choice = new H245_TerminalCapabilitySet();
      return TRUE;
    case e_openLogicalChannel :
      choice = new H245_OpenLogicalChannel();
      return TRUE;
    case e_closeLogicalChannel :
      choice = new H245_CloseLogicalChannel();
      return TRUE;
    case e_requestChannelClose :
      choice = new H245_RequestChannelClose();
      return TRUE;
    case e_multiplexEntrySend :
      choice = new H245_MultiplexEntrySend();
      return TRUE;
    case e_requestMultiplexEntry :
      choice = new H245_RequestMultiplexEntry();
      return TRUE;
    case e_requestMode :
      choice = new H245_RequestMode();
      return TRUE;
    case e_roundTripDelayRequest :
      choice = new H245_RoundTripDelayRequest();
      return TRUE;
    case e_maintenanceLoopRequest :
      choice = new H245_MaintenanceLoopRequest();
      return TRUE;
    case e_communicationModeRequest :
      choice = new H245_CommunicationModeRequest();
      return TRUE;
    case e_conferenceRequest :
      choice = new H245_ConferenceRequest();
      return TRUE;
    case e_multilinkRequest :
      choice = new H245_MultilinkRequest();
      return TRUE;
    case e_logicalChannelRateRequest :
      choice = new H245_LogicalChannelRateRequest();
      return TRUE;
    case e_genericRequest :
      choice = new H245_GenericMessage();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_RequestMessage::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RequestMessage::Class()), PInvalidCast);
#endif
  return new H245_RequestMessage(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_ResponseMessage[]={
      {"nonStandard",0}
     ,{"masterSlaveDeterminationAck",1}
     ,{"masterSlaveDeterminationReject",2}
     ,{"terminalCapabilitySetAck",3}
     ,{"terminalCapabilitySetReject",4}
     ,{"openLogicalChannelAck",5}
     ,{"openLogicalChannelReject",6}
     ,{"closeLogicalChannelAck",7}
     ,{"requestChannelCloseAck",8}
     ,{"requestChannelCloseReject",9}
     ,{"multiplexEntrySendAck",10}
     ,{"multiplexEntrySendReject",11}
     ,{"requestMultiplexEntryAck",12}
     ,{"requestMultiplexEntryReject",13}
     ,{"requestModeAck",14}
     ,{"requestModeReject",15}
     ,{"roundTripDelayResponse",16}
     ,{"maintenanceLoopAck",17}
     ,{"maintenanceLoopReject",18}
     ,{"communicationModeResponse",19}
     ,{"conferenceResponse",20}
     ,{"multilinkResponse",21}
     ,{"logicalChannelRateAcknowledge",22}
     ,{"logicalChannelRateReject",23}
     ,{"genericResponse",24}
};
#endif
//
// ResponseMessage
//

H245_ResponseMessage::H245_ResponseMessage(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 19, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_ResponseMessage,25
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ResponseMessage::operator H245_NonStandardMessage &() const
#else
H245_ResponseMessage::operator H245_NonStandardMessage &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardMessage), PInvalidCast);
#endif
  return *(H245_NonStandardMessage *)choice;
}


H245_ResponseMessage::operator const H245_NonStandardMessage &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardMessage), PInvalidCast);
#endif
  return *(H245_NonStandardMessage *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ResponseMessage::operator H245_MasterSlaveDeterminationAck &() const
#else
H245_ResponseMessage::operator H245_MasterSlaveDeterminationAck &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MasterSlaveDeterminationAck), PInvalidCast);
#endif
  return *(H245_MasterSlaveDeterminationAck *)choice;
}


H245_ResponseMessage::operator const H245_MasterSlaveDeterminationAck &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MasterSlaveDeterminationAck), PInvalidCast);
#endif
  return *(H245_MasterSlaveDeterminationAck *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ResponseMessage::operator H245_MasterSlaveDeterminationReject &() const
#else
H245_ResponseMessage::operator H245_MasterSlaveDeterminationReject &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MasterSlaveDeterminationReject), PInvalidCast);
#endif
  return *(H245_MasterSlaveDeterminationReject *)choice;
}


H245_ResponseMessage::operator const H245_MasterSlaveDeterminationReject &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MasterSlaveDeterminationReject), PInvalidCast);
#endif
  return *(H245_MasterSlaveDeterminationReject *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ResponseMessage::operator H245_TerminalCapabilitySetAck &() const
#else
H245_ResponseMessage::operator H245_TerminalCapabilitySetAck &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_TerminalCapabilitySetAck), PInvalidCast);
#endif
  return *(H245_TerminalCapabilitySetAck *)choice;
}


H245_ResponseMessage::operator const H245_TerminalCapabilitySetAck &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_TerminalCapabilitySetAck), PInvalidCast);
#endif
  return *(H245_TerminalCapabilitySetAck *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ResponseMessage::operator H245_TerminalCapabilitySetReject &() const
#else
H245_ResponseMessage::operator H245_TerminalCapabilitySetReject &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_TerminalCapabilitySetReject), PInvalidCast);
#endif
  return *(H245_TerminalCapabilitySetReject *)choice;
}


H245_ResponseMessage::operator const H245_TerminalCapabilitySetReject &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_TerminalCapabilitySetReject), PInvalidCast);
#endif
  return *(H245_TerminalCapabilitySetReject *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ResponseMessage::operator H245_OpenLogicalChannelAck &() const
#else
H245_ResponseMessage::operator H245_OpenLogicalChannelAck &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_OpenLogicalChannelAck), PInvalidCast);
#endif
  return *(H245_OpenLogicalChannelAck *)choice;
}


H245_ResponseMessage::operator const H245_OpenLogicalChannelAck &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_OpenLogicalChannelAck), PInvalidCast);
#endif
  return *(H245_OpenLogicalChannelAck *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ResponseMessage::operator H245_OpenLogicalChannelReject &() const
#else
H245_ResponseMessage::operator H245_OpenLogicalChannelReject &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_OpenLogicalChannelReject), PInvalidCast);
#endif
  return *(H245_OpenLogicalChannelReject *)choice;
}


H245_ResponseMessage::operator const H245_OpenLogicalChannelReject &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_OpenLogicalChannelReject), PInvalidCast);
#endif
  return *(H245_OpenLogicalChannelReject *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ResponseMessage::operator H245_CloseLogicalChannelAck &() const
#else
H245_ResponseMessage::operator H245_CloseLogicalChannelAck &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_CloseLogicalChannelAck), PInvalidCast);
#endif
  return *(H245_CloseLogicalChannelAck *)choice;
}


H245_ResponseMessage::operator const H245_CloseLogicalChannelAck &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_CloseLogicalChannelAck), PInvalidCast);
#endif
  return *(H245_CloseLogicalChannelAck *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ResponseMessage::operator H245_RequestChannelCloseAck &() const
#else
H245_ResponseMessage::operator H245_RequestChannelCloseAck &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RequestChannelCloseAck), PInvalidCast);
#endif
  return *(H245_RequestChannelCloseAck *)choice;
}


H245_ResponseMessage::operator const H245_RequestChannelCloseAck &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RequestChannelCloseAck), PInvalidCast);
#endif
  return *(H245_RequestChannelCloseAck *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ResponseMessage::operator H245_RequestChannelCloseReject &() const
#else
H245_ResponseMessage::operator H245_RequestChannelCloseReject &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RequestChannelCloseReject), PInvalidCast);
#endif
  return *(H245_RequestChannelCloseReject *)choice;
}


H245_ResponseMessage::operator const H245_RequestChannelCloseReject &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RequestChannelCloseReject), PInvalidCast);
#endif
  return *(H245_RequestChannelCloseReject *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ResponseMessage::operator H245_MultiplexEntrySendAck &() const
#else
H245_ResponseMessage::operator H245_MultiplexEntrySendAck &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultiplexEntrySendAck), PInvalidCast);
#endif
  return *(H245_MultiplexEntrySendAck *)choice;
}


H245_ResponseMessage::operator const H245_MultiplexEntrySendAck &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultiplexEntrySendAck), PInvalidCast);
#endif
  return *(H245_MultiplexEntrySendAck *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ResponseMessage::operator H245_MultiplexEntrySendReject &() const
#else
H245_ResponseMessage::operator H245_MultiplexEntrySendReject &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultiplexEntrySendReject), PInvalidCast);
#endif
  return *(H245_MultiplexEntrySendReject *)choice;
}


H245_ResponseMessage::operator const H245_MultiplexEntrySendReject &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultiplexEntrySendReject), PInvalidCast);
#endif
  return *(H245_MultiplexEntrySendReject *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ResponseMessage::operator H245_RequestMultiplexEntryAck &() const
#else
H245_ResponseMessage::operator H245_RequestMultiplexEntryAck &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RequestMultiplexEntryAck), PInvalidCast);
#endif
  return *(H245_RequestMultiplexEntryAck *)choice;
}


H245_ResponseMessage::operator const H245_RequestMultiplexEntryAck &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RequestMultiplexEntryAck), PInvalidCast);
#endif
  return *(H245_RequestMultiplexEntryAck *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ResponseMessage::operator H245_RequestMultiplexEntryReject &() const
#else
H245_ResponseMessage::operator H245_RequestMultiplexEntryReject &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RequestMultiplexEntryReject), PInvalidCast);
#endif
  return *(H245_RequestMultiplexEntryReject *)choice;
}


H245_ResponseMessage::operator const H245_RequestMultiplexEntryReject &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RequestMultiplexEntryReject), PInvalidCast);
#endif
  return *(H245_RequestMultiplexEntryReject *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ResponseMessage::operator H245_RequestModeAck &() const
#else
H245_ResponseMessage::operator H245_RequestModeAck &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RequestModeAck), PInvalidCast);
#endif
  return *(H245_RequestModeAck *)choice;
}


H245_ResponseMessage::operator const H245_RequestModeAck &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RequestModeAck), PInvalidCast);
#endif
  return *(H245_RequestModeAck *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ResponseMessage::operator H245_RequestModeReject &() const
#else
H245_ResponseMessage::operator H245_RequestModeReject &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RequestModeReject), PInvalidCast);
#endif
  return *(H245_RequestModeReject *)choice;
}


H245_ResponseMessage::operator const H245_RequestModeReject &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RequestModeReject), PInvalidCast);
#endif
  return *(H245_RequestModeReject *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ResponseMessage::operator H245_RoundTripDelayResponse &() const
#else
H245_ResponseMessage::operator H245_RoundTripDelayResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RoundTripDelayResponse), PInvalidCast);
#endif
  return *(H245_RoundTripDelayResponse *)choice;
}


H245_ResponseMessage::operator const H245_RoundTripDelayResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RoundTripDelayResponse), PInvalidCast);
#endif
  return *(H245_RoundTripDelayResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ResponseMessage::operator H245_MaintenanceLoopAck &() const
#else
H245_ResponseMessage::operator H245_MaintenanceLoopAck &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MaintenanceLoopAck), PInvalidCast);
#endif
  return *(H245_MaintenanceLoopAck *)choice;
}


H245_ResponseMessage::operator const H245_MaintenanceLoopAck &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MaintenanceLoopAck), PInvalidCast);
#endif
  return *(H245_MaintenanceLoopAck *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ResponseMessage::operator H245_MaintenanceLoopReject &() const
#else
H245_ResponseMessage::operator H245_MaintenanceLoopReject &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MaintenanceLoopReject), PInvalidCast);
#endif
  return *(H245_MaintenanceLoopReject *)choice;
}


H245_ResponseMessage::operator const H245_MaintenanceLoopReject &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MaintenanceLoopReject), PInvalidCast);
#endif
  return *(H245_MaintenanceLoopReject *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ResponseMessage::operator H245_CommunicationModeResponse &() const
#else
H245_ResponseMessage::operator H245_CommunicationModeResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_CommunicationModeResponse), PInvalidCast);
#endif
  return *(H245_CommunicationModeResponse *)choice;
}


H245_ResponseMessage::operator const H245_CommunicationModeResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_CommunicationModeResponse), PInvalidCast);
#endif
  return *(H245_CommunicationModeResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ResponseMessage::operator H245_ConferenceResponse &() const
#else
H245_ResponseMessage::operator H245_ConferenceResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ConferenceResponse), PInvalidCast);
#endif
  return *(H245_ConferenceResponse *)choice;
}


H245_ResponseMessage::operator const H245_ConferenceResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ConferenceResponse), PInvalidCast);
#endif
  return *(H245_ConferenceResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ResponseMessage::operator H245_MultilinkResponse &() const
#else
H245_ResponseMessage::operator H245_MultilinkResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultilinkResponse), PInvalidCast);
#endif
  return *(H245_MultilinkResponse *)choice;
}


H245_ResponseMessage::operator const H245_MultilinkResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultilinkResponse), PInvalidCast);
#endif
  return *(H245_MultilinkResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ResponseMessage::operator H245_LogicalChannelRateAcknowledge &() const
#else
H245_ResponseMessage::operator H245_LogicalChannelRateAcknowledge &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_LogicalChannelRateAcknowledge), PInvalidCast);
#endif
  return *(H245_LogicalChannelRateAcknowledge *)choice;
}


H245_ResponseMessage::operator const H245_LogicalChannelRateAcknowledge &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_LogicalChannelRateAcknowledge), PInvalidCast);
#endif
  return *(H245_LogicalChannelRateAcknowledge *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ResponseMessage::operator H245_LogicalChannelRateReject &() const
#else
H245_ResponseMessage::operator H245_LogicalChannelRateReject &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_LogicalChannelRateReject), PInvalidCast);
#endif
  return *(H245_LogicalChannelRateReject *)choice;
}


H245_ResponseMessage::operator const H245_LogicalChannelRateReject &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_LogicalChannelRateReject), PInvalidCast);
#endif
  return *(H245_LogicalChannelRateReject *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ResponseMessage::operator H245_GenericMessage &() const
#else
H245_ResponseMessage::operator H245_GenericMessage &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_GenericMessage), PInvalidCast);
#endif
  return *(H245_GenericMessage *)choice;
}


H245_ResponseMessage::operator const H245_GenericMessage &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_GenericMessage), PInvalidCast);
#endif
  return *(H245_GenericMessage *)choice;
}


BOOL H245_ResponseMessage::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardMessage();
      return TRUE;
    case e_masterSlaveDeterminationAck :
      choice = new H245_MasterSlaveDeterminationAck();
      return TRUE;
    case e_masterSlaveDeterminationReject :
      choice = new H245_MasterSlaveDeterminationReject();
      return TRUE;
    case e_terminalCapabilitySetAck :
      choice = new H245_TerminalCapabilitySetAck();
      return TRUE;
    case e_terminalCapabilitySetReject :
      choice = new H245_TerminalCapabilitySetReject();
      return TRUE;
    case e_openLogicalChannelAck :
      choice = new H245_OpenLogicalChannelAck();
      return TRUE;
    case e_openLogicalChannelReject :
      choice = new H245_OpenLogicalChannelReject();
      return TRUE;
    case e_closeLogicalChannelAck :
      choice = new H245_CloseLogicalChannelAck();
      return TRUE;
    case e_requestChannelCloseAck :
      choice = new H245_RequestChannelCloseAck();
      return TRUE;
    case e_requestChannelCloseReject :
      choice = new H245_RequestChannelCloseReject();
      return TRUE;
    case e_multiplexEntrySendAck :
      choice = new H245_MultiplexEntrySendAck();
      return TRUE;
    case e_multiplexEntrySendReject :
      choice = new H245_MultiplexEntrySendReject();
      return TRUE;
    case e_requestMultiplexEntryAck :
      choice = new H245_RequestMultiplexEntryAck();
      return TRUE;
    case e_requestMultiplexEntryReject :
      choice = new H245_RequestMultiplexEntryReject();
      return TRUE;
    case e_requestModeAck :
      choice = new H245_RequestModeAck();
      return TRUE;
    case e_requestModeReject :
      choice = new H245_RequestModeReject();
      return TRUE;
    case e_roundTripDelayResponse :
      choice = new H245_RoundTripDelayResponse();
      return TRUE;
    case e_maintenanceLoopAck :
      choice = new H245_MaintenanceLoopAck();
      return TRUE;
    case e_maintenanceLoopReject :
      choice = new H245_MaintenanceLoopReject();
      return TRUE;
    case e_communicationModeResponse :
      choice = new H245_CommunicationModeResponse();
      return TRUE;
    case e_conferenceResponse :
      choice = new H245_ConferenceResponse();
      return TRUE;
    case e_multilinkResponse :
      choice = new H245_MultilinkResponse();
      return TRUE;
    case e_logicalChannelRateAcknowledge :
      choice = new H245_LogicalChannelRateAcknowledge();
      return TRUE;
    case e_logicalChannelRateReject :
      choice = new H245_LogicalChannelRateReject();
      return TRUE;
    case e_genericResponse :
      choice = new H245_GenericMessage();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_ResponseMessage::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ResponseMessage::Class()), PInvalidCast);
#endif
  return new H245_ResponseMessage(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_CommandMessage[]={
      {"nonStandard",0}
     ,{"maintenanceLoopOffCommand",1}
     ,{"sendTerminalCapabilitySet",2}
     ,{"encryptionCommand",3}
     ,{"flowControlCommand",4}
     ,{"endSessionCommand",5}
     ,{"miscellaneousCommand",6}
     ,{"communicationModeCommand",7}
     ,{"conferenceCommand",8}
     ,{"h223MultiplexReconfiguration",9}
     ,{"newATMVCCommand",10}
     ,{"mobileMultilinkReconfigurationCommand",11}
     ,{"genericCommand",12}
};
#endif
//
// CommandMessage
//

H245_CommandMessage::H245_CommandMessage(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 7, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_CommandMessage,13
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_CommandMessage::operator H245_NonStandardMessage &() const
#else
H245_CommandMessage::operator H245_NonStandardMessage &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardMessage), PInvalidCast);
#endif
  return *(H245_NonStandardMessage *)choice;
}


H245_CommandMessage::operator const H245_NonStandardMessage &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardMessage), PInvalidCast);
#endif
  return *(H245_NonStandardMessage *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_CommandMessage::operator H245_MaintenanceLoopOffCommand &() const
#else
H245_CommandMessage::operator H245_MaintenanceLoopOffCommand &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MaintenanceLoopOffCommand), PInvalidCast);
#endif
  return *(H245_MaintenanceLoopOffCommand *)choice;
}


H245_CommandMessage::operator const H245_MaintenanceLoopOffCommand &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MaintenanceLoopOffCommand), PInvalidCast);
#endif
  return *(H245_MaintenanceLoopOffCommand *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_CommandMessage::operator H245_SendTerminalCapabilitySet &() const
#else
H245_CommandMessage::operator H245_SendTerminalCapabilitySet &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_SendTerminalCapabilitySet), PInvalidCast);
#endif
  return *(H245_SendTerminalCapabilitySet *)choice;
}


H245_CommandMessage::operator const H245_SendTerminalCapabilitySet &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_SendTerminalCapabilitySet), PInvalidCast);
#endif
  return *(H245_SendTerminalCapabilitySet *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_CommandMessage::operator H245_EncryptionCommand &() const
#else
H245_CommandMessage::operator H245_EncryptionCommand &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_EncryptionCommand), PInvalidCast);
#endif
  return *(H245_EncryptionCommand *)choice;
}


H245_CommandMessage::operator const H245_EncryptionCommand &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_EncryptionCommand), PInvalidCast);
#endif
  return *(H245_EncryptionCommand *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_CommandMessage::operator H245_FlowControlCommand &() const
#else
H245_CommandMessage::operator H245_FlowControlCommand &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_FlowControlCommand), PInvalidCast);
#endif
  return *(H245_FlowControlCommand *)choice;
}


H245_CommandMessage::operator const H245_FlowControlCommand &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_FlowControlCommand), PInvalidCast);
#endif
  return *(H245_FlowControlCommand *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_CommandMessage::operator H245_EndSessionCommand &() const
#else
H245_CommandMessage::operator H245_EndSessionCommand &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_EndSessionCommand), PInvalidCast);
#endif
  return *(H245_EndSessionCommand *)choice;
}


H245_CommandMessage::operator const H245_EndSessionCommand &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_EndSessionCommand), PInvalidCast);
#endif
  return *(H245_EndSessionCommand *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_CommandMessage::operator H245_MiscellaneousCommand &() const
#else
H245_CommandMessage::operator H245_MiscellaneousCommand &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MiscellaneousCommand), PInvalidCast);
#endif
  return *(H245_MiscellaneousCommand *)choice;
}


H245_CommandMessage::operator const H245_MiscellaneousCommand &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MiscellaneousCommand), PInvalidCast);
#endif
  return *(H245_MiscellaneousCommand *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_CommandMessage::operator H245_CommunicationModeCommand &() const
#else
H245_CommandMessage::operator H245_CommunicationModeCommand &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_CommunicationModeCommand), PInvalidCast);
#endif
  return *(H245_CommunicationModeCommand *)choice;
}


H245_CommandMessage::operator const H245_CommunicationModeCommand &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_CommunicationModeCommand), PInvalidCast);
#endif
  return *(H245_CommunicationModeCommand *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_CommandMessage::operator H245_ConferenceCommand &() const
#else
H245_CommandMessage::operator H245_ConferenceCommand &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ConferenceCommand), PInvalidCast);
#endif
  return *(H245_ConferenceCommand *)choice;
}


H245_CommandMessage::operator const H245_ConferenceCommand &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ConferenceCommand), PInvalidCast);
#endif
  return *(H245_ConferenceCommand *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_CommandMessage::operator H245_H223MultiplexReconfiguration &() const
#else
H245_CommandMessage::operator H245_H223MultiplexReconfiguration &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H223MultiplexReconfiguration), PInvalidCast);
#endif
  return *(H245_H223MultiplexReconfiguration *)choice;
}


H245_CommandMessage::operator const H245_H223MultiplexReconfiguration &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H223MultiplexReconfiguration), PInvalidCast);
#endif
  return *(H245_H223MultiplexReconfiguration *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_CommandMessage::operator H245_NewATMVCCommand &() const
#else
H245_CommandMessage::operator H245_NewATMVCCommand &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NewATMVCCommand), PInvalidCast);
#endif
  return *(H245_NewATMVCCommand *)choice;
}


H245_CommandMessage::operator const H245_NewATMVCCommand &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NewATMVCCommand), PInvalidCast);
#endif
  return *(H245_NewATMVCCommand *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_CommandMessage::operator H245_MobileMultilinkReconfigurationCommand &() const
#else
H245_CommandMessage::operator H245_MobileMultilinkReconfigurationCommand &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MobileMultilinkReconfigurationCommand), PInvalidCast);
#endif
  return *(H245_MobileMultilinkReconfigurationCommand *)choice;
}


H245_CommandMessage::operator const H245_MobileMultilinkReconfigurationCommand &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MobileMultilinkReconfigurationCommand), PInvalidCast);
#endif
  return *(H245_MobileMultilinkReconfigurationCommand *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_CommandMessage::operator H245_GenericMessage &() const
#else
H245_CommandMessage::operator H245_GenericMessage &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_GenericMessage), PInvalidCast);
#endif
  return *(H245_GenericMessage *)choice;
}


H245_CommandMessage::operator const H245_GenericMessage &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_GenericMessage), PInvalidCast);
#endif
  return *(H245_GenericMessage *)choice;
}


BOOL H245_CommandMessage::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardMessage();
      return TRUE;
    case e_maintenanceLoopOffCommand :
      choice = new H245_MaintenanceLoopOffCommand();
      return TRUE;
    case e_sendTerminalCapabilitySet :
      choice = new H245_SendTerminalCapabilitySet();
      return TRUE;
    case e_encryptionCommand :
      choice = new H245_EncryptionCommand();
      return TRUE;
    case e_flowControlCommand :
      choice = new H245_FlowControlCommand();
      return TRUE;
    case e_endSessionCommand :
      choice = new H245_EndSessionCommand();
      return TRUE;
    case e_miscellaneousCommand :
      choice = new H245_MiscellaneousCommand();
      return TRUE;
    case e_communicationModeCommand :
      choice = new H245_CommunicationModeCommand();
      return TRUE;
    case e_conferenceCommand :
      choice = new H245_ConferenceCommand();
      return TRUE;
    case e_h223MultiplexReconfiguration :
      choice = new H245_H223MultiplexReconfiguration();
      return TRUE;
    case e_newATMVCCommand :
      choice = new H245_NewATMVCCommand();
      return TRUE;
    case e_mobileMultilinkReconfigurationCommand :
      choice = new H245_MobileMultilinkReconfigurationCommand();
      return TRUE;
    case e_genericCommand :
      choice = new H245_GenericMessage();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_CommandMessage::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CommandMessage::Class()), PInvalidCast);
#endif
  return new H245_CommandMessage(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_IndicationMessage[]={
      {"nonStandard",0}
     ,{"functionNotUnderstood",1}
     ,{"masterSlaveDeterminationRelease",2}
     ,{"terminalCapabilitySetRelease",3}
     ,{"openLogicalChannelConfirm",4}
     ,{"requestChannelCloseRelease",5}
     ,{"multiplexEntrySendRelease",6}
     ,{"requestMultiplexEntryRelease",7}
     ,{"requestModeRelease",8}
     ,{"miscellaneousIndication",9}
     ,{"jitterIndication",10}
     ,{"h223SkewIndication",11}
     ,{"newATMVCIndication",12}
     ,{"userInput",13}
     ,{"h2250MaximumSkewIndication",14}
     ,{"mcLocationIndication",15}
     ,{"conferenceIndication",16}
     ,{"vendorIdentification",17}
     ,{"functionNotSupported",18}
     ,{"multilinkIndication",19}
     ,{"logicalChannelRateRelease",20}
     ,{"flowControlIndication",21}
     ,{"mobileMultilinkReconfigurationIndication",22}
     ,{"genericIndication",23}
};
#endif
//
// IndicationMessage
//

H245_IndicationMessage::H245_IndicationMessage(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 14, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_IndicationMessage,24
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_IndicationMessage::operator H245_NonStandardMessage &() const
#else
H245_IndicationMessage::operator H245_NonStandardMessage &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardMessage), PInvalidCast);
#endif
  return *(H245_NonStandardMessage *)choice;
}


H245_IndicationMessage::operator const H245_NonStandardMessage &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardMessage), PInvalidCast);
#endif
  return *(H245_NonStandardMessage *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_IndicationMessage::operator H245_FunctionNotUnderstood &() const
#else
H245_IndicationMessage::operator H245_FunctionNotUnderstood &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_FunctionNotUnderstood), PInvalidCast);
#endif
  return *(H245_FunctionNotUnderstood *)choice;
}


H245_IndicationMessage::operator const H245_FunctionNotUnderstood &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_FunctionNotUnderstood), PInvalidCast);
#endif
  return *(H245_FunctionNotUnderstood *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_IndicationMessage::operator H245_MasterSlaveDeterminationRelease &() const
#else
H245_IndicationMessage::operator H245_MasterSlaveDeterminationRelease &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MasterSlaveDeterminationRelease), PInvalidCast);
#endif
  return *(H245_MasterSlaveDeterminationRelease *)choice;
}


H245_IndicationMessage::operator const H245_MasterSlaveDeterminationRelease &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MasterSlaveDeterminationRelease), PInvalidCast);
#endif
  return *(H245_MasterSlaveDeterminationRelease *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_IndicationMessage::operator H245_TerminalCapabilitySetRelease &() const
#else
H245_IndicationMessage::operator H245_TerminalCapabilitySetRelease &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_TerminalCapabilitySetRelease), PInvalidCast);
#endif
  return *(H245_TerminalCapabilitySetRelease *)choice;
}


H245_IndicationMessage::operator const H245_TerminalCapabilitySetRelease &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_TerminalCapabilitySetRelease), PInvalidCast);
#endif
  return *(H245_TerminalCapabilitySetRelease *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_IndicationMessage::operator H245_OpenLogicalChannelConfirm &() const
#else
H245_IndicationMessage::operator H245_OpenLogicalChannelConfirm &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_OpenLogicalChannelConfirm), PInvalidCast);
#endif
  return *(H245_OpenLogicalChannelConfirm *)choice;
}


H245_IndicationMessage::operator const H245_OpenLogicalChannelConfirm &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_OpenLogicalChannelConfirm), PInvalidCast);
#endif
  return *(H245_OpenLogicalChannelConfirm *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_IndicationMessage::operator H245_RequestChannelCloseRelease &() const
#else
H245_IndicationMessage::operator H245_RequestChannelCloseRelease &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RequestChannelCloseRelease), PInvalidCast);
#endif
  return *(H245_RequestChannelCloseRelease *)choice;
}


H245_IndicationMessage::operator const H245_RequestChannelCloseRelease &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RequestChannelCloseRelease), PInvalidCast);
#endif
  return *(H245_RequestChannelCloseRelease *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_IndicationMessage::operator H245_MultiplexEntrySendRelease &() const
#else
H245_IndicationMessage::operator H245_MultiplexEntrySendRelease &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultiplexEntrySendRelease), PInvalidCast);
#endif
  return *(H245_MultiplexEntrySendRelease *)choice;
}


H245_IndicationMessage::operator const H245_MultiplexEntrySendRelease &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultiplexEntrySendRelease), PInvalidCast);
#endif
  return *(H245_MultiplexEntrySendRelease *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_IndicationMessage::operator H245_RequestMultiplexEntryRelease &() const
#else
H245_IndicationMessage::operator H245_RequestMultiplexEntryRelease &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RequestMultiplexEntryRelease), PInvalidCast);
#endif
  return *(H245_RequestMultiplexEntryRelease *)choice;
}


H245_IndicationMessage::operator const H245_RequestMultiplexEntryRelease &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RequestMultiplexEntryRelease), PInvalidCast);
#endif
  return *(H245_RequestMultiplexEntryRelease *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_IndicationMessage::operator H245_RequestModeRelease &() const
#else
H245_IndicationMessage::operator H245_RequestModeRelease &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RequestModeRelease), PInvalidCast);
#endif
  return *(H245_RequestModeRelease *)choice;
}


H245_IndicationMessage::operator const H245_RequestModeRelease &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RequestModeRelease), PInvalidCast);
#endif
  return *(H245_RequestModeRelease *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_IndicationMessage::operator H245_MiscellaneousIndication &() const
#else
H245_IndicationMessage::operator H245_MiscellaneousIndication &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MiscellaneousIndication), PInvalidCast);
#endif
  return *(H245_MiscellaneousIndication *)choice;
}


H245_IndicationMessage::operator const H245_MiscellaneousIndication &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MiscellaneousIndication), PInvalidCast);
#endif
  return *(H245_MiscellaneousIndication *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_IndicationMessage::operator H245_JitterIndication &() const
#else
H245_IndicationMessage::operator H245_JitterIndication &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_JitterIndication), PInvalidCast);
#endif
  return *(H245_JitterIndication *)choice;
}


H245_IndicationMessage::operator const H245_JitterIndication &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_JitterIndication), PInvalidCast);
#endif
  return *(H245_JitterIndication *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_IndicationMessage::operator H245_H223SkewIndication &() const
#else
H245_IndicationMessage::operator H245_H223SkewIndication &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H223SkewIndication), PInvalidCast);
#endif
  return *(H245_H223SkewIndication *)choice;
}


H245_IndicationMessage::operator const H245_H223SkewIndication &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H223SkewIndication), PInvalidCast);
#endif
  return *(H245_H223SkewIndication *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_IndicationMessage::operator H245_NewATMVCIndication &() const
#else
H245_IndicationMessage::operator H245_NewATMVCIndication &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NewATMVCIndication), PInvalidCast);
#endif
  return *(H245_NewATMVCIndication *)choice;
}


H245_IndicationMessage::operator const H245_NewATMVCIndication &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NewATMVCIndication), PInvalidCast);
#endif
  return *(H245_NewATMVCIndication *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_IndicationMessage::operator H245_UserInputIndication &() const
#else
H245_IndicationMessage::operator H245_UserInputIndication &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_UserInputIndication), PInvalidCast);
#endif
  return *(H245_UserInputIndication *)choice;
}


H245_IndicationMessage::operator const H245_UserInputIndication &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_UserInputIndication), PInvalidCast);
#endif
  return *(H245_UserInputIndication *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_IndicationMessage::operator H245_H2250MaximumSkewIndication &() const
#else
H245_IndicationMessage::operator H245_H2250MaximumSkewIndication &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H2250MaximumSkewIndication), PInvalidCast);
#endif
  return *(H245_H2250MaximumSkewIndication *)choice;
}


H245_IndicationMessage::operator const H245_H2250MaximumSkewIndication &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H2250MaximumSkewIndication), PInvalidCast);
#endif
  return *(H245_H2250MaximumSkewIndication *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_IndicationMessage::operator H245_MCLocationIndication &() const
#else
H245_IndicationMessage::operator H245_MCLocationIndication &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MCLocationIndication), PInvalidCast);
#endif
  return *(H245_MCLocationIndication *)choice;
}


H245_IndicationMessage::operator const H245_MCLocationIndication &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MCLocationIndication), PInvalidCast);
#endif
  return *(H245_MCLocationIndication *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_IndicationMessage::operator H245_ConferenceIndication &() const
#else
H245_IndicationMessage::operator H245_ConferenceIndication &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ConferenceIndication), PInvalidCast);
#endif
  return *(H245_ConferenceIndication *)choice;
}


H245_IndicationMessage::operator const H245_ConferenceIndication &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ConferenceIndication), PInvalidCast);
#endif
  return *(H245_ConferenceIndication *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_IndicationMessage::operator H245_VendorIdentification &() const
#else
H245_IndicationMessage::operator H245_VendorIdentification &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_VendorIdentification), PInvalidCast);
#endif
  return *(H245_VendorIdentification *)choice;
}


H245_IndicationMessage::operator const H245_VendorIdentification &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_VendorIdentification), PInvalidCast);
#endif
  return *(H245_VendorIdentification *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_IndicationMessage::operator H245_FunctionNotSupported &() const
#else
H245_IndicationMessage::operator H245_FunctionNotSupported &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_FunctionNotSupported), PInvalidCast);
#endif
  return *(H245_FunctionNotSupported *)choice;
}


H245_IndicationMessage::operator const H245_FunctionNotSupported &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_FunctionNotSupported), PInvalidCast);
#endif
  return *(H245_FunctionNotSupported *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_IndicationMessage::operator H245_MultilinkIndication &() const
#else
H245_IndicationMessage::operator H245_MultilinkIndication &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultilinkIndication), PInvalidCast);
#endif
  return *(H245_MultilinkIndication *)choice;
}


H245_IndicationMessage::operator const H245_MultilinkIndication &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultilinkIndication), PInvalidCast);
#endif
  return *(H245_MultilinkIndication *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_IndicationMessage::operator H245_LogicalChannelRateRelease &() const
#else
H245_IndicationMessage::operator H245_LogicalChannelRateRelease &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_LogicalChannelRateRelease), PInvalidCast);
#endif
  return *(H245_LogicalChannelRateRelease *)choice;
}


H245_IndicationMessage::operator const H245_LogicalChannelRateRelease &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_LogicalChannelRateRelease), PInvalidCast);
#endif
  return *(H245_LogicalChannelRateRelease *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_IndicationMessage::operator H245_FlowControlIndication &() const
#else
H245_IndicationMessage::operator H245_FlowControlIndication &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_FlowControlIndication), PInvalidCast);
#endif
  return *(H245_FlowControlIndication *)choice;
}


H245_IndicationMessage::operator const H245_FlowControlIndication &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_FlowControlIndication), PInvalidCast);
#endif
  return *(H245_FlowControlIndication *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_IndicationMessage::operator H245_MobileMultilinkReconfigurationIndication &() const
#else
H245_IndicationMessage::operator H245_MobileMultilinkReconfigurationIndication &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MobileMultilinkReconfigurationIndication), PInvalidCast);
#endif
  return *(H245_MobileMultilinkReconfigurationIndication *)choice;
}


H245_IndicationMessage::operator const H245_MobileMultilinkReconfigurationIndication &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MobileMultilinkReconfigurationIndication), PInvalidCast);
#endif
  return *(H245_MobileMultilinkReconfigurationIndication *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_IndicationMessage::operator H245_GenericMessage &() const
#else
H245_IndicationMessage::operator H245_GenericMessage &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_GenericMessage), PInvalidCast);
#endif
  return *(H245_GenericMessage *)choice;
}


H245_IndicationMessage::operator const H245_GenericMessage &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_GenericMessage), PInvalidCast);
#endif
  return *(H245_GenericMessage *)choice;
}


BOOL H245_IndicationMessage::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardMessage();
      return TRUE;
    case e_functionNotUnderstood :
      choice = new H245_FunctionNotUnderstood();
      return TRUE;
    case e_masterSlaveDeterminationRelease :
      choice = new H245_MasterSlaveDeterminationRelease();
      return TRUE;
    case e_terminalCapabilitySetRelease :
      choice = new H245_TerminalCapabilitySetRelease();
      return TRUE;
    case e_openLogicalChannelConfirm :
      choice = new H245_OpenLogicalChannelConfirm();
      return TRUE;
    case e_requestChannelCloseRelease :
      choice = new H245_RequestChannelCloseRelease();
      return TRUE;
    case e_multiplexEntrySendRelease :
      choice = new H245_MultiplexEntrySendRelease();
      return TRUE;
    case e_requestMultiplexEntryRelease :
      choice = new H245_RequestMultiplexEntryRelease();
      return TRUE;
    case e_requestModeRelease :
      choice = new H245_RequestModeRelease();
      return TRUE;
    case e_miscellaneousIndication :
      choice = new H245_MiscellaneousIndication();
      return TRUE;
    case e_jitterIndication :
      choice = new H245_JitterIndication();
      return TRUE;
    case e_h223SkewIndication :
      choice = new H245_H223SkewIndication();
      return TRUE;
    case e_newATMVCIndication :
      choice = new H245_NewATMVCIndication();
      return TRUE;
    case e_userInput :
      choice = new H245_UserInputIndication();
      return TRUE;
    case e_h2250MaximumSkewIndication :
      choice = new H245_H2250MaximumSkewIndication();
      return TRUE;
    case e_mcLocationIndication :
      choice = new H245_MCLocationIndication();
      return TRUE;
    case e_conferenceIndication :
      choice = new H245_ConferenceIndication();
      return TRUE;
    case e_vendorIdentification :
      choice = new H245_VendorIdentification();
      return TRUE;
    case e_functionNotSupported :
      choice = new H245_FunctionNotSupported();
      return TRUE;
    case e_multilinkIndication :
      choice = new H245_MultilinkIndication();
      return TRUE;
    case e_logicalChannelRateRelease :
      choice = new H245_LogicalChannelRateRelease();
      return TRUE;
    case e_flowControlIndication :
      choice = new H245_FlowControlIndication();
      return TRUE;
    case e_mobileMultilinkReconfigurationIndication :
      choice = new H245_MobileMultilinkReconfigurationIndication();
      return TRUE;
    case e_genericIndication :
      choice = new H245_GenericMessage();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_IndicationMessage::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_IndicationMessage::Class()), PInvalidCast);
#endif
  return new H245_IndicationMessage(*this);
}


//
// SequenceNumber
//

H245_SequenceNumber::H245_SequenceNumber(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


H245_SequenceNumber & H245_SequenceNumber::operator=(int v)
{
  SetValue(v);
  return *this;
}


H245_SequenceNumber & H245_SequenceNumber::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H245_SequenceNumber::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_SequenceNumber::Class()), PInvalidCast);
#endif
  return new H245_SequenceNumber(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_NonStandardIdentifier[]={
      {"object",0}
     ,{"h221NonStandard",1}
};
#endif
//
// NonStandardIdentifier
//

H245_NonStandardIdentifier::H245_NonStandardIdentifier(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_NonStandardIdentifier,2
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_NonStandardIdentifier::operator H245_NonStandardIdentifier_h221NonStandard &() const
#else
H245_NonStandardIdentifier::operator H245_NonStandardIdentifier_h221NonStandard &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardIdentifier_h221NonStandard), PInvalidCast);
#endif
  return *(H245_NonStandardIdentifier_h221NonStandard *)choice;
}


H245_NonStandardIdentifier::operator const H245_NonStandardIdentifier_h221NonStandard &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardIdentifier_h221NonStandard), PInvalidCast);
#endif
  return *(H245_NonStandardIdentifier_h221NonStandard *)choice;
}


BOOL H245_NonStandardIdentifier::CreateObject()
{
  switch (tag) {
    case e_object :
      choice = new PASN_ObjectId();
      return TRUE;
    case e_h221NonStandard :
      choice = new H245_NonStandardIdentifier_h221NonStandard();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_NonStandardIdentifier::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NonStandardIdentifier::Class()), PInvalidCast);
#endif
  return new H245_NonStandardIdentifier(*this);
}


//
// MasterSlaveDetermination
//

H245_MasterSlaveDetermination::H245_MasterSlaveDetermination(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_terminalType.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
  m_statusDeterminationNumber.SetConstraints(PASN_Object::FixedConstraint, 0, 16777215);
}


#ifndef PASN_NOPRINTON
void H245_MasterSlaveDetermination::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "terminalType = " << setprecision(indent) << m_terminalType << '\n';
  strm << setw(indent+28) << "statusDeterminationNumber = " << setprecision(indent) << m_statusDeterminationNumber << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MasterSlaveDetermination::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MasterSlaveDetermination), PInvalidCast);
#endif
  const H245_MasterSlaveDetermination & other = (const H245_MasterSlaveDetermination &)obj;

  Comparison result;

  if ((result = m_terminalType.Compare(other.m_terminalType)) != EqualTo)
    return result;
  if ((result = m_statusDeterminationNumber.Compare(other.m_statusDeterminationNumber)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MasterSlaveDetermination::GetDataLength() const
{
  PINDEX length = 0;
  length += m_terminalType.GetObjectLength();
  length += m_statusDeterminationNumber.GetObjectLength();
  return length;
}


BOOL H245_MasterSlaveDetermination::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_terminalType.Decode(strm))
    return FALSE;
  if (!m_statusDeterminationNumber.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MasterSlaveDetermination::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_terminalType.Encode(strm);
  m_statusDeterminationNumber.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MasterSlaveDetermination::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MasterSlaveDetermination::Class()), PInvalidCast);
#endif
  return new H245_MasterSlaveDetermination(*this);
}


//
// MasterSlaveDeterminationRelease
//

H245_MasterSlaveDeterminationRelease::H245_MasterSlaveDeterminationRelease(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MasterSlaveDeterminationRelease::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PINDEX H245_MasterSlaveDeterminationRelease::GetDataLength() const
{
  PINDEX length = 0;
  return length;
}


BOOL H245_MasterSlaveDeterminationRelease::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;


  return UnknownExtensionsDecode(strm);
}


void H245_MasterSlaveDeterminationRelease::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);


  UnknownExtensionsEncode(strm);
}


PObject * H245_MasterSlaveDeterminationRelease::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MasterSlaveDeterminationRelease::Class()), PInvalidCast);
#endif
  return new H245_MasterSlaveDeterminationRelease(*this);
}


//
// AlternativeCapabilitySet
//

H245_AlternativeCapabilitySet::H245_AlternativeCapabilitySet(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


PASN_Object * H245_AlternativeCapabilitySet::CreateObject() const
{
  return new H245_CapabilityTableEntryNumber;
}


H245_CapabilityTableEntryNumber & H245_AlternativeCapabilitySet::operator[](PINDEX i) const
{
  return (H245_CapabilityTableEntryNumber &)array[i];
}


PObject * H245_AlternativeCapabilitySet::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_AlternativeCapabilitySet::Class()), PInvalidCast);
#endif
  return new H245_AlternativeCapabilitySet(*this);
}


//
// CapabilityTableEntryNumber
//

H245_CapabilityTableEntryNumber::H245_CapabilityTableEntryNumber(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
}


H245_CapabilityTableEntryNumber & H245_CapabilityTableEntryNumber::operator=(int v)
{
  SetValue(v);
  return *this;
}


H245_CapabilityTableEntryNumber & H245_CapabilityTableEntryNumber::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H245_CapabilityTableEntryNumber::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CapabilityTableEntryNumber::Class()), PInvalidCast);
#endif
  return new H245_CapabilityTableEntryNumber(*this);
}


//
// CapabilityDescriptorNumber
//

H245_CapabilityDescriptorNumber::H245_CapabilityDescriptorNumber(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


H245_CapabilityDescriptorNumber & H245_CapabilityDescriptorNumber::operator=(int v)
{
  SetValue(v);
  return *this;
}


H245_CapabilityDescriptorNumber & H245_CapabilityDescriptorNumber::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H245_CapabilityDescriptorNumber::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CapabilityDescriptorNumber::Class()), PInvalidCast);
#endif
  return new H245_CapabilityDescriptorNumber(*this);
}


//
// TerminalCapabilitySetAck
//

H245_TerminalCapabilitySetAck::H245_TerminalCapabilitySetAck(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_TerminalCapabilitySetAck::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "sequenceNumber = " << setprecision(indent) << m_sequenceNumber << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_TerminalCapabilitySetAck::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_TerminalCapabilitySetAck), PInvalidCast);
#endif
  const H245_TerminalCapabilitySetAck & other = (const H245_TerminalCapabilitySetAck &)obj;

  Comparison result;

  if ((result = m_sequenceNumber.Compare(other.m_sequenceNumber)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_TerminalCapabilitySetAck::GetDataLength() const
{
  PINDEX length = 0;
  length += m_sequenceNumber.GetObjectLength();
  return length;
}


BOOL H245_TerminalCapabilitySetAck::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_sequenceNumber.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_TerminalCapabilitySetAck::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_sequenceNumber.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_TerminalCapabilitySetAck::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_TerminalCapabilitySetAck::Class()), PInvalidCast);
#endif
  return new H245_TerminalCapabilitySetAck(*this);
}


//
// TerminalCapabilitySetRelease
//

H245_TerminalCapabilitySetRelease::H245_TerminalCapabilitySetRelease(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_TerminalCapabilitySetRelease::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PINDEX H245_TerminalCapabilitySetRelease::GetDataLength() const
{
  PINDEX length = 0;
  return length;
}


BOOL H245_TerminalCapabilitySetRelease::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;


  return UnknownExtensionsDecode(strm);
}


void H245_TerminalCapabilitySetRelease::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);


  UnknownExtensionsEncode(strm);
}


PObject * H245_TerminalCapabilitySetRelease::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_TerminalCapabilitySetRelease::Class()), PInvalidCast);
#endif
  return new H245_TerminalCapabilitySetRelease(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_Capability[]={
      {"nonStandard",0}
     ,{"receiveVideoCapability",1}
     ,{"transmitVideoCapability",2}
     ,{"receiveAndTransmitVideoCapability",3}
     ,{"receiveAudioCapability",4}
     ,{"transmitAudioCapability",5}
     ,{"receiveAndTransmitAudioCapability",6}
     ,{"receiveDataApplicationCapability",7}
     ,{"transmitDataApplicationCapability",8}
     ,{"receiveAndTransmitDataApplicationCapability",9}
     ,{"h233EncryptionTransmitCapability",10}
     ,{"h233EncryptionReceiveCapability",11}
     ,{"conferenceCapability",12}
     ,{"h235SecurityCapability",13}
     ,{"maxPendingReplacementFor",14}
     ,{"receiveUserInputCapability",15}
     ,{"transmitUserInputCapability",16}
     ,{"receiveAndTransmitUserInputCapability",17}
     ,{"genericControlCapability",18}
     ,{"receiveMultiplexedStreamCapability",19}
     ,{"transmitMultiplexedStreamCapability",20}
     ,{"receiveAndTransmitMultiplexedStreamCapability",21}
     ,{"receiveRTPAudioTelephonyEventCapability",22}
     ,{"receiveRTPAudioToneCapability",23}
     ,{"depFecCapability",24}
     ,{"multiplePayloadStreamCapability",25}
     ,{"fecCapability",26}
     ,{"redundancyEncodingCap",27}
     ,{"oneOfCapabilities",28}
};
#endif
//
// Capability
//

H245_Capability::H245_Capability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 12, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_Capability,29
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_Capability::operator H245_NonStandardParameter &() const
#else
H245_Capability::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_Capability::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_Capability::operator H245_VideoCapability &() const
#else
H245_Capability::operator H245_VideoCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_VideoCapability), PInvalidCast);
#endif
  return *(H245_VideoCapability *)choice;
}


H245_Capability::operator const H245_VideoCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_VideoCapability), PInvalidCast);
#endif
  return *(H245_VideoCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_Capability::operator H245_AudioCapability &() const
#else
H245_Capability::operator H245_AudioCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_AudioCapability), PInvalidCast);
#endif
  return *(H245_AudioCapability *)choice;
}


H245_Capability::operator const H245_AudioCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_AudioCapability), PInvalidCast);
#endif
  return *(H245_AudioCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_Capability::operator H245_DataApplicationCapability &() const
#else
H245_Capability::operator H245_DataApplicationCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DataApplicationCapability), PInvalidCast);
#endif
  return *(H245_DataApplicationCapability *)choice;
}


H245_Capability::operator const H245_DataApplicationCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DataApplicationCapability), PInvalidCast);
#endif
  return *(H245_DataApplicationCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_Capability::operator H245_Capability_h233EncryptionReceiveCapability &() const
#else
H245_Capability::operator H245_Capability_h233EncryptionReceiveCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_Capability_h233EncryptionReceiveCapability), PInvalidCast);
#endif
  return *(H245_Capability_h233EncryptionReceiveCapability *)choice;
}


H245_Capability::operator const H245_Capability_h233EncryptionReceiveCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_Capability_h233EncryptionReceiveCapability), PInvalidCast);
#endif
  return *(H245_Capability_h233EncryptionReceiveCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_Capability::operator H245_ConferenceCapability &() const
#else
H245_Capability::operator H245_ConferenceCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ConferenceCapability), PInvalidCast);
#endif
  return *(H245_ConferenceCapability *)choice;
}


H245_Capability::operator const H245_ConferenceCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ConferenceCapability), PInvalidCast);
#endif
  return *(H245_ConferenceCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_Capability::operator H245_H235SecurityCapability &() const
#else
H245_Capability::operator H245_H235SecurityCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H235SecurityCapability), PInvalidCast);
#endif
  return *(H245_H235SecurityCapability *)choice;
}


H245_Capability::operator const H245_H235SecurityCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H235SecurityCapability), PInvalidCast);
#endif
  return *(H245_H235SecurityCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_Capability::operator H245_UserInputCapability &() const
#else
H245_Capability::operator H245_UserInputCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_UserInputCapability), PInvalidCast);
#endif
  return *(H245_UserInputCapability *)choice;
}


H245_Capability::operator const H245_UserInputCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_UserInputCapability), PInvalidCast);
#endif
  return *(H245_UserInputCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_Capability::operator H245_GenericCapability &() const
#else
H245_Capability::operator H245_GenericCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_GenericCapability), PInvalidCast);
#endif
  return *(H245_GenericCapability *)choice;
}


H245_Capability::operator const H245_GenericCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_GenericCapability), PInvalidCast);
#endif
  return *(H245_GenericCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_Capability::operator H245_MultiplexedStreamCapability &() const
#else
H245_Capability::operator H245_MultiplexedStreamCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultiplexedStreamCapability), PInvalidCast);
#endif
  return *(H245_MultiplexedStreamCapability *)choice;
}


H245_Capability::operator const H245_MultiplexedStreamCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultiplexedStreamCapability), PInvalidCast);
#endif
  return *(H245_MultiplexedStreamCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_Capability::operator H245_AudioTelephonyEventCapability &() const
#else
H245_Capability::operator H245_AudioTelephonyEventCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_AudioTelephonyEventCapability), PInvalidCast);
#endif
  return *(H245_AudioTelephonyEventCapability *)choice;
}


H245_Capability::operator const H245_AudioTelephonyEventCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_AudioTelephonyEventCapability), PInvalidCast);
#endif
  return *(H245_AudioTelephonyEventCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_Capability::operator H245_AudioToneCapability &() const
#else
H245_Capability::operator H245_AudioToneCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_AudioToneCapability), PInvalidCast);
#endif
  return *(H245_AudioToneCapability *)choice;
}


H245_Capability::operator const H245_AudioToneCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_AudioToneCapability), PInvalidCast);
#endif
  return *(H245_AudioToneCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_Capability::operator H245_DepFECCapability &() const
#else
H245_Capability::operator H245_DepFECCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DepFECCapability), PInvalidCast);
#endif
  return *(H245_DepFECCapability *)choice;
}


H245_Capability::operator const H245_DepFECCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DepFECCapability), PInvalidCast);
#endif
  return *(H245_DepFECCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_Capability::operator H245_MultiplePayloadStreamCapability &() const
#else
H245_Capability::operator H245_MultiplePayloadStreamCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultiplePayloadStreamCapability), PInvalidCast);
#endif
  return *(H245_MultiplePayloadStreamCapability *)choice;
}


H245_Capability::operator const H245_MultiplePayloadStreamCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultiplePayloadStreamCapability), PInvalidCast);
#endif
  return *(H245_MultiplePayloadStreamCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_Capability::operator H245_FECCapability &() const
#else
H245_Capability::operator H245_FECCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_FECCapability), PInvalidCast);
#endif
  return *(H245_FECCapability *)choice;
}


H245_Capability::operator const H245_FECCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_FECCapability), PInvalidCast);
#endif
  return *(H245_FECCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_Capability::operator H245_RedundancyEncodingCapability &() const
#else
H245_Capability::operator H245_RedundancyEncodingCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RedundancyEncodingCapability), PInvalidCast);
#endif
  return *(H245_RedundancyEncodingCapability *)choice;
}


H245_Capability::operator const H245_RedundancyEncodingCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RedundancyEncodingCapability), PInvalidCast);
#endif
  return *(H245_RedundancyEncodingCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_Capability::operator H245_AlternativeCapabilitySet &() const
#else
H245_Capability::operator H245_AlternativeCapabilitySet &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_AlternativeCapabilitySet), PInvalidCast);
#endif
  return *(H245_AlternativeCapabilitySet *)choice;
}


H245_Capability::operator const H245_AlternativeCapabilitySet &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_AlternativeCapabilitySet), PInvalidCast);
#endif
  return *(H245_AlternativeCapabilitySet *)choice;
}


BOOL H245_Capability::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_receiveVideoCapability :
    case e_transmitVideoCapability :
    case e_receiveAndTransmitVideoCapability :
      choice = new H245_VideoCapability();
      return TRUE;
    case e_receiveAudioCapability :
    case e_transmitAudioCapability :
    case e_receiveAndTransmitAudioCapability :
      choice = new H245_AudioCapability();
      return TRUE;
    case e_receiveDataApplicationCapability :
    case e_transmitDataApplicationCapability :
    case e_receiveAndTransmitDataApplicationCapability :
      choice = new H245_DataApplicationCapability();
      return TRUE;
    case e_h233EncryptionTransmitCapability :
      choice = new PASN_Boolean();
      return TRUE;
    case e_h233EncryptionReceiveCapability :
      choice = new H245_Capability_h233EncryptionReceiveCapability();
      return TRUE;
    case e_conferenceCapability :
      choice = new H245_ConferenceCapability();
      return TRUE;
    case e_h235SecurityCapability :
      choice = new H245_H235SecurityCapability();
      return TRUE;
    case e_maxPendingReplacementFor :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 0, 255);
      return TRUE;
    case e_receiveUserInputCapability :
    case e_transmitUserInputCapability :
    case e_receiveAndTransmitUserInputCapability :
      choice = new H245_UserInputCapability();
      return TRUE;
    case e_genericControlCapability :
      choice = new H245_GenericCapability();
      return TRUE;
    case e_receiveMultiplexedStreamCapability :
    case e_transmitMultiplexedStreamCapability :
    case e_receiveAndTransmitMultiplexedStreamCapability :
      choice = new H245_MultiplexedStreamCapability();
      return TRUE;
    case e_receiveRTPAudioTelephonyEventCapability :
      choice = new H245_AudioTelephonyEventCapability();
      return TRUE;
    case e_receiveRTPAudioToneCapability :
      choice = new H245_AudioToneCapability();
      return TRUE;
    case e_depFecCapability :
      choice = new H245_DepFECCapability();
      return TRUE;
    case e_multiplePayloadStreamCapability :
      choice = new H245_MultiplePayloadStreamCapability();
      return TRUE;
    case e_fecCapability :
      choice = new H245_FECCapability();
      return TRUE;
    case e_redundancyEncodingCap :
      choice = new H245_RedundancyEncodingCapability();
      return TRUE;
    case e_oneOfCapabilities :
      choice = new H245_AlternativeCapabilitySet();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_Capability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_Capability::Class()), PInvalidCast);
#endif
  return new H245_Capability(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_MultiplexCapability[]={
      {"nonStandard",0}
     ,{"h222Capability",1}
     ,{"h223Capability",2}
     ,{"v76Capability",3}
     ,{"h2250Capability",4}
     ,{"genericMultiplexCapability",5}
};
#endif
//
// MultiplexCapability
//

H245_MultiplexCapability::H245_MultiplexCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_MultiplexCapability,6
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultiplexCapability::operator H245_NonStandardParameter &() const
#else
H245_MultiplexCapability::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_MultiplexCapability::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultiplexCapability::operator H245_H222Capability &() const
#else
H245_MultiplexCapability::operator H245_H222Capability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H222Capability), PInvalidCast);
#endif
  return *(H245_H222Capability *)choice;
}


H245_MultiplexCapability::operator const H245_H222Capability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H222Capability), PInvalidCast);
#endif
  return *(H245_H222Capability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultiplexCapability::operator H245_H223Capability &() const
#else
H245_MultiplexCapability::operator H245_H223Capability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H223Capability), PInvalidCast);
#endif
  return *(H245_H223Capability *)choice;
}


H245_MultiplexCapability::operator const H245_H223Capability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H223Capability), PInvalidCast);
#endif
  return *(H245_H223Capability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultiplexCapability::operator H245_V76Capability &() const
#else
H245_MultiplexCapability::operator H245_V76Capability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_V76Capability), PInvalidCast);
#endif
  return *(H245_V76Capability *)choice;
}


H245_MultiplexCapability::operator const H245_V76Capability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_V76Capability), PInvalidCast);
#endif
  return *(H245_V76Capability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultiplexCapability::operator H245_H2250Capability &() const
#else
H245_MultiplexCapability::operator H245_H2250Capability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H2250Capability), PInvalidCast);
#endif
  return *(H245_H2250Capability *)choice;
}


H245_MultiplexCapability::operator const H245_H2250Capability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H2250Capability), PInvalidCast);
#endif
  return *(H245_H2250Capability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultiplexCapability::operator H245_GenericCapability &() const
#else
H245_MultiplexCapability::operator H245_GenericCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_GenericCapability), PInvalidCast);
#endif
  return *(H245_GenericCapability *)choice;
}


H245_MultiplexCapability::operator const H245_GenericCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_GenericCapability), PInvalidCast);
#endif
  return *(H245_GenericCapability *)choice;
}


BOOL H245_MultiplexCapability::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_h222Capability :
      choice = new H245_H222Capability();
      return TRUE;
    case e_h223Capability :
      choice = new H245_H223Capability();
      return TRUE;
    case e_v76Capability :
      choice = new H245_V76Capability();
      return TRUE;
    case e_h2250Capability :
      choice = new H245_H2250Capability();
      return TRUE;
    case e_genericMultiplexCapability :
      choice = new H245_GenericCapability();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_MultiplexCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultiplexCapability::Class()), PInvalidCast);
#endif
  return new H245_MultiplexCapability(*this);
}


//
// H223AnnexCCapability
//

H245_H223AnnexCCapability::H245_H223AnnexCCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 1)
{
  m_maximumAL1MPDUSize.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
  m_maximumAL2MSDUSize.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
  m_maximumAL3MSDUSize.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void H245_H223AnnexCCapability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "videoWithAL1M = " << setprecision(indent) << m_videoWithAL1M << '\n';
  strm << setw(indent+16) << "videoWithAL2M = " << setprecision(indent) << m_videoWithAL2M << '\n';
  strm << setw(indent+16) << "videoWithAL3M = " << setprecision(indent) << m_videoWithAL3M << '\n';
  strm << setw(indent+16) << "audioWithAL1M = " << setprecision(indent) << m_audioWithAL1M << '\n';
  strm << setw(indent+16) << "audioWithAL2M = " << setprecision(indent) << m_audioWithAL2M << '\n';
  strm << setw(indent+16) << "audioWithAL3M = " << setprecision(indent) << m_audioWithAL3M << '\n';
  strm << setw(indent+15) << "dataWithAL1M = " << setprecision(indent) << m_dataWithAL1M << '\n';
  strm << setw(indent+15) << "dataWithAL2M = " << setprecision(indent) << m_dataWithAL2M << '\n';
  strm << setw(indent+15) << "dataWithAL3M = " << setprecision(indent) << m_dataWithAL3M << '\n';
  strm << setw(indent+20) << "alpduInterleaving = " << setprecision(indent) << m_alpduInterleaving << '\n';
  strm << setw(indent+21) << "maximumAL1MPDUSize = " << setprecision(indent) << m_maximumAL1MPDUSize << '\n';
  strm << setw(indent+21) << "maximumAL2MSDUSize = " << setprecision(indent) << m_maximumAL2MSDUSize << '\n';
  strm << setw(indent+21) << "maximumAL3MSDUSize = " << setprecision(indent) << m_maximumAL3MSDUSize << '\n';
  if (HasOptionalField(e_rsCodeCapability))
    strm << setw(indent+19) << "rsCodeCapability = " << setprecision(indent) << m_rsCodeCapability << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_H223AnnexCCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_H223AnnexCCapability), PInvalidCast);
#endif
  const H245_H223AnnexCCapability & other = (const H245_H223AnnexCCapability &)obj;

  Comparison result;

  if ((result = m_videoWithAL1M.Compare(other.m_videoWithAL1M)) != EqualTo)
    return result;
  if ((result = m_videoWithAL2M.Compare(other.m_videoWithAL2M)) != EqualTo)
    return result;
  if ((result = m_videoWithAL3M.Compare(other.m_videoWithAL3M)) != EqualTo)
    return result;
  if ((result = m_audioWithAL1M.Compare(other.m_audioWithAL1M)) != EqualTo)
    return result;
  if ((result = m_audioWithAL2M.Compare(other.m_audioWithAL2M)) != EqualTo)
    return result;
  if ((result = m_audioWithAL3M.Compare(other.m_audioWithAL3M)) != EqualTo)
    return result;
  if ((result = m_dataWithAL1M.Compare(other.m_dataWithAL1M)) != EqualTo)
    return result;
  if ((result = m_dataWithAL2M.Compare(other.m_dataWithAL2M)) != EqualTo)
    return result;
  if ((result = m_dataWithAL3M.Compare(other.m_dataWithAL3M)) != EqualTo)
    return result;
  if ((result = m_alpduInterleaving.Compare(other.m_alpduInterleaving)) != EqualTo)
    return result;
  if ((result = m_maximumAL1MPDUSize.Compare(other.m_maximumAL1MPDUSize)) != EqualTo)
    return result;
  if ((result = m_maximumAL2MSDUSize.Compare(other.m_maximumAL2MSDUSize)) != EqualTo)
    return result;
  if ((result = m_maximumAL3MSDUSize.Compare(other.m_maximumAL3MSDUSize)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H223AnnexCCapability::GetDataLength() const
{
  PINDEX length = 0;
  length += m_videoWithAL1M.GetObjectLength();
  length += m_videoWithAL2M.GetObjectLength();
  length += m_videoWithAL3M.GetObjectLength();
  length += m_audioWithAL1M.GetObjectLength();
  length += m_audioWithAL2M.GetObjectLength();
  length += m_audioWithAL3M.GetObjectLength();
  length += m_dataWithAL1M.GetObjectLength();
  length += m_dataWithAL2M.GetObjectLength();
  length += m_dataWithAL3M.GetObjectLength();
  length += m_alpduInterleaving.GetObjectLength();
  length += m_maximumAL1MPDUSize.GetObjectLength();
  length += m_maximumAL2MSDUSize.GetObjectLength();
  length += m_maximumAL3MSDUSize.GetObjectLength();
  return length;
}


BOOL H245_H223AnnexCCapability::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_videoWithAL1M.Decode(strm))
    return FALSE;
  if (!m_videoWithAL2M.Decode(strm))
    return FALSE;
  if (!m_videoWithAL3M.Decode(strm))
    return FALSE;
  if (!m_audioWithAL1M.Decode(strm))
    return FALSE;
  if (!m_audioWithAL2M.Decode(strm))
    return FALSE;
  if (!m_audioWithAL3M.Decode(strm))
    return FALSE;
  if (!m_dataWithAL1M.Decode(strm))
    return FALSE;
  if (!m_dataWithAL2M.Decode(strm))
    return FALSE;
  if (!m_dataWithAL3M.Decode(strm))
    return FALSE;
  if (!m_alpduInterleaving.Decode(strm))
    return FALSE;
  if (!m_maximumAL1MPDUSize.Decode(strm))
    return FALSE;
  if (!m_maximumAL2MSDUSize.Decode(strm))
    return FALSE;
  if (!m_maximumAL3MSDUSize.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_rsCodeCapability, m_rsCodeCapability))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_H223AnnexCCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_videoWithAL1M.Encode(strm);
  m_videoWithAL2M.Encode(strm);
  m_videoWithAL3M.Encode(strm);
  m_audioWithAL1M.Encode(strm);
  m_audioWithAL2M.Encode(strm);
  m_audioWithAL3M.Encode(strm);
  m_dataWithAL1M.Encode(strm);
  m_dataWithAL2M.Encode(strm);
  m_dataWithAL3M.Encode(strm);
  m_alpduInterleaving.Encode(strm);
  m_maximumAL1MPDUSize.Encode(strm);
  m_maximumAL2MSDUSize.Encode(strm);
  m_maximumAL3MSDUSize.Encode(strm);
  KnownExtensionEncode(strm, e_rsCodeCapability, m_rsCodeCapability);

  UnknownExtensionsEncode(strm);
}


PObject * H245_H223AnnexCCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223AnnexCCapability::Class()), PInvalidCast);
#endif
  return new H245_H223AnnexCCapability(*this);
}


//
// V75Capability
//

H245_V75Capability::H245_V75Capability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_V75Capability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+14) << "audioHeader = " << setprecision(indent) << m_audioHeader << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_V75Capability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_V75Capability), PInvalidCast);
#endif
  const H245_V75Capability & other = (const H245_V75Capability &)obj;

  Comparison result;

  if ((result = m_audioHeader.Compare(other.m_audioHeader)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_V75Capability::GetDataLength() const
{
  PINDEX length = 0;
  length += m_audioHeader.GetObjectLength();
  return length;
}


BOOL H245_V75Capability::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_audioHeader.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_V75Capability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_audioHeader.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_V75Capability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_V75Capability::Class()), PInvalidCast);
#endif
  return new H245_V75Capability(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_QOSMode[]={
      {"guaranteedQOS",0}
     ,{"controlledLoad",1}
};
#endif
//
// QOSMode
//

H245_QOSMode::H245_QOSMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_QOSMode,2
#endif
)
{
}


BOOL H245_QOSMode::CreateObject()
{
  choice = (tag <= e_controlledLoad) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_QOSMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_QOSMode::Class()), PInvalidCast);
#endif
  return new H245_QOSMode(*this);
}


//
// ATMParameters
//

H245_ATMParameters::H245_ATMParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_maxNTUSize.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void H245_ATMParameters::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+13) << "maxNTUSize = " << setprecision(indent) << m_maxNTUSize << '\n';
  strm << setw(indent+9) << "atmUBR = " << setprecision(indent) << m_atmUBR << '\n';
  strm << setw(indent+11) << "atmrtVBR = " << setprecision(indent) << m_atmrtVBR << '\n';
  strm << setw(indent+12) << "atmnrtVBR = " << setprecision(indent) << m_atmnrtVBR << '\n';
  strm << setw(indent+9) << "atmABR = " << setprecision(indent) << m_atmABR << '\n';
  strm << setw(indent+9) << "atmCBR = " << setprecision(indent) << m_atmCBR << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_ATMParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_ATMParameters), PInvalidCast);
#endif
  const H245_ATMParameters & other = (const H245_ATMParameters &)obj;

  Comparison result;

  if ((result = m_maxNTUSize.Compare(other.m_maxNTUSize)) != EqualTo)
    return result;
  if ((result = m_atmUBR.Compare(other.m_atmUBR)) != EqualTo)
    return result;
  if ((result = m_atmrtVBR.Compare(other.m_atmrtVBR)) != EqualTo)
    return result;
  if ((result = m_atmnrtVBR.Compare(other.m_atmnrtVBR)) != EqualTo)
    return result;
  if ((result = m_atmABR.Compare(other.m_atmABR)) != EqualTo)
    return result;
  if ((result = m_atmCBR.Compare(other.m_atmCBR)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_ATMParameters::GetDataLength() const
{
  PINDEX length = 0;
  length += m_maxNTUSize.GetObjectLength();
  length += m_atmUBR.GetObjectLength();
  length += m_atmrtVBR.GetObjectLength();
  length += m_atmnrtVBR.GetObjectLength();
  length += m_atmABR.GetObjectLength();
  length += m_atmCBR.GetObjectLength();
  return length;
}


BOOL H245_ATMParameters::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_maxNTUSize.Decode(strm))
    return FALSE;
  if (!m_atmUBR.Decode(strm))
    return FALSE;
  if (!m_atmrtVBR.Decode(strm))
    return FALSE;
  if (!m_atmnrtVBR.Decode(strm))
    return FALSE;
  if (!m_atmABR.Decode(strm))
    return FALSE;
  if (!m_atmCBR.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_ATMParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_maxNTUSize.Encode(strm);
  m_atmUBR.Encode(strm);
  m_atmrtVBR.Encode(strm);
  m_atmnrtVBR.Encode(strm);
  m_atmABR.Encode(strm);
  m_atmCBR.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_ATMParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ATMParameters::Class()), PInvalidCast);
#endif
  return new H245_ATMParameters(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_MediaTransportType[]={
      {"ip_UDP",0}
     ,{"ip_TCP",1}
     ,{"atm_AAL5_UNIDIR",2}
     ,{"atm_AAL5_BIDIR",3}
     ,{"atm_AAL5_compressed",4}
};
#endif
//
// MediaTransportType
//

H245_MediaTransportType::H245_MediaTransportType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_MediaTransportType,5
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MediaTransportType::operator H245_MediaTransportType_atm_AAL5_compressed &() const
#else
H245_MediaTransportType::operator H245_MediaTransportType_atm_AAL5_compressed &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MediaTransportType_atm_AAL5_compressed), PInvalidCast);
#endif
  return *(H245_MediaTransportType_atm_AAL5_compressed *)choice;
}


H245_MediaTransportType::operator const H245_MediaTransportType_atm_AAL5_compressed &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MediaTransportType_atm_AAL5_compressed), PInvalidCast);
#endif
  return *(H245_MediaTransportType_atm_AAL5_compressed *)choice;
}


BOOL H245_MediaTransportType::CreateObject()
{
  switch (tag) {
    case e_ip_UDP :
    case e_ip_TCP :
    case e_atm_AAL5_UNIDIR :
    case e_atm_AAL5_BIDIR :
      choice = new PASN_Null();
      return TRUE;
    case e_atm_AAL5_compressed :
      choice = new H245_MediaTransportType_atm_AAL5_compressed();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_MediaTransportType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MediaTransportType::Class()), PInvalidCast);
#endif
  return new H245_MediaTransportType(*this);
}


//
// MediaChannelCapability
//

H245_MediaChannelCapability::H245_MediaChannelCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MediaChannelCapability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_mediaTransport))
    strm << setw(indent+17) << "mediaTransport = " << setprecision(indent) << m_mediaTransport << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MediaChannelCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MediaChannelCapability), PInvalidCast);
#endif
  const H245_MediaChannelCapability & other = (const H245_MediaChannelCapability &)obj;

  Comparison result;

  if ((result = m_mediaTransport.Compare(other.m_mediaTransport)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MediaChannelCapability::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_mediaTransport))
    length += m_mediaTransport.GetObjectLength();
  return length;
}


BOOL H245_MediaChannelCapability::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_mediaTransport) && !m_mediaTransport.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MediaChannelCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_mediaTransport))
    m_mediaTransport.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MediaChannelCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MediaChannelCapability::Class()), PInvalidCast);
#endif
  return new H245_MediaChannelCapability(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_RedundancyEncodingMethod[]={
      {"nonStandard",0}
     ,{"rtpAudioRedundancyEncoding",1}
     ,{"rtpH263VideoRedundancyEncoding",2}
};
#endif
//
// RedundancyEncodingMethod
//

H245_RedundancyEncodingMethod::H245_RedundancyEncodingMethod(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_RedundancyEncodingMethod,3
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RedundancyEncodingMethod::operator H245_NonStandardParameter &() const
#else
H245_RedundancyEncodingMethod::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_RedundancyEncodingMethod::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RedundancyEncodingMethod::operator H245_RTPH263VideoRedundancyEncoding &() const
#else
H245_RedundancyEncodingMethod::operator H245_RTPH263VideoRedundancyEncoding &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RTPH263VideoRedundancyEncoding), PInvalidCast);
#endif
  return *(H245_RTPH263VideoRedundancyEncoding *)choice;
}


H245_RedundancyEncodingMethod::operator const H245_RTPH263VideoRedundancyEncoding &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RTPH263VideoRedundancyEncoding), PInvalidCast);
#endif
  return *(H245_RTPH263VideoRedundancyEncoding *)choice;
}


BOOL H245_RedundancyEncodingMethod::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_rtpAudioRedundancyEncoding :
      choice = new PASN_Null();
      return TRUE;
    case e_rtpH263VideoRedundancyEncoding :
      choice = new H245_RTPH263VideoRedundancyEncoding();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_RedundancyEncodingMethod::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RedundancyEncodingMethod::Class()), PInvalidCast);
#endif
  return new H245_RedundancyEncodingMethod(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_VideoCapability[]={
      {"nonStandard",0}
     ,{"h261VideoCapability",1}
     ,{"h262VideoCapability",2}
     ,{"h263VideoCapability",3}
     ,{"is11172VideoCapability",4}
     ,{"genericVideoCapability",5}
     ,{"extendedVideoCapability",6}
};
#endif
//
// VideoCapability
//

H245_VideoCapability::H245_VideoCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 5, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_VideoCapability,7
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_VideoCapability::operator H245_NonStandardParameter &() const
#else
H245_VideoCapability::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_VideoCapability::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_VideoCapability::operator H245_H261VideoCapability &() const
#else
H245_VideoCapability::operator H245_H261VideoCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H261VideoCapability), PInvalidCast);
#endif
  return *(H245_H261VideoCapability *)choice;
}


H245_VideoCapability::operator const H245_H261VideoCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H261VideoCapability), PInvalidCast);
#endif
  return *(H245_H261VideoCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_VideoCapability::operator H245_H262VideoCapability &() const
#else
H245_VideoCapability::operator H245_H262VideoCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H262VideoCapability), PInvalidCast);
#endif
  return *(H245_H262VideoCapability *)choice;
}


H245_VideoCapability::operator const H245_H262VideoCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H262VideoCapability), PInvalidCast);
#endif
  return *(H245_H262VideoCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_VideoCapability::operator H245_H263VideoCapability &() const
#else
H245_VideoCapability::operator H245_H263VideoCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H263VideoCapability), PInvalidCast);
#endif
  return *(H245_H263VideoCapability *)choice;
}


H245_VideoCapability::operator const H245_H263VideoCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H263VideoCapability), PInvalidCast);
#endif
  return *(H245_H263VideoCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_VideoCapability::operator H245_IS11172VideoCapability &() const
#else
H245_VideoCapability::operator H245_IS11172VideoCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_IS11172VideoCapability), PInvalidCast);
#endif
  return *(H245_IS11172VideoCapability *)choice;
}


H245_VideoCapability::operator const H245_IS11172VideoCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_IS11172VideoCapability), PInvalidCast);
#endif
  return *(H245_IS11172VideoCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_VideoCapability::operator H245_GenericCapability &() const
#else
H245_VideoCapability::operator H245_GenericCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_GenericCapability), PInvalidCast);
#endif
  return *(H245_GenericCapability *)choice;
}


H245_VideoCapability::operator const H245_GenericCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_GenericCapability), PInvalidCast);
#endif
  return *(H245_GenericCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_VideoCapability::operator H245_ExtendedVideoCapability &() const
#else
H245_VideoCapability::operator H245_ExtendedVideoCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ExtendedVideoCapability), PInvalidCast);
#endif
  return *(H245_ExtendedVideoCapability *)choice;
}


H245_VideoCapability::operator const H245_ExtendedVideoCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ExtendedVideoCapability), PInvalidCast);
#endif
  return *(H245_ExtendedVideoCapability *)choice;
}


BOOL H245_VideoCapability::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_h261VideoCapability :
      choice = new H245_H261VideoCapability();
      return TRUE;
    case e_h262VideoCapability :
      choice = new H245_H262VideoCapability();
      return TRUE;
    case e_h263VideoCapability :
      choice = new H245_H263VideoCapability();
      return TRUE;
    case e_is11172VideoCapability :
      choice = new H245_IS11172VideoCapability();
      return TRUE;
    case e_genericVideoCapability :
      choice = new H245_GenericCapability();
      return TRUE;
    case e_extendedVideoCapability :
      choice = new H245_ExtendedVideoCapability();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_VideoCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_VideoCapability::Class()), PInvalidCast);
#endif
  return new H245_VideoCapability(*this);
}


//
// H261VideoCapability
//

H245_H261VideoCapability::H245_H261VideoCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 1)
{
  m_qcifMPI.SetConstraints(PASN_Object::FixedConstraint, 1, 4);
  m_cifMPI.SetConstraints(PASN_Object::FixedConstraint, 1, 4);
  m_maxBitRate.SetConstraints(PASN_Object::FixedConstraint, 1, 19200);
  IncludeOptionalField(e_videoBadMBsCap);
}


#ifndef PASN_NOPRINTON
void H245_H261VideoCapability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_qcifMPI))
    strm << setw(indent+10) << "qcifMPI = " << setprecision(indent) << m_qcifMPI << '\n';
  if (HasOptionalField(e_cifMPI))
    strm << setw(indent+9) << "cifMPI = " << setprecision(indent) << m_cifMPI << '\n';
  strm << setw(indent+36) << "temporalSpatialTradeOffCapability = " << setprecision(indent) << m_temporalSpatialTradeOffCapability << '\n';
  strm << setw(indent+13) << "maxBitRate = " << setprecision(indent) << m_maxBitRate << '\n';
  strm << setw(indent+25) << "stillImageTransmission = " << setprecision(indent) << m_stillImageTransmission << '\n';
  if (HasOptionalField(e_videoBadMBsCap))
    strm << setw(indent+17) << "videoBadMBsCap = " << setprecision(indent) << m_videoBadMBsCap << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_H261VideoCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_H261VideoCapability), PInvalidCast);
#endif
  const H245_H261VideoCapability & other = (const H245_H261VideoCapability &)obj;

  Comparison result;

  if ((result = m_qcifMPI.Compare(other.m_qcifMPI)) != EqualTo)
    return result;
  if ((result = m_cifMPI.Compare(other.m_cifMPI)) != EqualTo)
    return result;
  if ((result = m_temporalSpatialTradeOffCapability.Compare(other.m_temporalSpatialTradeOffCapability)) != EqualTo)
    return result;
  if ((result = m_maxBitRate.Compare(other.m_maxBitRate)) != EqualTo)
    return result;
  if ((result = m_stillImageTransmission.Compare(other.m_stillImageTransmission)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H261VideoCapability::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_qcifMPI))
    length += m_qcifMPI.GetObjectLength();
  if (HasOptionalField(e_cifMPI))
    length += m_cifMPI.GetObjectLength();
  length += m_temporalSpatialTradeOffCapability.GetObjectLength();
  length += m_maxBitRate.GetObjectLength();
  length += m_stillImageTransmission.GetObjectLength();
  return length;
}


BOOL H245_H261VideoCapability::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_qcifMPI) && !m_qcifMPI.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_cifMPI) && !m_cifMPI.Decode(strm))
    return FALSE;
  if (!m_temporalSpatialTradeOffCapability.Decode(strm))
    return FALSE;
  if (!m_maxBitRate.Decode(strm))
    return FALSE;
  if (!m_stillImageTransmission.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_videoBadMBsCap, m_videoBadMBsCap))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_H261VideoCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_qcifMPI))
    m_qcifMPI.Encode(strm);
  if (HasOptionalField(e_cifMPI))
    m_cifMPI.Encode(strm);
  m_temporalSpatialTradeOffCapability.Encode(strm);
  m_maxBitRate.Encode(strm);
  m_stillImageTransmission.Encode(strm);
  KnownExtensionEncode(strm, e_videoBadMBsCap, m_videoBadMBsCap);

  UnknownExtensionsEncode(strm);
}


PObject * H245_H261VideoCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H261VideoCapability::Class()), PInvalidCast);
#endif
  return new H245_H261VideoCapability(*this);
}


//
// H262VideoCapability
//

H245_H262VideoCapability::H245_H262VideoCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 6, FALSE, 0)
{
  m_videoBitRate.SetConstraints(PASN_Object::FixedConstraint, 0, 1073741823);
  m_vbvBufferSize.SetConstraints(PASN_Object::FixedConstraint, 0, 262143);
  m_samplesPerLine.SetConstraints(PASN_Object::FixedConstraint, 0, 16383);
  m_linesPerFrame.SetConstraints(PASN_Object::FixedConstraint, 0, 16383);
  m_framesPerSecond.SetConstraints(PASN_Object::FixedConstraint, 0, 15);
  m_luminanceSampleRate.SetConstraints(PASN_Object::FixedConstraint, 0, 4294967295U);
}


#ifndef PASN_NOPRINTON
void H245_H262VideoCapability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+25) << "profileAndLevel_SPatML = " << setprecision(indent) << m_profileAndLevel_SPatML << '\n';
  strm << setw(indent+25) << "profileAndLevel_MPatLL = " << setprecision(indent) << m_profileAndLevel_MPatLL << '\n';
  strm << setw(indent+25) << "profileAndLevel_MPatML = " << setprecision(indent) << m_profileAndLevel_MPatML << '\n';
  strm << setw(indent+27) << "profileAndLevel_MPatH_14 = " << setprecision(indent) << m_profileAndLevel_MPatH_14 << '\n';
  strm << setw(indent+25) << "profileAndLevel_MPatHL = " << setprecision(indent) << m_profileAndLevel_MPatHL << '\n';
  strm << setw(indent+26) << "profileAndLevel_SNRatLL = " << setprecision(indent) << m_profileAndLevel_SNRatLL << '\n';
  strm << setw(indent+26) << "profileAndLevel_SNRatML = " << setprecision(indent) << m_profileAndLevel_SNRatML << '\n';
  strm << setw(indent+32) << "profileAndLevel_SpatialatH_14 = " << setprecision(indent) << m_profileAndLevel_SpatialatH_14 << '\n';
  strm << setw(indent+25) << "profileAndLevel_HPatML = " << setprecision(indent) << m_profileAndLevel_HPatML << '\n';
  strm << setw(indent+27) << "profileAndLevel_HPatH_14 = " << setprecision(indent) << m_profileAndLevel_HPatH_14 << '\n';
  strm << setw(indent+25) << "profileAndLevel_HPatHL = " << setprecision(indent) << m_profileAndLevel_HPatHL << '\n';
  if (HasOptionalField(e_videoBitRate))
    strm << setw(indent+15) << "videoBitRate = " << setprecision(indent) << m_videoBitRate << '\n';
  if (HasOptionalField(e_vbvBufferSize))
    strm << setw(indent+16) << "vbvBufferSize = " << setprecision(indent) << m_vbvBufferSize << '\n';
  if (HasOptionalField(e_samplesPerLine))
    strm << setw(indent+17) << "samplesPerLine = " << setprecision(indent) << m_samplesPerLine << '\n';
  if (HasOptionalField(e_linesPerFrame))
    strm << setw(indent+16) << "linesPerFrame = " << setprecision(indent) << m_linesPerFrame << '\n';
  if (HasOptionalField(e_framesPerSecond))
    strm << setw(indent+18) << "framesPerSecond = " << setprecision(indent) << m_framesPerSecond << '\n';
  if (HasOptionalField(e_luminanceSampleRate))
    strm << setw(indent+22) << "luminanceSampleRate = " << setprecision(indent) << m_luminanceSampleRate << '\n';
  strm << setw(indent+17) << "videoBadMBsCap = " << setprecision(indent) << m_videoBadMBsCap << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_H262VideoCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_H262VideoCapability), PInvalidCast);
#endif
  const H245_H262VideoCapability & other = (const H245_H262VideoCapability &)obj;

  Comparison result;

  if ((result = m_profileAndLevel_SPatML.Compare(other.m_profileAndLevel_SPatML)) != EqualTo)
    return result;
  if ((result = m_profileAndLevel_MPatLL.Compare(other.m_profileAndLevel_MPatLL)) != EqualTo)
    return result;
  if ((result = m_profileAndLevel_MPatML.Compare(other.m_profileAndLevel_MPatML)) != EqualTo)
    return result;
  if ((result = m_profileAndLevel_MPatH_14.Compare(other.m_profileAndLevel_MPatH_14)) != EqualTo)
    return result;
  if ((result = m_profileAndLevel_MPatHL.Compare(other.m_profileAndLevel_MPatHL)) != EqualTo)
    return result;
  if ((result = m_profileAndLevel_SNRatLL.Compare(other.m_profileAndLevel_SNRatLL)) != EqualTo)
    return result;
  if ((result = m_profileAndLevel_SNRatML.Compare(other.m_profileAndLevel_SNRatML)) != EqualTo)
    return result;
  if ((result = m_profileAndLevel_SpatialatH_14.Compare(other.m_profileAndLevel_SpatialatH_14)) != EqualTo)
    return result;
  if ((result = m_profileAndLevel_HPatML.Compare(other.m_profileAndLevel_HPatML)) != EqualTo)
    return result;
  if ((result = m_profileAndLevel_HPatH_14.Compare(other.m_profileAndLevel_HPatH_14)) != EqualTo)
    return result;
  if ((result = m_profileAndLevel_HPatHL.Compare(other.m_profileAndLevel_HPatHL)) != EqualTo)
    return result;
  if ((result = m_videoBitRate.Compare(other.m_videoBitRate)) != EqualTo)
    return result;
  if ((result = m_vbvBufferSize.Compare(other.m_vbvBufferSize)) != EqualTo)
    return result;
  if ((result = m_samplesPerLine.Compare(other.m_samplesPerLine)) != EqualTo)
    return result;
  if ((result = m_linesPerFrame.Compare(other.m_linesPerFrame)) != EqualTo)
    return result;
  if ((result = m_framesPerSecond.Compare(other.m_framesPerSecond)) != EqualTo)
    return result;
  if ((result = m_luminanceSampleRate.Compare(other.m_luminanceSampleRate)) != EqualTo)
    return result;
  if ((result = m_videoBadMBsCap.Compare(other.m_videoBadMBsCap)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H262VideoCapability::GetDataLength() const
{
  PINDEX length = 0;
  length += m_profileAndLevel_SPatML.GetObjectLength();
  length += m_profileAndLevel_MPatLL.GetObjectLength();
  length += m_profileAndLevel_MPatML.GetObjectLength();
  length += m_profileAndLevel_MPatH_14.GetObjectLength();
  length += m_profileAndLevel_MPatHL.GetObjectLength();
  length += m_profileAndLevel_SNRatLL.GetObjectLength();
  length += m_profileAndLevel_SNRatML.GetObjectLength();
  length += m_profileAndLevel_SpatialatH_14.GetObjectLength();
  length += m_profileAndLevel_HPatML.GetObjectLength();
  length += m_profileAndLevel_HPatH_14.GetObjectLength();
  length += m_profileAndLevel_HPatHL.GetObjectLength();
  if (HasOptionalField(e_videoBitRate))
    length += m_videoBitRate.GetObjectLength();
  if (HasOptionalField(e_vbvBufferSize))
    length += m_vbvBufferSize.GetObjectLength();
  if (HasOptionalField(e_samplesPerLine))
    length += m_samplesPerLine.GetObjectLength();
  if (HasOptionalField(e_linesPerFrame))
    length += m_linesPerFrame.GetObjectLength();
  if (HasOptionalField(e_framesPerSecond))
    length += m_framesPerSecond.GetObjectLength();
  if (HasOptionalField(e_luminanceSampleRate))
    length += m_luminanceSampleRate.GetObjectLength();
  length += m_videoBadMBsCap.GetObjectLength();
  return length;
}


BOOL H245_H262VideoCapability::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_profileAndLevel_SPatML.Decode(strm))
    return FALSE;
  if (!m_profileAndLevel_MPatLL.Decode(strm))
    return FALSE;
  if (!m_profileAndLevel_MPatML.Decode(strm))
    return FALSE;
  if (!m_profileAndLevel_MPatH_14.Decode(strm))
    return FALSE;
  if (!m_profileAndLevel_MPatHL.Decode(strm))
    return FALSE;
  if (!m_profileAndLevel_SNRatLL.Decode(strm))
    return FALSE;
  if (!m_profileAndLevel_SNRatML.Decode(strm))
    return FALSE;
  if (!m_profileAndLevel_SpatialatH_14.Decode(strm))
    return FALSE;
  if (!m_profileAndLevel_HPatML.Decode(strm))
    return FALSE;
  if (!m_profileAndLevel_HPatH_14.Decode(strm))
    return FALSE;
  if (!m_profileAndLevel_HPatHL.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_videoBitRate) && !m_videoBitRate.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_vbvBufferSize) && !m_vbvBufferSize.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_samplesPerLine) && !m_samplesPerLine.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_linesPerFrame) && !m_linesPerFrame.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_framesPerSecond) && !m_framesPerSecond.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_luminanceSampleRate) && !m_luminanceSampleRate.Decode(strm))
    return FALSE;
  if (!m_videoBadMBsCap.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_H262VideoCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_profileAndLevel_SPatML.Encode(strm);
  m_profileAndLevel_MPatLL.Encode(strm);
  m_profileAndLevel_MPatML.Encode(strm);
  m_profileAndLevel_MPatH_14.Encode(strm);
  m_profileAndLevel_MPatHL.Encode(strm);
  m_profileAndLevel_SNRatLL.Encode(strm);
  m_profileAndLevel_SNRatML.Encode(strm);
  m_profileAndLevel_SpatialatH_14.Encode(strm);
  m_profileAndLevel_HPatML.Encode(strm);
  m_profileAndLevel_HPatH_14.Encode(strm);
  m_profileAndLevel_HPatHL.Encode(strm);
  if (HasOptionalField(e_videoBitRate))
    m_videoBitRate.Encode(strm);
  if (HasOptionalField(e_vbvBufferSize))
    m_vbvBufferSize.Encode(strm);
  if (HasOptionalField(e_samplesPerLine))
    m_samplesPerLine.Encode(strm);
  if (HasOptionalField(e_linesPerFrame))
    m_linesPerFrame.Encode(strm);
  if (HasOptionalField(e_framesPerSecond))
    m_framesPerSecond.Encode(strm);
  if (HasOptionalField(e_luminanceSampleRate))
    m_luminanceSampleRate.Encode(strm);
  m_videoBadMBsCap.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_H262VideoCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H262VideoCapability::Class()), PInvalidCast);
#endif
  return new H245_H262VideoCapability(*this);
}


//
// TransparencyParameters
//

H245_TransparencyParameters::H245_TransparencyParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_presentationOrder.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
  m_offset_x.SetConstraints(PASN_Object::FixedConstraint, -262144, 262143);
  m_offset_y.SetConstraints(PASN_Object::FixedConstraint, -262144, 262143);
  m_scale_x.SetConstraints(PASN_Object::FixedConstraint, 1, 255);
  m_scale_y.SetConstraints(PASN_Object::FixedConstraint, 1, 255);
}


#ifndef PASN_NOPRINTON
void H245_TransparencyParameters::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+20) << "presentationOrder = " << setprecision(indent) << m_presentationOrder << '\n';
  strm << setw(indent+11) << "offset_x = " << setprecision(indent) << m_offset_x << '\n';
  strm << setw(indent+11) << "offset_y = " << setprecision(indent) << m_offset_y << '\n';
  strm << setw(indent+10) << "scale_x = " << setprecision(indent) << m_scale_x << '\n';
  strm << setw(indent+10) << "scale_y = " << setprecision(indent) << m_scale_y << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_TransparencyParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_TransparencyParameters), PInvalidCast);
#endif
  const H245_TransparencyParameters & other = (const H245_TransparencyParameters &)obj;

  Comparison result;

  if ((result = m_presentationOrder.Compare(other.m_presentationOrder)) != EqualTo)
    return result;
  if ((result = m_offset_x.Compare(other.m_offset_x)) != EqualTo)
    return result;
  if ((result = m_offset_y.Compare(other.m_offset_y)) != EqualTo)
    return result;
  if ((result = m_scale_x.Compare(other.m_scale_x)) != EqualTo)
    return result;
  if ((result = m_scale_y.Compare(other.m_scale_y)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_TransparencyParameters::GetDataLength() const
{
  PINDEX length = 0;
  length += m_presentationOrder.GetObjectLength();
  length += m_offset_x.GetObjectLength();
  length += m_offset_y.GetObjectLength();
  length += m_scale_x.GetObjectLength();
  length += m_scale_y.GetObjectLength();
  return length;
}


BOOL H245_TransparencyParameters::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_presentationOrder.Decode(strm))
    return FALSE;
  if (!m_offset_x.Decode(strm))
    return FALSE;
  if (!m_offset_y.Decode(strm))
    return FALSE;
  if (!m_scale_x.Decode(strm))
    return FALSE;
  if (!m_scale_y.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_TransparencyParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_presentationOrder.Encode(strm);
  m_offset_x.Encode(strm);
  m_offset_y.Encode(strm);
  m_scale_x.Encode(strm);
  m_scale_y.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_TransparencyParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_TransparencyParameters::Class()), PInvalidCast);
#endif
  return new H245_TransparencyParameters(*this);
}


//
// CustomPictureClockFrequency
//

H245_CustomPictureClockFrequency::H245_CustomPictureClockFrequency(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 5, TRUE, 0)
{
  m_clockConversionCode.SetConstraints(PASN_Object::FixedConstraint, 1000, 1001);
  m_clockDivisor.SetConstraints(PASN_Object::FixedConstraint, 1, 127);
  m_sqcifMPI.SetConstraints(PASN_Object::FixedConstraint, 1, 2048);
  m_qcifMPI.SetConstraints(PASN_Object::FixedConstraint, 1, 2048);
  m_cifMPI.SetConstraints(PASN_Object::FixedConstraint, 1, 2048);
  m_cif4MPI.SetConstraints(PASN_Object::FixedConstraint, 1, 2048);
  m_cif16MPI.SetConstraints(PASN_Object::FixedConstraint, 1, 2048);
}


#ifndef PASN_NOPRINTON
void H245_CustomPictureClockFrequency::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+22) << "clockConversionCode = " << setprecision(indent) << m_clockConversionCode << '\n';
  strm << setw(indent+15) << "clockDivisor = " << setprecision(indent) << m_clockDivisor << '\n';
  if (HasOptionalField(e_sqcifMPI))
    strm << setw(indent+11) << "sqcifMPI = " << setprecision(indent) << m_sqcifMPI << '\n';
  if (HasOptionalField(e_qcifMPI))
    strm << setw(indent+10) << "qcifMPI = " << setprecision(indent) << m_qcifMPI << '\n';
  if (HasOptionalField(e_cifMPI))
    strm << setw(indent+9) << "cifMPI = " << setprecision(indent) << m_cifMPI << '\n';
  if (HasOptionalField(e_cif4MPI))
    strm << setw(indent+10) << "cif4MPI = " << setprecision(indent) << m_cif4MPI << '\n';
  if (HasOptionalField(e_cif16MPI))
    strm << setw(indent+11) << "cif16MPI = " << setprecision(indent) << m_cif16MPI << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_CustomPictureClockFrequency::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_CustomPictureClockFrequency), PInvalidCast);
#endif
  const H245_CustomPictureClockFrequency & other = (const H245_CustomPictureClockFrequency &)obj;

  Comparison result;

  if ((result = m_clockConversionCode.Compare(other.m_clockConversionCode)) != EqualTo)
    return result;
  if ((result = m_clockDivisor.Compare(other.m_clockDivisor)) != EqualTo)
    return result;
  if ((result = m_sqcifMPI.Compare(other.m_sqcifMPI)) != EqualTo)
    return result;
  if ((result = m_qcifMPI.Compare(other.m_qcifMPI)) != EqualTo)
    return result;
  if ((result = m_cifMPI.Compare(other.m_cifMPI)) != EqualTo)
    return result;
  if ((result = m_cif4MPI.Compare(other.m_cif4MPI)) != EqualTo)
    return result;
  if ((result = m_cif16MPI.Compare(other.m_cif16MPI)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_CustomPictureClockFrequency::GetDataLength() const
{
  PINDEX length = 0;
  length += m_clockConversionCode.GetObjectLength();
  length += m_clockDivisor.GetObjectLength();
  if (HasOptionalField(e_sqcifMPI))
    length += m_sqcifMPI.GetObjectLength();
  if (HasOptionalField(e_qcifMPI))
    length += m_qcifMPI.GetObjectLength();
  if (HasOptionalField(e_cifMPI))
    length += m_cifMPI.GetObjectLength();
  if (HasOptionalField(e_cif4MPI))
    length += m_cif4MPI.GetObjectLength();
  if (HasOptionalField(e_cif16MPI))
    length += m_cif16MPI.GetObjectLength();
  return length;
}


BOOL H245_CustomPictureClockFrequency::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_clockConversionCode.Decode(strm))
    return FALSE;
  if (!m_clockDivisor.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_sqcifMPI) && !m_sqcifMPI.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_qcifMPI) && !m_qcifMPI.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_cifMPI) && !m_cifMPI.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_cif4MPI) && !m_cif4MPI.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_cif16MPI) && !m_cif16MPI.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_CustomPictureClockFrequency::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_clockConversionCode.Encode(strm);
  m_clockDivisor.Encode(strm);
  if (HasOptionalField(e_sqcifMPI))
    m_sqcifMPI.Encode(strm);
  if (HasOptionalField(e_qcifMPI))
    m_qcifMPI.Encode(strm);
  if (HasOptionalField(e_cifMPI))
    m_cifMPI.Encode(strm);
  if (HasOptionalField(e_cif4MPI))
    m_cif4MPI.Encode(strm);
  if (HasOptionalField(e_cif16MPI))
    m_cif16MPI.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_CustomPictureClockFrequency::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CustomPictureClockFrequency::Class()), PInvalidCast);
#endif
  return new H245_CustomPictureClockFrequency(*this);
}


//
// H263Version3Options
//

H245_H263Version3Options::H245_H263Version3Options(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_H263Version3Options::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+24) << "dataPartitionedSlices = " << setprecision(indent) << m_dataPartitionedSlices << '\n';
  strm << setw(indent+18) << "fixedPointIDCT0 = " << setprecision(indent) << m_fixedPointIDCT0 << '\n';
  strm << setw(indent+19) << "interlacedFields = " << setprecision(indent) << m_interlacedFields << '\n';
  strm << setw(indent+33) << "currentPictureHeaderRepetition = " << setprecision(indent) << m_currentPictureHeaderRepetition << '\n';
  strm << setw(indent+34) << "previousPictureHeaderRepetition = " << setprecision(indent) << m_previousPictureHeaderRepetition << '\n';
  strm << setw(indent+30) << "nextPictureHeaderRepetition = " << setprecision(indent) << m_nextPictureHeaderRepetition << '\n';
  strm << setw(indent+16) << "pictureNumber = " << setprecision(indent) << m_pictureNumber << '\n';
  strm << setw(indent+25) << "spareReferencePictures = " << setprecision(indent) << m_spareReferencePictures << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_H263Version3Options::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_H263Version3Options), PInvalidCast);
#endif
  const H245_H263Version3Options & other = (const H245_H263Version3Options &)obj;

  Comparison result;

  if ((result = m_dataPartitionedSlices.Compare(other.m_dataPartitionedSlices)) != EqualTo)
    return result;
  if ((result = m_fixedPointIDCT0.Compare(other.m_fixedPointIDCT0)) != EqualTo)
    return result;
  if ((result = m_interlacedFields.Compare(other.m_interlacedFields)) != EqualTo)
    return result;
  if ((result = m_currentPictureHeaderRepetition.Compare(other.m_currentPictureHeaderRepetition)) != EqualTo)
    return result;
  if ((result = m_previousPictureHeaderRepetition.Compare(other.m_previousPictureHeaderRepetition)) != EqualTo)
    return result;
  if ((result = m_nextPictureHeaderRepetition.Compare(other.m_nextPictureHeaderRepetition)) != EqualTo)
    return result;
  if ((result = m_pictureNumber.Compare(other.m_pictureNumber)) != EqualTo)
    return result;
  if ((result = m_spareReferencePictures.Compare(other.m_spareReferencePictures)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H263Version3Options::GetDataLength() const
{
  PINDEX length = 0;
  length += m_dataPartitionedSlices.GetObjectLength();
  length += m_fixedPointIDCT0.GetObjectLength();
  length += m_interlacedFields.GetObjectLength();
  length += m_currentPictureHeaderRepetition.GetObjectLength();
  length += m_previousPictureHeaderRepetition.GetObjectLength();
  length += m_nextPictureHeaderRepetition.GetObjectLength();
  length += m_pictureNumber.GetObjectLength();
  length += m_spareReferencePictures.GetObjectLength();
  return length;
}


BOOL H245_H263Version3Options::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_dataPartitionedSlices.Decode(strm))
    return FALSE;
  if (!m_fixedPointIDCT0.Decode(strm))
    return FALSE;
  if (!m_interlacedFields.Decode(strm))
    return FALSE;
  if (!m_currentPictureHeaderRepetition.Decode(strm))
    return FALSE;
  if (!m_previousPictureHeaderRepetition.Decode(strm))
    return FALSE;
  if (!m_nextPictureHeaderRepetition.Decode(strm))
    return FALSE;
  if (!m_pictureNumber.Decode(strm))
    return FALSE;
  if (!m_spareReferencePictures.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_H263Version3Options::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_dataPartitionedSlices.Encode(strm);
  m_fixedPointIDCT0.Encode(strm);
  m_interlacedFields.Encode(strm);
  m_currentPictureHeaderRepetition.Encode(strm);
  m_previousPictureHeaderRepetition.Encode(strm);
  m_nextPictureHeaderRepetition.Encode(strm);
  m_pictureNumber.Encode(strm);
  m_spareReferencePictures.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_H263Version3Options::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H263Version3Options::Class()), PInvalidCast);
#endif
  return new H245_H263Version3Options(*this);
}


//
// IS11172VideoCapability
//

H245_IS11172VideoCapability::H245_IS11172VideoCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 6, TRUE, 1)
{
  m_videoBitRate.SetConstraints(PASN_Object::FixedConstraint, 0, 1073741823);
  m_vbvBufferSize.SetConstraints(PASN_Object::FixedConstraint, 0, 262143);
  m_samplesPerLine.SetConstraints(PASN_Object::FixedConstraint, 0, 16383);
  m_linesPerFrame.SetConstraints(PASN_Object::FixedConstraint, 0, 16383);
  m_pictureRate.SetConstraints(PASN_Object::FixedConstraint, 0, 15);
  m_luminanceSampleRate.SetConstraints(PASN_Object::FixedConstraint, 0, 4294967295U);
  IncludeOptionalField(e_videoBadMBsCap);
}


#ifndef PASN_NOPRINTON
void H245_IS11172VideoCapability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+23) << "constrainedBitstream = " << setprecision(indent) << m_constrainedBitstream << '\n';
  if (HasOptionalField(e_videoBitRate))
    strm << setw(indent+15) << "videoBitRate = " << setprecision(indent) << m_videoBitRate << '\n';
  if (HasOptionalField(e_vbvBufferSize))
    strm << setw(indent+16) << "vbvBufferSize = " << setprecision(indent) << m_vbvBufferSize << '\n';
  if (HasOptionalField(e_samplesPerLine))
    strm << setw(indent+17) << "samplesPerLine = " << setprecision(indent) << m_samplesPerLine << '\n';
  if (HasOptionalField(e_linesPerFrame))
    strm << setw(indent+16) << "linesPerFrame = " << setprecision(indent) << m_linesPerFrame << '\n';
  if (HasOptionalField(e_pictureRate))
    strm << setw(indent+14) << "pictureRate = " << setprecision(indent) << m_pictureRate << '\n';
  if (HasOptionalField(e_luminanceSampleRate))
    strm << setw(indent+22) << "luminanceSampleRate = " << setprecision(indent) << m_luminanceSampleRate << '\n';
  if (HasOptionalField(e_videoBadMBsCap))
    strm << setw(indent+17) << "videoBadMBsCap = " << setprecision(indent) << m_videoBadMBsCap << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_IS11172VideoCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_IS11172VideoCapability), PInvalidCast);
#endif
  const H245_IS11172VideoCapability & other = (const H245_IS11172VideoCapability &)obj;

  Comparison result;

  if ((result = m_constrainedBitstream.Compare(other.m_constrainedBitstream)) != EqualTo)
    return result;
  if ((result = m_videoBitRate.Compare(other.m_videoBitRate)) != EqualTo)
    return result;
  if ((result = m_vbvBufferSize.Compare(other.m_vbvBufferSize)) != EqualTo)
    return result;
  if ((result = m_samplesPerLine.Compare(other.m_samplesPerLine)) != EqualTo)
    return result;
  if ((result = m_linesPerFrame.Compare(other.m_linesPerFrame)) != EqualTo)
    return result;
  if ((result = m_pictureRate.Compare(other.m_pictureRate)) != EqualTo)
    return result;
  if ((result = m_luminanceSampleRate.Compare(other.m_luminanceSampleRate)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_IS11172VideoCapability::GetDataLength() const
{
  PINDEX length = 0;
  length += m_constrainedBitstream.GetObjectLength();
  if (HasOptionalField(e_videoBitRate))
    length += m_videoBitRate.GetObjectLength();
  if (HasOptionalField(e_vbvBufferSize))
    length += m_vbvBufferSize.GetObjectLength();
  if (HasOptionalField(e_samplesPerLine))
    length += m_samplesPerLine.GetObjectLength();
  if (HasOptionalField(e_linesPerFrame))
    length += m_linesPerFrame.GetObjectLength();
  if (HasOptionalField(e_pictureRate))
    length += m_pictureRate.GetObjectLength();
  if (HasOptionalField(e_luminanceSampleRate))
    length += m_luminanceSampleRate.GetObjectLength();
  return length;
}


BOOL H245_IS11172VideoCapability::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_constrainedBitstream.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_videoBitRate) && !m_videoBitRate.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_vbvBufferSize) && !m_vbvBufferSize.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_samplesPerLine) && !m_samplesPerLine.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_linesPerFrame) && !m_linesPerFrame.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_pictureRate) && !m_pictureRate.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_luminanceSampleRate) && !m_luminanceSampleRate.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_videoBadMBsCap, m_videoBadMBsCap))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_IS11172VideoCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_constrainedBitstream.Encode(strm);
  if (HasOptionalField(e_videoBitRate))
    m_videoBitRate.Encode(strm);
  if (HasOptionalField(e_vbvBufferSize))
    m_vbvBufferSize.Encode(strm);
  if (HasOptionalField(e_samplesPerLine))
    m_samplesPerLine.Encode(strm);
  if (HasOptionalField(e_linesPerFrame))
    m_linesPerFrame.Encode(strm);
  if (HasOptionalField(e_pictureRate))
    m_pictureRate.Encode(strm);
  if (HasOptionalField(e_luminanceSampleRate))
    m_luminanceSampleRate.Encode(strm);
  KnownExtensionEncode(strm, e_videoBadMBsCap, m_videoBadMBsCap);

  UnknownExtensionsEncode(strm);
}


PObject * H245_IS11172VideoCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_IS11172VideoCapability::Class()), PInvalidCast);
#endif
  return new H245_IS11172VideoCapability(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_AudioCapability[]={
      {"nonStandard",0}
     ,{"g711Alaw64k",1}
     ,{"g711Alaw56k",2}
     ,{"g711Ulaw64k",3}
     ,{"g711Ulaw56k",4}
     ,{"g722_64k",5}
     ,{"g722_56k",6}
     ,{"g722_48k",7}
     ,{"g7231",8}
     ,{"g728",9}
     ,{"g729",10}
     ,{"g729AnnexA",11}
     ,{"is11172AudioCapability",12}
     ,{"is13818AudioCapability",13}
     ,{"g729wAnnexB",14}
     ,{"g729AnnexAwAnnexB",15}
     ,{"g7231AnnexCCapability",16}
     ,{"gsmFullRate",17}
     ,{"gsmHalfRate",18}
     ,{"gsmEnhancedFullRate",19}
     ,{"genericAudioCapability",20}
     ,{"g729Extensions",21}
     ,{"vbd",22}
     ,{"audioTelephonyEvent",23}
     ,{"audioTone",24}
};
#endif
//
// AudioCapability
//

H245_AudioCapability::H245_AudioCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 14, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_AudioCapability,25
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_AudioCapability::operator H245_NonStandardParameter &() const
#else
H245_AudioCapability::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_AudioCapability::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_AudioCapability::operator H245_AudioCapability_g7231 &() const
#else
H245_AudioCapability::operator H245_AudioCapability_g7231 &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_AudioCapability_g7231), PInvalidCast);
#endif
  return *(H245_AudioCapability_g7231 *)choice;
}


H245_AudioCapability::operator const H245_AudioCapability_g7231 &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_AudioCapability_g7231), PInvalidCast);
#endif
  return *(H245_AudioCapability_g7231 *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_AudioCapability::operator H245_IS11172AudioCapability &() const
#else
H245_AudioCapability::operator H245_IS11172AudioCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_IS11172AudioCapability), PInvalidCast);
#endif
  return *(H245_IS11172AudioCapability *)choice;
}


H245_AudioCapability::operator const H245_IS11172AudioCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_IS11172AudioCapability), PInvalidCast);
#endif
  return *(H245_IS11172AudioCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_AudioCapability::operator H245_IS13818AudioCapability &() const
#else
H245_AudioCapability::operator H245_IS13818AudioCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_IS13818AudioCapability), PInvalidCast);
#endif
  return *(H245_IS13818AudioCapability *)choice;
}


H245_AudioCapability::operator const H245_IS13818AudioCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_IS13818AudioCapability), PInvalidCast);
#endif
  return *(H245_IS13818AudioCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_AudioCapability::operator H245_G7231AnnexCCapability &() const
#else
H245_AudioCapability::operator H245_G7231AnnexCCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_G7231AnnexCCapability), PInvalidCast);
#endif
  return *(H245_G7231AnnexCCapability *)choice;
}


H245_AudioCapability::operator const H245_G7231AnnexCCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_G7231AnnexCCapability), PInvalidCast);
#endif
  return *(H245_G7231AnnexCCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_AudioCapability::operator H245_GSMAudioCapability &() const
#else
H245_AudioCapability::operator H245_GSMAudioCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_GSMAudioCapability), PInvalidCast);
#endif
  return *(H245_GSMAudioCapability *)choice;
}


H245_AudioCapability::operator const H245_GSMAudioCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_GSMAudioCapability), PInvalidCast);
#endif
  return *(H245_GSMAudioCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_AudioCapability::operator H245_GenericCapability &() const
#else
H245_AudioCapability::operator H245_GenericCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_GenericCapability), PInvalidCast);
#endif
  return *(H245_GenericCapability *)choice;
}


H245_AudioCapability::operator const H245_GenericCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_GenericCapability), PInvalidCast);
#endif
  return *(H245_GenericCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_AudioCapability::operator H245_G729Extensions &() const
#else
H245_AudioCapability::operator H245_G729Extensions &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_G729Extensions), PInvalidCast);
#endif
  return *(H245_G729Extensions *)choice;
}


H245_AudioCapability::operator const H245_G729Extensions &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_G729Extensions), PInvalidCast);
#endif
  return *(H245_G729Extensions *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_AudioCapability::operator H245_VBDCapability &() const
#else
H245_AudioCapability::operator H245_VBDCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_VBDCapability), PInvalidCast);
#endif
  return *(H245_VBDCapability *)choice;
}


H245_AudioCapability::operator const H245_VBDCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_VBDCapability), PInvalidCast);
#endif
  return *(H245_VBDCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_AudioCapability::operator H245_NoPTAudioTelephonyEventCapability &() const
#else
H245_AudioCapability::operator H245_NoPTAudioTelephonyEventCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NoPTAudioTelephonyEventCapability), PInvalidCast);
#endif
  return *(H245_NoPTAudioTelephonyEventCapability *)choice;
}


H245_AudioCapability::operator const H245_NoPTAudioTelephonyEventCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NoPTAudioTelephonyEventCapability), PInvalidCast);
#endif
  return *(H245_NoPTAudioTelephonyEventCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_AudioCapability::operator H245_NoPTAudioToneCapability &() const
#else
H245_AudioCapability::operator H245_NoPTAudioToneCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NoPTAudioToneCapability), PInvalidCast);
#endif
  return *(H245_NoPTAudioToneCapability *)choice;
}


H245_AudioCapability::operator const H245_NoPTAudioToneCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NoPTAudioToneCapability), PInvalidCast);
#endif
  return *(H245_NoPTAudioToneCapability *)choice;
}


BOOL H245_AudioCapability::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_g711Alaw64k :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 256);
      return TRUE;
    case e_g711Alaw56k :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 256);
      return TRUE;
    case e_g711Ulaw64k :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 256);
      return TRUE;
    case e_g711Ulaw56k :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 256);
      return TRUE;
    case e_g722_64k :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 256);
      return TRUE;
    case e_g722_56k :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 256);
      return TRUE;
    case e_g722_48k :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 256);
      return TRUE;
    case e_g7231 :
      choice = new H245_AudioCapability_g7231();
      return TRUE;
    case e_g728 :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 256);
      return TRUE;
    case e_g729 :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 256);
      return TRUE;
    case e_g729AnnexA :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 256);
      return TRUE;
    case e_is11172AudioCapability :
      choice = new H245_IS11172AudioCapability();
      return TRUE;
    case e_is13818AudioCapability :
      choice = new H245_IS13818AudioCapability();
      return TRUE;
    case e_g729wAnnexB :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 256);
      return TRUE;
    case e_g729AnnexAwAnnexB :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 256);
      return TRUE;
    case e_g7231AnnexCCapability :
      choice = new H245_G7231AnnexCCapability();
      return TRUE;
    case e_gsmFullRate :
    case e_gsmHalfRate :
    case e_gsmEnhancedFullRate :
      choice = new H245_GSMAudioCapability();
      return TRUE;
    case e_genericAudioCapability :
      choice = new H245_GenericCapability();
      return TRUE;
    case e_g729Extensions :
      choice = new H245_G729Extensions();
      return TRUE;
    case e_vbd :
      choice = new H245_VBDCapability();
      return TRUE;
    case e_audioTelephonyEvent :
      choice = new H245_NoPTAudioTelephonyEventCapability();
      return TRUE;
    case e_audioTone :
      choice = new H245_NoPTAudioToneCapability();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_AudioCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_AudioCapability::Class()), PInvalidCast);
#endif
  return new H245_AudioCapability(*this);
}


//
// G729Extensions
//

H245_G729Extensions::H245_G729Extensions(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_audioUnit.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H245_G729Extensions::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_audioUnit))
    strm << setw(indent+12) << "audioUnit = " << setprecision(indent) << m_audioUnit << '\n';
  strm << setw(indent+9) << "annexA = " << setprecision(indent) << m_annexA << '\n';
  strm << setw(indent+9) << "annexB = " << setprecision(indent) << m_annexB << '\n';
  strm << setw(indent+9) << "annexD = " << setprecision(indent) << m_annexD << '\n';
  strm << setw(indent+9) << "annexE = " << setprecision(indent) << m_annexE << '\n';
  strm << setw(indent+9) << "annexF = " << setprecision(indent) << m_annexF << '\n';
  strm << setw(indent+9) << "annexG = " << setprecision(indent) << m_annexG << '\n';
  strm << setw(indent+9) << "annexH = " << setprecision(indent) << m_annexH << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_G729Extensions::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_G729Extensions), PInvalidCast);
#endif
  const H245_G729Extensions & other = (const H245_G729Extensions &)obj;

  Comparison result;

  if ((result = m_audioUnit.Compare(other.m_audioUnit)) != EqualTo)
    return result;
  if ((result = m_annexA.Compare(other.m_annexA)) != EqualTo)
    return result;
  if ((result = m_annexB.Compare(other.m_annexB)) != EqualTo)
    return result;
  if ((result = m_annexD.Compare(other.m_annexD)) != EqualTo)
    return result;
  if ((result = m_annexE.Compare(other.m_annexE)) != EqualTo)
    return result;
  if ((result = m_annexF.Compare(other.m_annexF)) != EqualTo)
    return result;
  if ((result = m_annexG.Compare(other.m_annexG)) != EqualTo)
    return result;
  if ((result = m_annexH.Compare(other.m_annexH)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_G729Extensions::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_audioUnit))
    length += m_audioUnit.GetObjectLength();
  length += m_annexA.GetObjectLength();
  length += m_annexB.GetObjectLength();
  length += m_annexD.GetObjectLength();
  length += m_annexE.GetObjectLength();
  length += m_annexF.GetObjectLength();
  length += m_annexG.GetObjectLength();
  length += m_annexH.GetObjectLength();
  return length;
}


BOOL H245_G729Extensions::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_audioUnit) && !m_audioUnit.Decode(strm))
    return FALSE;
  if (!m_annexA.Decode(strm))
    return FALSE;
  if (!m_annexB.Decode(strm))
    return FALSE;
  if (!m_annexD.Decode(strm))
    return FALSE;
  if (!m_annexE.Decode(strm))
    return FALSE;
  if (!m_annexF.Decode(strm))
    return FALSE;
  if (!m_annexG.Decode(strm))
    return FALSE;
  if (!m_annexH.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_G729Extensions::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_audioUnit))
    m_audioUnit.Encode(strm);
  m_annexA.Encode(strm);
  m_annexB.Encode(strm);
  m_annexD.Encode(strm);
  m_annexE.Encode(strm);
  m_annexF.Encode(strm);
  m_annexG.Encode(strm);
  m_annexH.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_G729Extensions::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_G729Extensions::Class()), PInvalidCast);
#endif
  return new H245_G729Extensions(*this);
}


//
// IS11172AudioCapability
//

H245_IS11172AudioCapability::H245_IS11172AudioCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_bitRate.SetConstraints(PASN_Object::FixedConstraint, 1, 448);
}


#ifndef PASN_NOPRINTON
void H245_IS11172AudioCapability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+14) << "audioLayer1 = " << setprecision(indent) << m_audioLayer1 << '\n';
  strm << setw(indent+14) << "audioLayer2 = " << setprecision(indent) << m_audioLayer2 << '\n';
  strm << setw(indent+14) << "audioLayer3 = " << setprecision(indent) << m_audioLayer3 << '\n';
  strm << setw(indent+19) << "audioSampling32k = " << setprecision(indent) << m_audioSampling32k << '\n';
  strm << setw(indent+20) << "audioSampling44k1 = " << setprecision(indent) << m_audioSampling44k1 << '\n';
  strm << setw(indent+19) << "audioSampling48k = " << setprecision(indent) << m_audioSampling48k << '\n';
  strm << setw(indent+16) << "singleChannel = " << setprecision(indent) << m_singleChannel << '\n';
  strm << setw(indent+14) << "twoChannels = " << setprecision(indent) << m_twoChannels << '\n';
  strm << setw(indent+10) << "bitRate = " << setprecision(indent) << m_bitRate << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_IS11172AudioCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_IS11172AudioCapability), PInvalidCast);
#endif
  const H245_IS11172AudioCapability & other = (const H245_IS11172AudioCapability &)obj;

  Comparison result;

  if ((result = m_audioLayer1.Compare(other.m_audioLayer1)) != EqualTo)
    return result;
  if ((result = m_audioLayer2.Compare(other.m_audioLayer2)) != EqualTo)
    return result;
  if ((result = m_audioLayer3.Compare(other.m_audioLayer3)) != EqualTo)
    return result;
  if ((result = m_audioSampling32k.Compare(other.m_audioSampling32k)) != EqualTo)
    return result;
  if ((result = m_audioSampling44k1.Compare(other.m_audioSampling44k1)) != EqualTo)
    return result;
  if ((result = m_audioSampling48k.Compare(other.m_audioSampling48k)) != EqualTo)
    return result;
  if ((result = m_singleChannel.Compare(other.m_singleChannel)) != EqualTo)
    return result;
  if ((result = m_twoChannels.Compare(other.m_twoChannels)) != EqualTo)
    return result;
  if ((result = m_bitRate.Compare(other.m_bitRate)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_IS11172AudioCapability::GetDataLength() const
{
  PINDEX length = 0;
  length += m_audioLayer1.GetObjectLength();
  length += m_audioLayer2.GetObjectLength();
  length += m_audioLayer3.GetObjectLength();
  length += m_audioSampling32k.GetObjectLength();
  length += m_audioSampling44k1.GetObjectLength();
  length += m_audioSampling48k.GetObjectLength();
  length += m_singleChannel.GetObjectLength();
  length += m_twoChannels.GetObjectLength();
  length += m_bitRate.GetObjectLength();
  return length;
}


BOOL H245_IS11172AudioCapability::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_audioLayer1.Decode(strm))
    return FALSE;
  if (!m_audioLayer2.Decode(strm))
    return FALSE;
  if (!m_audioLayer3.Decode(strm))
    return FALSE;
  if (!m_audioSampling32k.Decode(strm))
    return FALSE;
  if (!m_audioSampling44k1.Decode(strm))
    return FALSE;
  if (!m_audioSampling48k.Decode(strm))
    return FALSE;
  if (!m_singleChannel.Decode(strm))
    return FALSE;
  if (!m_twoChannels.Decode(strm))
    return FALSE;
  if (!m_bitRate.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_IS11172AudioCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_audioLayer1.Encode(strm);
  m_audioLayer2.Encode(strm);
  m_audioLayer3.Encode(strm);
  m_audioSampling32k.Encode(strm);
  m_audioSampling44k1.Encode(strm);
  m_audioSampling48k.Encode(strm);
  m_singleChannel.Encode(strm);
  m_twoChannels.Encode(strm);
  m_bitRate.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_IS11172AudioCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_IS11172AudioCapability::Class()), PInvalidCast);
#endif
  return new H245_IS11172AudioCapability(*this);
}


//
// IS13818AudioCapability
//

H245_IS13818AudioCapability::H245_IS13818AudioCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_bitRate.SetConstraints(PASN_Object::FixedConstraint, 1, 1130);
}


#ifndef PASN_NOPRINTON
void H245_IS13818AudioCapability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+14) << "audioLayer1 = " << setprecision(indent) << m_audioLayer1 << '\n';
  strm << setw(indent+14) << "audioLayer2 = " << setprecision(indent) << m_audioLayer2 << '\n';
  strm << setw(indent+14) << "audioLayer3 = " << setprecision(indent) << m_audioLayer3 << '\n';
  strm << setw(indent+19) << "audioSampling16k = " << setprecision(indent) << m_audioSampling16k << '\n';
  strm << setw(indent+21) << "audioSampling22k05 = " << setprecision(indent) << m_audioSampling22k05 << '\n';
  strm << setw(indent+19) << "audioSampling24k = " << setprecision(indent) << m_audioSampling24k << '\n';
  strm << setw(indent+19) << "audioSampling32k = " << setprecision(indent) << m_audioSampling32k << '\n';
  strm << setw(indent+20) << "audioSampling44k1 = " << setprecision(indent) << m_audioSampling44k1 << '\n';
  strm << setw(indent+19) << "audioSampling48k = " << setprecision(indent) << m_audioSampling48k << '\n';
  strm << setw(indent+16) << "singleChannel = " << setprecision(indent) << m_singleChannel << '\n';
  strm << setw(indent+14) << "twoChannels = " << setprecision(indent) << m_twoChannels << '\n';
  strm << setw(indent+19) << "threeChannels2_1 = " << setprecision(indent) << m_threeChannels2_1 << '\n';
  strm << setw(indent+19) << "threeChannels3_0 = " << setprecision(indent) << m_threeChannels3_0 << '\n';
  strm << setw(indent+22) << "fourChannels2_0_2_0 = " << setprecision(indent) << m_fourChannels2_0_2_0 << '\n';
  strm << setw(indent+18) << "fourChannels2_2 = " << setprecision(indent) << m_fourChannels2_2 << '\n';
  strm << setw(indent+18) << "fourChannels3_1 = " << setprecision(indent) << m_fourChannels3_1 << '\n';
  strm << setw(indent+22) << "fiveChannels3_0_2_0 = " << setprecision(indent) << m_fiveChannels3_0_2_0 << '\n';
  strm << setw(indent+18) << "fiveChannels3_2 = " << setprecision(indent) << m_fiveChannels3_2 << '\n';
  strm << setw(indent+26) << "lowFrequencyEnhancement = " << setprecision(indent) << m_lowFrequencyEnhancement << '\n';
  strm << setw(indent+15) << "multilingual = " << setprecision(indent) << m_multilingual << '\n';
  strm << setw(indent+10) << "bitRate = " << setprecision(indent) << m_bitRate << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_IS13818AudioCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_IS13818AudioCapability), PInvalidCast);
#endif
  const H245_IS13818AudioCapability & other = (const H245_IS13818AudioCapability &)obj;

  Comparison result;

  if ((result = m_audioLayer1.Compare(other.m_audioLayer1)) != EqualTo)
    return result;
  if ((result = m_audioLayer2.Compare(other.m_audioLayer2)) != EqualTo)
    return result;
  if ((result = m_audioLayer3.Compare(other.m_audioLayer3)) != EqualTo)
    return result;
  if ((result = m_audioSampling16k.Compare(other.m_audioSampling16k)) != EqualTo)
    return result;
  if ((result = m_audioSampling22k05.Compare(other.m_audioSampling22k05)) != EqualTo)
    return result;
  if ((result = m_audioSampling24k.Compare(other.m_audioSampling24k)) != EqualTo)
    return result;
  if ((result = m_audioSampling32k.Compare(other.m_audioSampling32k)) != EqualTo)
    return result;
  if ((result = m_audioSampling44k1.Compare(other.m_audioSampling44k1)) != EqualTo)
    return result;
  if ((result = m_audioSampling48k.Compare(other.m_audioSampling48k)) != EqualTo)
    return result;
  if ((result = m_singleChannel.Compare(other.m_singleChannel)) != EqualTo)
    return result;
  if ((result = m_twoChannels.Compare(other.m_twoChannels)) != EqualTo)
    return result;
  if ((result = m_threeChannels2_1.Compare(other.m_threeChannels2_1)) != EqualTo)
    return result;
  if ((result = m_threeChannels3_0.Compare(other.m_threeChannels3_0)) != EqualTo)
    return result;
  if ((result = m_fourChannels2_0_2_0.Compare(other.m_fourChannels2_0_2_0)) != EqualTo)
    return result;
  if ((result = m_fourChannels2_2.Compare(other.m_fourChannels2_2)) != EqualTo)
    return result;
  if ((result = m_fourChannels3_1.Compare(other.m_fourChannels3_1)) != EqualTo)
    return result;
  if ((result = m_fiveChannels3_0_2_0.Compare(other.m_fiveChannels3_0_2_0)) != EqualTo)
    return result;
  if ((result = m_fiveChannels3_2.Compare(other.m_fiveChannels3_2)) != EqualTo)
    return result;
  if ((result = m_lowFrequencyEnhancement.Compare(other.m_lowFrequencyEnhancement)) != EqualTo)
    return result;
  if ((result = m_multilingual.Compare(other.m_multilingual)) != EqualTo)
    return result;
  if ((result = m_bitRate.Compare(other.m_bitRate)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_IS13818AudioCapability::GetDataLength() const
{
  PINDEX length = 0;
  length += m_audioLayer1.GetObjectLength();
  length += m_audioLayer2.GetObjectLength();
  length += m_audioLayer3.GetObjectLength();
  length += m_audioSampling16k.GetObjectLength();
  length += m_audioSampling22k05.GetObjectLength();
  length += m_audioSampling24k.GetObjectLength();
  length += m_audioSampling32k.GetObjectLength();
  length += m_audioSampling44k1.GetObjectLength();
  length += m_audioSampling48k.GetObjectLength();
  length += m_singleChannel.GetObjectLength();
  length += m_twoChannels.GetObjectLength();
  length += m_threeChannels2_1.GetObjectLength();
  length += m_threeChannels3_0.GetObjectLength();
  length += m_fourChannels2_0_2_0.GetObjectLength();
  length += m_fourChannels2_2.GetObjectLength();
  length += m_fourChannels3_1.GetObjectLength();
  length += m_fiveChannels3_0_2_0.GetObjectLength();
  length += m_fiveChannels3_2.GetObjectLength();
  length += m_lowFrequencyEnhancement.GetObjectLength();
  length += m_multilingual.GetObjectLength();
  length += m_bitRate.GetObjectLength();
  return length;
}


BOOL H245_IS13818AudioCapability::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_audioLayer1.Decode(strm))
    return FALSE;
  if (!m_audioLayer2.Decode(strm))
    return FALSE;
  if (!m_audioLayer3.Decode(strm))
    return FALSE;
  if (!m_audioSampling16k.Decode(strm))
    return FALSE;
  if (!m_audioSampling22k05.Decode(strm))
    return FALSE;
  if (!m_audioSampling24k.Decode(strm))
    return FALSE;
  if (!m_audioSampling32k.Decode(strm))
    return FALSE;
  if (!m_audioSampling44k1.Decode(strm))
    return FALSE;
  if (!m_audioSampling48k.Decode(strm))
    return FALSE;
  if (!m_singleChannel.Decode(strm))
    return FALSE;
  if (!m_twoChannels.Decode(strm))
    return FALSE;
  if (!m_threeChannels2_1.Decode(strm))
    return FALSE;
  if (!m_threeChannels3_0.Decode(strm))
    return FALSE;
  if (!m_fourChannels2_0_2_0.Decode(strm))
    return FALSE;
  if (!m_fourChannels2_2.Decode(strm))
    return FALSE;
  if (!m_fourChannels3_1.Decode(strm))
    return FALSE;
  if (!m_fiveChannels3_0_2_0.Decode(strm))
    return FALSE;
  if (!m_fiveChannels3_2.Decode(strm))
    return FALSE;
  if (!m_lowFrequencyEnhancement.Decode(strm))
    return FALSE;
  if (!m_multilingual.Decode(strm))
    return FALSE;
  if (!m_bitRate.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_IS13818AudioCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_audioLayer1.Encode(strm);
  m_audioLayer2.Encode(strm);
  m_audioLayer3.Encode(strm);
  m_audioSampling16k.Encode(strm);
  m_audioSampling22k05.Encode(strm);
  m_audioSampling24k.Encode(strm);
  m_audioSampling32k.Encode(strm);
  m_audioSampling44k1.Encode(strm);
  m_audioSampling48k.Encode(strm);
  m_singleChannel.Encode(strm);
  m_twoChannels.Encode(strm);
  m_threeChannels2_1.Encode(strm);
  m_threeChannels3_0.Encode(strm);
  m_fourChannels2_0_2_0.Encode(strm);
  m_fourChannels2_2.Encode(strm);
  m_fourChannels3_1.Encode(strm);
  m_fiveChannels3_0_2_0.Encode(strm);
  m_fiveChannels3_2.Encode(strm);
  m_lowFrequencyEnhancement.Encode(strm);
  m_multilingual.Encode(strm);
  m_bitRate.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_IS13818AudioCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_IS13818AudioCapability::Class()), PInvalidCast);
#endif
  return new H245_IS13818AudioCapability(*this);
}


//
// GSMAudioCapability
//

H245_GSMAudioCapability::H245_GSMAudioCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_audioUnitSize.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H245_GSMAudioCapability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "audioUnitSize = " << setprecision(indent) << m_audioUnitSize << '\n';
  strm << setw(indent+15) << "comfortNoise = " << setprecision(indent) << m_comfortNoise << '\n';
  strm << setw(indent+12) << "scrambled = " << setprecision(indent) << m_scrambled << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_GSMAudioCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_GSMAudioCapability), PInvalidCast);
#endif
  const H245_GSMAudioCapability & other = (const H245_GSMAudioCapability &)obj;

  Comparison result;

  if ((result = m_audioUnitSize.Compare(other.m_audioUnitSize)) != EqualTo)
    return result;
  if ((result = m_comfortNoise.Compare(other.m_comfortNoise)) != EqualTo)
    return result;
  if ((result = m_scrambled.Compare(other.m_scrambled)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_GSMAudioCapability::GetDataLength() const
{
  PINDEX length = 0;
  length += m_audioUnitSize.GetObjectLength();
  length += m_comfortNoise.GetObjectLength();
  length += m_scrambled.GetObjectLength();
  return length;
}


BOOL H245_GSMAudioCapability::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_audioUnitSize.Decode(strm))
    return FALSE;
  if (!m_comfortNoise.Decode(strm))
    return FALSE;
  if (!m_scrambled.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_GSMAudioCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_audioUnitSize.Encode(strm);
  m_comfortNoise.Encode(strm);
  m_scrambled.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_GSMAudioCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_GSMAudioCapability::Class()), PInvalidCast);
#endif
  return new H245_GSMAudioCapability(*this);
}


//
// VBDCapability
//

H245_VBDCapability::H245_VBDCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_VBDCapability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+7) << "type = " << setprecision(indent) << m_type << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_VBDCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_VBDCapability), PInvalidCast);
#endif
  const H245_VBDCapability & other = (const H245_VBDCapability &)obj;

  Comparison result;

  if ((result = m_type.Compare(other.m_type)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_VBDCapability::GetDataLength() const
{
  PINDEX length = 0;
  length += m_type.GetObjectLength();
  return length;
}


BOOL H245_VBDCapability::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_type.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_VBDCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_type.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_VBDCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_VBDCapability::Class()), PInvalidCast);
#endif
  return new H245_VBDCapability(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_DataProtocolCapability[]={
      {"nonStandard",0}
     ,{"v14buffered",1}
     ,{"v42lapm",2}
     ,{"hdlcFrameTunnelling",3}
     ,{"h310SeparateVCStack",4}
     ,{"h310SingleVCStack",5}
     ,{"transparent",6}
     ,{"segmentationAndReassembly",7}
     ,{"hdlcFrameTunnelingwSAR",8}
     ,{"v120",9}
     ,{"separateLANStack",10}
     ,{"v76wCompression",11}
     ,{"tcp",12}
     ,{"udp",13}
};
#endif
//
// DataProtocolCapability
//

H245_DataProtocolCapability::H245_DataProtocolCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 7, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_DataProtocolCapability,14
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DataProtocolCapability::operator H245_NonStandardParameter &() const
#else
H245_DataProtocolCapability::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_DataProtocolCapability::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DataProtocolCapability::operator H245_DataProtocolCapability_v76wCompression &() const
#else
H245_DataProtocolCapability::operator H245_DataProtocolCapability_v76wCompression &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DataProtocolCapability_v76wCompression), PInvalidCast);
#endif
  return *(H245_DataProtocolCapability_v76wCompression *)choice;
}


H245_DataProtocolCapability::operator const H245_DataProtocolCapability_v76wCompression &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DataProtocolCapability_v76wCompression), PInvalidCast);
#endif
  return *(H245_DataProtocolCapability_v76wCompression *)choice;
}


BOOL H245_DataProtocolCapability::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_v14buffered :
    case e_v42lapm :
    case e_hdlcFrameTunnelling :
    case e_h310SeparateVCStack :
    case e_h310SingleVCStack :
    case e_transparent :
    case e_segmentationAndReassembly :
    case e_hdlcFrameTunnelingwSAR :
    case e_v120 :
    case e_separateLANStack :
    case e_tcp :
    case e_udp :
      choice = new PASN_Null();
      return TRUE;
    case e_v76wCompression :
      choice = new H245_DataProtocolCapability_v76wCompression();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_DataProtocolCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_DataProtocolCapability::Class()), PInvalidCast);
#endif
  return new H245_DataProtocolCapability(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_CompressionType[]={
      {"v42bis",0}
};
#endif
//
// CompressionType
//

H245_CompressionType::H245_CompressionType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 1, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_CompressionType,1
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_CompressionType::operator H245_V42bis &() const
#else
H245_CompressionType::operator H245_V42bis &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_V42bis), PInvalidCast);
#endif
  return *(H245_V42bis *)choice;
}


H245_CompressionType::operator const H245_V42bis &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_V42bis), PInvalidCast);
#endif
  return *(H245_V42bis *)choice;
}


BOOL H245_CompressionType::CreateObject()
{
  switch (tag) {
    case e_v42bis :
      choice = new H245_V42bis();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_CompressionType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CompressionType::Class()), PInvalidCast);
#endif
  return new H245_CompressionType(*this);
}


//
// V42bis
//

H245_V42bis::H245_V42bis(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_numberOfCodewords.SetConstraints(PASN_Object::FixedConstraint, 1, 65536);
  m_maximumStringLength.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H245_V42bis::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+20) << "numberOfCodewords = " << setprecision(indent) << m_numberOfCodewords << '\n';
  strm << setw(indent+22) << "maximumStringLength = " << setprecision(indent) << m_maximumStringLength << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_V42bis::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_V42bis), PInvalidCast);
#endif
  const H245_V42bis & other = (const H245_V42bis &)obj;

  Comparison result;

  if ((result = m_numberOfCodewords.Compare(other.m_numberOfCodewords)) != EqualTo)
    return result;
  if ((result = m_maximumStringLength.Compare(other.m_maximumStringLength)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_V42bis::GetDataLength() const
{
  PINDEX length = 0;
  length += m_numberOfCodewords.GetObjectLength();
  length += m_maximumStringLength.GetObjectLength();
  return length;
}


BOOL H245_V42bis::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_numberOfCodewords.Decode(strm))
    return FALSE;
  if (!m_maximumStringLength.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_V42bis::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_numberOfCodewords.Encode(strm);
  m_maximumStringLength.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_V42bis::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_V42bis::Class()), PInvalidCast);
#endif
  return new H245_V42bis(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_T84Profile[]={
      {"t84Unrestricted",0}
     ,{"t84Restricted",1}
};
#endif
//
// T84Profile
//

H245_T84Profile::H245_T84Profile(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_T84Profile,2
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_T84Profile::operator H245_T84Profile_t84Restricted &() const
#else
H245_T84Profile::operator H245_T84Profile_t84Restricted &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_T84Profile_t84Restricted), PInvalidCast);
#endif
  return *(H245_T84Profile_t84Restricted *)choice;
}


H245_T84Profile::operator const H245_T84Profile_t84Restricted &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_T84Profile_t84Restricted), PInvalidCast);
#endif
  return *(H245_T84Profile_t84Restricted *)choice;
}


BOOL H245_T84Profile::CreateObject()
{
  switch (tag) {
    case e_t84Unrestricted :
      choice = new PASN_Null();
      return TRUE;
    case e_t84Restricted :
      choice = new H245_T84Profile_t84Restricted();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_T84Profile::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_T84Profile::Class()), PInvalidCast);
#endif
  return new H245_T84Profile(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_T38FaxRateManagement[]={
      {"localTCF",0}
     ,{"transferredTCF",1}
};
#endif
//
// T38FaxRateManagement
//

H245_T38FaxRateManagement::H245_T38FaxRateManagement(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_T38FaxRateManagement,2
#endif
)
{
}


BOOL H245_T38FaxRateManagement::CreateObject()
{
  choice = (tag <= e_transferredTCF) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_T38FaxRateManagement::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_T38FaxRateManagement::Class()), PInvalidCast);
#endif
  return new H245_T38FaxRateManagement(*this);
}


//
// T38FaxTcpOptions
//

H245_T38FaxTcpOptions::H245_T38FaxTcpOptions(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_T38FaxTcpOptions::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+26) << "t38TCPBidirectionalMode = " << setprecision(indent) << m_t38TCPBidirectionalMode << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_T38FaxTcpOptions::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_T38FaxTcpOptions), PInvalidCast);
#endif
  const H245_T38FaxTcpOptions & other = (const H245_T38FaxTcpOptions &)obj;

  Comparison result;

  if ((result = m_t38TCPBidirectionalMode.Compare(other.m_t38TCPBidirectionalMode)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_T38FaxTcpOptions::GetDataLength() const
{
  PINDEX length = 0;
  length += m_t38TCPBidirectionalMode.GetObjectLength();
  return length;
}


BOOL H245_T38FaxTcpOptions::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_t38TCPBidirectionalMode.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_T38FaxTcpOptions::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_t38TCPBidirectionalMode.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_T38FaxTcpOptions::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_T38FaxTcpOptions::Class()), PInvalidCast);
#endif
  return new H245_T38FaxTcpOptions(*this);
}


//
// EncryptionCapability
//

H245_EncryptionCapability::H245_EncryptionCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


PASN_Object * H245_EncryptionCapability::CreateObject() const
{
  return new H245_MediaEncryptionAlgorithm;
}


H245_MediaEncryptionAlgorithm & H245_EncryptionCapability::operator[](PINDEX i) const
{
  return (H245_MediaEncryptionAlgorithm &)array[i];
}


PObject * H245_EncryptionCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_EncryptionCapability::Class()), PInvalidCast);
#endif
  return new H245_EncryptionCapability(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_MediaEncryptionAlgorithm[]={
      {"nonStandard",0}
     ,{"algorithm",1}
};
#endif
//
// MediaEncryptionAlgorithm
//

H245_MediaEncryptionAlgorithm::H245_MediaEncryptionAlgorithm(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_MediaEncryptionAlgorithm,2
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MediaEncryptionAlgorithm::operator H245_NonStandardParameter &() const
#else
H245_MediaEncryptionAlgorithm::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_MediaEncryptionAlgorithm::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


BOOL H245_MediaEncryptionAlgorithm::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_algorithm :
      choice = new PASN_ObjectId();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_MediaEncryptionAlgorithm::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MediaEncryptionAlgorithm::Class()), PInvalidCast);
#endif
  return new H245_MediaEncryptionAlgorithm(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_UserInputCapability[]={
      {"nonStandard",0}
     ,{"basicString",1}
     ,{"iA5String",2}
     ,{"generalString",3}
     ,{"dtmf",4}
     ,{"hookflash",5}
     ,{"extendedAlphanumeric",6}
     ,{"encryptedBasicString",7}
     ,{"encryptedIA5String",8}
     ,{"encryptedGeneralString",9}
     ,{"secureDTMF",10}
};
#endif
//
// UserInputCapability
//

H245_UserInputCapability::H245_UserInputCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 6, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_UserInputCapability,11
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_UserInputCapability::operator H245_ArrayOf_NonStandardParameter &() const
#else
H245_UserInputCapability::operator H245_ArrayOf_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ArrayOf_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_ArrayOf_NonStandardParameter *)choice;
}


H245_UserInputCapability::operator const H245_ArrayOf_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ArrayOf_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_ArrayOf_NonStandardParameter *)choice;
}


BOOL H245_UserInputCapability::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_ArrayOf_NonStandardParameter();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 16);
      return TRUE;
    case e_basicString :
    case e_iA5String :
    case e_generalString :
    case e_dtmf :
    case e_hookflash :
    case e_extendedAlphanumeric :
    case e_encryptedBasicString :
    case e_encryptedIA5String :
    case e_encryptedGeneralString :
    case e_secureDTMF :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_UserInputCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_UserInputCapability::Class()), PInvalidCast);
#endif
  return new H245_UserInputCapability(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_CapabilityIdentifier[]={
      {"standard",0}
     ,{"h221NonStandard",1}
     ,{"uuid",2}
     ,{"domainBased",3}
};
#endif
//
// CapabilityIdentifier
//

H245_CapabilityIdentifier::H245_CapabilityIdentifier(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_CapabilityIdentifier,4
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_CapabilityIdentifier::operator H245_NonStandardParameter &() const
#else
H245_CapabilityIdentifier::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_CapabilityIdentifier::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


BOOL H245_CapabilityIdentifier::CreateObject()
{
  switch (tag) {
    case e_standard :
      choice = new PASN_ObjectId();
      return TRUE;
    case e_h221NonStandard :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_uuid :
      choice = new PASN_OctetString();
      choice->SetConstraints(PASN_Object::FixedConstraint, 16);
      return TRUE;
    case e_domainBased :
      choice = new PASN_IA5String();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 64);
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_CapabilityIdentifier::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CapabilityIdentifier::Class()), PInvalidCast);
#endif
  return new H245_CapabilityIdentifier(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_ParameterIdentifier[]={
      {"standard",0}
     ,{"h221NonStandard",1}
     ,{"uuid",2}
     ,{"domainBased",3}
};
#endif
//
// ParameterIdentifier
//

H245_ParameterIdentifier::H245_ParameterIdentifier(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_ParameterIdentifier,4
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ParameterIdentifier::operator H245_NonStandardParameter &() const
#else
H245_ParameterIdentifier::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_ParameterIdentifier::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


BOOL H245_ParameterIdentifier::CreateObject()
{
  switch (tag) {
    case e_standard :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 0, 127);
      return TRUE;
    case e_h221NonStandard :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_uuid :
      choice = new PASN_OctetString();
      choice->SetConstraints(PASN_Object::FixedConstraint, 16);
      return TRUE;
    case e_domainBased :
      choice = new PASN_IA5String();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 64);
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_ParameterIdentifier::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ParameterIdentifier::Class()), PInvalidCast);
#endif
  return new H245_ParameterIdentifier(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_ParameterValue[]={
      {"logical",0}
     ,{"booleanArray",1}
     ,{"unsignedMin",2}
     ,{"unsignedMax",3}
     ,{"unsigned32Min",4}
     ,{"unsigned32Max",5}
     ,{"octetString",6}
     ,{"genericParameter",7}
};
#endif
//
// ParameterValue
//

H245_ParameterValue::H245_ParameterValue(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 8, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_ParameterValue,8
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ParameterValue::operator H245_ArrayOf_GenericParameter &() const
#else
H245_ParameterValue::operator H245_ArrayOf_GenericParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ArrayOf_GenericParameter), PInvalidCast);
#endif
  return *(H245_ArrayOf_GenericParameter *)choice;
}


H245_ParameterValue::operator const H245_ArrayOf_GenericParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ArrayOf_GenericParameter), PInvalidCast);
#endif
  return *(H245_ArrayOf_GenericParameter *)choice;
}


BOOL H245_ParameterValue::CreateObject()
{
  switch (tag) {
    case e_logical :
      choice = new PASN_Null();
      return TRUE;
    case e_booleanArray :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 0, 255);
      return TRUE;
    case e_unsignedMin :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
      return TRUE;
    case e_unsignedMax :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
      return TRUE;
    case e_unsigned32Min :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 0, 4294967295U);
      return TRUE;
    case e_unsigned32Max :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 0, 4294967295U);
      return TRUE;
    case e_octetString :
      choice = new PASN_OctetString();
      return TRUE;
    case e_genericParameter :
      choice = new H245_ArrayOf_GenericParameter();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_ParameterValue::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ParameterValue::Class()), PInvalidCast);
#endif
  return new H245_ParameterValue(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_MultiplexFormat[]={
      {"nonStandard",0}
     ,{"h222Capability",1}
     ,{"h223Capability",2}
};
#endif
//
// MultiplexFormat
//

H245_MultiplexFormat::H245_MultiplexFormat(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_MultiplexFormat,3
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultiplexFormat::operator H245_NonStandardParameter &() const
#else
H245_MultiplexFormat::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_MultiplexFormat::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultiplexFormat::operator H245_H222Capability &() const
#else
H245_MultiplexFormat::operator H245_H222Capability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H222Capability), PInvalidCast);
#endif
  return *(H245_H222Capability *)choice;
}


H245_MultiplexFormat::operator const H245_H222Capability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H222Capability), PInvalidCast);
#endif
  return *(H245_H222Capability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultiplexFormat::operator H245_H223Capability &() const
#else
H245_MultiplexFormat::operator H245_H223Capability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H223Capability), PInvalidCast);
#endif
  return *(H245_H223Capability *)choice;
}


H245_MultiplexFormat::operator const H245_H223Capability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H223Capability), PInvalidCast);
#endif
  return *(H245_H223Capability *)choice;
}


BOOL H245_MultiplexFormat::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_h222Capability :
      choice = new H245_H222Capability();
      return TRUE;
    case e_h223Capability :
      choice = new H245_H223Capability();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_MultiplexFormat::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultiplexFormat::Class()), PInvalidCast);
#endif
  return new H245_MultiplexFormat(*this);
}


//
// AudioTelephonyEventCapability
//

H245_AudioTelephonyEventCapability::H245_AudioTelephonyEventCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_dynamicRTPPayloadType.SetConstraints(PASN_Object::FixedConstraint, 96, 127);
}


#ifndef PASN_NOPRINTON
void H245_AudioTelephonyEventCapability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+24) << "dynamicRTPPayloadType = " << setprecision(indent) << m_dynamicRTPPayloadType << '\n';
  strm << setw(indent+22) << "audioTelephoneEvent = " << setprecision(indent) << m_audioTelephoneEvent << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_AudioTelephonyEventCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_AudioTelephonyEventCapability), PInvalidCast);
#endif
  const H245_AudioTelephonyEventCapability & other = (const H245_AudioTelephonyEventCapability &)obj;

  Comparison result;

  if ((result = m_dynamicRTPPayloadType.Compare(other.m_dynamicRTPPayloadType)) != EqualTo)
    return result;
  if ((result = m_audioTelephoneEvent.Compare(other.m_audioTelephoneEvent)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_AudioTelephonyEventCapability::GetDataLength() const
{
  PINDEX length = 0;
  length += m_dynamicRTPPayloadType.GetObjectLength();
  length += m_audioTelephoneEvent.GetObjectLength();
  return length;
}


BOOL H245_AudioTelephonyEventCapability::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_dynamicRTPPayloadType.Decode(strm))
    return FALSE;
  if (!m_audioTelephoneEvent.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_AudioTelephonyEventCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_dynamicRTPPayloadType.Encode(strm);
  m_audioTelephoneEvent.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_AudioTelephonyEventCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_AudioTelephonyEventCapability::Class()), PInvalidCast);
#endif
  return new H245_AudioTelephonyEventCapability(*this);
}


//
// AudioToneCapability
//

H245_AudioToneCapability::H245_AudioToneCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_dynamicRTPPayloadType.SetConstraints(PASN_Object::FixedConstraint, 96, 127);
}


#ifndef PASN_NOPRINTON
void H245_AudioToneCapability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+24) << "dynamicRTPPayloadType = " << setprecision(indent) << m_dynamicRTPPayloadType << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_AudioToneCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_AudioToneCapability), PInvalidCast);
#endif
  const H245_AudioToneCapability & other = (const H245_AudioToneCapability &)obj;

  Comparison result;

  if ((result = m_dynamicRTPPayloadType.Compare(other.m_dynamicRTPPayloadType)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_AudioToneCapability::GetDataLength() const
{
  PINDEX length = 0;
  length += m_dynamicRTPPayloadType.GetObjectLength();
  return length;
}


BOOL H245_AudioToneCapability::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_dynamicRTPPayloadType.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_AudioToneCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_dynamicRTPPayloadType.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_AudioToneCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_AudioToneCapability::Class()), PInvalidCast);
#endif
  return new H245_AudioToneCapability(*this);
}


//
// NoPTAudioTelephonyEventCapability
//

H245_NoPTAudioTelephonyEventCapability::H245_NoPTAudioTelephonyEventCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_NoPTAudioTelephonyEventCapability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+22) << "audioTelephoneEvent = " << setprecision(indent) << m_audioTelephoneEvent << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_NoPTAudioTelephonyEventCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_NoPTAudioTelephonyEventCapability), PInvalidCast);
#endif
  const H245_NoPTAudioTelephonyEventCapability & other = (const H245_NoPTAudioTelephonyEventCapability &)obj;

  Comparison result;

  if ((result = m_audioTelephoneEvent.Compare(other.m_audioTelephoneEvent)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_NoPTAudioTelephonyEventCapability::GetDataLength() const
{
  PINDEX length = 0;
  length += m_audioTelephoneEvent.GetObjectLength();
  return length;
}


BOOL H245_NoPTAudioTelephonyEventCapability::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_audioTelephoneEvent.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_NoPTAudioTelephonyEventCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_audioTelephoneEvent.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_NoPTAudioTelephonyEventCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NoPTAudioTelephonyEventCapability::Class()), PInvalidCast);
#endif
  return new H245_NoPTAudioTelephonyEventCapability(*this);
}


//
// NoPTAudioToneCapability
//

H245_NoPTAudioToneCapability::H245_NoPTAudioToneCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_NoPTAudioToneCapability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PINDEX H245_NoPTAudioToneCapability::GetDataLength() const
{
  PINDEX length = 0;
  return length;
}


BOOL H245_NoPTAudioToneCapability::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;


  return UnknownExtensionsDecode(strm);
}


void H245_NoPTAudioToneCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);


  UnknownExtensionsEncode(strm);
}


PObject * H245_NoPTAudioToneCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NoPTAudioToneCapability::Class()), PInvalidCast);
#endif
  return new H245_NoPTAudioToneCapability(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_DepFECCapability[]={
      {"rfc2733",0}
};
#endif
//
// DepFECCapability
//

H245_DepFECCapability::H245_DepFECCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 1, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_DepFECCapability,1
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DepFECCapability::operator H245_DepFECCapability_rfc2733 &() const
#else
H245_DepFECCapability::operator H245_DepFECCapability_rfc2733 &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DepFECCapability_rfc2733), PInvalidCast);
#endif
  return *(H245_DepFECCapability_rfc2733 *)choice;
}


H245_DepFECCapability::operator const H245_DepFECCapability_rfc2733 &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DepFECCapability_rfc2733), PInvalidCast);
#endif
  return *(H245_DepFECCapability_rfc2733 *)choice;
}


BOOL H245_DepFECCapability::CreateObject()
{
  switch (tag) {
    case e_rfc2733 :
      choice = new H245_DepFECCapability_rfc2733();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_DepFECCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_DepFECCapability::Class()), PInvalidCast);
#endif
  return new H245_DepFECCapability(*this);
}


//
// MaxRedundancy
//

H245_MaxRedundancy::H245_MaxRedundancy(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, MaximumValue);
}


H245_MaxRedundancy & H245_MaxRedundancy::operator=(int v)
{
  SetValue(v);
  return *this;
}


H245_MaxRedundancy & H245_MaxRedundancy::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H245_MaxRedundancy::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MaxRedundancy::Class()), PInvalidCast);
#endif
  return new H245_MaxRedundancy(*this);
}


//
// LogicalChannelNumber
//

H245_LogicalChannelNumber::H245_LogicalChannelNumber(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
}


H245_LogicalChannelNumber & H245_LogicalChannelNumber::operator=(int v)
{
  SetValue(v);
  return *this;
}


H245_LogicalChannelNumber & H245_LogicalChannelNumber::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H245_LogicalChannelNumber::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_LogicalChannelNumber::Class()), PInvalidCast);
#endif
  return new H245_LogicalChannelNumber(*this);
}


//
// V75Parameters
//

H245_V75Parameters::H245_V75Parameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_V75Parameters::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+21) << "audioHeaderPresent = " << setprecision(indent) << m_audioHeaderPresent << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_V75Parameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_V75Parameters), PInvalidCast);
#endif
  const H245_V75Parameters & other = (const H245_V75Parameters &)obj;

  Comparison result;

  if ((result = m_audioHeaderPresent.Compare(other.m_audioHeaderPresent)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_V75Parameters::GetDataLength() const
{
  PINDEX length = 0;
  length += m_audioHeaderPresent.GetObjectLength();
  return length;
}


BOOL H245_V75Parameters::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_audioHeaderPresent.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_V75Parameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_audioHeaderPresent.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_V75Parameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_V75Parameters::Class()), PInvalidCast);
#endif
  return new H245_V75Parameters(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_DataType[]={
      {"nonStandard",0}
     ,{"nullData",1}
     ,{"videoData",2}
     ,{"audioData",3}
     ,{"data",4}
     ,{"encryptionData",5}
     ,{"h235Control",6}
     ,{"h235Media",7}
     ,{"multiplexedStream",8}
     ,{"redundancyEncoding",9}
     ,{"multiplePayloadStream",10}
     ,{"depFec",11}
     ,{"fec",12}
};
#endif
//
// DataType
//

H245_DataType::H245_DataType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 6, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_DataType,13
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DataType::operator H245_NonStandardParameter &() const
#else
H245_DataType::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_DataType::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DataType::operator H245_VideoCapability &() const
#else
H245_DataType::operator H245_VideoCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_VideoCapability), PInvalidCast);
#endif
  return *(H245_VideoCapability *)choice;
}


H245_DataType::operator const H245_VideoCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_VideoCapability), PInvalidCast);
#endif
  return *(H245_VideoCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DataType::operator H245_AudioCapability &() const
#else
H245_DataType::operator H245_AudioCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_AudioCapability), PInvalidCast);
#endif
  return *(H245_AudioCapability *)choice;
}


H245_DataType::operator const H245_AudioCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_AudioCapability), PInvalidCast);
#endif
  return *(H245_AudioCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DataType::operator H245_DataApplicationCapability &() const
#else
H245_DataType::operator H245_DataApplicationCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DataApplicationCapability), PInvalidCast);
#endif
  return *(H245_DataApplicationCapability *)choice;
}


H245_DataType::operator const H245_DataApplicationCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DataApplicationCapability), PInvalidCast);
#endif
  return *(H245_DataApplicationCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DataType::operator H245_EncryptionMode &() const
#else
H245_DataType::operator H245_EncryptionMode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_EncryptionMode), PInvalidCast);
#endif
  return *(H245_EncryptionMode *)choice;
}


H245_DataType::operator const H245_EncryptionMode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_EncryptionMode), PInvalidCast);
#endif
  return *(H245_EncryptionMode *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DataType::operator H245_H235Media &() const
#else
H245_DataType::operator H245_H235Media &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H235Media), PInvalidCast);
#endif
  return *(H245_H235Media *)choice;
}


H245_DataType::operator const H245_H235Media &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H235Media), PInvalidCast);
#endif
  return *(H245_H235Media *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DataType::operator H245_MultiplexedStreamParameter &() const
#else
H245_DataType::operator H245_MultiplexedStreamParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultiplexedStreamParameter), PInvalidCast);
#endif
  return *(H245_MultiplexedStreamParameter *)choice;
}


H245_DataType::operator const H245_MultiplexedStreamParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultiplexedStreamParameter), PInvalidCast);
#endif
  return *(H245_MultiplexedStreamParameter *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DataType::operator H245_RedundancyEncoding &() const
#else
H245_DataType::operator H245_RedundancyEncoding &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RedundancyEncoding), PInvalidCast);
#endif
  return *(H245_RedundancyEncoding *)choice;
}


H245_DataType::operator const H245_RedundancyEncoding &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RedundancyEncoding), PInvalidCast);
#endif
  return *(H245_RedundancyEncoding *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DataType::operator H245_MultiplePayloadStream &() const
#else
H245_DataType::operator H245_MultiplePayloadStream &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultiplePayloadStream), PInvalidCast);
#endif
  return *(H245_MultiplePayloadStream *)choice;
}


H245_DataType::operator const H245_MultiplePayloadStream &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultiplePayloadStream), PInvalidCast);
#endif
  return *(H245_MultiplePayloadStream *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DataType::operator H245_DepFECData &() const
#else
H245_DataType::operator H245_DepFECData &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DepFECData), PInvalidCast);
#endif
  return *(H245_DepFECData *)choice;
}


H245_DataType::operator const H245_DepFECData &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DepFECData), PInvalidCast);
#endif
  return *(H245_DepFECData *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DataType::operator H245_FECData &() const
#else
H245_DataType::operator H245_FECData &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_FECData), PInvalidCast);
#endif
  return *(H245_FECData *)choice;
}


H245_DataType::operator const H245_FECData &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_FECData), PInvalidCast);
#endif
  return *(H245_FECData *)choice;
}


BOOL H245_DataType::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
    case e_h235Control :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_nullData :
      choice = new PASN_Null();
      return TRUE;
    case e_videoData :
      choice = new H245_VideoCapability();
      return TRUE;
    case e_audioData :
      choice = new H245_AudioCapability();
      return TRUE;
    case e_data :
      choice = new H245_DataApplicationCapability();
      return TRUE;
    case e_encryptionData :
      choice = new H245_EncryptionMode();
      return TRUE;
    case e_h235Media :
      choice = new H245_H235Media();
      return TRUE;
    case e_multiplexedStream :
      choice = new H245_MultiplexedStreamParameter();
      return TRUE;
    case e_redundancyEncoding :
      choice = new H245_RedundancyEncoding();
      return TRUE;
    case e_multiplePayloadStream :
      choice = new H245_MultiplePayloadStream();
      return TRUE;
    case e_depFec :
      choice = new H245_DepFECData();
      return TRUE;
    case e_fec :
      choice = new H245_FECData();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_DataType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_DataType::Class()), PInvalidCast);
#endif
  return new H245_DataType(*this);
}


//
// MultiplexedStreamParameter
//

H245_MultiplexedStreamParameter::H245_MultiplexedStreamParameter(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MultiplexedStreamParameter::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+18) << "multiplexFormat = " << setprecision(indent) << m_multiplexFormat << '\n';
  strm << setw(indent+21) << "controlOnMuxStream = " << setprecision(indent) << m_controlOnMuxStream << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MultiplexedStreamParameter::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MultiplexedStreamParameter), PInvalidCast);
#endif
  const H245_MultiplexedStreamParameter & other = (const H245_MultiplexedStreamParameter &)obj;

  Comparison result;

  if ((result = m_multiplexFormat.Compare(other.m_multiplexFormat)) != EqualTo)
    return result;
  if ((result = m_controlOnMuxStream.Compare(other.m_controlOnMuxStream)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MultiplexedStreamParameter::GetDataLength() const
{
  PINDEX length = 0;
  length += m_multiplexFormat.GetObjectLength();
  length += m_controlOnMuxStream.GetObjectLength();
  return length;
}


BOOL H245_MultiplexedStreamParameter::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_multiplexFormat.Decode(strm))
    return FALSE;
  if (!m_controlOnMuxStream.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MultiplexedStreamParameter::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_multiplexFormat.Encode(strm);
  m_controlOnMuxStream.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MultiplexedStreamParameter::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultiplexedStreamParameter::Class()), PInvalidCast);
#endif
  return new H245_MultiplexedStreamParameter(*this);
}


//
// H222LogicalChannelParameters
//

H245_H222LogicalChannelParameters::H245_H222LogicalChannelParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 0)
{
  m_resourceID.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
  m_subChannelID.SetConstraints(PASN_Object::FixedConstraint, 0, 8191);
  m_pcr_pid.SetConstraints(PASN_Object::FixedConstraint, 0, 8191);
}


#ifndef PASN_NOPRINTON
void H245_H222LogicalChannelParameters::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+13) << "resourceID = " << setprecision(indent) << m_resourceID << '\n';
  strm << setw(indent+15) << "subChannelID = " << setprecision(indent) << m_subChannelID << '\n';
  if (HasOptionalField(e_pcr_pid))
    strm << setw(indent+10) << "pcr_pid = " << setprecision(indent) << m_pcr_pid << '\n';
  if (HasOptionalField(e_programDescriptors))
    strm << setw(indent+21) << "programDescriptors = " << setprecision(indent) << m_programDescriptors << '\n';
  if (HasOptionalField(e_streamDescriptors))
    strm << setw(indent+20) << "streamDescriptors = " << setprecision(indent) << m_streamDescriptors << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_H222LogicalChannelParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_H222LogicalChannelParameters), PInvalidCast);
#endif
  const H245_H222LogicalChannelParameters & other = (const H245_H222LogicalChannelParameters &)obj;

  Comparison result;

  if ((result = m_resourceID.Compare(other.m_resourceID)) != EqualTo)
    return result;
  if ((result = m_subChannelID.Compare(other.m_subChannelID)) != EqualTo)
    return result;
  if ((result = m_pcr_pid.Compare(other.m_pcr_pid)) != EqualTo)
    return result;
  if ((result = m_programDescriptors.Compare(other.m_programDescriptors)) != EqualTo)
    return result;
  if ((result = m_streamDescriptors.Compare(other.m_streamDescriptors)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H222LogicalChannelParameters::GetDataLength() const
{
  PINDEX length = 0;
  length += m_resourceID.GetObjectLength();
  length += m_subChannelID.GetObjectLength();
  if (HasOptionalField(e_pcr_pid))
    length += m_pcr_pid.GetObjectLength();
  if (HasOptionalField(e_programDescriptors))
    length += m_programDescriptors.GetObjectLength();
  if (HasOptionalField(e_streamDescriptors))
    length += m_streamDescriptors.GetObjectLength();
  return length;
}


BOOL H245_H222LogicalChannelParameters::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_resourceID.Decode(strm))
    return FALSE;
  if (!m_subChannelID.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_pcr_pid) && !m_pcr_pid.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_programDescriptors) && !m_programDescriptors.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_streamDescriptors) && !m_streamDescriptors.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_H222LogicalChannelParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_resourceID.Encode(strm);
  m_subChannelID.Encode(strm);
  if (HasOptionalField(e_pcr_pid))
    m_pcr_pid.Encode(strm);
  if (HasOptionalField(e_programDescriptors))
    m_programDescriptors.Encode(strm);
  if (HasOptionalField(e_streamDescriptors))
    m_streamDescriptors.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_H222LogicalChannelParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H222LogicalChannelParameters::Class()), PInvalidCast);
#endif
  return new H245_H222LogicalChannelParameters(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_CRCLength[]={
      {"crc8bit",0}
     ,{"crc16bit",1}
     ,{"crc32bit",2}
};
#endif
//
// CRCLength
//

H245_CRCLength::H245_CRCLength(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_CRCLength,3
#endif
)
{
}


BOOL H245_CRCLength::CreateObject()
{
  choice = (tag <= e_crc32bit) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_CRCLength::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CRCLength::Class()), PInvalidCast);
#endif
  return new H245_CRCLength(*this);
}


//
// RedundancyEncodingElement
//

H245_RedundancyEncodingElement::H245_RedundancyEncodingElement(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_payloadType.SetConstraints(PASN_Object::FixedConstraint, 0, 127);
}


#ifndef PASN_NOPRINTON
void H245_RedundancyEncodingElement::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "dataType = " << setprecision(indent) << m_dataType << '\n';
  if (HasOptionalField(e_payloadType))
    strm << setw(indent+14) << "payloadType = " << setprecision(indent) << m_payloadType << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_RedundancyEncodingElement::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_RedundancyEncodingElement), PInvalidCast);
#endif
  const H245_RedundancyEncodingElement & other = (const H245_RedundancyEncodingElement &)obj;

  Comparison result;

  if ((result = m_dataType.Compare(other.m_dataType)) != EqualTo)
    return result;
  if ((result = m_payloadType.Compare(other.m_payloadType)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RedundancyEncodingElement::GetDataLength() const
{
  PINDEX length = 0;
  length += m_dataType.GetObjectLength();
  if (HasOptionalField(e_payloadType))
    length += m_payloadType.GetObjectLength();
  return length;
}


BOOL H245_RedundancyEncodingElement::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_dataType.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_payloadType) && !m_payloadType.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_RedundancyEncodingElement::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_dataType.Encode(strm);
  if (HasOptionalField(e_payloadType))
    m_payloadType.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_RedundancyEncodingElement::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RedundancyEncodingElement::Class()), PInvalidCast);
#endif
  return new H245_RedundancyEncodingElement(*this);
}


//
// MultiplePayloadStreamElement
//

H245_MultiplePayloadStreamElement::H245_MultiplePayloadStreamElement(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_payloadType.SetConstraints(PASN_Object::FixedConstraint, 0, 127);
}


#ifndef PASN_NOPRINTON
void H245_MultiplePayloadStreamElement::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "dataType = " << setprecision(indent) << m_dataType << '\n';
  if (HasOptionalField(e_payloadType))
    strm << setw(indent+14) << "payloadType = " << setprecision(indent) << m_payloadType << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MultiplePayloadStreamElement::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MultiplePayloadStreamElement), PInvalidCast);
#endif
  const H245_MultiplePayloadStreamElement & other = (const H245_MultiplePayloadStreamElement &)obj;

  Comparison result;

  if ((result = m_dataType.Compare(other.m_dataType)) != EqualTo)
    return result;
  if ((result = m_payloadType.Compare(other.m_payloadType)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MultiplePayloadStreamElement::GetDataLength() const
{
  PINDEX length = 0;
  length += m_dataType.GetObjectLength();
  if (HasOptionalField(e_payloadType))
    length += m_payloadType.GetObjectLength();
  return length;
}


BOOL H245_MultiplePayloadStreamElement::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_dataType.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_payloadType) && !m_payloadType.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MultiplePayloadStreamElement::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_dataType.Encode(strm);
  if (HasOptionalField(e_payloadType))
    m_payloadType.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MultiplePayloadStreamElement::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultiplePayloadStreamElement::Class()), PInvalidCast);
#endif
  return new H245_MultiplePayloadStreamElement(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_DepFECData[]={
      {"rfc2733",0}
};
#endif
//
// DepFECData
//

H245_DepFECData::H245_DepFECData(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 1, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_DepFECData,1
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DepFECData::operator H245_DepFECData_rfc2733 &() const
#else
H245_DepFECData::operator H245_DepFECData_rfc2733 &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DepFECData_rfc2733), PInvalidCast);
#endif
  return *(H245_DepFECData_rfc2733 *)choice;
}


H245_DepFECData::operator const H245_DepFECData_rfc2733 &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DepFECData_rfc2733), PInvalidCast);
#endif
  return *(H245_DepFECData_rfc2733 *)choice;
}


BOOL H245_DepFECData::CreateObject()
{
  switch (tag) {
    case e_rfc2733 :
      choice = new H245_DepFECData_rfc2733();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_DepFECData::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_DepFECData::Class()), PInvalidCast);
#endif
  return new H245_DepFECData(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_FECData[]={
      {"rfc2733",0}
};
#endif
//
// FECData
//

H245_FECData::H245_FECData(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 1, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_FECData,1
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_FECData::operator H245_FECData_rfc2733 &() const
#else
H245_FECData::operator H245_FECData_rfc2733 &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_FECData_rfc2733), PInvalidCast);
#endif
  return *(H245_FECData_rfc2733 *)choice;
}


H245_FECData::operator const H245_FECData_rfc2733 &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_FECData_rfc2733), PInvalidCast);
#endif
  return *(H245_FECData_rfc2733 *)choice;
}


BOOL H245_FECData::CreateObject()
{
  switch (tag) {
    case e_rfc2733 :
      choice = new H245_FECData_rfc2733();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_FECData::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_FECData::Class()), PInvalidCast);
#endif
  return new H245_FECData(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_TransportAddress[]={
      {"unicastAddress",0}
     ,{"multicastAddress",1}
};
#endif
//
// TransportAddress
//

H245_TransportAddress::H245_TransportAddress(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_TransportAddress,2
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_TransportAddress::operator H245_UnicastAddress &() const
#else
H245_TransportAddress::operator H245_UnicastAddress &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_UnicastAddress), PInvalidCast);
#endif
  return *(H245_UnicastAddress *)choice;
}


H245_TransportAddress::operator const H245_UnicastAddress &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_UnicastAddress), PInvalidCast);
#endif
  return *(H245_UnicastAddress *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_TransportAddress::operator H245_MulticastAddress &() const
#else
H245_TransportAddress::operator H245_MulticastAddress &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MulticastAddress), PInvalidCast);
#endif
  return *(H245_MulticastAddress *)choice;
}


H245_TransportAddress::operator const H245_MulticastAddress &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MulticastAddress), PInvalidCast);
#endif
  return *(H245_MulticastAddress *)choice;
}


BOOL H245_TransportAddress::CreateObject()
{
  switch (tag) {
    case e_unicastAddress :
      choice = new H245_UnicastAddress();
      return TRUE;
    case e_multicastAddress :
      choice = new H245_MulticastAddress();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_TransportAddress::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_TransportAddress::Class()), PInvalidCast);
#endif
  return new H245_TransportAddress(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_UnicastAddress[]={
      {"iPAddress",0}
     ,{"iPXAddress",1}
     ,{"iP6Address",2}
     ,{"netBios",3}
     ,{"iPSourceRouteAddress",4}
     ,{"nsap",5}
     ,{"nonStandardAddress",6}
};
#endif
//
// UnicastAddress
//

H245_UnicastAddress::H245_UnicastAddress(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 5, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_UnicastAddress,7
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_UnicastAddress::operator H245_UnicastAddress_iPAddress &() const
#else
H245_UnicastAddress::operator H245_UnicastAddress_iPAddress &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_UnicastAddress_iPAddress), PInvalidCast);
#endif
  return *(H245_UnicastAddress_iPAddress *)choice;
}


H245_UnicastAddress::operator const H245_UnicastAddress_iPAddress &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_UnicastAddress_iPAddress), PInvalidCast);
#endif
  return *(H245_UnicastAddress_iPAddress *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_UnicastAddress::operator H245_UnicastAddress_iPXAddress &() const
#else
H245_UnicastAddress::operator H245_UnicastAddress_iPXAddress &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_UnicastAddress_iPXAddress), PInvalidCast);
#endif
  return *(H245_UnicastAddress_iPXAddress *)choice;
}


H245_UnicastAddress::operator const H245_UnicastAddress_iPXAddress &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_UnicastAddress_iPXAddress), PInvalidCast);
#endif
  return *(H245_UnicastAddress_iPXAddress *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_UnicastAddress::operator H245_UnicastAddress_iP6Address &() const
#else
H245_UnicastAddress::operator H245_UnicastAddress_iP6Address &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_UnicastAddress_iP6Address), PInvalidCast);
#endif
  return *(H245_UnicastAddress_iP6Address *)choice;
}


H245_UnicastAddress::operator const H245_UnicastAddress_iP6Address &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_UnicastAddress_iP6Address), PInvalidCast);
#endif
  return *(H245_UnicastAddress_iP6Address *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_UnicastAddress::operator H245_UnicastAddress_iPSourceRouteAddress &() const
#else
H245_UnicastAddress::operator H245_UnicastAddress_iPSourceRouteAddress &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_UnicastAddress_iPSourceRouteAddress), PInvalidCast);
#endif
  return *(H245_UnicastAddress_iPSourceRouteAddress *)choice;
}


H245_UnicastAddress::operator const H245_UnicastAddress_iPSourceRouteAddress &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_UnicastAddress_iPSourceRouteAddress), PInvalidCast);
#endif
  return *(H245_UnicastAddress_iPSourceRouteAddress *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_UnicastAddress::operator H245_NonStandardParameter &() const
#else
H245_UnicastAddress::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_UnicastAddress::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


BOOL H245_UnicastAddress::CreateObject()
{
  switch (tag) {
    case e_iPAddress :
      choice = new H245_UnicastAddress_iPAddress();
      return TRUE;
    case e_iPXAddress :
      choice = new H245_UnicastAddress_iPXAddress();
      return TRUE;
    case e_iP6Address :
      choice = new H245_UnicastAddress_iP6Address();
      return TRUE;
    case e_netBios :
      choice = new PASN_OctetString();
      choice->SetConstraints(PASN_Object::FixedConstraint, 16);
      return TRUE;
    case e_iPSourceRouteAddress :
      choice = new H245_UnicastAddress_iPSourceRouteAddress();
      return TRUE;
    case e_nsap :
      choice = new PASN_OctetString();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 20);
      return TRUE;
    case e_nonStandardAddress :
      choice = new H245_NonStandardParameter();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_UnicastAddress::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_UnicastAddress::Class()), PInvalidCast);
#endif
  return new H245_UnicastAddress(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_MulticastAddress[]={
      {"iPAddress",0}
     ,{"iP6Address",1}
     ,{"nsap",2}
     ,{"nonStandardAddress",3}
};
#endif
//
// MulticastAddress
//

H245_MulticastAddress::H245_MulticastAddress(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_MulticastAddress,4
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MulticastAddress::operator H245_MulticastAddress_iPAddress &() const
#else
H245_MulticastAddress::operator H245_MulticastAddress_iPAddress &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MulticastAddress_iPAddress), PInvalidCast);
#endif
  return *(H245_MulticastAddress_iPAddress *)choice;
}


H245_MulticastAddress::operator const H245_MulticastAddress_iPAddress &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MulticastAddress_iPAddress), PInvalidCast);
#endif
  return *(H245_MulticastAddress_iPAddress *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MulticastAddress::operator H245_MulticastAddress_iP6Address &() const
#else
H245_MulticastAddress::operator H245_MulticastAddress_iP6Address &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MulticastAddress_iP6Address), PInvalidCast);
#endif
  return *(H245_MulticastAddress_iP6Address *)choice;
}


H245_MulticastAddress::operator const H245_MulticastAddress_iP6Address &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MulticastAddress_iP6Address), PInvalidCast);
#endif
  return *(H245_MulticastAddress_iP6Address *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MulticastAddress::operator H245_NonStandardParameter &() const
#else
H245_MulticastAddress::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_MulticastAddress::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


BOOL H245_MulticastAddress::CreateObject()
{
  switch (tag) {
    case e_iPAddress :
      choice = new H245_MulticastAddress_iPAddress();
      return TRUE;
    case e_iP6Address :
      choice = new H245_MulticastAddress_iP6Address();
      return TRUE;
    case e_nsap :
      choice = new PASN_OctetString();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 20);
      return TRUE;
    case e_nonStandardAddress :
      choice = new H245_NonStandardParameter();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_MulticastAddress::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MulticastAddress::Class()), PInvalidCast);
#endif
  return new H245_MulticastAddress(*this);
}


//
// EscrowData
//

H245_EscrowData::H245_EscrowData(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_escrowValue.SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
}


#ifndef PASN_NOPRINTON
void H245_EscrowData::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "escrowID = " << setprecision(indent) << m_escrowID << '\n';
  strm << setw(indent+14) << "escrowValue = " << setprecision(indent) << m_escrowValue << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_EscrowData::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_EscrowData), PInvalidCast);
#endif
  const H245_EscrowData & other = (const H245_EscrowData &)obj;

  Comparison result;

  if ((result = m_escrowID.Compare(other.m_escrowID)) != EqualTo)
    return result;
  if ((result = m_escrowValue.Compare(other.m_escrowValue)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_EscrowData::GetDataLength() const
{
  PINDEX length = 0;
  length += m_escrowID.GetObjectLength();
  length += m_escrowValue.GetObjectLength();
  return length;
}


BOOL H245_EscrowData::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_escrowID.Decode(strm))
    return FALSE;
  if (!m_escrowValue.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_EscrowData::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_escrowID.Encode(strm);
  m_escrowValue.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_EscrowData::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_EscrowData::Class()), PInvalidCast);
#endif
  return new H245_EscrowData(*this);
}


//
// OpenLogicalChannelConfirm
//

H245_OpenLogicalChannelConfirm::H245_OpenLogicalChannelConfirm(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_OpenLogicalChannelConfirm::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+30) << "forwardLogicalChannelNumber = " << setprecision(indent) << m_forwardLogicalChannelNumber << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_OpenLogicalChannelConfirm::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_OpenLogicalChannelConfirm), PInvalidCast);
#endif
  const H245_OpenLogicalChannelConfirm & other = (const H245_OpenLogicalChannelConfirm &)obj;

  Comparison result;

  if ((result = m_forwardLogicalChannelNumber.Compare(other.m_forwardLogicalChannelNumber)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_OpenLogicalChannelConfirm::GetDataLength() const
{
  PINDEX length = 0;
  length += m_forwardLogicalChannelNumber.GetObjectLength();
  return length;
}


BOOL H245_OpenLogicalChannelConfirm::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_forwardLogicalChannelNumber.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_OpenLogicalChannelConfirm::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_forwardLogicalChannelNumber.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_OpenLogicalChannelConfirm::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_OpenLogicalChannelConfirm::Class()), PInvalidCast);
#endif
  return new H245_OpenLogicalChannelConfirm(*this);
}


//
// CloseLogicalChannelAck
//

H245_CloseLogicalChannelAck::H245_CloseLogicalChannelAck(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_CloseLogicalChannelAck::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+30) << "forwardLogicalChannelNumber = " << setprecision(indent) << m_forwardLogicalChannelNumber << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_CloseLogicalChannelAck::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_CloseLogicalChannelAck), PInvalidCast);
#endif
  const H245_CloseLogicalChannelAck & other = (const H245_CloseLogicalChannelAck &)obj;

  Comparison result;

  if ((result = m_forwardLogicalChannelNumber.Compare(other.m_forwardLogicalChannelNumber)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_CloseLogicalChannelAck::GetDataLength() const
{
  PINDEX length = 0;
  length += m_forwardLogicalChannelNumber.GetObjectLength();
  return length;
}


BOOL H245_CloseLogicalChannelAck::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_forwardLogicalChannelNumber.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_CloseLogicalChannelAck::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_forwardLogicalChannelNumber.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_CloseLogicalChannelAck::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CloseLogicalChannelAck::Class()), PInvalidCast);
#endif
  return new H245_CloseLogicalChannelAck(*this);
}


//
// RequestChannelCloseAck
//

H245_RequestChannelCloseAck::H245_RequestChannelCloseAck(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_RequestChannelCloseAck::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+30) << "forwardLogicalChannelNumber = " << setprecision(indent) << m_forwardLogicalChannelNumber << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_RequestChannelCloseAck::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_RequestChannelCloseAck), PInvalidCast);
#endif
  const H245_RequestChannelCloseAck & other = (const H245_RequestChannelCloseAck &)obj;

  Comparison result;

  if ((result = m_forwardLogicalChannelNumber.Compare(other.m_forwardLogicalChannelNumber)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RequestChannelCloseAck::GetDataLength() const
{
  PINDEX length = 0;
  length += m_forwardLogicalChannelNumber.GetObjectLength();
  return length;
}


BOOL H245_RequestChannelCloseAck::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_forwardLogicalChannelNumber.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_RequestChannelCloseAck::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_forwardLogicalChannelNumber.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_RequestChannelCloseAck::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RequestChannelCloseAck::Class()), PInvalidCast);
#endif
  return new H245_RequestChannelCloseAck(*this);
}


//
// RequestChannelCloseRelease
//

H245_RequestChannelCloseRelease::H245_RequestChannelCloseRelease(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_RequestChannelCloseRelease::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+30) << "forwardLogicalChannelNumber = " << setprecision(indent) << m_forwardLogicalChannelNumber << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_RequestChannelCloseRelease::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_RequestChannelCloseRelease), PInvalidCast);
#endif
  const H245_RequestChannelCloseRelease & other = (const H245_RequestChannelCloseRelease &)obj;

  Comparison result;

  if ((result = m_forwardLogicalChannelNumber.Compare(other.m_forwardLogicalChannelNumber)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RequestChannelCloseRelease::GetDataLength() const
{
  PINDEX length = 0;
  length += m_forwardLogicalChannelNumber.GetObjectLength();
  return length;
}


BOOL H245_RequestChannelCloseRelease::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_forwardLogicalChannelNumber.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_RequestChannelCloseRelease::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_forwardLogicalChannelNumber.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_RequestChannelCloseRelease::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RequestChannelCloseRelease::Class()), PInvalidCast);
#endif
  return new H245_RequestChannelCloseRelease(*this);
}


//
// MultiplexTableEntryNumber
//

H245_MultiplexTableEntryNumber::H245_MultiplexTableEntryNumber(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 15);
}


H245_MultiplexTableEntryNumber & H245_MultiplexTableEntryNumber::operator=(int v)
{
  SetValue(v);
  return *this;
}


H245_MultiplexTableEntryNumber & H245_MultiplexTableEntryNumber::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H245_MultiplexTableEntryNumber::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultiplexTableEntryNumber::Class()), PInvalidCast);
#endif
  return new H245_MultiplexTableEntryNumber(*this);
}


//
// RequestModeRelease
//

H245_RequestModeRelease::H245_RequestModeRelease(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_RequestModeRelease::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PINDEX H245_RequestModeRelease::GetDataLength() const
{
  PINDEX length = 0;
  return length;
}


BOOL H245_RequestModeRelease::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;


  return UnknownExtensionsDecode(strm);
}


void H245_RequestModeRelease::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);


  UnknownExtensionsEncode(strm);
}


PObject * H245_RequestModeRelease::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RequestModeRelease::Class()), PInvalidCast);
#endif
  return new H245_RequestModeRelease(*this);
}


//
// ModeDescription
//

H245_ModeDescription::H245_ModeDescription(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


PASN_Object * H245_ModeDescription::CreateObject() const
{
  return new H245_ModeElement;
}


H245_ModeElement & H245_ModeDescription::operator[](PINDEX i) const
{
  return (H245_ModeElement &)array[i];
}


PObject * H245_ModeDescription::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ModeDescription::Class()), PInvalidCast);
#endif
  return new H245_ModeDescription(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_ModeElementType[]={
      {"nonStandard",0}
     ,{"videoMode",1}
     ,{"audioMode",2}
     ,{"dataMode",3}
     ,{"encryptionMode",4}
     ,{"h235Mode",5}
     ,{"multiplexedStreamMode",6}
     ,{"redundancyEncodingDTMode",7}
     ,{"multiplePayloadStreamMode",8}
     ,{"depFecMode",9}
     ,{"fecMode",10}
};
#endif
//
// ModeElementType
//

H245_ModeElementType::H245_ModeElementType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 5, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_ModeElementType,11
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ModeElementType::operator H245_NonStandardParameter &() const
#else
H245_ModeElementType::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_ModeElementType::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ModeElementType::operator H245_VideoMode &() const
#else
H245_ModeElementType::operator H245_VideoMode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_VideoMode), PInvalidCast);
#endif
  return *(H245_VideoMode *)choice;
}


H245_ModeElementType::operator const H245_VideoMode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_VideoMode), PInvalidCast);
#endif
  return *(H245_VideoMode *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ModeElementType::operator H245_AudioMode &() const
#else
H245_ModeElementType::operator H245_AudioMode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_AudioMode), PInvalidCast);
#endif
  return *(H245_AudioMode *)choice;
}


H245_ModeElementType::operator const H245_AudioMode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_AudioMode), PInvalidCast);
#endif
  return *(H245_AudioMode *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ModeElementType::operator H245_DataMode &() const
#else
H245_ModeElementType::operator H245_DataMode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DataMode), PInvalidCast);
#endif
  return *(H245_DataMode *)choice;
}


H245_ModeElementType::operator const H245_DataMode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DataMode), PInvalidCast);
#endif
  return *(H245_DataMode *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ModeElementType::operator H245_EncryptionMode &() const
#else
H245_ModeElementType::operator H245_EncryptionMode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_EncryptionMode), PInvalidCast);
#endif
  return *(H245_EncryptionMode *)choice;
}


H245_ModeElementType::operator const H245_EncryptionMode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_EncryptionMode), PInvalidCast);
#endif
  return *(H245_EncryptionMode *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ModeElementType::operator H245_H235Mode &() const
#else
H245_ModeElementType::operator H245_H235Mode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H235Mode), PInvalidCast);
#endif
  return *(H245_H235Mode *)choice;
}


H245_ModeElementType::operator const H245_H235Mode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H235Mode), PInvalidCast);
#endif
  return *(H245_H235Mode *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ModeElementType::operator H245_MultiplexedStreamParameter &() const
#else
H245_ModeElementType::operator H245_MultiplexedStreamParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultiplexedStreamParameter), PInvalidCast);
#endif
  return *(H245_MultiplexedStreamParameter *)choice;
}


H245_ModeElementType::operator const H245_MultiplexedStreamParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultiplexedStreamParameter), PInvalidCast);
#endif
  return *(H245_MultiplexedStreamParameter *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ModeElementType::operator H245_RedundancyEncodingDTMode &() const
#else
H245_ModeElementType::operator H245_RedundancyEncodingDTMode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RedundancyEncodingDTMode), PInvalidCast);
#endif
  return *(H245_RedundancyEncodingDTMode *)choice;
}


H245_ModeElementType::operator const H245_RedundancyEncodingDTMode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RedundancyEncodingDTMode), PInvalidCast);
#endif
  return *(H245_RedundancyEncodingDTMode *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ModeElementType::operator H245_MultiplePayloadStreamMode &() const
#else
H245_ModeElementType::operator H245_MultiplePayloadStreamMode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultiplePayloadStreamMode), PInvalidCast);
#endif
  return *(H245_MultiplePayloadStreamMode *)choice;
}


H245_ModeElementType::operator const H245_MultiplePayloadStreamMode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultiplePayloadStreamMode), PInvalidCast);
#endif
  return *(H245_MultiplePayloadStreamMode *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ModeElementType::operator H245_DepFECMode &() const
#else
H245_ModeElementType::operator H245_DepFECMode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DepFECMode), PInvalidCast);
#endif
  return *(H245_DepFECMode *)choice;
}


H245_ModeElementType::operator const H245_DepFECMode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DepFECMode), PInvalidCast);
#endif
  return *(H245_DepFECMode *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ModeElementType::operator H245_FECMode &() const
#else
H245_ModeElementType::operator H245_FECMode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_FECMode), PInvalidCast);
#endif
  return *(H245_FECMode *)choice;
}


H245_ModeElementType::operator const H245_FECMode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_FECMode), PInvalidCast);
#endif
  return *(H245_FECMode *)choice;
}


BOOL H245_ModeElementType::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_videoMode :
      choice = new H245_VideoMode();
      return TRUE;
    case e_audioMode :
      choice = new H245_AudioMode();
      return TRUE;
    case e_dataMode :
      choice = new H245_DataMode();
      return TRUE;
    case e_encryptionMode :
      choice = new H245_EncryptionMode();
      return TRUE;
    case e_h235Mode :
      choice = new H245_H235Mode();
      return TRUE;
    case e_multiplexedStreamMode :
      choice = new H245_MultiplexedStreamParameter();
      return TRUE;
    case e_redundancyEncodingDTMode :
      choice = new H245_RedundancyEncodingDTMode();
      return TRUE;
    case e_multiplePayloadStreamMode :
      choice = new H245_MultiplePayloadStreamMode();
      return TRUE;
    case e_depFecMode :
      choice = new H245_DepFECMode();
      return TRUE;
    case e_fecMode :
      choice = new H245_FECMode();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_ModeElementType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ModeElementType::Class()), PInvalidCast);
#endif
  return new H245_ModeElementType(*this);
}


//
// MultiplexedStreamModeParameters
//

H245_MultiplexedStreamModeParameters::H245_MultiplexedStreamModeParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MultiplexedStreamModeParameters::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+23) << "logicalChannelNumber = " << setprecision(indent) << m_logicalChannelNumber << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MultiplexedStreamModeParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MultiplexedStreamModeParameters), PInvalidCast);
#endif
  const H245_MultiplexedStreamModeParameters & other = (const H245_MultiplexedStreamModeParameters &)obj;

  Comparison result;

  if ((result = m_logicalChannelNumber.Compare(other.m_logicalChannelNumber)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MultiplexedStreamModeParameters::GetDataLength() const
{
  PINDEX length = 0;
  length += m_logicalChannelNumber.GetObjectLength();
  return length;
}


BOOL H245_MultiplexedStreamModeParameters::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_logicalChannelNumber.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MultiplexedStreamModeParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_logicalChannelNumber.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MultiplexedStreamModeParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultiplexedStreamModeParameters::Class()), PInvalidCast);
#endif
  return new H245_MultiplexedStreamModeParameters(*this);
}


//
// MultiplePayloadStreamElementMode
//

H245_MultiplePayloadStreamElementMode::H245_MultiplePayloadStreamElementMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MultiplePayloadStreamElementMode::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+7) << "type = " << setprecision(indent) << m_type << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MultiplePayloadStreamElementMode::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MultiplePayloadStreamElementMode), PInvalidCast);
#endif
  const H245_MultiplePayloadStreamElementMode & other = (const H245_MultiplePayloadStreamElementMode &)obj;

  Comparison result;

  if ((result = m_type.Compare(other.m_type)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MultiplePayloadStreamElementMode::GetDataLength() const
{
  PINDEX length = 0;
  length += m_type.GetObjectLength();
  return length;
}


BOOL H245_MultiplePayloadStreamElementMode::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_type.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MultiplePayloadStreamElementMode::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_type.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MultiplePayloadStreamElementMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultiplePayloadStreamElementMode::Class()), PInvalidCast);
#endif
  return new H245_MultiplePayloadStreamElementMode(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_DepFECMode[]={
      {"rfc2733Mode",0}
};
#endif
//
// DepFECMode
//

H245_DepFECMode::H245_DepFECMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 1, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_DepFECMode,1
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DepFECMode::operator H245_DepFECMode_rfc2733Mode &() const
#else
H245_DepFECMode::operator H245_DepFECMode_rfc2733Mode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DepFECMode_rfc2733Mode), PInvalidCast);
#endif
  return *(H245_DepFECMode_rfc2733Mode *)choice;
}


H245_DepFECMode::operator const H245_DepFECMode_rfc2733Mode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DepFECMode_rfc2733Mode), PInvalidCast);
#endif
  return *(H245_DepFECMode_rfc2733Mode *)choice;
}


BOOL H245_DepFECMode::CreateObject()
{
  switch (tag) {
    case e_rfc2733Mode :
      choice = new H245_DepFECMode_rfc2733Mode();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_DepFECMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_DepFECMode::Class()), PInvalidCast);
#endif
  return new H245_DepFECMode(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_V76ModeParameters[]={
      {"suspendResumewAddress",0}
     ,{"suspendResumewoAddress",1}
};
#endif
//
// V76ModeParameters
//

H245_V76ModeParameters::H245_V76ModeParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_V76ModeParameters,2
#endif
)
{
}


BOOL H245_V76ModeParameters::CreateObject()
{
  choice = (tag <= e_suspendResumewoAddress) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_V76ModeParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_V76ModeParameters::Class()), PInvalidCast);
#endif
  return new H245_V76ModeParameters(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_VideoMode[]={
      {"nonStandard",0}
     ,{"h261VideoMode",1}
     ,{"h262VideoMode",2}
     ,{"h263VideoMode",3}
     ,{"is11172VideoMode",4}
     ,{"genericVideoMode",5}
};
#endif
//
// VideoMode
//

H245_VideoMode::H245_VideoMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 5, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_VideoMode,6
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_VideoMode::operator H245_NonStandardParameter &() const
#else
H245_VideoMode::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_VideoMode::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_VideoMode::operator H245_H261VideoMode &() const
#else
H245_VideoMode::operator H245_H261VideoMode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H261VideoMode), PInvalidCast);
#endif
  return *(H245_H261VideoMode *)choice;
}


H245_VideoMode::operator const H245_H261VideoMode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H261VideoMode), PInvalidCast);
#endif
  return *(H245_H261VideoMode *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_VideoMode::operator H245_H262VideoMode &() const
#else
H245_VideoMode::operator H245_H262VideoMode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H262VideoMode), PInvalidCast);
#endif
  return *(H245_H262VideoMode *)choice;
}


H245_VideoMode::operator const H245_H262VideoMode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H262VideoMode), PInvalidCast);
#endif
  return *(H245_H262VideoMode *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_VideoMode::operator H245_H263VideoMode &() const
#else
H245_VideoMode::operator H245_H263VideoMode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H263VideoMode), PInvalidCast);
#endif
  return *(H245_H263VideoMode *)choice;
}


H245_VideoMode::operator const H245_H263VideoMode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H263VideoMode), PInvalidCast);
#endif
  return *(H245_H263VideoMode *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_VideoMode::operator H245_IS11172VideoMode &() const
#else
H245_VideoMode::operator H245_IS11172VideoMode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_IS11172VideoMode), PInvalidCast);
#endif
  return *(H245_IS11172VideoMode *)choice;
}


H245_VideoMode::operator const H245_IS11172VideoMode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_IS11172VideoMode), PInvalidCast);
#endif
  return *(H245_IS11172VideoMode *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_VideoMode::operator H245_GenericCapability &() const
#else
H245_VideoMode::operator H245_GenericCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_GenericCapability), PInvalidCast);
#endif
  return *(H245_GenericCapability *)choice;
}


H245_VideoMode::operator const H245_GenericCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_GenericCapability), PInvalidCast);
#endif
  return *(H245_GenericCapability *)choice;
}


BOOL H245_VideoMode::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_h261VideoMode :
      choice = new H245_H261VideoMode();
      return TRUE;
    case e_h262VideoMode :
      choice = new H245_H262VideoMode();
      return TRUE;
    case e_h263VideoMode :
      choice = new H245_H263VideoMode();
      return TRUE;
    case e_is11172VideoMode :
      choice = new H245_IS11172VideoMode();
      return TRUE;
    case e_genericVideoMode :
      choice = new H245_GenericCapability();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_VideoMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_VideoMode::Class()), PInvalidCast);
#endif
  return new H245_VideoMode(*this);
}


//
// IS11172VideoMode
//

H245_IS11172VideoMode::H245_IS11172VideoMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 6, TRUE, 0)
{
  m_videoBitRate.SetConstraints(PASN_Object::FixedConstraint, 0, 1073741823);
  m_vbvBufferSize.SetConstraints(PASN_Object::FixedConstraint, 0, 262143);
  m_samplesPerLine.SetConstraints(PASN_Object::FixedConstraint, 0, 16383);
  m_linesPerFrame.SetConstraints(PASN_Object::FixedConstraint, 0, 16383);
  m_pictureRate.SetConstraints(PASN_Object::FixedConstraint, 0, 15);
  m_luminanceSampleRate.SetConstraints(PASN_Object::FixedConstraint, 0, 4294967295U);
}


#ifndef PASN_NOPRINTON
void H245_IS11172VideoMode::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+23) << "constrainedBitstream = " << setprecision(indent) << m_constrainedBitstream << '\n';
  if (HasOptionalField(e_videoBitRate))
    strm << setw(indent+15) << "videoBitRate = " << setprecision(indent) << m_videoBitRate << '\n';
  if (HasOptionalField(e_vbvBufferSize))
    strm << setw(indent+16) << "vbvBufferSize = " << setprecision(indent) << m_vbvBufferSize << '\n';
  if (HasOptionalField(e_samplesPerLine))
    strm << setw(indent+17) << "samplesPerLine = " << setprecision(indent) << m_samplesPerLine << '\n';
  if (HasOptionalField(e_linesPerFrame))
    strm << setw(indent+16) << "linesPerFrame = " << setprecision(indent) << m_linesPerFrame << '\n';
  if (HasOptionalField(e_pictureRate))
    strm << setw(indent+14) << "pictureRate = " << setprecision(indent) << m_pictureRate << '\n';
  if (HasOptionalField(e_luminanceSampleRate))
    strm << setw(indent+22) << "luminanceSampleRate = " << setprecision(indent) << m_luminanceSampleRate << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_IS11172VideoMode::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_IS11172VideoMode), PInvalidCast);
#endif
  const H245_IS11172VideoMode & other = (const H245_IS11172VideoMode &)obj;

  Comparison result;

  if ((result = m_constrainedBitstream.Compare(other.m_constrainedBitstream)) != EqualTo)
    return result;
  if ((result = m_videoBitRate.Compare(other.m_videoBitRate)) != EqualTo)
    return result;
  if ((result = m_vbvBufferSize.Compare(other.m_vbvBufferSize)) != EqualTo)
    return result;
  if ((result = m_samplesPerLine.Compare(other.m_samplesPerLine)) != EqualTo)
    return result;
  if ((result = m_linesPerFrame.Compare(other.m_linesPerFrame)) != EqualTo)
    return result;
  if ((result = m_pictureRate.Compare(other.m_pictureRate)) != EqualTo)
    return result;
  if ((result = m_luminanceSampleRate.Compare(other.m_luminanceSampleRate)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_IS11172VideoMode::GetDataLength() const
{
  PINDEX length = 0;
  length += m_constrainedBitstream.GetObjectLength();
  if (HasOptionalField(e_videoBitRate))
    length += m_videoBitRate.GetObjectLength();
  if (HasOptionalField(e_vbvBufferSize))
    length += m_vbvBufferSize.GetObjectLength();
  if (HasOptionalField(e_samplesPerLine))
    length += m_samplesPerLine.GetObjectLength();
  if (HasOptionalField(e_linesPerFrame))
    length += m_linesPerFrame.GetObjectLength();
  if (HasOptionalField(e_pictureRate))
    length += m_pictureRate.GetObjectLength();
  if (HasOptionalField(e_luminanceSampleRate))
    length += m_luminanceSampleRate.GetObjectLength();
  return length;
}


BOOL H245_IS11172VideoMode::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_constrainedBitstream.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_videoBitRate) && !m_videoBitRate.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_vbvBufferSize) && !m_vbvBufferSize.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_samplesPerLine) && !m_samplesPerLine.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_linesPerFrame) && !m_linesPerFrame.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_pictureRate) && !m_pictureRate.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_luminanceSampleRate) && !m_luminanceSampleRate.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_IS11172VideoMode::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_constrainedBitstream.Encode(strm);
  if (HasOptionalField(e_videoBitRate))
    m_videoBitRate.Encode(strm);
  if (HasOptionalField(e_vbvBufferSize))
    m_vbvBufferSize.Encode(strm);
  if (HasOptionalField(e_samplesPerLine))
    m_samplesPerLine.Encode(strm);
  if (HasOptionalField(e_linesPerFrame))
    m_linesPerFrame.Encode(strm);
  if (HasOptionalField(e_pictureRate))
    m_pictureRate.Encode(strm);
  if (HasOptionalField(e_luminanceSampleRate))
    m_luminanceSampleRate.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_IS11172VideoMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_IS11172VideoMode::Class()), PInvalidCast);
#endif
  return new H245_IS11172VideoMode(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_AudioMode[]={
      {"nonStandard",0}
     ,{"g711Alaw64k",1}
     ,{"g711Alaw56k",2}
     ,{"g711Ulaw64k",3}
     ,{"g711Ulaw56k",4}
     ,{"g722_64k",5}
     ,{"g722_56k",6}
     ,{"g722_48k",7}
     ,{"g728",8}
     ,{"g729",9}
     ,{"g729AnnexA",10}
     ,{"g7231",11}
     ,{"is11172AudioMode",12}
     ,{"is13818AudioMode",13}
     ,{"g729wAnnexB",14}
     ,{"g729AnnexAwAnnexB",15}
     ,{"g7231AnnexCMode",16}
     ,{"gsmFullRate",17}
     ,{"gsmHalfRate",18}
     ,{"gsmEnhancedFullRate",19}
     ,{"genericAudioMode",20}
     ,{"g729Extensions",21}
     ,{"vbd",22}
};
#endif
//
// AudioMode
//

H245_AudioMode::H245_AudioMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 14, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_AudioMode,23
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_AudioMode::operator H245_NonStandardParameter &() const
#else
H245_AudioMode::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_AudioMode::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_AudioMode::operator H245_AudioMode_g7231 &() const
#else
H245_AudioMode::operator H245_AudioMode_g7231 &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_AudioMode_g7231), PInvalidCast);
#endif
  return *(H245_AudioMode_g7231 *)choice;
}


H245_AudioMode::operator const H245_AudioMode_g7231 &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_AudioMode_g7231), PInvalidCast);
#endif
  return *(H245_AudioMode_g7231 *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_AudioMode::operator H245_IS11172AudioMode &() const
#else
H245_AudioMode::operator H245_IS11172AudioMode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_IS11172AudioMode), PInvalidCast);
#endif
  return *(H245_IS11172AudioMode *)choice;
}


H245_AudioMode::operator const H245_IS11172AudioMode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_IS11172AudioMode), PInvalidCast);
#endif
  return *(H245_IS11172AudioMode *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_AudioMode::operator H245_IS13818AudioMode &() const
#else
H245_AudioMode::operator H245_IS13818AudioMode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_IS13818AudioMode), PInvalidCast);
#endif
  return *(H245_IS13818AudioMode *)choice;
}


H245_AudioMode::operator const H245_IS13818AudioMode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_IS13818AudioMode), PInvalidCast);
#endif
  return *(H245_IS13818AudioMode *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_AudioMode::operator H245_G7231AnnexCMode &() const
#else
H245_AudioMode::operator H245_G7231AnnexCMode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_G7231AnnexCMode), PInvalidCast);
#endif
  return *(H245_G7231AnnexCMode *)choice;
}


H245_AudioMode::operator const H245_G7231AnnexCMode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_G7231AnnexCMode), PInvalidCast);
#endif
  return *(H245_G7231AnnexCMode *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_AudioMode::operator H245_GSMAudioCapability &() const
#else
H245_AudioMode::operator H245_GSMAudioCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_GSMAudioCapability), PInvalidCast);
#endif
  return *(H245_GSMAudioCapability *)choice;
}


H245_AudioMode::operator const H245_GSMAudioCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_GSMAudioCapability), PInvalidCast);
#endif
  return *(H245_GSMAudioCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_AudioMode::operator H245_GenericCapability &() const
#else
H245_AudioMode::operator H245_GenericCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_GenericCapability), PInvalidCast);
#endif
  return *(H245_GenericCapability *)choice;
}


H245_AudioMode::operator const H245_GenericCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_GenericCapability), PInvalidCast);
#endif
  return *(H245_GenericCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_AudioMode::operator H245_G729Extensions &() const
#else
H245_AudioMode::operator H245_G729Extensions &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_G729Extensions), PInvalidCast);
#endif
  return *(H245_G729Extensions *)choice;
}


H245_AudioMode::operator const H245_G729Extensions &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_G729Extensions), PInvalidCast);
#endif
  return *(H245_G729Extensions *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_AudioMode::operator H245_VBDMode &() const
#else
H245_AudioMode::operator H245_VBDMode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_VBDMode), PInvalidCast);
#endif
  return *(H245_VBDMode *)choice;
}


H245_AudioMode::operator const H245_VBDMode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_VBDMode), PInvalidCast);
#endif
  return *(H245_VBDMode *)choice;
}


BOOL H245_AudioMode::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_g711Alaw64k :
    case e_g711Alaw56k :
    case e_g711Ulaw64k :
    case e_g711Ulaw56k :
    case e_g722_64k :
    case e_g722_56k :
    case e_g722_48k :
    case e_g728 :
    case e_g729 :
    case e_g729AnnexA :
      choice = new PASN_Null();
      return TRUE;
    case e_g7231 :
      choice = new H245_AudioMode_g7231();
      return TRUE;
    case e_is11172AudioMode :
      choice = new H245_IS11172AudioMode();
      return TRUE;
    case e_is13818AudioMode :
      choice = new H245_IS13818AudioMode();
      return TRUE;
    case e_g729wAnnexB :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 256);
      return TRUE;
    case e_g729AnnexAwAnnexB :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 256);
      return TRUE;
    case e_g7231AnnexCMode :
      choice = new H245_G7231AnnexCMode();
      return TRUE;
    case e_gsmFullRate :
    case e_gsmHalfRate :
    case e_gsmEnhancedFullRate :
      choice = new H245_GSMAudioCapability();
      return TRUE;
    case e_genericAudioMode :
      choice = new H245_GenericCapability();
      return TRUE;
    case e_g729Extensions :
      choice = new H245_G729Extensions();
      return TRUE;
    case e_vbd :
      choice = new H245_VBDMode();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_AudioMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_AudioMode::Class()), PInvalidCast);
#endif
  return new H245_AudioMode(*this);
}


//
// VBDMode
//

H245_VBDMode::H245_VBDMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_VBDMode::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+7) << "type = " << setprecision(indent) << m_type << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_VBDMode::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_VBDMode), PInvalidCast);
#endif
  const H245_VBDMode & other = (const H245_VBDMode &)obj;

  Comparison result;

  if ((result = m_type.Compare(other.m_type)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_VBDMode::GetDataLength() const
{
  PINDEX length = 0;
  length += m_type.GetObjectLength();
  return length;
}


BOOL H245_VBDMode::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_type.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_VBDMode::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_type.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_VBDMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_VBDMode::Class()), PInvalidCast);
#endif
  return new H245_VBDMode(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_EncryptionMode[]={
      {"nonStandard",0}
     ,{"h233Encryption",1}
};
#endif
//
// EncryptionMode
//

H245_EncryptionMode::H245_EncryptionMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_EncryptionMode,2
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_EncryptionMode::operator H245_NonStandardParameter &() const
#else
H245_EncryptionMode::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_EncryptionMode::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


BOOL H245_EncryptionMode::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_h233Encryption :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_EncryptionMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_EncryptionMode::Class()), PInvalidCast);
#endif
  return new H245_EncryptionMode(*this);
}


//
// RoundTripDelayRequest
//

H245_RoundTripDelayRequest::H245_RoundTripDelayRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_RoundTripDelayRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "sequenceNumber = " << setprecision(indent) << m_sequenceNumber << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_RoundTripDelayRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_RoundTripDelayRequest), PInvalidCast);
#endif
  const H245_RoundTripDelayRequest & other = (const H245_RoundTripDelayRequest &)obj;

  Comparison result;

  if ((result = m_sequenceNumber.Compare(other.m_sequenceNumber)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RoundTripDelayRequest::GetDataLength() const
{
  PINDEX length = 0;
  length += m_sequenceNumber.GetObjectLength();
  return length;
}


BOOL H245_RoundTripDelayRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_sequenceNumber.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_RoundTripDelayRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_sequenceNumber.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_RoundTripDelayRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RoundTripDelayRequest::Class()), PInvalidCast);
#endif
  return new H245_RoundTripDelayRequest(*this);
}


//
// RoundTripDelayResponse
//

H245_RoundTripDelayResponse::H245_RoundTripDelayResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_RoundTripDelayResponse::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "sequenceNumber = " << setprecision(indent) << m_sequenceNumber << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_RoundTripDelayResponse::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_RoundTripDelayResponse), PInvalidCast);
#endif
  const H245_RoundTripDelayResponse & other = (const H245_RoundTripDelayResponse &)obj;

  Comparison result;

  if ((result = m_sequenceNumber.Compare(other.m_sequenceNumber)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RoundTripDelayResponse::GetDataLength() const
{
  PINDEX length = 0;
  length += m_sequenceNumber.GetObjectLength();
  return length;
}


BOOL H245_RoundTripDelayResponse::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_sequenceNumber.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_RoundTripDelayResponse::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_sequenceNumber.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_RoundTripDelayResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RoundTripDelayResponse::Class()), PInvalidCast);
#endif
  return new H245_RoundTripDelayResponse(*this);
}


//
// MaintenanceLoopOffCommand
//

H245_MaintenanceLoopOffCommand::H245_MaintenanceLoopOffCommand(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MaintenanceLoopOffCommand::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PINDEX H245_MaintenanceLoopOffCommand::GetDataLength() const
{
  PINDEX length = 0;
  return length;
}


BOOL H245_MaintenanceLoopOffCommand::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;


  return UnknownExtensionsDecode(strm);
}


void H245_MaintenanceLoopOffCommand::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);


  UnknownExtensionsEncode(strm);
}


PObject * H245_MaintenanceLoopOffCommand::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MaintenanceLoopOffCommand::Class()), PInvalidCast);
#endif
  return new H245_MaintenanceLoopOffCommand(*this);
}


//
// CommunicationModeRequest
//

H245_CommunicationModeRequest::H245_CommunicationModeRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_CommunicationModeRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PINDEX H245_CommunicationModeRequest::GetDataLength() const
{
  PINDEX length = 0;
  return length;
}


BOOL H245_CommunicationModeRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;


  return UnknownExtensionsDecode(strm);
}


void H245_CommunicationModeRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);


  UnknownExtensionsEncode(strm);
}


PObject * H245_CommunicationModeRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CommunicationModeRequest::Class()), PInvalidCast);
#endif
  return new H245_CommunicationModeRequest(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_CommunicationModeResponse[]={
      {"communicationModeTable",0}
};
#endif
//
// CommunicationModeResponse
//

H245_CommunicationModeResponse::H245_CommunicationModeResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 1, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_CommunicationModeResponse,1
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_CommunicationModeResponse::operator H245_ArrayOf_CommunicationModeTableEntry &() const
#else
H245_CommunicationModeResponse::operator H245_ArrayOf_CommunicationModeTableEntry &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ArrayOf_CommunicationModeTableEntry), PInvalidCast);
#endif
  return *(H245_ArrayOf_CommunicationModeTableEntry *)choice;
}


H245_CommunicationModeResponse::operator const H245_ArrayOf_CommunicationModeTableEntry &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ArrayOf_CommunicationModeTableEntry), PInvalidCast);
#endif
  return *(H245_ArrayOf_CommunicationModeTableEntry *)choice;
}


BOOL H245_CommunicationModeResponse::CreateObject()
{
  switch (tag) {
    case e_communicationModeTable :
      choice = new H245_ArrayOf_CommunicationModeTableEntry();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 256);
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_CommunicationModeResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CommunicationModeResponse::Class()), PInvalidCast);
#endif
  return new H245_CommunicationModeResponse(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_ConferenceRequest[]={
      {"terminalListRequest",0}
     ,{"makeMeChair",1}
     ,{"cancelMakeMeChair",2}
     ,{"dropTerminal",3}
     ,{"requestTerminalID",4}
     ,{"enterH243Password",5}
     ,{"enterH243TerminalID",6}
     ,{"enterH243ConferenceID",7}
     ,{"enterExtensionAddress",8}
     ,{"requestChairTokenOwner",9}
     ,{"requestTerminalCertificate",10}
     ,{"broadcastMyLogicalChannel",11}
     ,{"makeTerminalBroadcaster",12}
     ,{"sendThisSource",13}
     ,{"requestAllTerminalIDs",14}
     ,{"remoteMCRequest",15}
};
#endif
//
// ConferenceRequest
//

H245_ConferenceRequest::H245_ConferenceRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 8, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_ConferenceRequest,16
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ConferenceRequest::operator H245_TerminalLabel &() const
#else
H245_ConferenceRequest::operator H245_TerminalLabel &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_TerminalLabel), PInvalidCast);
#endif
  return *(H245_TerminalLabel *)choice;
}


H245_ConferenceRequest::operator const H245_TerminalLabel &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_TerminalLabel), PInvalidCast);
#endif
  return *(H245_TerminalLabel *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ConferenceRequest::operator H245_ConferenceRequest_requestTerminalCertificate &() const
#else
H245_ConferenceRequest::operator H245_ConferenceRequest_requestTerminalCertificate &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ConferenceRequest_requestTerminalCertificate), PInvalidCast);
#endif
  return *(H245_ConferenceRequest_requestTerminalCertificate *)choice;
}


H245_ConferenceRequest::operator const H245_ConferenceRequest_requestTerminalCertificate &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ConferenceRequest_requestTerminalCertificate), PInvalidCast);
#endif
  return *(H245_ConferenceRequest_requestTerminalCertificate *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ConferenceRequest::operator H245_LogicalChannelNumber &() const
#else
H245_ConferenceRequest::operator H245_LogicalChannelNumber &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_LogicalChannelNumber), PInvalidCast);
#endif
  return *(H245_LogicalChannelNumber *)choice;
}


H245_ConferenceRequest::operator const H245_LogicalChannelNumber &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_LogicalChannelNumber), PInvalidCast);
#endif
  return *(H245_LogicalChannelNumber *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ConferenceRequest::operator H245_RemoteMCRequest &() const
#else
H245_ConferenceRequest::operator H245_RemoteMCRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RemoteMCRequest), PInvalidCast);
#endif
  return *(H245_RemoteMCRequest *)choice;
}


H245_ConferenceRequest::operator const H245_RemoteMCRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RemoteMCRequest), PInvalidCast);
#endif
  return *(H245_RemoteMCRequest *)choice;
}


BOOL H245_ConferenceRequest::CreateObject()
{
  switch (tag) {
    case e_terminalListRequest :
    case e_makeMeChair :
    case e_cancelMakeMeChair :
    case e_enterH243Password :
    case e_enterH243TerminalID :
    case e_enterH243ConferenceID :
    case e_enterExtensionAddress :
    case e_requestChairTokenOwner :
    case e_requestAllTerminalIDs :
      choice = new PASN_Null();
      return TRUE;
    case e_dropTerminal :
    case e_requestTerminalID :
    case e_makeTerminalBroadcaster :
    case e_sendThisSource :
      choice = new H245_TerminalLabel();
      return TRUE;
    case e_requestTerminalCertificate :
      choice = new H245_ConferenceRequest_requestTerminalCertificate();
      return TRUE;
    case e_broadcastMyLogicalChannel :
      choice = new H245_LogicalChannelNumber();
      return TRUE;
    case e_remoteMCRequest :
      choice = new H245_RemoteMCRequest();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_ConferenceRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ConferenceRequest::Class()), PInvalidCast);
#endif
  return new H245_ConferenceRequest(*this);
}


//
// CertSelectionCriteria
//

H245_CertSelectionCriteria::H245_CertSelectionCriteria(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 16);
}


PASN_Object * H245_CertSelectionCriteria::CreateObject() const
{
  return new H245_Criteria;
}


H245_Criteria & H245_CertSelectionCriteria::operator[](PINDEX i) const
{
  return (H245_Criteria &)array[i];
}


PObject * H245_CertSelectionCriteria::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CertSelectionCriteria::Class()), PInvalidCast);
#endif
  return new H245_CertSelectionCriteria(*this);
}


//
// Criteria
//

H245_Criteria::H245_Criteria(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_value.SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
}


#ifndef PASN_NOPRINTON
void H245_Criteria::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+8) << "field = " << setprecision(indent) << m_field << '\n';
  strm << setw(indent+8) << "value = " << setprecision(indent) << m_value << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_Criteria::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_Criteria), PInvalidCast);
#endif
  const H245_Criteria & other = (const H245_Criteria &)obj;

  Comparison result;

  if ((result = m_field.Compare(other.m_field)) != EqualTo)
    return result;
  if ((result = m_value.Compare(other.m_value)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_Criteria::GetDataLength() const
{
  PINDEX length = 0;
  length += m_field.GetObjectLength();
  length += m_value.GetObjectLength();
  return length;
}


BOOL H245_Criteria::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_field.Decode(strm))
    return FALSE;
  if (!m_value.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_Criteria::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_field.Encode(strm);
  m_value.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_Criteria::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_Criteria::Class()), PInvalidCast);
#endif
  return new H245_Criteria(*this);
}


//
// McuNumber
//

H245_McuNumber::H245_McuNumber(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 0, 192);
}


H245_McuNumber & H245_McuNumber::operator=(int v)
{
  SetValue(v);
  return *this;
}


H245_McuNumber & H245_McuNumber::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H245_McuNumber::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_McuNumber::Class()), PInvalidCast);
#endif
  return new H245_McuNumber(*this);
}


//
// TerminalNumber
//

H245_TerminalNumber::H245_TerminalNumber(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 0, 192);
}


H245_TerminalNumber & H245_TerminalNumber::operator=(int v)
{
  SetValue(v);
  return *this;
}


H245_TerminalNumber & H245_TerminalNumber::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H245_TerminalNumber::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_TerminalNumber::Class()), PInvalidCast);
#endif
  return new H245_TerminalNumber(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_ConferenceResponse[]={
      {"mCTerminalIDResponse",0}
     ,{"terminalIDResponse",1}
     ,{"conferenceIDResponse",2}
     ,{"passwordResponse",3}
     ,{"terminalListResponse",4}
     ,{"videoCommandReject",5}
     ,{"terminalDropReject",6}
     ,{"makeMeChairResponse",7}
     ,{"extensionAddressResponse",8}
     ,{"chairTokenOwnerResponse",9}
     ,{"terminalCertificateResponse",10}
     ,{"broadcastMyLogicalChannelResponse",11}
     ,{"makeTerminalBroadcasterResponse",12}
     ,{"sendThisSourceResponse",13}
     ,{"requestAllTerminalIDsResponse",14}
     ,{"remoteMCResponse",15}
};
#endif
//
// ConferenceResponse
//

H245_ConferenceResponse::H245_ConferenceResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 8, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_ConferenceResponse,16
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ConferenceResponse::operator H245_ConferenceResponse_mCTerminalIDResponse &() const
#else
H245_ConferenceResponse::operator H245_ConferenceResponse_mCTerminalIDResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ConferenceResponse_mCTerminalIDResponse), PInvalidCast);
#endif
  return *(H245_ConferenceResponse_mCTerminalIDResponse *)choice;
}


H245_ConferenceResponse::operator const H245_ConferenceResponse_mCTerminalIDResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ConferenceResponse_mCTerminalIDResponse), PInvalidCast);
#endif
  return *(H245_ConferenceResponse_mCTerminalIDResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ConferenceResponse::operator H245_ConferenceResponse_terminalIDResponse &() const
#else
H245_ConferenceResponse::operator H245_ConferenceResponse_terminalIDResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ConferenceResponse_terminalIDResponse), PInvalidCast);
#endif
  return *(H245_ConferenceResponse_terminalIDResponse *)choice;
}


H245_ConferenceResponse::operator const H245_ConferenceResponse_terminalIDResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ConferenceResponse_terminalIDResponse), PInvalidCast);
#endif
  return *(H245_ConferenceResponse_terminalIDResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ConferenceResponse::operator H245_ConferenceResponse_conferenceIDResponse &() const
#else
H245_ConferenceResponse::operator H245_ConferenceResponse_conferenceIDResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ConferenceResponse_conferenceIDResponse), PInvalidCast);
#endif
  return *(H245_ConferenceResponse_conferenceIDResponse *)choice;
}


H245_ConferenceResponse::operator const H245_ConferenceResponse_conferenceIDResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ConferenceResponse_conferenceIDResponse), PInvalidCast);
#endif
  return *(H245_ConferenceResponse_conferenceIDResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ConferenceResponse::operator H245_ConferenceResponse_passwordResponse &() const
#else
H245_ConferenceResponse::operator H245_ConferenceResponse_passwordResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ConferenceResponse_passwordResponse), PInvalidCast);
#endif
  return *(H245_ConferenceResponse_passwordResponse *)choice;
}


H245_ConferenceResponse::operator const H245_ConferenceResponse_passwordResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ConferenceResponse_passwordResponse), PInvalidCast);
#endif
  return *(H245_ConferenceResponse_passwordResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ConferenceResponse::operator H245_ArrayOf_TerminalLabel &() const
#else
H245_ConferenceResponse::operator H245_ArrayOf_TerminalLabel &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ArrayOf_TerminalLabel), PInvalidCast);
#endif
  return *(H245_ArrayOf_TerminalLabel *)choice;
}


H245_ConferenceResponse::operator const H245_ArrayOf_TerminalLabel &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ArrayOf_TerminalLabel), PInvalidCast);
#endif
  return *(H245_ArrayOf_TerminalLabel *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ConferenceResponse::operator H245_ConferenceResponse_makeMeChairResponse &() const
#else
H245_ConferenceResponse::operator H245_ConferenceResponse_makeMeChairResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ConferenceResponse_makeMeChairResponse), PInvalidCast);
#endif
  return *(H245_ConferenceResponse_makeMeChairResponse *)choice;
}


H245_ConferenceResponse::operator const H245_ConferenceResponse_makeMeChairResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ConferenceResponse_makeMeChairResponse), PInvalidCast);
#endif
  return *(H245_ConferenceResponse_makeMeChairResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ConferenceResponse::operator H245_ConferenceResponse_extensionAddressResponse &() const
#else
H245_ConferenceResponse::operator H245_ConferenceResponse_extensionAddressResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ConferenceResponse_extensionAddressResponse), PInvalidCast);
#endif
  return *(H245_ConferenceResponse_extensionAddressResponse *)choice;
}


H245_ConferenceResponse::operator const H245_ConferenceResponse_extensionAddressResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ConferenceResponse_extensionAddressResponse), PInvalidCast);
#endif
  return *(H245_ConferenceResponse_extensionAddressResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ConferenceResponse::operator H245_ConferenceResponse_chairTokenOwnerResponse &() const
#else
H245_ConferenceResponse::operator H245_ConferenceResponse_chairTokenOwnerResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ConferenceResponse_chairTokenOwnerResponse), PInvalidCast);
#endif
  return *(H245_ConferenceResponse_chairTokenOwnerResponse *)choice;
}


H245_ConferenceResponse::operator const H245_ConferenceResponse_chairTokenOwnerResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ConferenceResponse_chairTokenOwnerResponse), PInvalidCast);
#endif
  return *(H245_ConferenceResponse_chairTokenOwnerResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ConferenceResponse::operator H245_ConferenceResponse_terminalCertificateResponse &() const
#else
H245_ConferenceResponse::operator H245_ConferenceResponse_terminalCertificateResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ConferenceResponse_terminalCertificateResponse), PInvalidCast);
#endif
  return *(H245_ConferenceResponse_terminalCertificateResponse *)choice;
}


H245_ConferenceResponse::operator const H245_ConferenceResponse_terminalCertificateResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ConferenceResponse_terminalCertificateResponse), PInvalidCast);
#endif
  return *(H245_ConferenceResponse_terminalCertificateResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ConferenceResponse::operator H245_ConferenceResponse_broadcastMyLogicalChannelResponse &() const
#else
H245_ConferenceResponse::operator H245_ConferenceResponse_broadcastMyLogicalChannelResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ConferenceResponse_broadcastMyLogicalChannelResponse), PInvalidCast);
#endif
  return *(H245_ConferenceResponse_broadcastMyLogicalChannelResponse *)choice;
}


H245_ConferenceResponse::operator const H245_ConferenceResponse_broadcastMyLogicalChannelResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ConferenceResponse_broadcastMyLogicalChannelResponse), PInvalidCast);
#endif
  return *(H245_ConferenceResponse_broadcastMyLogicalChannelResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ConferenceResponse::operator H245_ConferenceResponse_makeTerminalBroadcasterResponse &() const
#else
H245_ConferenceResponse::operator H245_ConferenceResponse_makeTerminalBroadcasterResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ConferenceResponse_makeTerminalBroadcasterResponse), PInvalidCast);
#endif
  return *(H245_ConferenceResponse_makeTerminalBroadcasterResponse *)choice;
}


H245_ConferenceResponse::operator const H245_ConferenceResponse_makeTerminalBroadcasterResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ConferenceResponse_makeTerminalBroadcasterResponse), PInvalidCast);
#endif
  return *(H245_ConferenceResponse_makeTerminalBroadcasterResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ConferenceResponse::operator H245_ConferenceResponse_sendThisSourceResponse &() const
#else
H245_ConferenceResponse::operator H245_ConferenceResponse_sendThisSourceResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ConferenceResponse_sendThisSourceResponse), PInvalidCast);
#endif
  return *(H245_ConferenceResponse_sendThisSourceResponse *)choice;
}


H245_ConferenceResponse::operator const H245_ConferenceResponse_sendThisSourceResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ConferenceResponse_sendThisSourceResponse), PInvalidCast);
#endif
  return *(H245_ConferenceResponse_sendThisSourceResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ConferenceResponse::operator H245_RequestAllTerminalIDsResponse &() const
#else
H245_ConferenceResponse::operator H245_RequestAllTerminalIDsResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RequestAllTerminalIDsResponse), PInvalidCast);
#endif
  return *(H245_RequestAllTerminalIDsResponse *)choice;
}


H245_ConferenceResponse::operator const H245_RequestAllTerminalIDsResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RequestAllTerminalIDsResponse), PInvalidCast);
#endif
  return *(H245_RequestAllTerminalIDsResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ConferenceResponse::operator H245_RemoteMCResponse &() const
#else
H245_ConferenceResponse::operator H245_RemoteMCResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RemoteMCResponse), PInvalidCast);
#endif
  return *(H245_RemoteMCResponse *)choice;
}


H245_ConferenceResponse::operator const H245_RemoteMCResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RemoteMCResponse), PInvalidCast);
#endif
  return *(H245_RemoteMCResponse *)choice;
}


BOOL H245_ConferenceResponse::CreateObject()
{
  switch (tag) {
    case e_mCTerminalIDResponse :
      choice = new H245_ConferenceResponse_mCTerminalIDResponse();
      return TRUE;
    case e_terminalIDResponse :
      choice = new H245_ConferenceResponse_terminalIDResponse();
      return TRUE;
    case e_conferenceIDResponse :
      choice = new H245_ConferenceResponse_conferenceIDResponse();
      return TRUE;
    case e_passwordResponse :
      choice = new H245_ConferenceResponse_passwordResponse();
      return TRUE;
    case e_terminalListResponse :
      choice = new H245_ArrayOf_TerminalLabel();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 256);
      return TRUE;
    case e_videoCommandReject :
    case e_terminalDropReject :
      choice = new PASN_Null();
      return TRUE;
    case e_makeMeChairResponse :
      choice = new H245_ConferenceResponse_makeMeChairResponse();
      return TRUE;
    case e_extensionAddressResponse :
      choice = new H245_ConferenceResponse_extensionAddressResponse();
      return TRUE;
    case e_chairTokenOwnerResponse :
      choice = new H245_ConferenceResponse_chairTokenOwnerResponse();
      return TRUE;
    case e_terminalCertificateResponse :
      choice = new H245_ConferenceResponse_terminalCertificateResponse();
      return TRUE;
    case e_broadcastMyLogicalChannelResponse :
      choice = new H245_ConferenceResponse_broadcastMyLogicalChannelResponse();
      return TRUE;
    case e_makeTerminalBroadcasterResponse :
      choice = new H245_ConferenceResponse_makeTerminalBroadcasterResponse();
      return TRUE;
    case e_sendThisSourceResponse :
      choice = new H245_ConferenceResponse_sendThisSourceResponse();
      return TRUE;
    case e_requestAllTerminalIDsResponse :
      choice = new H245_RequestAllTerminalIDsResponse();
      return TRUE;
    case e_remoteMCResponse :
      choice = new H245_RemoteMCResponse();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_ConferenceResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ConferenceResponse::Class()), PInvalidCast);
#endif
  return new H245_ConferenceResponse(*this);
}


//
// TerminalID
//

H245_TerminalID::H245_TerminalID(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_OctetString(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 128);
}


H245_TerminalID::H245_TerminalID(const char * v)
{
  SetValue(v);
}


H245_TerminalID::H245_TerminalID(const PString & v)
{
  SetValue(v);
}


H245_TerminalID::H245_TerminalID(const PBYTEArray & v)
{
  SetValue(v);
}


H245_TerminalID & H245_TerminalID::operator=(const char * v)
{
  SetValue(v);
  return *this;
}


H245_TerminalID & H245_TerminalID::operator=(const PString & v)
{
  SetValue(v);
  return *this;
}


H245_TerminalID & H245_TerminalID::operator=(const PBYTEArray & v)
{
  SetValue(v);
  return *this;
}


PObject * H245_TerminalID::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_TerminalID::Class()), PInvalidCast);
#endif
  return new H245_TerminalID(*this);
}


//
// ConferenceID
//

H245_ConferenceID::H245_ConferenceID(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_OctetString(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 32);
}


H245_ConferenceID::H245_ConferenceID(const char * v)
{
  SetValue(v);
}


H245_ConferenceID::H245_ConferenceID(const PString & v)
{
  SetValue(v);
}


H245_ConferenceID::H245_ConferenceID(const PBYTEArray & v)
{
  SetValue(v);
}


H245_ConferenceID & H245_ConferenceID::operator=(const char * v)
{
  SetValue(v);
  return *this;
}


H245_ConferenceID & H245_ConferenceID::operator=(const PString & v)
{
  SetValue(v);
  return *this;
}


H245_ConferenceID & H245_ConferenceID::operator=(const PBYTEArray & v)
{
  SetValue(v);
  return *this;
}


PObject * H245_ConferenceID::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ConferenceID::Class()), PInvalidCast);
#endif
  return new H245_ConferenceID(*this);
}


//
// Password
//

H245_Password::H245_Password(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_OctetString(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 32);
}


H245_Password::H245_Password(const char * v)
{
  SetValue(v);
}


H245_Password::H245_Password(const PString & v)
{
  SetValue(v);
}


H245_Password::H245_Password(const PBYTEArray & v)
{
  SetValue(v);
}


H245_Password & H245_Password::operator=(const char * v)
{
  SetValue(v);
  return *this;
}


H245_Password & H245_Password::operator=(const PString & v)
{
  SetValue(v);
  return *this;
}


H245_Password & H245_Password::operator=(const PBYTEArray & v)
{
  SetValue(v);
  return *this;
}


PObject * H245_Password::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_Password::Class()), PInvalidCast);
#endif
  return new H245_Password(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_RemoteMCRequest[]={
      {"masterActivate",0}
     ,{"slaveActivate",1}
     ,{"deActivate",2}
};
#endif
//
// RemoteMCRequest
//

H245_RemoteMCRequest::H245_RemoteMCRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_RemoteMCRequest,3
#endif
)
{
}


BOOL H245_RemoteMCRequest::CreateObject()
{
  choice = (tag <= e_deActivate) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_RemoteMCRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RemoteMCRequest::Class()), PInvalidCast);
#endif
  return new H245_RemoteMCRequest(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_RemoteMCResponse[]={
      {"accept",0}
     ,{"reject",1}
};
#endif
//
// RemoteMCResponse
//

H245_RemoteMCResponse::H245_RemoteMCResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_RemoteMCResponse,2
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RemoteMCResponse::operator H245_RemoteMCResponse_reject &() const
#else
H245_RemoteMCResponse::operator H245_RemoteMCResponse_reject &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RemoteMCResponse_reject), PInvalidCast);
#endif
  return *(H245_RemoteMCResponse_reject *)choice;
}


H245_RemoteMCResponse::operator const H245_RemoteMCResponse_reject &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RemoteMCResponse_reject), PInvalidCast);
#endif
  return *(H245_RemoteMCResponse_reject *)choice;
}


BOOL H245_RemoteMCResponse::CreateObject()
{
  switch (tag) {
    case e_accept :
      choice = new PASN_Null();
      return TRUE;
    case e_reject :
      choice = new H245_RemoteMCResponse_reject();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_RemoteMCResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RemoteMCResponse::Class()), PInvalidCast);
#endif
  return new H245_RemoteMCResponse(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_MultilinkRequest[]={
      {"nonStandard",0}
     ,{"callInformation",1}
     ,{"addConnection",2}
     ,{"removeConnection",3}
     ,{"maximumHeaderInterval",4}
};
#endif
//
// MultilinkRequest
//

H245_MultilinkRequest::H245_MultilinkRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 5, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_MultilinkRequest,5
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultilinkRequest::operator H245_NonStandardMessage &() const
#else
H245_MultilinkRequest::operator H245_NonStandardMessage &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardMessage), PInvalidCast);
#endif
  return *(H245_NonStandardMessage *)choice;
}


H245_MultilinkRequest::operator const H245_NonStandardMessage &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardMessage), PInvalidCast);
#endif
  return *(H245_NonStandardMessage *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultilinkRequest::operator H245_MultilinkRequest_callInformation &() const
#else
H245_MultilinkRequest::operator H245_MultilinkRequest_callInformation &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultilinkRequest_callInformation), PInvalidCast);
#endif
  return *(H245_MultilinkRequest_callInformation *)choice;
}


H245_MultilinkRequest::operator const H245_MultilinkRequest_callInformation &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultilinkRequest_callInformation), PInvalidCast);
#endif
  return *(H245_MultilinkRequest_callInformation *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultilinkRequest::operator H245_MultilinkRequest_addConnection &() const
#else
H245_MultilinkRequest::operator H245_MultilinkRequest_addConnection &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultilinkRequest_addConnection), PInvalidCast);
#endif
  return *(H245_MultilinkRequest_addConnection *)choice;
}


H245_MultilinkRequest::operator const H245_MultilinkRequest_addConnection &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultilinkRequest_addConnection), PInvalidCast);
#endif
  return *(H245_MultilinkRequest_addConnection *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultilinkRequest::operator H245_MultilinkRequest_removeConnection &() const
#else
H245_MultilinkRequest::operator H245_MultilinkRequest_removeConnection &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultilinkRequest_removeConnection), PInvalidCast);
#endif
  return *(H245_MultilinkRequest_removeConnection *)choice;
}


H245_MultilinkRequest::operator const H245_MultilinkRequest_removeConnection &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultilinkRequest_removeConnection), PInvalidCast);
#endif
  return *(H245_MultilinkRequest_removeConnection *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultilinkRequest::operator H245_MultilinkRequest_maximumHeaderInterval &() const
#else
H245_MultilinkRequest::operator H245_MultilinkRequest_maximumHeaderInterval &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultilinkRequest_maximumHeaderInterval), PInvalidCast);
#endif
  return *(H245_MultilinkRequest_maximumHeaderInterval *)choice;
}


H245_MultilinkRequest::operator const H245_MultilinkRequest_maximumHeaderInterval &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultilinkRequest_maximumHeaderInterval), PInvalidCast);
#endif
  return *(H245_MultilinkRequest_maximumHeaderInterval *)choice;
}


BOOL H245_MultilinkRequest::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardMessage();
      return TRUE;
    case e_callInformation :
      choice = new H245_MultilinkRequest_callInformation();
      return TRUE;
    case e_addConnection :
      choice = new H245_MultilinkRequest_addConnection();
      return TRUE;
    case e_removeConnection :
      choice = new H245_MultilinkRequest_removeConnection();
      return TRUE;
    case e_maximumHeaderInterval :
      choice = new H245_MultilinkRequest_maximumHeaderInterval();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_MultilinkRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultilinkRequest::Class()), PInvalidCast);
#endif
  return new H245_MultilinkRequest(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_MultilinkResponse[]={
      {"nonStandard",0}
     ,{"callInformation",1}
     ,{"addConnection",2}
     ,{"removeConnection",3}
     ,{"maximumHeaderInterval",4}
};
#endif
//
// MultilinkResponse
//

H245_MultilinkResponse::H245_MultilinkResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 5, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_MultilinkResponse,5
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultilinkResponse::operator H245_NonStandardMessage &() const
#else
H245_MultilinkResponse::operator H245_NonStandardMessage &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardMessage), PInvalidCast);
#endif
  return *(H245_NonStandardMessage *)choice;
}


H245_MultilinkResponse::operator const H245_NonStandardMessage &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardMessage), PInvalidCast);
#endif
  return *(H245_NonStandardMessage *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultilinkResponse::operator H245_MultilinkResponse_callInformation &() const
#else
H245_MultilinkResponse::operator H245_MultilinkResponse_callInformation &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultilinkResponse_callInformation), PInvalidCast);
#endif
  return *(H245_MultilinkResponse_callInformation *)choice;
}


H245_MultilinkResponse::operator const H245_MultilinkResponse_callInformation &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultilinkResponse_callInformation), PInvalidCast);
#endif
  return *(H245_MultilinkResponse_callInformation *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultilinkResponse::operator H245_MultilinkResponse_addConnection &() const
#else
H245_MultilinkResponse::operator H245_MultilinkResponse_addConnection &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultilinkResponse_addConnection), PInvalidCast);
#endif
  return *(H245_MultilinkResponse_addConnection *)choice;
}


H245_MultilinkResponse::operator const H245_MultilinkResponse_addConnection &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultilinkResponse_addConnection), PInvalidCast);
#endif
  return *(H245_MultilinkResponse_addConnection *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultilinkResponse::operator H245_MultilinkResponse_removeConnection &() const
#else
H245_MultilinkResponse::operator H245_MultilinkResponse_removeConnection &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultilinkResponse_removeConnection), PInvalidCast);
#endif
  return *(H245_MultilinkResponse_removeConnection *)choice;
}


H245_MultilinkResponse::operator const H245_MultilinkResponse_removeConnection &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultilinkResponse_removeConnection), PInvalidCast);
#endif
  return *(H245_MultilinkResponse_removeConnection *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultilinkResponse::operator H245_MultilinkResponse_maximumHeaderInterval &() const
#else
H245_MultilinkResponse::operator H245_MultilinkResponse_maximumHeaderInterval &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultilinkResponse_maximumHeaderInterval), PInvalidCast);
#endif
  return *(H245_MultilinkResponse_maximumHeaderInterval *)choice;
}


H245_MultilinkResponse::operator const H245_MultilinkResponse_maximumHeaderInterval &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultilinkResponse_maximumHeaderInterval), PInvalidCast);
#endif
  return *(H245_MultilinkResponse_maximumHeaderInterval *)choice;
}


BOOL H245_MultilinkResponse::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardMessage();
      return TRUE;
    case e_callInformation :
      choice = new H245_MultilinkResponse_callInformation();
      return TRUE;
    case e_addConnection :
      choice = new H245_MultilinkResponse_addConnection();
      return TRUE;
    case e_removeConnection :
      choice = new H245_MultilinkResponse_removeConnection();
      return TRUE;
    case e_maximumHeaderInterval :
      choice = new H245_MultilinkResponse_maximumHeaderInterval();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_MultilinkResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultilinkResponse::Class()), PInvalidCast);
#endif
  return new H245_MultilinkResponse(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_MultilinkIndication[]={
      {"nonStandard",0}
     ,{"crcDesired",1}
     ,{"excessiveError",2}
};
#endif
//
// MultilinkIndication
//

H245_MultilinkIndication::H245_MultilinkIndication(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_MultilinkIndication,3
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultilinkIndication::operator H245_NonStandardMessage &() const
#else
H245_MultilinkIndication::operator H245_NonStandardMessage &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardMessage), PInvalidCast);
#endif
  return *(H245_NonStandardMessage *)choice;
}


H245_MultilinkIndication::operator const H245_NonStandardMessage &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardMessage), PInvalidCast);
#endif
  return *(H245_NonStandardMessage *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultilinkIndication::operator H245_MultilinkIndication_crcDesired &() const
#else
H245_MultilinkIndication::operator H245_MultilinkIndication_crcDesired &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultilinkIndication_crcDesired), PInvalidCast);
#endif
  return *(H245_MultilinkIndication_crcDesired *)choice;
}


H245_MultilinkIndication::operator const H245_MultilinkIndication_crcDesired &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultilinkIndication_crcDesired), PInvalidCast);
#endif
  return *(H245_MultilinkIndication_crcDesired *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultilinkIndication::operator H245_MultilinkIndication_excessiveError &() const
#else
H245_MultilinkIndication::operator H245_MultilinkIndication_excessiveError &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultilinkIndication_excessiveError), PInvalidCast);
#endif
  return *(H245_MultilinkIndication_excessiveError *)choice;
}


H245_MultilinkIndication::operator const H245_MultilinkIndication_excessiveError &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultilinkIndication_excessiveError), PInvalidCast);
#endif
  return *(H245_MultilinkIndication_excessiveError *)choice;
}


BOOL H245_MultilinkIndication::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardMessage();
      return TRUE;
    case e_crcDesired :
      choice = new H245_MultilinkIndication_crcDesired();
      return TRUE;
    case e_excessiveError :
      choice = new H245_MultilinkIndication_excessiveError();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_MultilinkIndication::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultilinkIndication::Class()), PInvalidCast);
#endif
  return new H245_MultilinkIndication(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_DialingInformation[]={
      {"nonStandard",0}
     ,{"differential",1}
     ,{"infoNotAvailable",2}
};
#endif
//
// DialingInformation
//

H245_DialingInformation::H245_DialingInformation(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_DialingInformation,3
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DialingInformation::operator H245_NonStandardMessage &() const
#else
H245_DialingInformation::operator H245_NonStandardMessage &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardMessage), PInvalidCast);
#endif
  return *(H245_NonStandardMessage *)choice;
}


H245_DialingInformation::operator const H245_NonStandardMessage &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardMessage), PInvalidCast);
#endif
  return *(H245_NonStandardMessage *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DialingInformation::operator H245_ArrayOf_DialingInformationNumber &() const
#else
H245_DialingInformation::operator H245_ArrayOf_DialingInformationNumber &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ArrayOf_DialingInformationNumber), PInvalidCast);
#endif
  return *(H245_ArrayOf_DialingInformationNumber *)choice;
}


H245_DialingInformation::operator const H245_ArrayOf_DialingInformationNumber &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ArrayOf_DialingInformationNumber), PInvalidCast);
#endif
  return *(H245_ArrayOf_DialingInformationNumber *)choice;
}


BOOL H245_DialingInformation::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardMessage();
      return TRUE;
    case e_differential :
      choice = new H245_ArrayOf_DialingInformationNumber();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
      return TRUE;
    case e_infoNotAvailable :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_DialingInformation::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_DialingInformation::Class()), PInvalidCast);
#endif
  return new H245_DialingInformation(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_DialingInformationNetworkType[]={
      {"nonStandard",0}
     ,{"n_isdn",1}
     ,{"gstn",2}
     ,{"mobile",3}
};
#endif
//
// DialingInformationNetworkType
//

H245_DialingInformationNetworkType::H245_DialingInformationNetworkType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_DialingInformationNetworkType,4
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DialingInformationNetworkType::operator H245_NonStandardMessage &() const
#else
H245_DialingInformationNetworkType::operator H245_NonStandardMessage &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardMessage), PInvalidCast);
#endif
  return *(H245_NonStandardMessage *)choice;
}


H245_DialingInformationNetworkType::operator const H245_NonStandardMessage &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardMessage), PInvalidCast);
#endif
  return *(H245_NonStandardMessage *)choice;
}


BOOL H245_DialingInformationNetworkType::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardMessage();
      return TRUE;
    case e_n_isdn :
    case e_gstn :
    case e_mobile :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_DialingInformationNetworkType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_DialingInformationNetworkType::Class()), PInvalidCast);
#endif
  return new H245_DialingInformationNetworkType(*this);
}


//
// ConnectionIdentifier
//

H245_ConnectionIdentifier::H245_ConnectionIdentifier(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_channelTag.SetConstraints(PASN_Object::FixedConstraint, 0, 4294967295U);
  m_sequenceNumber.SetConstraints(PASN_Object::FixedConstraint, 0, 4294967295U);
}


#ifndef PASN_NOPRINTON
void H245_ConnectionIdentifier::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+13) << "channelTag = " << setprecision(indent) << m_channelTag << '\n';
  strm << setw(indent+17) << "sequenceNumber = " << setprecision(indent) << m_sequenceNumber << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_ConnectionIdentifier::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_ConnectionIdentifier), PInvalidCast);
#endif
  const H245_ConnectionIdentifier & other = (const H245_ConnectionIdentifier &)obj;

  Comparison result;

  if ((result = m_channelTag.Compare(other.m_channelTag)) != EqualTo)
    return result;
  if ((result = m_sequenceNumber.Compare(other.m_sequenceNumber)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_ConnectionIdentifier::GetDataLength() const
{
  PINDEX length = 0;
  length += m_channelTag.GetObjectLength();
  length += m_sequenceNumber.GetObjectLength();
  return length;
}


BOOL H245_ConnectionIdentifier::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_channelTag.Decode(strm))
    return FALSE;
  if (!m_sequenceNumber.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_ConnectionIdentifier::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_channelTag.Encode(strm);
  m_sequenceNumber.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_ConnectionIdentifier::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ConnectionIdentifier::Class()), PInvalidCast);
#endif
  return new H245_ConnectionIdentifier(*this);
}


//
// MaximumBitRate
//

H245_MaximumBitRate::H245_MaximumBitRate(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 0, 4294967295U);
}


H245_MaximumBitRate & H245_MaximumBitRate::operator=(int v)
{
  SetValue(v);
  return *this;
}


H245_MaximumBitRate & H245_MaximumBitRate::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H245_MaximumBitRate::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MaximumBitRate::Class()), PInvalidCast);
#endif
  return new H245_MaximumBitRate(*this);
}


//
// LogicalChannelRateRequest
//

H245_LogicalChannelRateRequest::H245_LogicalChannelRateRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_LogicalChannelRateRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "sequenceNumber = " << setprecision(indent) << m_sequenceNumber << '\n';
  strm << setw(indent+23) << "logicalChannelNumber = " << setprecision(indent) << m_logicalChannelNumber << '\n';
  strm << setw(indent+17) << "maximumBitRate = " << setprecision(indent) << m_maximumBitRate << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_LogicalChannelRateRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_LogicalChannelRateRequest), PInvalidCast);
#endif
  const H245_LogicalChannelRateRequest & other = (const H245_LogicalChannelRateRequest &)obj;

  Comparison result;

  if ((result = m_sequenceNumber.Compare(other.m_sequenceNumber)) != EqualTo)
    return result;
  if ((result = m_logicalChannelNumber.Compare(other.m_logicalChannelNumber)) != EqualTo)
    return result;
  if ((result = m_maximumBitRate.Compare(other.m_maximumBitRate)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_LogicalChannelRateRequest::GetDataLength() const
{
  PINDEX length = 0;
  length += m_sequenceNumber.GetObjectLength();
  length += m_logicalChannelNumber.GetObjectLength();
  length += m_maximumBitRate.GetObjectLength();
  return length;
}


BOOL H245_LogicalChannelRateRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_sequenceNumber.Decode(strm))
    return FALSE;
  if (!m_logicalChannelNumber.Decode(strm))
    return FALSE;
  if (!m_maximumBitRate.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_LogicalChannelRateRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_sequenceNumber.Encode(strm);
  m_logicalChannelNumber.Encode(strm);
  m_maximumBitRate.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_LogicalChannelRateRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_LogicalChannelRateRequest::Class()), PInvalidCast);
#endif
  return new H245_LogicalChannelRateRequest(*this);
}


//
// LogicalChannelRateAcknowledge
//

H245_LogicalChannelRateAcknowledge::H245_LogicalChannelRateAcknowledge(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_LogicalChannelRateAcknowledge::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "sequenceNumber = " << setprecision(indent) << m_sequenceNumber << '\n';
  strm << setw(indent+23) << "logicalChannelNumber = " << setprecision(indent) << m_logicalChannelNumber << '\n';
  strm << setw(indent+17) << "maximumBitRate = " << setprecision(indent) << m_maximumBitRate << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_LogicalChannelRateAcknowledge::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_LogicalChannelRateAcknowledge), PInvalidCast);
#endif
  const H245_LogicalChannelRateAcknowledge & other = (const H245_LogicalChannelRateAcknowledge &)obj;

  Comparison result;

  if ((result = m_sequenceNumber.Compare(other.m_sequenceNumber)) != EqualTo)
    return result;
  if ((result = m_logicalChannelNumber.Compare(other.m_logicalChannelNumber)) != EqualTo)
    return result;
  if ((result = m_maximumBitRate.Compare(other.m_maximumBitRate)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_LogicalChannelRateAcknowledge::GetDataLength() const
{
  PINDEX length = 0;
  length += m_sequenceNumber.GetObjectLength();
  length += m_logicalChannelNumber.GetObjectLength();
  length += m_maximumBitRate.GetObjectLength();
  return length;
}


BOOL H245_LogicalChannelRateAcknowledge::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_sequenceNumber.Decode(strm))
    return FALSE;
  if (!m_logicalChannelNumber.Decode(strm))
    return FALSE;
  if (!m_maximumBitRate.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_LogicalChannelRateAcknowledge::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_sequenceNumber.Encode(strm);
  m_logicalChannelNumber.Encode(strm);
  m_maximumBitRate.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_LogicalChannelRateAcknowledge::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_LogicalChannelRateAcknowledge::Class()), PInvalidCast);
#endif
  return new H245_LogicalChannelRateAcknowledge(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_LogicalChannelRateRejectReason[]={
      {"undefinedReason",0}
     ,{"insufficientResources",1}
};
#endif
//
// LogicalChannelRateRejectReason
//

H245_LogicalChannelRateRejectReason::H245_LogicalChannelRateRejectReason(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_LogicalChannelRateRejectReason,2
#endif
)
{
}


BOOL H245_LogicalChannelRateRejectReason::CreateObject()
{
  choice = (tag <= e_insufficientResources) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_LogicalChannelRateRejectReason::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_LogicalChannelRateRejectReason::Class()), PInvalidCast);
#endif
  return new H245_LogicalChannelRateRejectReason(*this);
}


//
// LogicalChannelRateRelease
//

H245_LogicalChannelRateRelease::H245_LogicalChannelRateRelease(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_LogicalChannelRateRelease::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PINDEX H245_LogicalChannelRateRelease::GetDataLength() const
{
  PINDEX length = 0;
  return length;
}


BOOL H245_LogicalChannelRateRelease::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;


  return UnknownExtensionsDecode(strm);
}


void H245_LogicalChannelRateRelease::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);


  UnknownExtensionsEncode(strm);
}


PObject * H245_LogicalChannelRateRelease::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_LogicalChannelRateRelease::Class()), PInvalidCast);
#endif
  return new H245_LogicalChannelRateRelease(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_SendTerminalCapabilitySet[]={
      {"specificRequest",0}
     ,{"genericRequest",1}
};
#endif
//
// SendTerminalCapabilitySet
//

H245_SendTerminalCapabilitySet::H245_SendTerminalCapabilitySet(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_SendTerminalCapabilitySet,2
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_SendTerminalCapabilitySet::operator H245_SendTerminalCapabilitySet_specificRequest &() const
#else
H245_SendTerminalCapabilitySet::operator H245_SendTerminalCapabilitySet_specificRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_SendTerminalCapabilitySet_specificRequest), PInvalidCast);
#endif
  return *(H245_SendTerminalCapabilitySet_specificRequest *)choice;
}


H245_SendTerminalCapabilitySet::operator const H245_SendTerminalCapabilitySet_specificRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_SendTerminalCapabilitySet_specificRequest), PInvalidCast);
#endif
  return *(H245_SendTerminalCapabilitySet_specificRequest *)choice;
}


BOOL H245_SendTerminalCapabilitySet::CreateObject()
{
  switch (tag) {
    case e_specificRequest :
      choice = new H245_SendTerminalCapabilitySet_specificRequest();
      return TRUE;
    case e_genericRequest :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_SendTerminalCapabilitySet::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_SendTerminalCapabilitySet::Class()), PInvalidCast);
#endif
  return new H245_SendTerminalCapabilitySet(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_EncryptionCommand[]={
      {"encryptionSE",0}
     ,{"encryptionIVRequest",1}
     ,{"encryptionAlgorithmID",2}
};
#endif
//
// EncryptionCommand
//

H245_EncryptionCommand::H245_EncryptionCommand(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_EncryptionCommand,3
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_EncryptionCommand::operator H245_EncryptionCommand_encryptionAlgorithmID &() const
#else
H245_EncryptionCommand::operator H245_EncryptionCommand_encryptionAlgorithmID &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_EncryptionCommand_encryptionAlgorithmID), PInvalidCast);
#endif
  return *(H245_EncryptionCommand_encryptionAlgorithmID *)choice;
}


H245_EncryptionCommand::operator const H245_EncryptionCommand_encryptionAlgorithmID &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_EncryptionCommand_encryptionAlgorithmID), PInvalidCast);
#endif
  return *(H245_EncryptionCommand_encryptionAlgorithmID *)choice;
}


BOOL H245_EncryptionCommand::CreateObject()
{
  switch (tag) {
    case e_encryptionSE :
      choice = new PASN_OctetString();
      return TRUE;
    case e_encryptionIVRequest :
      choice = new PASN_Null();
      return TRUE;
    case e_encryptionAlgorithmID :
      choice = new H245_EncryptionCommand_encryptionAlgorithmID();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_EncryptionCommand::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_EncryptionCommand::Class()), PInvalidCast);
#endif
  return new H245_EncryptionCommand(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_EndSessionCommand[]={
      {"nonStandard",0}
     ,{"disconnect",1}
     ,{"gstnOptions",2}
     ,{"isdnOptions",3}
};
#endif
//
// EndSessionCommand
//

H245_EndSessionCommand::H245_EndSessionCommand(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_EndSessionCommand,4
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_EndSessionCommand::operator H245_NonStandardParameter &() const
#else
H245_EndSessionCommand::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_EndSessionCommand::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_EndSessionCommand::operator H245_EndSessionCommand_gstnOptions &() const
#else
H245_EndSessionCommand::operator H245_EndSessionCommand_gstnOptions &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_EndSessionCommand_gstnOptions), PInvalidCast);
#endif
  return *(H245_EndSessionCommand_gstnOptions *)choice;
}


H245_EndSessionCommand::operator const H245_EndSessionCommand_gstnOptions &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_EndSessionCommand_gstnOptions), PInvalidCast);
#endif
  return *(H245_EndSessionCommand_gstnOptions *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_EndSessionCommand::operator H245_EndSessionCommand_isdnOptions &() const
#else
H245_EndSessionCommand::operator H245_EndSessionCommand_isdnOptions &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_EndSessionCommand_isdnOptions), PInvalidCast);
#endif
  return *(H245_EndSessionCommand_isdnOptions *)choice;
}


H245_EndSessionCommand::operator const H245_EndSessionCommand_isdnOptions &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_EndSessionCommand_isdnOptions), PInvalidCast);
#endif
  return *(H245_EndSessionCommand_isdnOptions *)choice;
}


BOOL H245_EndSessionCommand::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_disconnect :
      choice = new PASN_Null();
      return TRUE;
    case e_gstnOptions :
      choice = new H245_EndSessionCommand_gstnOptions();
      return TRUE;
    case e_isdnOptions :
      choice = new H245_EndSessionCommand_isdnOptions();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_EndSessionCommand::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_EndSessionCommand::Class()), PInvalidCast);
#endif
  return new H245_EndSessionCommand(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_ConferenceCommand[]={
      {"broadcastMyLogicalChannel",0}
     ,{"cancelBroadcastMyLogicalChannel",1}
     ,{"makeTerminalBroadcaster",2}
     ,{"cancelMakeTerminalBroadcaster",3}
     ,{"sendThisSource",4}
     ,{"cancelSendThisSource",5}
     ,{"dropConference",6}
     ,{"substituteConferenceIDCommand",7}
};
#endif
//
// ConferenceCommand
//

H245_ConferenceCommand::H245_ConferenceCommand(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 7, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_ConferenceCommand,8
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ConferenceCommand::operator H245_LogicalChannelNumber &() const
#else
H245_ConferenceCommand::operator H245_LogicalChannelNumber &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_LogicalChannelNumber), PInvalidCast);
#endif
  return *(H245_LogicalChannelNumber *)choice;
}


H245_ConferenceCommand::operator const H245_LogicalChannelNumber &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_LogicalChannelNumber), PInvalidCast);
#endif
  return *(H245_LogicalChannelNumber *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ConferenceCommand::operator H245_TerminalLabel &() const
#else
H245_ConferenceCommand::operator H245_TerminalLabel &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_TerminalLabel), PInvalidCast);
#endif
  return *(H245_TerminalLabel *)choice;
}


H245_ConferenceCommand::operator const H245_TerminalLabel &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_TerminalLabel), PInvalidCast);
#endif
  return *(H245_TerminalLabel *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ConferenceCommand::operator H245_SubstituteConferenceIDCommand &() const
#else
H245_ConferenceCommand::operator H245_SubstituteConferenceIDCommand &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_SubstituteConferenceIDCommand), PInvalidCast);
#endif
  return *(H245_SubstituteConferenceIDCommand *)choice;
}


H245_ConferenceCommand::operator const H245_SubstituteConferenceIDCommand &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_SubstituteConferenceIDCommand), PInvalidCast);
#endif
  return *(H245_SubstituteConferenceIDCommand *)choice;
}


BOOL H245_ConferenceCommand::CreateObject()
{
  switch (tag) {
    case e_broadcastMyLogicalChannel :
    case e_cancelBroadcastMyLogicalChannel :
      choice = new H245_LogicalChannelNumber();
      return TRUE;
    case e_makeTerminalBroadcaster :
    case e_sendThisSource :
      choice = new H245_TerminalLabel();
      return TRUE;
    case e_cancelMakeTerminalBroadcaster :
    case e_cancelSendThisSource :
    case e_dropConference :
      choice = new PASN_Null();
      return TRUE;
    case e_substituteConferenceIDCommand :
      choice = new H245_SubstituteConferenceIDCommand();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_ConferenceCommand::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ConferenceCommand::Class()), PInvalidCast);
#endif
  return new H245_ConferenceCommand(*this);
}


//
// SubstituteConferenceIDCommand
//

H245_SubstituteConferenceIDCommand::H245_SubstituteConferenceIDCommand(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_conferenceIdentifier.SetConstraints(PASN_Object::FixedConstraint, 16);
}


#ifndef PASN_NOPRINTON
void H245_SubstituteConferenceIDCommand::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+23) << "conferenceIdentifier = " << setprecision(indent) << m_conferenceIdentifier << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_SubstituteConferenceIDCommand::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_SubstituteConferenceIDCommand), PInvalidCast);
#endif
  const H245_SubstituteConferenceIDCommand & other = (const H245_SubstituteConferenceIDCommand &)obj;

  Comparison result;

  if ((result = m_conferenceIdentifier.Compare(other.m_conferenceIdentifier)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_SubstituteConferenceIDCommand::GetDataLength() const
{
  PINDEX length = 0;
  length += m_conferenceIdentifier.GetObjectLength();
  return length;
}


BOOL H245_SubstituteConferenceIDCommand::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_conferenceIdentifier.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_SubstituteConferenceIDCommand::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_conferenceIdentifier.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_SubstituteConferenceIDCommand::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_SubstituteConferenceIDCommand::Class()), PInvalidCast);
#endif
  return new H245_SubstituteConferenceIDCommand(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_EncryptionUpdateDirection[]={
      {"masterToSlave",0}
     ,{"slaveToMaster",1}
};
#endif
//
// EncryptionUpdateDirection
//

H245_EncryptionUpdateDirection::H245_EncryptionUpdateDirection(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_EncryptionUpdateDirection,2
#endif
)
{
}


BOOL H245_EncryptionUpdateDirection::CreateObject()
{
  choice = (tag <= e_slaveToMaster) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_EncryptionUpdateDirection::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_EncryptionUpdateDirection::Class()), PInvalidCast);
#endif
  return new H245_EncryptionUpdateDirection(*this);
}


//
// KeyProtectionMethod
//

H245_KeyProtectionMethod::H245_KeyProtectionMethod(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_KeyProtectionMethod::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "secureChannel = " << setprecision(indent) << m_secureChannel << '\n';
  strm << setw(indent+15) << "sharedSecret = " << setprecision(indent) << m_sharedSecret << '\n';
  strm << setw(indent+19) << "certProtectedKey = " << setprecision(indent) << m_certProtectedKey << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_KeyProtectionMethod::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_KeyProtectionMethod), PInvalidCast);
#endif
  const H245_KeyProtectionMethod & other = (const H245_KeyProtectionMethod &)obj;

  Comparison result;

  if ((result = m_secureChannel.Compare(other.m_secureChannel)) != EqualTo)
    return result;
  if ((result = m_sharedSecret.Compare(other.m_sharedSecret)) != EqualTo)
    return result;
  if ((result = m_certProtectedKey.Compare(other.m_certProtectedKey)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_KeyProtectionMethod::GetDataLength() const
{
  PINDEX length = 0;
  length += m_secureChannel.GetObjectLength();
  length += m_sharedSecret.GetObjectLength();
  length += m_certProtectedKey.GetObjectLength();
  return length;
}


BOOL H245_KeyProtectionMethod::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_secureChannel.Decode(strm))
    return FALSE;
  if (!m_sharedSecret.Decode(strm))
    return FALSE;
  if (!m_certProtectedKey.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_KeyProtectionMethod::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_secureChannel.Encode(strm);
  m_sharedSecret.Encode(strm);
  m_certProtectedKey.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_KeyProtectionMethod::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_KeyProtectionMethod::Class()), PInvalidCast);
#endif
  return new H245_KeyProtectionMethod(*this);
}


//
// EncryptionUpdateRequest
//

H245_EncryptionUpdateRequest::H245_EncryptionUpdateRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 1)
{
  m_synchFlag.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H245_EncryptionUpdateRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_keyProtectionMethod))
    strm << setw(indent+22) << "keyProtectionMethod = " << setprecision(indent) << m_keyProtectionMethod << '\n';
  if (HasOptionalField(e_synchFlag))
    strm << setw(indent+12) << "synchFlag = " << setprecision(indent) << m_synchFlag << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_EncryptionUpdateRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_EncryptionUpdateRequest), PInvalidCast);
#endif
  const H245_EncryptionUpdateRequest & other = (const H245_EncryptionUpdateRequest &)obj;

  Comparison result;

  if ((result = m_keyProtectionMethod.Compare(other.m_keyProtectionMethod)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_EncryptionUpdateRequest::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_keyProtectionMethod))
    length += m_keyProtectionMethod.GetObjectLength();
  return length;
}


BOOL H245_EncryptionUpdateRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_keyProtectionMethod) && !m_keyProtectionMethod.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_synchFlag, m_synchFlag))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_EncryptionUpdateRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_keyProtectionMethod))
    m_keyProtectionMethod.Encode(strm);
  KnownExtensionEncode(strm, e_synchFlag, m_synchFlag);

  UnknownExtensionsEncode(strm);
}


PObject * H245_EncryptionUpdateRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_EncryptionUpdateRequest::Class()), PInvalidCast);
#endif
  return new H245_EncryptionUpdateRequest(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_PictureReference[]={
      {"pictureNumber",0}
     ,{"longTermPictureIndex",1}
};
#endif
//
// PictureReference
//

H245_PictureReference::H245_PictureReference(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_PictureReference,2
#endif
)
{
}


BOOL H245_PictureReference::CreateObject()
{
  switch (tag) {
    case e_pictureNumber :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 0, 1023);
      return TRUE;
    case e_longTermPictureIndex :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 0, 255);
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_PictureReference::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_PictureReference::Class()), PInvalidCast);
#endif
  return new H245_PictureReference(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_H223MultiplexReconfiguration[]={
      {"h223ModeChange",0}
     ,{"h223AnnexADoubleFlag",1}
};
#endif
//
// H223MultiplexReconfiguration
//

H245_H223MultiplexReconfiguration::H245_H223MultiplexReconfiguration(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_H223MultiplexReconfiguration,2
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H223MultiplexReconfiguration::operator H245_H223MultiplexReconfiguration_h223ModeChange &() const
#else
H245_H223MultiplexReconfiguration::operator H245_H223MultiplexReconfiguration_h223ModeChange &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H223MultiplexReconfiguration_h223ModeChange), PInvalidCast);
#endif
  return *(H245_H223MultiplexReconfiguration_h223ModeChange *)choice;
}


H245_H223MultiplexReconfiguration::operator const H245_H223MultiplexReconfiguration_h223ModeChange &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H223MultiplexReconfiguration_h223ModeChange), PInvalidCast);
#endif
  return *(H245_H223MultiplexReconfiguration_h223ModeChange *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H223MultiplexReconfiguration::operator H245_H223MultiplexReconfiguration_h223AnnexADoubleFlag &() const
#else
H245_H223MultiplexReconfiguration::operator H245_H223MultiplexReconfiguration_h223AnnexADoubleFlag &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H223MultiplexReconfiguration_h223AnnexADoubleFlag), PInvalidCast);
#endif
  return *(H245_H223MultiplexReconfiguration_h223AnnexADoubleFlag *)choice;
}


H245_H223MultiplexReconfiguration::operator const H245_H223MultiplexReconfiguration_h223AnnexADoubleFlag &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H223MultiplexReconfiguration_h223AnnexADoubleFlag), PInvalidCast);
#endif
  return *(H245_H223MultiplexReconfiguration_h223AnnexADoubleFlag *)choice;
}


BOOL H245_H223MultiplexReconfiguration::CreateObject()
{
  switch (tag) {
    case e_h223ModeChange :
      choice = new H245_H223MultiplexReconfiguration_h223ModeChange();
      return TRUE;
    case e_h223AnnexADoubleFlag :
      choice = new H245_H223MultiplexReconfiguration_h223AnnexADoubleFlag();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_H223MultiplexReconfiguration::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223MultiplexReconfiguration::Class()), PInvalidCast);
#endif
  return new H245_H223MultiplexReconfiguration(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_FunctionNotUnderstood[]={
      {"request",0}
     ,{"response",1}
     ,{"command",2}
};
#endif
//
// FunctionNotUnderstood
//

H245_FunctionNotUnderstood::H245_FunctionNotUnderstood(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_FunctionNotUnderstood,3
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_FunctionNotUnderstood::operator H245_RequestMessage &() const
#else
H245_FunctionNotUnderstood::operator H245_RequestMessage &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RequestMessage), PInvalidCast);
#endif
  return *(H245_RequestMessage *)choice;
}


H245_FunctionNotUnderstood::operator const H245_RequestMessage &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RequestMessage), PInvalidCast);
#endif
  return *(H245_RequestMessage *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_FunctionNotUnderstood::operator H245_ResponseMessage &() const
#else
H245_FunctionNotUnderstood::operator H245_ResponseMessage &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ResponseMessage), PInvalidCast);
#endif
  return *(H245_ResponseMessage *)choice;
}


H245_FunctionNotUnderstood::operator const H245_ResponseMessage &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ResponseMessage), PInvalidCast);
#endif
  return *(H245_ResponseMessage *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_FunctionNotUnderstood::operator H245_CommandMessage &() const
#else
H245_FunctionNotUnderstood::operator H245_CommandMessage &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_CommandMessage), PInvalidCast);
#endif
  return *(H245_CommandMessage *)choice;
}


H245_FunctionNotUnderstood::operator const H245_CommandMessage &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_CommandMessage), PInvalidCast);
#endif
  return *(H245_CommandMessage *)choice;
}


BOOL H245_FunctionNotUnderstood::CreateObject()
{
  switch (tag) {
    case e_request :
      choice = new H245_RequestMessage();
      return TRUE;
    case e_response :
      choice = new H245_ResponseMessage();
      return TRUE;
    case e_command :
      choice = new H245_CommandMessage();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_FunctionNotUnderstood::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_FunctionNotUnderstood::Class()), PInvalidCast);
#endif
  return new H245_FunctionNotUnderstood(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_ConferenceIndication[]={
      {"sbeNumber",0}
     ,{"terminalNumberAssign",1}
     ,{"terminalJoinedConference",2}
     ,{"terminalLeftConference",3}
     ,{"seenByAtLeastOneOther",4}
     ,{"cancelSeenByAtLeastOneOther",5}
     ,{"seenByAll",6}
     ,{"cancelSeenByAll",7}
     ,{"terminalYouAreSeeing",8}
     ,{"requestForFloor",9}
     ,{"withdrawChairToken",10}
     ,{"floorRequested",11}
     ,{"terminalYouAreSeeingInSubPictureNumber",12}
     ,{"videoIndicateCompose",13}
};
#endif
//
// ConferenceIndication
//

H245_ConferenceIndication::H245_ConferenceIndication(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 10, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_ConferenceIndication,14
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ConferenceIndication::operator H245_TerminalLabel &() const
#else
H245_ConferenceIndication::operator H245_TerminalLabel &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_TerminalLabel), PInvalidCast);
#endif
  return *(H245_TerminalLabel *)choice;
}


H245_ConferenceIndication::operator const H245_TerminalLabel &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_TerminalLabel), PInvalidCast);
#endif
  return *(H245_TerminalLabel *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ConferenceIndication::operator H245_TerminalYouAreSeeingInSubPictureNumber &() const
#else
H245_ConferenceIndication::operator H245_TerminalYouAreSeeingInSubPictureNumber &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_TerminalYouAreSeeingInSubPictureNumber), PInvalidCast);
#endif
  return *(H245_TerminalYouAreSeeingInSubPictureNumber *)choice;
}


H245_ConferenceIndication::operator const H245_TerminalYouAreSeeingInSubPictureNumber &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_TerminalYouAreSeeingInSubPictureNumber), PInvalidCast);
#endif
  return *(H245_TerminalYouAreSeeingInSubPictureNumber *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_ConferenceIndication::operator H245_VideoIndicateCompose &() const
#else
H245_ConferenceIndication::operator H245_VideoIndicateCompose &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_VideoIndicateCompose), PInvalidCast);
#endif
  return *(H245_VideoIndicateCompose *)choice;
}


H245_ConferenceIndication::operator const H245_VideoIndicateCompose &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_VideoIndicateCompose), PInvalidCast);
#endif
  return *(H245_VideoIndicateCompose *)choice;
}


BOOL H245_ConferenceIndication::CreateObject()
{
  switch (tag) {
    case e_sbeNumber :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 0, 9);
      return TRUE;
    case e_terminalNumberAssign :
    case e_terminalJoinedConference :
    case e_terminalLeftConference :
    case e_terminalYouAreSeeing :
    case e_floorRequested :
      choice = new H245_TerminalLabel();
      return TRUE;
    case e_seenByAtLeastOneOther :
    case e_cancelSeenByAtLeastOneOther :
    case e_seenByAll :
    case e_cancelSeenByAll :
    case e_requestForFloor :
    case e_withdrawChairToken :
      choice = new PASN_Null();
      return TRUE;
    case e_terminalYouAreSeeingInSubPictureNumber :
      choice = new H245_TerminalYouAreSeeingInSubPictureNumber();
      return TRUE;
    case e_videoIndicateCompose :
      choice = new H245_VideoIndicateCompose();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_ConferenceIndication::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ConferenceIndication::Class()), PInvalidCast);
#endif
  return new H245_ConferenceIndication(*this);
}


//
// TerminalYouAreSeeingInSubPictureNumber
//

H245_TerminalYouAreSeeingInSubPictureNumber::H245_TerminalYouAreSeeingInSubPictureNumber(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_subPictureNumber.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H245_TerminalYouAreSeeingInSubPictureNumber::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "terminalNumber = " << setprecision(indent) << m_terminalNumber << '\n';
  strm << setw(indent+19) << "subPictureNumber = " << setprecision(indent) << m_subPictureNumber << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_TerminalYouAreSeeingInSubPictureNumber::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_TerminalYouAreSeeingInSubPictureNumber), PInvalidCast);
#endif
  const H245_TerminalYouAreSeeingInSubPictureNumber & other = (const H245_TerminalYouAreSeeingInSubPictureNumber &)obj;

  Comparison result;

  if ((result = m_terminalNumber.Compare(other.m_terminalNumber)) != EqualTo)
    return result;
  if ((result = m_subPictureNumber.Compare(other.m_subPictureNumber)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_TerminalYouAreSeeingInSubPictureNumber::GetDataLength() const
{
  PINDEX length = 0;
  length += m_terminalNumber.GetObjectLength();
  length += m_subPictureNumber.GetObjectLength();
  return length;
}


BOOL H245_TerminalYouAreSeeingInSubPictureNumber::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_terminalNumber.Decode(strm))
    return FALSE;
  if (!m_subPictureNumber.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_TerminalYouAreSeeingInSubPictureNumber::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_terminalNumber.Encode(strm);
  m_subPictureNumber.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_TerminalYouAreSeeingInSubPictureNumber::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_TerminalYouAreSeeingInSubPictureNumber::Class()), PInvalidCast);
#endif
  return new H245_TerminalYouAreSeeingInSubPictureNumber(*this);
}


//
// VideoIndicateCompose
//

H245_VideoIndicateCompose::H245_VideoIndicateCompose(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_compositionNumber.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H245_VideoIndicateCompose::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+20) << "compositionNumber = " << setprecision(indent) << m_compositionNumber << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_VideoIndicateCompose::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_VideoIndicateCompose), PInvalidCast);
#endif
  const H245_VideoIndicateCompose & other = (const H245_VideoIndicateCompose &)obj;

  Comparison result;

  if ((result = m_compositionNumber.Compare(other.m_compositionNumber)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_VideoIndicateCompose::GetDataLength() const
{
  PINDEX length = 0;
  length += m_compositionNumber.GetObjectLength();
  return length;
}


BOOL H245_VideoIndicateCompose::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_compositionNumber.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_VideoIndicateCompose::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_compositionNumber.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_VideoIndicateCompose::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_VideoIndicateCompose::Class()), PInvalidCast);
#endif
  return new H245_VideoIndicateCompose(*this);
}


//
// H223SkewIndication
//

H245_H223SkewIndication::H245_H223SkewIndication(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_skew.SetConstraints(PASN_Object::FixedConstraint, 0, 4095);
}


#ifndef PASN_NOPRINTON
void H245_H223SkewIndication::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+24) << "logicalChannelNumber1 = " << setprecision(indent) << m_logicalChannelNumber1 << '\n';
  strm << setw(indent+24) << "logicalChannelNumber2 = " << setprecision(indent) << m_logicalChannelNumber2 << '\n';
  strm << setw(indent+7) << "skew = " << setprecision(indent) << m_skew << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_H223SkewIndication::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_H223SkewIndication), PInvalidCast);
#endif
  const H245_H223SkewIndication & other = (const H245_H223SkewIndication &)obj;

  Comparison result;

  if ((result = m_logicalChannelNumber1.Compare(other.m_logicalChannelNumber1)) != EqualTo)
    return result;
  if ((result = m_logicalChannelNumber2.Compare(other.m_logicalChannelNumber2)) != EqualTo)
    return result;
  if ((result = m_skew.Compare(other.m_skew)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H223SkewIndication::GetDataLength() const
{
  PINDEX length = 0;
  length += m_logicalChannelNumber1.GetObjectLength();
  length += m_logicalChannelNumber2.GetObjectLength();
  length += m_skew.GetObjectLength();
  return length;
}


BOOL H245_H223SkewIndication::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_logicalChannelNumber1.Decode(strm))
    return FALSE;
  if (!m_logicalChannelNumber2.Decode(strm))
    return FALSE;
  if (!m_skew.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_H223SkewIndication::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_logicalChannelNumber1.Encode(strm);
  m_logicalChannelNumber2.Encode(strm);
  m_skew.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_H223SkewIndication::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223SkewIndication::Class()), PInvalidCast);
#endif
  return new H245_H223SkewIndication(*this);
}


//
// H2250MaximumSkewIndication
//

H245_H2250MaximumSkewIndication::H245_H2250MaximumSkewIndication(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_maximumSkew.SetConstraints(PASN_Object::FixedConstraint, 0, 4095);
}


#ifndef PASN_NOPRINTON
void H245_H2250MaximumSkewIndication::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+24) << "logicalChannelNumber1 = " << setprecision(indent) << m_logicalChannelNumber1 << '\n';
  strm << setw(indent+24) << "logicalChannelNumber2 = " << setprecision(indent) << m_logicalChannelNumber2 << '\n';
  strm << setw(indent+14) << "maximumSkew = " << setprecision(indent) << m_maximumSkew << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_H2250MaximumSkewIndication::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_H2250MaximumSkewIndication), PInvalidCast);
#endif
  const H245_H2250MaximumSkewIndication & other = (const H245_H2250MaximumSkewIndication &)obj;

  Comparison result;

  if ((result = m_logicalChannelNumber1.Compare(other.m_logicalChannelNumber1)) != EqualTo)
    return result;
  if ((result = m_logicalChannelNumber2.Compare(other.m_logicalChannelNumber2)) != EqualTo)
    return result;
  if ((result = m_maximumSkew.Compare(other.m_maximumSkew)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H2250MaximumSkewIndication::GetDataLength() const
{
  PINDEX length = 0;
  length += m_logicalChannelNumber1.GetObjectLength();
  length += m_logicalChannelNumber2.GetObjectLength();
  length += m_maximumSkew.GetObjectLength();
  return length;
}


BOOL H245_H2250MaximumSkewIndication::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_logicalChannelNumber1.Decode(strm))
    return FALSE;
  if (!m_logicalChannelNumber2.Decode(strm))
    return FALSE;
  if (!m_maximumSkew.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_H2250MaximumSkewIndication::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_logicalChannelNumber1.Encode(strm);
  m_logicalChannelNumber2.Encode(strm);
  m_maximumSkew.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_H2250MaximumSkewIndication::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H2250MaximumSkewIndication::Class()), PInvalidCast);
#endif
  return new H245_H2250MaximumSkewIndication(*this);
}


//
// MCLocationIndication
//

H245_MCLocationIndication::H245_MCLocationIndication(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MCLocationIndication::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "signalAddress = " << setprecision(indent) << m_signalAddress << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MCLocationIndication::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MCLocationIndication), PInvalidCast);
#endif
  const H245_MCLocationIndication & other = (const H245_MCLocationIndication &)obj;

  Comparison result;

  if ((result = m_signalAddress.Compare(other.m_signalAddress)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MCLocationIndication::GetDataLength() const
{
  PINDEX length = 0;
  length += m_signalAddress.GetObjectLength();
  return length;
}


BOOL H245_MCLocationIndication::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_signalAddress.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MCLocationIndication::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_signalAddress.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MCLocationIndication::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MCLocationIndication::Class()), PInvalidCast);
#endif
  return new H245_MCLocationIndication(*this);
}


//
// VendorIdentification
//

H245_VendorIdentification::H245_VendorIdentification(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
  m_productNumber.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
  m_versionNumber.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H245_VendorIdentification::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+9) << "vendor = " << setprecision(indent) << m_vendor << '\n';
  if (HasOptionalField(e_productNumber))
    strm << setw(indent+16) << "productNumber = " << setprecision(indent) << m_productNumber << '\n';
  if (HasOptionalField(e_versionNumber))
    strm << setw(indent+16) << "versionNumber = " << setprecision(indent) << m_versionNumber << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_VendorIdentification::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_VendorIdentification), PInvalidCast);
#endif
  const H245_VendorIdentification & other = (const H245_VendorIdentification &)obj;

  Comparison result;

  if ((result = m_vendor.Compare(other.m_vendor)) != EqualTo)
    return result;
  if ((result = m_productNumber.Compare(other.m_productNumber)) != EqualTo)
    return result;
  if ((result = m_versionNumber.Compare(other.m_versionNumber)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_VendorIdentification::GetDataLength() const
{
  PINDEX length = 0;
  length += m_vendor.GetObjectLength();
  if (HasOptionalField(e_productNumber))
    length += m_productNumber.GetObjectLength();
  if (HasOptionalField(e_versionNumber))
    length += m_versionNumber.GetObjectLength();
  return length;
}


BOOL H245_VendorIdentification::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_vendor.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_productNumber) && !m_productNumber.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_versionNumber) && !m_versionNumber.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_VendorIdentification::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_vendor.Encode(strm);
  if (HasOptionalField(e_productNumber))
    m_productNumber.Encode(strm);
  if (HasOptionalField(e_versionNumber))
    m_versionNumber.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_VendorIdentification::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_VendorIdentification::Class()), PInvalidCast);
#endif
  return new H245_VendorIdentification(*this);
}


//
// IV8
//

H245_IV8::H245_IV8(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_OctetString(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 8);
}


H245_IV8::H245_IV8(const char * v)
{
  SetValue(v);
}


H245_IV8::H245_IV8(const PString & v)
{
  SetValue(v);
}


H245_IV8::H245_IV8(const PBYTEArray & v)
{
  SetValue(v);
}


H245_IV8 & H245_IV8::operator=(const char * v)
{
  SetValue(v);
  return *this;
}


H245_IV8 & H245_IV8::operator=(const PString & v)
{
  SetValue(v);
  return *this;
}


H245_IV8 & H245_IV8::operator=(const PBYTEArray & v)
{
  SetValue(v);
  return *this;
}


PObject * H245_IV8::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_IV8::Class()), PInvalidCast);
#endif
  return new H245_IV8(*this);
}


//
// IV16
//

H245_IV16::H245_IV16(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_OctetString(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 16);
}


H245_IV16::H245_IV16(const char * v)
{
  SetValue(v);
}


H245_IV16::H245_IV16(const PString & v)
{
  SetValue(v);
}


H245_IV16::H245_IV16(const PBYTEArray & v)
{
  SetValue(v);
}


H245_IV16 & H245_IV16::operator=(const char * v)
{
  SetValue(v);
  return *this;
}


H245_IV16 & H245_IV16::operator=(const PString & v)
{
  SetValue(v);
  return *this;
}


H245_IV16 & H245_IV16::operator=(const PBYTEArray & v)
{
  SetValue(v);
  return *this;
}


PObject * H245_IV16::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_IV16::Class()), PInvalidCast);
#endif
  return new H245_IV16(*this);
}


//
// Params
//

H245_Params::H245_Params(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_Params::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_iv8))
    strm << setw(indent+6) << "iv8 = " << setprecision(indent) << m_iv8 << '\n';
  if (HasOptionalField(e_iv16))
    strm << setw(indent+7) << "iv16 = " << setprecision(indent) << m_iv16 << '\n';
  if (HasOptionalField(e_iv))
    strm << setw(indent+5) << "iv = " << setprecision(indent) << m_iv << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_Params::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_Params), PInvalidCast);
#endif
  const H245_Params & other = (const H245_Params &)obj;

  Comparison result;

  if ((result = m_iv8.Compare(other.m_iv8)) != EqualTo)
    return result;
  if ((result = m_iv16.Compare(other.m_iv16)) != EqualTo)
    return result;
  if ((result = m_iv.Compare(other.m_iv)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_Params::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_iv8))
    length += m_iv8.GetObjectLength();
  if (HasOptionalField(e_iv16))
    length += m_iv16.GetObjectLength();
  if (HasOptionalField(e_iv))
    length += m_iv.GetObjectLength();
  return length;
}


BOOL H245_Params::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_iv8) && !m_iv8.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_iv16) && !m_iv16.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_iv) && !m_iv.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_Params::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_iv8))
    m_iv8.Encode(strm);
  if (HasOptionalField(e_iv16))
    m_iv16.Encode(strm);
  if (HasOptionalField(e_iv))
    m_iv.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_Params::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_Params::Class()), PInvalidCast);
#endif
  return new H245_Params(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_UserInputIndication[]={
      {"nonStandard",0}
     ,{"alphanumeric",1}
     ,{"userInputSupportIndication",2}
     ,{"signal",3}
     ,{"signalUpdate",4}
     ,{"extendedAlphanumeric",5}
     ,{"encryptedAlphanumeric",6}
};
#endif
//
// UserInputIndication
//

H245_UserInputIndication::H245_UserInputIndication(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_UserInputIndication,7
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_UserInputIndication::operator H245_NonStandardParameter &() const
#else
H245_UserInputIndication::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_UserInputIndication::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_UserInputIndication::operator H245_UserInputIndication_userInputSupportIndication &() const
#else
H245_UserInputIndication::operator H245_UserInputIndication_userInputSupportIndication &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_UserInputIndication_userInputSupportIndication), PInvalidCast);
#endif
  return *(H245_UserInputIndication_userInputSupportIndication *)choice;
}


H245_UserInputIndication::operator const H245_UserInputIndication_userInputSupportIndication &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_UserInputIndication_userInputSupportIndication), PInvalidCast);
#endif
  return *(H245_UserInputIndication_userInputSupportIndication *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_UserInputIndication::operator H245_UserInputIndication_signal &() const
#else
H245_UserInputIndication::operator H245_UserInputIndication_signal &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_UserInputIndication_signal), PInvalidCast);
#endif
  return *(H245_UserInputIndication_signal *)choice;
}


H245_UserInputIndication::operator const H245_UserInputIndication_signal &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_UserInputIndication_signal), PInvalidCast);
#endif
  return *(H245_UserInputIndication_signal *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_UserInputIndication::operator H245_UserInputIndication_signalUpdate &() const
#else
H245_UserInputIndication::operator H245_UserInputIndication_signalUpdate &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_UserInputIndication_signalUpdate), PInvalidCast);
#endif
  return *(H245_UserInputIndication_signalUpdate *)choice;
}


H245_UserInputIndication::operator const H245_UserInputIndication_signalUpdate &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_UserInputIndication_signalUpdate), PInvalidCast);
#endif
  return *(H245_UserInputIndication_signalUpdate *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_UserInputIndication::operator H245_UserInputIndication_extendedAlphanumeric &() const
#else
H245_UserInputIndication::operator H245_UserInputIndication_extendedAlphanumeric &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_UserInputIndication_extendedAlphanumeric), PInvalidCast);
#endif
  return *(H245_UserInputIndication_extendedAlphanumeric *)choice;
}


H245_UserInputIndication::operator const H245_UserInputIndication_extendedAlphanumeric &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_UserInputIndication_extendedAlphanumeric), PInvalidCast);
#endif
  return *(H245_UserInputIndication_extendedAlphanumeric *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_UserInputIndication::operator H245_UserInputIndication_encryptedAlphanumeric &() const
#else
H245_UserInputIndication::operator H245_UserInputIndication_encryptedAlphanumeric &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_UserInputIndication_encryptedAlphanumeric), PInvalidCast);
#endif
  return *(H245_UserInputIndication_encryptedAlphanumeric *)choice;
}


H245_UserInputIndication::operator const H245_UserInputIndication_encryptedAlphanumeric &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_UserInputIndication_encryptedAlphanumeric), PInvalidCast);
#endif
  return *(H245_UserInputIndication_encryptedAlphanumeric *)choice;
}


BOOL H245_UserInputIndication::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_alphanumeric :
      choice = new PASN_GeneralString();
      return TRUE;
    case e_userInputSupportIndication :
      choice = new H245_UserInputIndication_userInputSupportIndication();
      return TRUE;
    case e_signal :
      choice = new H245_UserInputIndication_signal();
      return TRUE;
    case e_signalUpdate :
      choice = new H245_UserInputIndication_signalUpdate();
      return TRUE;
    case e_extendedAlphanumeric :
      choice = new H245_UserInputIndication_extendedAlphanumeric();
      return TRUE;
    case e_encryptedAlphanumeric :
      choice = new H245_UserInputIndication_encryptedAlphanumeric();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_UserInputIndication::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_UserInputIndication::Class()), PInvalidCast);
#endif
  return new H245_UserInputIndication(*this);
}


//
// MobileMultilinkReconfigurationIndication
//

H245_MobileMultilinkReconfigurationIndication::H245_MobileMultilinkReconfigurationIndication(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_sampleSize.SetConstraints(PASN_Object::FixedConstraint, 1, 255);
  m_samplesPerFrame.SetConstraints(PASN_Object::FixedConstraint, 1, 255);
}


#ifndef PASN_NOPRINTON
void H245_MobileMultilinkReconfigurationIndication::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+13) << "sampleSize = " << setprecision(indent) << m_sampleSize << '\n';
  strm << setw(indent+18) << "samplesPerFrame = " << setprecision(indent) << m_samplesPerFrame << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MobileMultilinkReconfigurationIndication::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MobileMultilinkReconfigurationIndication), PInvalidCast);
#endif
  const H245_MobileMultilinkReconfigurationIndication & other = (const H245_MobileMultilinkReconfigurationIndication &)obj;

  Comparison result;

  if ((result = m_sampleSize.Compare(other.m_sampleSize)) != EqualTo)
    return result;
  if ((result = m_samplesPerFrame.Compare(other.m_samplesPerFrame)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MobileMultilinkReconfigurationIndication::GetDataLength() const
{
  PINDEX length = 0;
  length += m_sampleSize.GetObjectLength();
  length += m_samplesPerFrame.GetObjectLength();
  return length;
}


BOOL H245_MobileMultilinkReconfigurationIndication::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_sampleSize.Decode(strm))
    return FALSE;
  if (!m_samplesPerFrame.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MobileMultilinkReconfigurationIndication::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_sampleSize.Encode(strm);
  m_samplesPerFrame.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MobileMultilinkReconfigurationIndication::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MobileMultilinkReconfigurationIndication::Class()), PInvalidCast);
#endif
  return new H245_MobileMultilinkReconfigurationIndication(*this);
}


//
// ArrayOf_GenericParameter
//

H245_ArrayOf_GenericParameter::H245_ArrayOf_GenericParameter(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_GenericParameter::CreateObject() const
{
  return new H245_GenericParameter;
}


H245_GenericParameter & H245_ArrayOf_GenericParameter::operator[](PINDEX i) const
{
  return (H245_GenericParameter &)array[i];
}


PObject * H245_ArrayOf_GenericParameter::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_GenericParameter::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_GenericParameter(*this);
}


//
// NonStandardIdentifier_h221NonStandard
//

H245_NonStandardIdentifier_h221NonStandard::H245_NonStandardIdentifier_h221NonStandard(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
  m_t35CountryCode.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
  m_t35Extension.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
  m_manufacturerCode.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void H245_NonStandardIdentifier_h221NonStandard::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "t35CountryCode = " << setprecision(indent) << m_t35CountryCode << '\n';
  strm << setw(indent+15) << "t35Extension = " << setprecision(indent) << m_t35Extension << '\n';
  strm << setw(indent+19) << "manufacturerCode = " << setprecision(indent) << m_manufacturerCode << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_NonStandardIdentifier_h221NonStandard::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_NonStandardIdentifier_h221NonStandard), PInvalidCast);
#endif
  const H245_NonStandardIdentifier_h221NonStandard & other = (const H245_NonStandardIdentifier_h221NonStandard &)obj;

  Comparison result;

  if ((result = m_t35CountryCode.Compare(other.m_t35CountryCode)) != EqualTo)
    return result;
  if ((result = m_t35Extension.Compare(other.m_t35Extension)) != EqualTo)
    return result;
  if ((result = m_manufacturerCode.Compare(other.m_manufacturerCode)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_NonStandardIdentifier_h221NonStandard::GetDataLength() const
{
  PINDEX length = 0;
  length += m_t35CountryCode.GetObjectLength();
  length += m_t35Extension.GetObjectLength();
  length += m_manufacturerCode.GetObjectLength();
  return length;
}


BOOL H245_NonStandardIdentifier_h221NonStandard::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_t35CountryCode.Decode(strm))
    return FALSE;
  if (!m_t35Extension.Decode(strm))
    return FALSE;
  if (!m_manufacturerCode.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_NonStandardIdentifier_h221NonStandard::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_t35CountryCode.Encode(strm);
  m_t35Extension.Encode(strm);
  m_manufacturerCode.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_NonStandardIdentifier_h221NonStandard::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NonStandardIdentifier_h221NonStandard::Class()), PInvalidCast);
#endif
  return new H245_NonStandardIdentifier_h221NonStandard(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_MasterSlaveDeterminationAck_decision[]={
      {"master",0}
     ,{"slave",1}
};
#endif
//
// MasterSlaveDeterminationAck_decision
//

H245_MasterSlaveDeterminationAck_decision::H245_MasterSlaveDeterminationAck_decision(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_MasterSlaveDeterminationAck_decision,2
#endif
)
{
}


BOOL H245_MasterSlaveDeterminationAck_decision::CreateObject()
{
  choice = (tag <= e_slave) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_MasterSlaveDeterminationAck_decision::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MasterSlaveDeterminationAck_decision::Class()), PInvalidCast);
#endif
  return new H245_MasterSlaveDeterminationAck_decision(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_MasterSlaveDeterminationReject_cause[]={
      {"identicalNumbers",0}
};
#endif
//
// MasterSlaveDeterminationReject_cause
//

H245_MasterSlaveDeterminationReject_cause::H245_MasterSlaveDeterminationReject_cause(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 1, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_MasterSlaveDeterminationReject_cause,1
#endif
)
{
}


BOOL H245_MasterSlaveDeterminationReject_cause::CreateObject()
{
  choice = (tag <= e_identicalNumbers) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_MasterSlaveDeterminationReject_cause::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MasterSlaveDeterminationReject_cause::Class()), PInvalidCast);
#endif
  return new H245_MasterSlaveDeterminationReject_cause(*this);
}


//
// ArrayOf_CapabilityTableEntry
//

H245_ArrayOf_CapabilityTableEntry::H245_ArrayOf_CapabilityTableEntry(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_CapabilityTableEntry::CreateObject() const
{
  return new H245_CapabilityTableEntry;
}


H245_CapabilityTableEntry & H245_ArrayOf_CapabilityTableEntry::operator[](PINDEX i) const
{
  return (H245_CapabilityTableEntry &)array[i];
}


PObject * H245_ArrayOf_CapabilityTableEntry::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_CapabilityTableEntry::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_CapabilityTableEntry(*this);
}


//
// ArrayOf_CapabilityDescriptor
//

H245_ArrayOf_CapabilityDescriptor::H245_ArrayOf_CapabilityDescriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_CapabilityDescriptor::CreateObject() const
{
  return new H245_CapabilityDescriptor;
}


H245_CapabilityDescriptor & H245_ArrayOf_CapabilityDescriptor::operator[](PINDEX i) const
{
  return (H245_CapabilityDescriptor &)array[i];
}


PObject * H245_ArrayOf_CapabilityDescriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_CapabilityDescriptor::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_CapabilityDescriptor(*this);
}


//
// ArrayOf_AlternativeCapabilitySet
//

H245_ArrayOf_AlternativeCapabilitySet::H245_ArrayOf_AlternativeCapabilitySet(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_AlternativeCapabilitySet::CreateObject() const
{
  return new H245_AlternativeCapabilitySet;
}


H245_AlternativeCapabilitySet & H245_ArrayOf_AlternativeCapabilitySet::operator[](PINDEX i) const
{
  return (H245_AlternativeCapabilitySet &)array[i];
}


PObject * H245_ArrayOf_AlternativeCapabilitySet::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_AlternativeCapabilitySet::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_AlternativeCapabilitySet(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_TerminalCapabilitySetReject_cause[]={
      {"unspecified",0}
     ,{"undefinedTableEntryUsed",1}
     ,{"descriptorCapacityExceeded",2}
     ,{"tableEntryCapacityExceeded",3}
};
#endif
//
// TerminalCapabilitySetReject_cause
//

H245_TerminalCapabilitySetReject_cause::H245_TerminalCapabilitySetReject_cause(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_TerminalCapabilitySetReject_cause,4
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_TerminalCapabilitySetReject_cause::operator H245_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded &() const
#else
H245_TerminalCapabilitySetReject_cause::operator H245_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded), PInvalidCast);
#endif
  return *(H245_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded *)choice;
}


H245_TerminalCapabilitySetReject_cause::operator const H245_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded), PInvalidCast);
#endif
  return *(H245_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded *)choice;
}


BOOL H245_TerminalCapabilitySetReject_cause::CreateObject()
{
  switch (tag) {
    case e_unspecified :
    case e_undefinedTableEntryUsed :
    case e_descriptorCapacityExceeded :
      choice = new PASN_Null();
      return TRUE;
    case e_tableEntryCapacityExceeded :
      choice = new H245_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_TerminalCapabilitySetReject_cause::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_TerminalCapabilitySetReject_cause::Class()), PInvalidCast);
#endif
  return new H245_TerminalCapabilitySetReject_cause(*this);
}


//
// Capability_h233EncryptionReceiveCapability
//

H245_Capability_h233EncryptionReceiveCapability::H245_Capability_h233EncryptionReceiveCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_h233IVResponseTime.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H245_Capability_h233EncryptionReceiveCapability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+21) << "h233IVResponseTime = " << setprecision(indent) << m_h233IVResponseTime << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_Capability_h233EncryptionReceiveCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_Capability_h233EncryptionReceiveCapability), PInvalidCast);
#endif
  const H245_Capability_h233EncryptionReceiveCapability & other = (const H245_Capability_h233EncryptionReceiveCapability &)obj;

  Comparison result;

  if ((result = m_h233IVResponseTime.Compare(other.m_h233IVResponseTime)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_Capability_h233EncryptionReceiveCapability::GetDataLength() const
{
  PINDEX length = 0;
  length += m_h233IVResponseTime.GetObjectLength();
  return length;
}


BOOL H245_Capability_h233EncryptionReceiveCapability::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_h233IVResponseTime.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_Capability_h233EncryptionReceiveCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_h233IVResponseTime.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_Capability_h233EncryptionReceiveCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_Capability_h233EncryptionReceiveCapability::Class()), PInvalidCast);
#endif
  return new H245_Capability_h233EncryptionReceiveCapability(*this);
}


//
// ArrayOf_VCCapability
//

H245_ArrayOf_VCCapability::H245_ArrayOf_VCCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_VCCapability::CreateObject() const
{
  return new H245_VCCapability;
}


H245_VCCapability & H245_ArrayOf_VCCapability::operator[](PINDEX i) const
{
  return (H245_VCCapability &)array[i];
}


PObject * H245_ArrayOf_VCCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_VCCapability::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_VCCapability(*this);
}


//
// VCCapability_aal1
//

H245_VCCapability_aal1::H245_VCCapability_aal1(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_VCCapability_aal1::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+20) << "nullClockRecovery = " << setprecision(indent) << m_nullClockRecovery << '\n';
  strm << setw(indent+20) << "srtsClockRecovery = " << setprecision(indent) << m_srtsClockRecovery << '\n';
  strm << setw(indent+24) << "adaptiveClockRecovery = " << setprecision(indent) << m_adaptiveClockRecovery << '\n';
  strm << setw(indent+22) << "nullErrorCorrection = " << setprecision(indent) << m_nullErrorCorrection << '\n';
  strm << setw(indent+18) << "longInterleaver = " << setprecision(indent) << m_longInterleaver << '\n';
  strm << setw(indent+19) << "shortInterleaver = " << setprecision(indent) << m_shortInterleaver << '\n';
  strm << setw(indent+22) << "errorCorrectionOnly = " << setprecision(indent) << m_errorCorrectionOnly << '\n';
  strm << setw(indent+25) << "structuredDataTransfer = " << setprecision(indent) << m_structuredDataTransfer << '\n';
  strm << setw(indent+23) << "partiallyFilledCells = " << setprecision(indent) << m_partiallyFilledCells << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_VCCapability_aal1::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_VCCapability_aal1), PInvalidCast);
#endif
  const H245_VCCapability_aal1 & other = (const H245_VCCapability_aal1 &)obj;

  Comparison result;

  if ((result = m_nullClockRecovery.Compare(other.m_nullClockRecovery)) != EqualTo)
    return result;
  if ((result = m_srtsClockRecovery.Compare(other.m_srtsClockRecovery)) != EqualTo)
    return result;
  if ((result = m_adaptiveClockRecovery.Compare(other.m_adaptiveClockRecovery)) != EqualTo)
    return result;
  if ((result = m_nullErrorCorrection.Compare(other.m_nullErrorCorrection)) != EqualTo)
    return result;
  if ((result = m_longInterleaver.Compare(other.m_longInterleaver)) != EqualTo)
    return result;
  if ((result = m_shortInterleaver.Compare(other.m_shortInterleaver)) != EqualTo)
    return result;
  if ((result = m_errorCorrectionOnly.Compare(other.m_errorCorrectionOnly)) != EqualTo)
    return result;
  if ((result = m_structuredDataTransfer.Compare(other.m_structuredDataTransfer)) != EqualTo)
    return result;
  if ((result = m_partiallyFilledCells.Compare(other.m_partiallyFilledCells)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_VCCapability_aal1::GetDataLength() const
{
  PINDEX length = 0;
  length += m_nullClockRecovery.GetObjectLength();
  length += m_srtsClockRecovery.GetObjectLength();
  length += m_adaptiveClockRecovery.GetObjectLength();
  length += m_nullErrorCorrection.GetObjectLength();
  length += m_longInterleaver.GetObjectLength();
  length += m_shortInterleaver.GetObjectLength();
  length += m_errorCorrectionOnly.GetObjectLength();
  length += m_structuredDataTransfer.GetObjectLength();
  length += m_partiallyFilledCells.GetObjectLength();
  return length;
}


BOOL H245_VCCapability_aal1::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_nullClockRecovery.Decode(strm))
    return FALSE;
  if (!m_srtsClockRecovery.Decode(strm))
    return FALSE;
  if (!m_adaptiveClockRecovery.Decode(strm))
    return FALSE;
  if (!m_nullErrorCorrection.Decode(strm))
    return FALSE;
  if (!m_longInterleaver.Decode(strm))
    return FALSE;
  if (!m_shortInterleaver.Decode(strm))
    return FALSE;
  if (!m_errorCorrectionOnly.Decode(strm))
    return FALSE;
  if (!m_structuredDataTransfer.Decode(strm))
    return FALSE;
  if (!m_partiallyFilledCells.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_VCCapability_aal1::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_nullClockRecovery.Encode(strm);
  m_srtsClockRecovery.Encode(strm);
  m_adaptiveClockRecovery.Encode(strm);
  m_nullErrorCorrection.Encode(strm);
  m_longInterleaver.Encode(strm);
  m_shortInterleaver.Encode(strm);
  m_errorCorrectionOnly.Encode(strm);
  m_structuredDataTransfer.Encode(strm);
  m_partiallyFilledCells.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_VCCapability_aal1::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_VCCapability_aal1::Class()), PInvalidCast);
#endif
  return new H245_VCCapability_aal1(*this);
}


//
// VCCapability_aal5
//

H245_VCCapability_aal5::H245_VCCapability_aal5(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_forwardMaximumSDUSize.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
  m_backwardMaximumSDUSize.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void H245_VCCapability_aal5::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+24) << "forwardMaximumSDUSize = " << setprecision(indent) << m_forwardMaximumSDUSize << '\n';
  strm << setw(indent+25) << "backwardMaximumSDUSize = " << setprecision(indent) << m_backwardMaximumSDUSize << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_VCCapability_aal5::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_VCCapability_aal5), PInvalidCast);
#endif
  const H245_VCCapability_aal5 & other = (const H245_VCCapability_aal5 &)obj;

  Comparison result;

  if ((result = m_forwardMaximumSDUSize.Compare(other.m_forwardMaximumSDUSize)) != EqualTo)
    return result;
  if ((result = m_backwardMaximumSDUSize.Compare(other.m_backwardMaximumSDUSize)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_VCCapability_aal5::GetDataLength() const
{
  PINDEX length = 0;
  length += m_forwardMaximumSDUSize.GetObjectLength();
  length += m_backwardMaximumSDUSize.GetObjectLength();
  return length;
}


BOOL H245_VCCapability_aal5::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_forwardMaximumSDUSize.Decode(strm))
    return FALSE;
  if (!m_backwardMaximumSDUSize.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_VCCapability_aal5::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_forwardMaximumSDUSize.Encode(strm);
  m_backwardMaximumSDUSize.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_VCCapability_aal5::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_VCCapability_aal5::Class()), PInvalidCast);
#endif
  return new H245_VCCapability_aal5(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_H223Capability_h223MultiplexTableCapability[]={
      {"basic",0}
     ,{"enhanced",1}
};
#endif
//
// H223Capability_h223MultiplexTableCapability
//

H245_H223Capability_h223MultiplexTableCapability::H245_H223Capability_h223MultiplexTableCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_H223Capability_h223MultiplexTableCapability,2
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H223Capability_h223MultiplexTableCapability::operator H245_H223Capability_h223MultiplexTableCapability_enhanced &() const
#else
H245_H223Capability_h223MultiplexTableCapability::operator H245_H223Capability_h223MultiplexTableCapability_enhanced &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H223Capability_h223MultiplexTableCapability_enhanced), PInvalidCast);
#endif
  return *(H245_H223Capability_h223MultiplexTableCapability_enhanced *)choice;
}


H245_H223Capability_h223MultiplexTableCapability::operator const H245_H223Capability_h223MultiplexTableCapability_enhanced &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H223Capability_h223MultiplexTableCapability_enhanced), PInvalidCast);
#endif
  return *(H245_H223Capability_h223MultiplexTableCapability_enhanced *)choice;
}


BOOL H245_H223Capability_h223MultiplexTableCapability::CreateObject()
{
  switch (tag) {
    case e_basic :
      choice = new PASN_Null();
      return TRUE;
    case e_enhanced :
      choice = new H245_H223Capability_h223MultiplexTableCapability_enhanced();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_H223Capability_h223MultiplexTableCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223Capability_h223MultiplexTableCapability::Class()), PInvalidCast);
#endif
  return new H245_H223Capability_h223MultiplexTableCapability(*this);
}


//
// H223Capability_mobileOperationTransmitCapability
//

H245_H223Capability_mobileOperationTransmitCapability::H245_H223Capability_mobileOperationTransmitCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_H223Capability_mobileOperationTransmitCapability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+23) << "modeChangeCapability = " << setprecision(indent) << m_modeChangeCapability << '\n';
  strm << setw(indent+13) << "h223AnnexA = " << setprecision(indent) << m_h223AnnexA << '\n';
  strm << setw(indent+23) << "h223AnnexADoubleFlag = " << setprecision(indent) << m_h223AnnexADoubleFlag << '\n';
  strm << setw(indent+13) << "h223AnnexB = " << setprecision(indent) << m_h223AnnexB << '\n';
  strm << setw(indent+23) << "h223AnnexBwithHeader = " << setprecision(indent) << m_h223AnnexBwithHeader << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_H223Capability_mobileOperationTransmitCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_H223Capability_mobileOperationTransmitCapability), PInvalidCast);
#endif
  const H245_H223Capability_mobileOperationTransmitCapability & other = (const H245_H223Capability_mobileOperationTransmitCapability &)obj;

  Comparison result;

  if ((result = m_modeChangeCapability.Compare(other.m_modeChangeCapability)) != EqualTo)
    return result;
  if ((result = m_h223AnnexA.Compare(other.m_h223AnnexA)) != EqualTo)
    return result;
  if ((result = m_h223AnnexADoubleFlag.Compare(other.m_h223AnnexADoubleFlag)) != EqualTo)
    return result;
  if ((result = m_h223AnnexB.Compare(other.m_h223AnnexB)) != EqualTo)
    return result;
  if ((result = m_h223AnnexBwithHeader.Compare(other.m_h223AnnexBwithHeader)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H223Capability_mobileOperationTransmitCapability::GetDataLength() const
{
  PINDEX length = 0;
  length += m_modeChangeCapability.GetObjectLength();
  length += m_h223AnnexA.GetObjectLength();
  length += m_h223AnnexADoubleFlag.GetObjectLength();
  length += m_h223AnnexB.GetObjectLength();
  length += m_h223AnnexBwithHeader.GetObjectLength();
  return length;
}


BOOL H245_H223Capability_mobileOperationTransmitCapability::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_modeChangeCapability.Decode(strm))
    return FALSE;
  if (!m_h223AnnexA.Decode(strm))
    return FALSE;
  if (!m_h223AnnexADoubleFlag.Decode(strm))
    return FALSE;
  if (!m_h223AnnexB.Decode(strm))
    return FALSE;
  if (!m_h223AnnexBwithHeader.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_H223Capability_mobileOperationTransmitCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_modeChangeCapability.Encode(strm);
  m_h223AnnexA.Encode(strm);
  m_h223AnnexADoubleFlag.Encode(strm);
  m_h223AnnexB.Encode(strm);
  m_h223AnnexBwithHeader.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_H223Capability_mobileOperationTransmitCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223Capability_mobileOperationTransmitCapability::Class()), PInvalidCast);
#endif
  return new H245_H223Capability_mobileOperationTransmitCapability(*this);
}


//
// H223Capability_mobileMultilinkFrameCapability
//

H245_H223Capability_mobileMultilinkFrameCapability::H245_H223Capability_mobileMultilinkFrameCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_maximumSampleSize.SetConstraints(PASN_Object::FixedConstraint, 1, 255);
  m_maximumPayloadLength.SetConstraints(PASN_Object::FixedConstraint, 1, 65025);
}


#ifndef PASN_NOPRINTON
void H245_H223Capability_mobileMultilinkFrameCapability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+20) << "maximumSampleSize = " << setprecision(indent) << m_maximumSampleSize << '\n';
  strm << setw(indent+23) << "maximumPayloadLength = " << setprecision(indent) << m_maximumPayloadLength << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_H223Capability_mobileMultilinkFrameCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_H223Capability_mobileMultilinkFrameCapability), PInvalidCast);
#endif
  const H245_H223Capability_mobileMultilinkFrameCapability & other = (const H245_H223Capability_mobileMultilinkFrameCapability &)obj;

  Comparison result;

  if ((result = m_maximumSampleSize.Compare(other.m_maximumSampleSize)) != EqualTo)
    return result;
  if ((result = m_maximumPayloadLength.Compare(other.m_maximumPayloadLength)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H223Capability_mobileMultilinkFrameCapability::GetDataLength() const
{
  PINDEX length = 0;
  length += m_maximumSampleSize.GetObjectLength();
  length += m_maximumPayloadLength.GetObjectLength();
  return length;
}


BOOL H245_H223Capability_mobileMultilinkFrameCapability::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_maximumSampleSize.Decode(strm))
    return FALSE;
  if (!m_maximumPayloadLength.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_H223Capability_mobileMultilinkFrameCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_maximumSampleSize.Encode(strm);
  m_maximumPayloadLength.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_H223Capability_mobileMultilinkFrameCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223Capability_mobileMultilinkFrameCapability::Class()), PInvalidCast);
#endif
  return new H245_H223Capability_mobileMultilinkFrameCapability(*this);
}


//
// H2250Capability_mcCapability
//

H245_H2250Capability_mcCapability::H245_H2250Capability_mcCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_H2250Capability_mcCapability::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+26) << "centralizedConferenceMC = " << setprecision(indent) << m_centralizedConferenceMC << '\n';
  strm << setw(indent+28) << "decentralizedConferenceMC = " << setprecision(indent) << m_decentralizedConferenceMC << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_H2250Capability_mcCapability::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_H2250Capability_mcCapability), PInvalidCast);
#endif
  const H245_H2250Capability_mcCapability & other = (const H245_H2250Capability_mcCapability &)obj;

  Comparison result;

  if ((result = m_centralizedConferenceMC.Compare(other.m_centralizedConferenceMC)) != EqualTo)
    return result;
  if ((result = m_decentralizedConferenceMC.Compare(other.m_decentralizedConferenceMC)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H2250Capability_mcCapability::GetDataLength() const
{
  PINDEX length = 0;
  length += m_centralizedConferenceMC.GetObjectLength();
  length += m_decentralizedConferenceMC.GetObjectLength();
  return length;
}


BOOL H245_H2250Capability_mcCapability::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_centralizedConferenceMC.Decode(strm))
    return FALSE;
  if (!m_decentralizedConferenceMC.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_H2250Capability_mcCapability::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_centralizedConferenceMC.Encode(strm);
  m_decentralizedConferenceMC.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_H2250Capability_mcCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H2250Capability_mcCapability::Class()), PInvalidCast);
#endif
  return new H245_H2250Capability_mcCapability(*this);
}


//
// ArrayOf_RedundancyEncodingCapability
//

H245_ArrayOf_RedundancyEncodingCapability::H245_ArrayOf_RedundancyEncodingCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_RedundancyEncodingCapability::CreateObject() const
{
  return new H245_RedundancyEncodingCapability;
}


H245_RedundancyEncodingCapability & H245_ArrayOf_RedundancyEncodingCapability::operator[](PINDEX i) const
{
  return (H245_RedundancyEncodingCapability &)array[i];
}


PObject * H245_ArrayOf_RedundancyEncodingCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_RedundancyEncodingCapability::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_RedundancyEncodingCapability(*this);
}


//
// ArrayOf_RTPPayloadType
//

H245_ArrayOf_RTPPayloadType::H245_ArrayOf_RTPPayloadType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_RTPPayloadType::CreateObject() const
{
  return new H245_RTPPayloadType;
}


H245_RTPPayloadType & H245_ArrayOf_RTPPayloadType::operator[](PINDEX i) const
{
  return (H245_RTPPayloadType &)array[i];
}


PObject * H245_ArrayOf_RTPPayloadType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_RTPPayloadType::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_RTPPayloadType(*this);
}


//
// MediaTransportType_atm-AAL5-compressed
//

H245_MediaTransportType_atm_AAL5_compressed::H245_MediaTransportType_atm_AAL5_compressed(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MediaTransportType_atm_AAL5_compressed::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "variable_delta = " << setprecision(indent) << m_variable_delta << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MediaTransportType_atm_AAL5_compressed::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MediaTransportType_atm_AAL5_compressed), PInvalidCast);
#endif
  const H245_MediaTransportType_atm_AAL5_compressed & other = (const H245_MediaTransportType_atm_AAL5_compressed &)obj;

  Comparison result;

  if ((result = m_variable_delta.Compare(other.m_variable_delta)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MediaTransportType_atm_AAL5_compressed::GetDataLength() const
{
  PINDEX length = 0;
  length += m_variable_delta.GetObjectLength();
  return length;
}


BOOL H245_MediaTransportType_atm_AAL5_compressed::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_variable_delta.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MediaTransportType_atm_AAL5_compressed::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_variable_delta.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MediaTransportType_atm_AAL5_compressed::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MediaTransportType_atm_AAL5_compressed::Class()), PInvalidCast);
#endif
  return new H245_MediaTransportType_atm_AAL5_compressed(*this);
}


//
// ArrayOf_QOSCapability
//

H245_ArrayOf_QOSCapability::H245_ArrayOf_QOSCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_QOSCapability::CreateObject() const
{
  return new H245_QOSCapability;
}


H245_QOSCapability & H245_ArrayOf_QOSCapability::operator[](PINDEX i) const
{
  return (H245_QOSCapability &)array[i];
}


PObject * H245_ArrayOf_QOSCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_QOSCapability::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_QOSCapability(*this);
}


//
// ArrayOf_MediaChannelCapability
//

H245_ArrayOf_MediaChannelCapability::H245_ArrayOf_MediaChannelCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_MediaChannelCapability::CreateObject() const
{
  return new H245_MediaChannelCapability;
}


H245_MediaChannelCapability & H245_ArrayOf_MediaChannelCapability::operator[](PINDEX i) const
{
  return (H245_MediaChannelCapability &)array[i];
}


PObject * H245_ArrayOf_MediaChannelCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_MediaChannelCapability::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_MediaChannelCapability(*this);
}


//
// ArrayOf_CapabilityTableEntryNumber
//

H245_ArrayOf_CapabilityTableEntryNumber::H245_ArrayOf_CapabilityTableEntryNumber(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_CapabilityTableEntryNumber::CreateObject() const
{
  return new H245_CapabilityTableEntryNumber;
}


H245_CapabilityTableEntryNumber & H245_ArrayOf_CapabilityTableEntryNumber::operator[](PINDEX i) const
{
  return (H245_CapabilityTableEntryNumber &)array[i];
}


PObject * H245_ArrayOf_CapabilityTableEntryNumber::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_CapabilityTableEntryNumber::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_CapabilityTableEntryNumber(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_RTPH263VideoRedundancyEncoding_frameToThreadMapping[]={
      {"roundrobin",0}
     ,{"custom",1}
};
#endif
//
// RTPH263VideoRedundancyEncoding_frameToThreadMapping
//

H245_RTPH263VideoRedundancyEncoding_frameToThreadMapping::H245_RTPH263VideoRedundancyEncoding_frameToThreadMapping(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_RTPH263VideoRedundancyEncoding_frameToThreadMapping,2
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RTPH263VideoRedundancyEncoding_frameToThreadMapping::operator H245_ArrayOf_RTPH263VideoRedundancyFrameMapping &() const
#else
H245_RTPH263VideoRedundancyEncoding_frameToThreadMapping::operator H245_ArrayOf_RTPH263VideoRedundancyFrameMapping &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ArrayOf_RTPH263VideoRedundancyFrameMapping), PInvalidCast);
#endif
  return *(H245_ArrayOf_RTPH263VideoRedundancyFrameMapping *)choice;
}


H245_RTPH263VideoRedundancyEncoding_frameToThreadMapping::operator const H245_ArrayOf_RTPH263VideoRedundancyFrameMapping &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ArrayOf_RTPH263VideoRedundancyFrameMapping), PInvalidCast);
#endif
  return *(H245_ArrayOf_RTPH263VideoRedundancyFrameMapping *)choice;
}


BOOL H245_RTPH263VideoRedundancyEncoding_frameToThreadMapping::CreateObject()
{
  switch (tag) {
    case e_roundrobin :
      choice = new PASN_Null();
      return TRUE;
    case e_custom :
      choice = new H245_ArrayOf_RTPH263VideoRedundancyFrameMapping();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 256);
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_RTPH263VideoRedundancyEncoding_frameToThreadMapping::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RTPH263VideoRedundancyEncoding_frameToThreadMapping::Class()), PInvalidCast);
#endif
  return new H245_RTPH263VideoRedundancyEncoding_frameToThreadMapping(*this);
}


//
// RTPH263VideoRedundancyEncoding_containedThreads
//

H245_RTPH263VideoRedundancyEncoding_containedThreads::H245_RTPH263VideoRedundancyEncoding_containedThreads(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


PASN_Object * H245_RTPH263VideoRedundancyEncoding_containedThreads::CreateObject() const
{
  PASN_Integer * obj = new PASN_Integer;
  obj->SetConstraints(PASN_Object::FixedConstraint, 0, 15);
  return obj;
}


PASN_Integer & H245_RTPH263VideoRedundancyEncoding_containedThreads::operator[](PINDEX i) const
{
  return (PASN_Integer &)array[i];
}


PObject * H245_RTPH263VideoRedundancyEncoding_containedThreads::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RTPH263VideoRedundancyEncoding_containedThreads::Class()), PInvalidCast);
#endif
  return new H245_RTPH263VideoRedundancyEncoding_containedThreads(*this);
}


//
// RTPH263VideoRedundancyFrameMapping_frameSequence
//

H245_RTPH263VideoRedundancyFrameMapping_frameSequence::H245_RTPH263VideoRedundancyFrameMapping_frameSequence(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


PASN_Object * H245_RTPH263VideoRedundancyFrameMapping_frameSequence::CreateObject() const
{
  PASN_Integer * obj = new PASN_Integer;
  obj->SetConstraints(PASN_Object::FixedConstraint, 0, 255);
  return obj;
}


PASN_Integer & H245_RTPH263VideoRedundancyFrameMapping_frameSequence::operator[](PINDEX i) const
{
  return (PASN_Integer &)array[i];
}


PObject * H245_RTPH263VideoRedundancyFrameMapping_frameSequence::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RTPH263VideoRedundancyFrameMapping_frameSequence::Class()), PInvalidCast);
#endif
  return new H245_RTPH263VideoRedundancyFrameMapping_frameSequence(*this);
}


//
// ArrayOf_MediaDistributionCapability
//

H245_ArrayOf_MediaDistributionCapability::H245_ArrayOf_MediaDistributionCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_MediaDistributionCapability::CreateObject() const
{
  return new H245_MediaDistributionCapability;
}


H245_MediaDistributionCapability & H245_ArrayOf_MediaDistributionCapability::operator[](PINDEX i) const
{
  return (H245_MediaDistributionCapability &)array[i];
}


PObject * H245_ArrayOf_MediaDistributionCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_MediaDistributionCapability::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_MediaDistributionCapability(*this);
}


//
// ArrayOf_DataApplicationCapability
//

H245_ArrayOf_DataApplicationCapability::H245_ArrayOf_DataApplicationCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_DataApplicationCapability::CreateObject() const
{
  return new H245_DataApplicationCapability;
}


H245_DataApplicationCapability & H245_ArrayOf_DataApplicationCapability::operator[](PINDEX i) const
{
  return (H245_DataApplicationCapability &)array[i];
}


PObject * H245_ArrayOf_DataApplicationCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_DataApplicationCapability::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_DataApplicationCapability(*this);
}


//
// ArrayOf_VideoCapability
//

H245_ArrayOf_VideoCapability::H245_ArrayOf_VideoCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_VideoCapability::CreateObject() const
{
  return new H245_VideoCapability;
}


H245_VideoCapability & H245_ArrayOf_VideoCapability::operator[](PINDEX i) const
{
  return (H245_VideoCapability &)array[i];
}


PObject * H245_ArrayOf_VideoCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_VideoCapability::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_VideoCapability(*this);
}


//
// ArrayOf_GenericCapability
//

H245_ArrayOf_GenericCapability::H245_ArrayOf_GenericCapability(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_GenericCapability::CreateObject() const
{
  return new H245_GenericCapability;
}


H245_GenericCapability & H245_ArrayOf_GenericCapability::operator[](PINDEX i) const
{
  return (H245_GenericCapability &)array[i];
}


PObject * H245_ArrayOf_GenericCapability::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_GenericCapability::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_GenericCapability(*this);
}


//
// ArrayOf_EnhancementOptions
//

H245_ArrayOf_EnhancementOptions::H245_ArrayOf_EnhancementOptions(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_EnhancementOptions::CreateObject() const
{
  return new H245_EnhancementOptions;
}


H245_EnhancementOptions & H245_ArrayOf_EnhancementOptions::operator[](PINDEX i) const
{
  return (H245_EnhancementOptions &)array[i];
}


PObject * H245_ArrayOf_EnhancementOptions::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_EnhancementOptions::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_EnhancementOptions(*this);
}


//
// ArrayOf_BEnhancementParameters
//

H245_ArrayOf_BEnhancementParameters::H245_ArrayOf_BEnhancementParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_BEnhancementParameters::CreateObject() const
{
  return new H245_BEnhancementParameters;
}


H245_BEnhancementParameters & H245_ArrayOf_BEnhancementParameters::operator[](PINDEX i) const
{
  return (H245_BEnhancementParameters &)array[i];
}


PObject * H245_ArrayOf_BEnhancementParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_BEnhancementParameters::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_BEnhancementParameters(*this);
}


//
// ArrayOf_CustomPictureClockFrequency
//

H245_ArrayOf_CustomPictureClockFrequency::H245_ArrayOf_CustomPictureClockFrequency(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_CustomPictureClockFrequency::CreateObject() const
{
  return new H245_CustomPictureClockFrequency;
}


H245_CustomPictureClockFrequency & H245_ArrayOf_CustomPictureClockFrequency::operator[](PINDEX i) const
{
  return (H245_CustomPictureClockFrequency &)array[i];
}


PObject * H245_ArrayOf_CustomPictureClockFrequency::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_CustomPictureClockFrequency::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_CustomPictureClockFrequency(*this);
}


#endif // if ! H323_DISABLE_H245


// End of h245_1.cxx
