//
// h245_2.cxx
//
// Code automatically generated by asnparse.
//

#include <ptlib.h>
#include "h245.h"

#define new PNEW


#if ! H323_DISABLE_H245

//
// ArrayOf_CustomPictureFormat
//

H245_ArrayOf_CustomPictureFormat::H245_ArrayOf_CustomPictureFormat(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_CustomPictureFormat::CreateObject() const
{
  return new H245_CustomPictureFormat;
}


H245_CustomPictureFormat & H245_ArrayOf_CustomPictureFormat::operator[](PINDEX i) const
{
  return (H245_CustomPictureFormat &)array[i];
}


PObject * H245_ArrayOf_CustomPictureFormat::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_CustomPictureFormat::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_CustomPictureFormat(*this);
}


//
// ArrayOf_H263VideoModeCombos
//

H245_ArrayOf_H263VideoModeCombos::H245_ArrayOf_H263VideoModeCombos(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_H263VideoModeCombos::CreateObject() const
{
  return new H245_H263VideoModeCombos;
}


H245_H263VideoModeCombos & H245_ArrayOf_H263VideoModeCombos::operator[](PINDEX i) const
{
  return (H245_H263VideoModeCombos &)array[i];
}


PObject * H245_ArrayOf_H263VideoModeCombos::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_H263VideoModeCombos::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_H263VideoModeCombos(*this);
}


//
// RefPictureSelection_additionalPictureMemory
//

H245_RefPictureSelection_additionalPictureMemory::H245_RefPictureSelection_additionalPictureMemory(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 6, TRUE, 0)
{
  m_sqcifAdditionalPictureMemory.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
  m_qcifAdditionalPictureMemory.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
  m_cifAdditionalPictureMemory.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
  m_cif4AdditionalPictureMemory.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
  m_cif16AdditionalPictureMemory.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
  m_bigCpfAdditionalPictureMemory.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H245_RefPictureSelection_additionalPictureMemory::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_sqcifAdditionalPictureMemory))
    strm << setw(indent+31) << "sqcifAdditionalPictureMemory = " << setprecision(indent) << m_sqcifAdditionalPictureMemory << '\n';
  if (HasOptionalField(e_qcifAdditionalPictureMemory))
    strm << setw(indent+30) << "qcifAdditionalPictureMemory = " << setprecision(indent) << m_qcifAdditionalPictureMemory << '\n';
  if (HasOptionalField(e_cifAdditionalPictureMemory))
    strm << setw(indent+29) << "cifAdditionalPictureMemory = " << setprecision(indent) << m_cifAdditionalPictureMemory << '\n';
  if (HasOptionalField(e_cif4AdditionalPictureMemory))
    strm << setw(indent+30) << "cif4AdditionalPictureMemory = " << setprecision(indent) << m_cif4AdditionalPictureMemory << '\n';
  if (HasOptionalField(e_cif16AdditionalPictureMemory))
    strm << setw(indent+31) << "cif16AdditionalPictureMemory = " << setprecision(indent) << m_cif16AdditionalPictureMemory << '\n';
  if (HasOptionalField(e_bigCpfAdditionalPictureMemory))
    strm << setw(indent+32) << "bigCpfAdditionalPictureMemory = " << setprecision(indent) << m_bigCpfAdditionalPictureMemory << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_RefPictureSelection_additionalPictureMemory::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_RefPictureSelection_additionalPictureMemory), PInvalidCast);
#endif
  const H245_RefPictureSelection_additionalPictureMemory & other = (const H245_RefPictureSelection_additionalPictureMemory &)obj;

  Comparison result;

  if ((result = m_sqcifAdditionalPictureMemory.Compare(other.m_sqcifAdditionalPictureMemory)) != EqualTo)
    return result;
  if ((result = m_qcifAdditionalPictureMemory.Compare(other.m_qcifAdditionalPictureMemory)) != EqualTo)
    return result;
  if ((result = m_cifAdditionalPictureMemory.Compare(other.m_cifAdditionalPictureMemory)) != EqualTo)
    return result;
  if ((result = m_cif4AdditionalPictureMemory.Compare(other.m_cif4AdditionalPictureMemory)) != EqualTo)
    return result;
  if ((result = m_cif16AdditionalPictureMemory.Compare(other.m_cif16AdditionalPictureMemory)) != EqualTo)
    return result;
  if ((result = m_bigCpfAdditionalPictureMemory.Compare(other.m_bigCpfAdditionalPictureMemory)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RefPictureSelection_additionalPictureMemory::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_sqcifAdditionalPictureMemory))
    length += m_sqcifAdditionalPictureMemory.GetObjectLength();
  if (HasOptionalField(e_qcifAdditionalPictureMemory))
    length += m_qcifAdditionalPictureMemory.GetObjectLength();
  if (HasOptionalField(e_cifAdditionalPictureMemory))
    length += m_cifAdditionalPictureMemory.GetObjectLength();
  if (HasOptionalField(e_cif4AdditionalPictureMemory))
    length += m_cif4AdditionalPictureMemory.GetObjectLength();
  if (HasOptionalField(e_cif16AdditionalPictureMemory))
    length += m_cif16AdditionalPictureMemory.GetObjectLength();
  if (HasOptionalField(e_bigCpfAdditionalPictureMemory))
    length += m_bigCpfAdditionalPictureMemory.GetObjectLength();
  return length;
}


BOOL H245_RefPictureSelection_additionalPictureMemory::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_sqcifAdditionalPictureMemory) && !m_sqcifAdditionalPictureMemory.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_qcifAdditionalPictureMemory) && !m_qcifAdditionalPictureMemory.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_cifAdditionalPictureMemory) && !m_cifAdditionalPictureMemory.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_cif4AdditionalPictureMemory) && !m_cif4AdditionalPictureMemory.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_cif16AdditionalPictureMemory) && !m_cif16AdditionalPictureMemory.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_bigCpfAdditionalPictureMemory) && !m_bigCpfAdditionalPictureMemory.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_RefPictureSelection_additionalPictureMemory::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_sqcifAdditionalPictureMemory))
    m_sqcifAdditionalPictureMemory.Encode(strm);
  if (HasOptionalField(e_qcifAdditionalPictureMemory))
    m_qcifAdditionalPictureMemory.Encode(strm);
  if (HasOptionalField(e_cifAdditionalPictureMemory))
    m_cifAdditionalPictureMemory.Encode(strm);
  if (HasOptionalField(e_cif4AdditionalPictureMemory))
    m_cif4AdditionalPictureMemory.Encode(strm);
  if (HasOptionalField(e_cif16AdditionalPictureMemory))
    m_cif16AdditionalPictureMemory.Encode(strm);
  if (HasOptionalField(e_bigCpfAdditionalPictureMemory))
    m_bigCpfAdditionalPictureMemory.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_RefPictureSelection_additionalPictureMemory::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RefPictureSelection_additionalPictureMemory::Class()), PInvalidCast);
#endif
  return new H245_RefPictureSelection_additionalPictureMemory(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_RefPictureSelection_videoBackChannelSend[]={
      {"none",0}
     ,{"ackMessageOnly",1}
     ,{"nackMessageOnly",2}
     ,{"ackOrNackMessageOnly",3}
     ,{"ackAndNackMessage",4}
};
#endif
//
// RefPictureSelection_videoBackChannelSend
//

H245_RefPictureSelection_videoBackChannelSend::H245_RefPictureSelection_videoBackChannelSend(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 5, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_RefPictureSelection_videoBackChannelSend,5
#endif
)
{
}


BOOL H245_RefPictureSelection_videoBackChannelSend::CreateObject()
{
  choice = (tag <= e_ackAndNackMessage) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_RefPictureSelection_videoBackChannelSend::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RefPictureSelection_videoBackChannelSend::Class()), PInvalidCast);
#endif
  return new H245_RefPictureSelection_videoBackChannelSend(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_CustomPictureFormat_pixelAspectInformation[]={
      {"anyPixelAspectRatio",0}
     ,{"pixelAspectCode",1}
     ,{"extendedPAR",2}
};
#endif
//
// CustomPictureFormat_pixelAspectInformation
//

H245_CustomPictureFormat_pixelAspectInformation::H245_CustomPictureFormat_pixelAspectInformation(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_CustomPictureFormat_pixelAspectInformation,3
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_CustomPictureFormat_pixelAspectInformation::operator H245_CustomPictureFormat_pixelAspectInformation_pixelAspectCode &() const
#else
H245_CustomPictureFormat_pixelAspectInformation::operator H245_CustomPictureFormat_pixelAspectInformation_pixelAspectCode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_CustomPictureFormat_pixelAspectInformation_pixelAspectCode), PInvalidCast);
#endif
  return *(H245_CustomPictureFormat_pixelAspectInformation_pixelAspectCode *)choice;
}


H245_CustomPictureFormat_pixelAspectInformation::operator const H245_CustomPictureFormat_pixelAspectInformation_pixelAspectCode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_CustomPictureFormat_pixelAspectInformation_pixelAspectCode), PInvalidCast);
#endif
  return *(H245_CustomPictureFormat_pixelAspectInformation_pixelAspectCode *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_CustomPictureFormat_pixelAspectInformation::operator H245_CustomPictureFormat_pixelAspectInformation_extendedPAR &() const
#else
H245_CustomPictureFormat_pixelAspectInformation::operator H245_CustomPictureFormat_pixelAspectInformation_extendedPAR &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_CustomPictureFormat_pixelAspectInformation_extendedPAR), PInvalidCast);
#endif
  return *(H245_CustomPictureFormat_pixelAspectInformation_extendedPAR *)choice;
}


H245_CustomPictureFormat_pixelAspectInformation::operator const H245_CustomPictureFormat_pixelAspectInformation_extendedPAR &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_CustomPictureFormat_pixelAspectInformation_extendedPAR), PInvalidCast);
#endif
  return *(H245_CustomPictureFormat_pixelAspectInformation_extendedPAR *)choice;
}


BOOL H245_CustomPictureFormat_pixelAspectInformation::CreateObject()
{
  switch (tag) {
    case e_anyPixelAspectRatio :
      choice = new PASN_Boolean();
      return TRUE;
    case e_pixelAspectCode :
      choice = new H245_CustomPictureFormat_pixelAspectInformation_pixelAspectCode();
      return TRUE;
    case e_extendedPAR :
      choice = new H245_CustomPictureFormat_pixelAspectInformation_extendedPAR();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_CustomPictureFormat_pixelAspectInformation::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CustomPictureFormat_pixelAspectInformation::Class()), PInvalidCast);
#endif
  return new H245_CustomPictureFormat_pixelAspectInformation(*this);
}


//
// ArrayOf_H263ModeComboFlags
//

H245_ArrayOf_H263ModeComboFlags::H245_ArrayOf_H263ModeComboFlags(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_H263ModeComboFlags::CreateObject() const
{
  return new H245_H263ModeComboFlags;
}


H245_H263ModeComboFlags & H245_ArrayOf_H263ModeComboFlags::operator[](PINDEX i) const
{
  return (H245_H263ModeComboFlags &)array[i];
}


PObject * H245_ArrayOf_H263ModeComboFlags::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_H263ModeComboFlags::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_H263ModeComboFlags(*this);
}


//
// AudioCapability_g7231
//

H245_AudioCapability_g7231::H245_AudioCapability_g7231(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
  m_maxAl_sduAudioFrames.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H245_AudioCapability_g7231::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+23) << "maxAl_sduAudioFrames = " << setprecision(indent) << m_maxAl_sduAudioFrames << '\n';
  strm << setw(indent+21) << "silenceSuppression = " << setprecision(indent) << m_silenceSuppression << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_AudioCapability_g7231::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_AudioCapability_g7231), PInvalidCast);
#endif
  const H245_AudioCapability_g7231 & other = (const H245_AudioCapability_g7231 &)obj;

  Comparison result;

  if ((result = m_maxAl_sduAudioFrames.Compare(other.m_maxAl_sduAudioFrames)) != EqualTo)
    return result;
  if ((result = m_silenceSuppression.Compare(other.m_silenceSuppression)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_AudioCapability_g7231::GetDataLength() const
{
  PINDEX length = 0;
  length += m_maxAl_sduAudioFrames.GetObjectLength();
  length += m_silenceSuppression.GetObjectLength();
  return length;
}


BOOL H245_AudioCapability_g7231::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_maxAl_sduAudioFrames.Decode(strm))
    return FALSE;
  if (!m_silenceSuppression.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_AudioCapability_g7231::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_maxAl_sduAudioFrames.Encode(strm);
  m_silenceSuppression.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_AudioCapability_g7231::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_AudioCapability_g7231::Class()), PInvalidCast);
#endif
  return new H245_AudioCapability_g7231(*this);
}


//
// G7231AnnexCCapability_g723AnnexCAudioMode
//

H245_G7231AnnexCCapability_g723AnnexCAudioMode::H245_G7231AnnexCCapability_g723AnnexCAudioMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_highRateMode0.SetConstraints(PASN_Object::FixedConstraint, 27, 78);
  m_highRateMode1.SetConstraints(PASN_Object::FixedConstraint, 27, 78);
  m_lowRateMode0.SetConstraints(PASN_Object::FixedConstraint, 23, 66);
  m_lowRateMode1.SetConstraints(PASN_Object::FixedConstraint, 23, 66);
  m_sidMode0.SetConstraints(PASN_Object::FixedConstraint, 6, 17);
  m_sidMode1.SetConstraints(PASN_Object::FixedConstraint, 6, 17);
}


#ifndef PASN_NOPRINTON
void H245_G7231AnnexCCapability_g723AnnexCAudioMode::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "highRateMode0 = " << setprecision(indent) << m_highRateMode0 << '\n';
  strm << setw(indent+16) << "highRateMode1 = " << setprecision(indent) << m_highRateMode1 << '\n';
  strm << setw(indent+15) << "lowRateMode0 = " << setprecision(indent) << m_lowRateMode0 << '\n';
  strm << setw(indent+15) << "lowRateMode1 = " << setprecision(indent) << m_lowRateMode1 << '\n';
  strm << setw(indent+11) << "sidMode0 = " << setprecision(indent) << m_sidMode0 << '\n';
  strm << setw(indent+11) << "sidMode1 = " << setprecision(indent) << m_sidMode1 << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_G7231AnnexCCapability_g723AnnexCAudioMode::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_G7231AnnexCCapability_g723AnnexCAudioMode), PInvalidCast);
#endif
  const H245_G7231AnnexCCapability_g723AnnexCAudioMode & other = (const H245_G7231AnnexCCapability_g723AnnexCAudioMode &)obj;

  Comparison result;

  if ((result = m_highRateMode0.Compare(other.m_highRateMode0)) != EqualTo)
    return result;
  if ((result = m_highRateMode1.Compare(other.m_highRateMode1)) != EqualTo)
    return result;
  if ((result = m_lowRateMode0.Compare(other.m_lowRateMode0)) != EqualTo)
    return result;
  if ((result = m_lowRateMode1.Compare(other.m_lowRateMode1)) != EqualTo)
    return result;
  if ((result = m_sidMode0.Compare(other.m_sidMode0)) != EqualTo)
    return result;
  if ((result = m_sidMode1.Compare(other.m_sidMode1)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_G7231AnnexCCapability_g723AnnexCAudioMode::GetDataLength() const
{
  PINDEX length = 0;
  length += m_highRateMode0.GetObjectLength();
  length += m_highRateMode1.GetObjectLength();
  length += m_lowRateMode0.GetObjectLength();
  length += m_lowRateMode1.GetObjectLength();
  length += m_sidMode0.GetObjectLength();
  length += m_sidMode1.GetObjectLength();
  return length;
}


BOOL H245_G7231AnnexCCapability_g723AnnexCAudioMode::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_highRateMode0.Decode(strm))
    return FALSE;
  if (!m_highRateMode1.Decode(strm))
    return FALSE;
  if (!m_lowRateMode0.Decode(strm))
    return FALSE;
  if (!m_lowRateMode1.Decode(strm))
    return FALSE;
  if (!m_sidMode0.Decode(strm))
    return FALSE;
  if (!m_sidMode1.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_G7231AnnexCCapability_g723AnnexCAudioMode::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_highRateMode0.Encode(strm);
  m_highRateMode1.Encode(strm);
  m_lowRateMode0.Encode(strm);
  m_lowRateMode1.Encode(strm);
  m_sidMode0.Encode(strm);
  m_sidMode1.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_G7231AnnexCCapability_g723AnnexCAudioMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_G7231AnnexCCapability_g723AnnexCAudioMode::Class()), PInvalidCast);
#endif
  return new H245_G7231AnnexCCapability_g723AnnexCAudioMode(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_DataApplicationCapability_application[]={
      {"nonStandard",0}
     ,{"t120",1}
     ,{"dsm_cc",2}
     ,{"userData",3}
     ,{"t84",4}
     ,{"t434",5}
     ,{"h224",6}
     ,{"nlpid",7}
     ,{"dsvdControl",8}
     ,{"h222DataPartitioning",9}
     ,{"t30fax",10}
     ,{"t140",11}
     ,{"t38fax",12}
     ,{"genericDataCapability",13}
};
#endif
//
// DataApplicationCapability_application
//

H245_DataApplicationCapability_application::H245_DataApplicationCapability_application(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 10, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_DataApplicationCapability_application,14
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DataApplicationCapability_application::operator H245_NonStandardParameter &() const
#else
H245_DataApplicationCapability_application::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_DataApplicationCapability_application::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DataApplicationCapability_application::operator H245_DataProtocolCapability &() const
#else
H245_DataApplicationCapability_application::operator H245_DataProtocolCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DataProtocolCapability), PInvalidCast);
#endif
  return *(H245_DataProtocolCapability *)choice;
}


H245_DataApplicationCapability_application::operator const H245_DataProtocolCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DataProtocolCapability), PInvalidCast);
#endif
  return *(H245_DataProtocolCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DataApplicationCapability_application::operator H245_DataApplicationCapability_application_t84 &() const
#else
H245_DataApplicationCapability_application::operator H245_DataApplicationCapability_application_t84 &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DataApplicationCapability_application_t84), PInvalidCast);
#endif
  return *(H245_DataApplicationCapability_application_t84 *)choice;
}


H245_DataApplicationCapability_application::operator const H245_DataApplicationCapability_application_t84 &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DataApplicationCapability_application_t84), PInvalidCast);
#endif
  return *(H245_DataApplicationCapability_application_t84 *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DataApplicationCapability_application::operator H245_DataApplicationCapability_application_nlpid &() const
#else
H245_DataApplicationCapability_application::operator H245_DataApplicationCapability_application_nlpid &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DataApplicationCapability_application_nlpid), PInvalidCast);
#endif
  return *(H245_DataApplicationCapability_application_nlpid *)choice;
}


H245_DataApplicationCapability_application::operator const H245_DataApplicationCapability_application_nlpid &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DataApplicationCapability_application_nlpid), PInvalidCast);
#endif
  return *(H245_DataApplicationCapability_application_nlpid *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DataApplicationCapability_application::operator H245_DataApplicationCapability_application_t38fax &() const
#else
H245_DataApplicationCapability_application::operator H245_DataApplicationCapability_application_t38fax &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DataApplicationCapability_application_t38fax), PInvalidCast);
#endif
  return *(H245_DataApplicationCapability_application_t38fax *)choice;
}


H245_DataApplicationCapability_application::operator const H245_DataApplicationCapability_application_t38fax &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DataApplicationCapability_application_t38fax), PInvalidCast);
#endif
  return *(H245_DataApplicationCapability_application_t38fax *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DataApplicationCapability_application::operator H245_GenericCapability &() const
#else
H245_DataApplicationCapability_application::operator H245_GenericCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_GenericCapability), PInvalidCast);
#endif
  return *(H245_GenericCapability *)choice;
}


H245_DataApplicationCapability_application::operator const H245_GenericCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_GenericCapability), PInvalidCast);
#endif
  return *(H245_GenericCapability *)choice;
}


BOOL H245_DataApplicationCapability_application::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_t120 :
    case e_dsm_cc :
    case e_userData :
    case e_t434 :
    case e_h224 :
    case e_h222DataPartitioning :
    case e_t30fax :
    case e_t140 :
      choice = new H245_DataProtocolCapability();
      return TRUE;
    case e_t84 :
      choice = new H245_DataApplicationCapability_application_t84();
      return TRUE;
    case e_nlpid :
      choice = new H245_DataApplicationCapability_application_nlpid();
      return TRUE;
    case e_dsvdControl :
      choice = new PASN_Null();
      return TRUE;
    case e_t38fax :
      choice = new H245_DataApplicationCapability_application_t38fax();
      return TRUE;
    case e_genericDataCapability :
      choice = new H245_GenericCapability();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_DataApplicationCapability_application::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_DataApplicationCapability_application::Class()), PInvalidCast);
#endif
  return new H245_DataApplicationCapability_application(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_DataProtocolCapability_v76wCompression[]={
      {"transmitCompression",0}
     ,{"receiveCompression",1}
     ,{"transmitAndReceiveCompression",2}
};
#endif
//
// DataProtocolCapability_v76wCompression
//

H245_DataProtocolCapability_v76wCompression::H245_DataProtocolCapability_v76wCompression(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_DataProtocolCapability_v76wCompression,3
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DataProtocolCapability_v76wCompression::operator H245_CompressionType &() const
#else
H245_DataProtocolCapability_v76wCompression::operator H245_CompressionType &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_CompressionType), PInvalidCast);
#endif
  return *(H245_CompressionType *)choice;
}


H245_DataProtocolCapability_v76wCompression::operator const H245_CompressionType &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_CompressionType), PInvalidCast);
#endif
  return *(H245_CompressionType *)choice;
}


BOOL H245_DataProtocolCapability_v76wCompression::CreateObject()
{
  switch (tag) {
    case e_transmitCompression :
    case e_receiveCompression :
    case e_transmitAndReceiveCompression :
      choice = new H245_CompressionType();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_DataProtocolCapability_v76wCompression::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_DataProtocolCapability_v76wCompression::Class()), PInvalidCast);
#endif
  return new H245_DataProtocolCapability_v76wCompression(*this);
}


//
// T84Profile_t84Restricted
//

H245_T84Profile_t84Restricted::H245_T84Profile_t84Restricted(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_T84Profile_t84Restricted::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+7) << "qcif = " << setprecision(indent) << m_qcif << '\n';
  strm << setw(indent+6) << "cif = " << setprecision(indent) << m_cif << '\n';
  strm << setw(indent+13) << "ccir601Seq = " << setprecision(indent) << m_ccir601Seq << '\n';
  strm << setw(indent+14) << "ccir601Prog = " << setprecision(indent) << m_ccir601Prog << '\n';
  strm << setw(indent+10) << "hdtvSeq = " << setprecision(indent) << m_hdtvSeq << '\n';
  strm << setw(indent+11) << "hdtvProg = " << setprecision(indent) << m_hdtvProg << '\n';
  strm << setw(indent+18) << "g3FacsMH200x100 = " << setprecision(indent) << m_g3FacsMH200x100 << '\n';
  strm << setw(indent+18) << "g3FacsMH200x200 = " << setprecision(indent) << m_g3FacsMH200x200 << '\n';
  strm << setw(indent+19) << "g4FacsMMR200x100 = " << setprecision(indent) << m_g4FacsMMR200x100 << '\n';
  strm << setw(indent+19) << "g4FacsMMR200x200 = " << setprecision(indent) << m_g4FacsMMR200x200 << '\n';
  strm << setw(indent+17) << "jbig200x200Seq = " << setprecision(indent) << m_jbig200x200Seq << '\n';
  strm << setw(indent+18) << "jbig200x200Prog = " << setprecision(indent) << m_jbig200x200Prog << '\n';
  strm << setw(indent+17) << "jbig300x300Seq = " << setprecision(indent) << m_jbig300x300Seq << '\n';
  strm << setw(indent+18) << "jbig300x300Prog = " << setprecision(indent) << m_jbig300x300Prog << '\n';
  strm << setw(indent+14) << "digPhotoLow = " << setprecision(indent) << m_digPhotoLow << '\n';
  strm << setw(indent+17) << "digPhotoMedSeq = " << setprecision(indent) << m_digPhotoMedSeq << '\n';
  strm << setw(indent+18) << "digPhotoMedProg = " << setprecision(indent) << m_digPhotoMedProg << '\n';
  strm << setw(indent+18) << "digPhotoHighSeq = " << setprecision(indent) << m_digPhotoHighSeq << '\n';
  strm << setw(indent+19) << "digPhotoHighProg = " << setprecision(indent) << m_digPhotoHighProg << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_T84Profile_t84Restricted::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_T84Profile_t84Restricted), PInvalidCast);
#endif
  const H245_T84Profile_t84Restricted & other = (const H245_T84Profile_t84Restricted &)obj;

  Comparison result;

  if ((result = m_qcif.Compare(other.m_qcif)) != EqualTo)
    return result;
  if ((result = m_cif.Compare(other.m_cif)) != EqualTo)
    return result;
  if ((result = m_ccir601Seq.Compare(other.m_ccir601Seq)) != EqualTo)
    return result;
  if ((result = m_ccir601Prog.Compare(other.m_ccir601Prog)) != EqualTo)
    return result;
  if ((result = m_hdtvSeq.Compare(other.m_hdtvSeq)) != EqualTo)
    return result;
  if ((result = m_hdtvProg.Compare(other.m_hdtvProg)) != EqualTo)
    return result;
  if ((result = m_g3FacsMH200x100.Compare(other.m_g3FacsMH200x100)) != EqualTo)
    return result;
  if ((result = m_g3FacsMH200x200.Compare(other.m_g3FacsMH200x200)) != EqualTo)
    return result;
  if ((result = m_g4FacsMMR200x100.Compare(other.m_g4FacsMMR200x100)) != EqualTo)
    return result;
  if ((result = m_g4FacsMMR200x200.Compare(other.m_g4FacsMMR200x200)) != EqualTo)
    return result;
  if ((result = m_jbig200x200Seq.Compare(other.m_jbig200x200Seq)) != EqualTo)
    return result;
  if ((result = m_jbig200x200Prog.Compare(other.m_jbig200x200Prog)) != EqualTo)
    return result;
  if ((result = m_jbig300x300Seq.Compare(other.m_jbig300x300Seq)) != EqualTo)
    return result;
  if ((result = m_jbig300x300Prog.Compare(other.m_jbig300x300Prog)) != EqualTo)
    return result;
  if ((result = m_digPhotoLow.Compare(other.m_digPhotoLow)) != EqualTo)
    return result;
  if ((result = m_digPhotoMedSeq.Compare(other.m_digPhotoMedSeq)) != EqualTo)
    return result;
  if ((result = m_digPhotoMedProg.Compare(other.m_digPhotoMedProg)) != EqualTo)
    return result;
  if ((result = m_digPhotoHighSeq.Compare(other.m_digPhotoHighSeq)) != EqualTo)
    return result;
  if ((result = m_digPhotoHighProg.Compare(other.m_digPhotoHighProg)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_T84Profile_t84Restricted::GetDataLength() const
{
  PINDEX length = 0;
  length += m_qcif.GetObjectLength();
  length += m_cif.GetObjectLength();
  length += m_ccir601Seq.GetObjectLength();
  length += m_ccir601Prog.GetObjectLength();
  length += m_hdtvSeq.GetObjectLength();
  length += m_hdtvProg.GetObjectLength();
  length += m_g3FacsMH200x100.GetObjectLength();
  length += m_g3FacsMH200x200.GetObjectLength();
  length += m_g4FacsMMR200x100.GetObjectLength();
  length += m_g4FacsMMR200x200.GetObjectLength();
  length += m_jbig200x200Seq.GetObjectLength();
  length += m_jbig200x200Prog.GetObjectLength();
  length += m_jbig300x300Seq.GetObjectLength();
  length += m_jbig300x300Prog.GetObjectLength();
  length += m_digPhotoLow.GetObjectLength();
  length += m_digPhotoMedSeq.GetObjectLength();
  length += m_digPhotoMedProg.GetObjectLength();
  length += m_digPhotoHighSeq.GetObjectLength();
  length += m_digPhotoHighProg.GetObjectLength();
  return length;
}


BOOL H245_T84Profile_t84Restricted::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_qcif.Decode(strm))
    return FALSE;
  if (!m_cif.Decode(strm))
    return FALSE;
  if (!m_ccir601Seq.Decode(strm))
    return FALSE;
  if (!m_ccir601Prog.Decode(strm))
    return FALSE;
  if (!m_hdtvSeq.Decode(strm))
    return FALSE;
  if (!m_hdtvProg.Decode(strm))
    return FALSE;
  if (!m_g3FacsMH200x100.Decode(strm))
    return FALSE;
  if (!m_g3FacsMH200x200.Decode(strm))
    return FALSE;
  if (!m_g4FacsMMR200x100.Decode(strm))
    return FALSE;
  if (!m_g4FacsMMR200x200.Decode(strm))
    return FALSE;
  if (!m_jbig200x200Seq.Decode(strm))
    return FALSE;
  if (!m_jbig200x200Prog.Decode(strm))
    return FALSE;
  if (!m_jbig300x300Seq.Decode(strm))
    return FALSE;
  if (!m_jbig300x300Prog.Decode(strm))
    return FALSE;
  if (!m_digPhotoLow.Decode(strm))
    return FALSE;
  if (!m_digPhotoMedSeq.Decode(strm))
    return FALSE;
  if (!m_digPhotoMedProg.Decode(strm))
    return FALSE;
  if (!m_digPhotoHighSeq.Decode(strm))
    return FALSE;
  if (!m_digPhotoHighProg.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_T84Profile_t84Restricted::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_qcif.Encode(strm);
  m_cif.Encode(strm);
  m_ccir601Seq.Encode(strm);
  m_ccir601Prog.Encode(strm);
  m_hdtvSeq.Encode(strm);
  m_hdtvProg.Encode(strm);
  m_g3FacsMH200x100.Encode(strm);
  m_g3FacsMH200x200.Encode(strm);
  m_g4FacsMMR200x100.Encode(strm);
  m_g4FacsMMR200x200.Encode(strm);
  m_jbig200x200Seq.Encode(strm);
  m_jbig200x200Prog.Encode(strm);
  m_jbig300x300Seq.Encode(strm);
  m_jbig300x300Prog.Encode(strm);
  m_digPhotoLow.Encode(strm);
  m_digPhotoMedSeq.Encode(strm);
  m_digPhotoMedProg.Encode(strm);
  m_digPhotoHighSeq.Encode(strm);
  m_digPhotoHighProg.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_T84Profile_t84Restricted::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_T84Profile_t84Restricted::Class()), PInvalidCast);
#endif
  return new H245_T84Profile_t84Restricted(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_T38FaxUdpOptions_t38FaxUdpEC[]={
      {"t38UDPFEC",0}
     ,{"t38UDPRedundancy",1}
};
#endif
//
// T38FaxUdpOptions_t38FaxUdpEC
//

H245_T38FaxUdpOptions_t38FaxUdpEC::H245_T38FaxUdpOptions_t38FaxUdpEC(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_T38FaxUdpOptions_t38FaxUdpEC,2
#endif
)
{
}


BOOL H245_T38FaxUdpOptions_t38FaxUdpEC::CreateObject()
{
  choice = (tag <= e_t38UDPRedundancy) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_T38FaxUdpOptions_t38FaxUdpEC::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_T38FaxUdpOptions_t38FaxUdpEC::Class()), PInvalidCast);
#endif
  return new H245_T38FaxUdpOptions_t38FaxUdpEC(*this);
}


//
// ArrayOf_NonStandardParameter
//

H245_ArrayOf_NonStandardParameter::H245_ArrayOf_NonStandardParameter(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_NonStandardParameter::CreateObject() const
{
  return new H245_NonStandardParameter;
}


H245_NonStandardParameter & H245_ArrayOf_NonStandardParameter::operator[](PINDEX i) const
{
  return (H245_NonStandardParameter &)array[i];
}


PObject * H245_ArrayOf_NonStandardParameter::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_NonStandardParameter::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_NonStandardParameter(*this);
}


//
// ArrayOf_ParameterIdentifier
//

H245_ArrayOf_ParameterIdentifier::H245_ArrayOf_ParameterIdentifier(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_ParameterIdentifier::CreateObject() const
{
  return new H245_ParameterIdentifier;
}


H245_ParameterIdentifier & H245_ArrayOf_ParameterIdentifier::operator[](PINDEX i) const
{
  return (H245_ParameterIdentifier &)array[i];
}


PObject * H245_ArrayOf_ParameterIdentifier::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_ParameterIdentifier::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_ParameterIdentifier(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_FECCapability_rfc2733Format[]={
      {"rfc2733rfc2198",0}
     ,{"rfc2733sameport",1}
     ,{"rfc2733diffport",2}
};
#endif
//
// FECCapability_rfc2733Format
//

H245_FECCapability_rfc2733Format::H245_FECCapability_rfc2733Format(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_FECCapability_rfc2733Format,3
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_FECCapability_rfc2733Format::operator H245_MaxRedundancy &() const
#else
H245_FECCapability_rfc2733Format::operator H245_MaxRedundancy &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MaxRedundancy), PInvalidCast);
#endif
  return *(H245_MaxRedundancy *)choice;
}


H245_FECCapability_rfc2733Format::operator const H245_MaxRedundancy &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MaxRedundancy), PInvalidCast);
#endif
  return *(H245_MaxRedundancy *)choice;
}


BOOL H245_FECCapability_rfc2733Format::CreateObject()
{
  switch (tag) {
    case e_rfc2733rfc2198 :
    case e_rfc2733sameport :
    case e_rfc2733diffport :
      choice = new H245_MaxRedundancy();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_FECCapability_rfc2733Format::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_FECCapability_rfc2733Format::Class()), PInvalidCast);
#endif
  return new H245_FECCapability_rfc2733Format(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_NetworkAccessParameters_distribution[]={
      {"unicast",0}
     ,{"multicast",1}
};
#endif
//
// NetworkAccessParameters_distribution
//

H245_NetworkAccessParameters_distribution::H245_NetworkAccessParameters_distribution(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_NetworkAccessParameters_distribution,2
#endif
)
{
}


BOOL H245_NetworkAccessParameters_distribution::CreateObject()
{
  choice = (tag <= e_multicast) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_NetworkAccessParameters_distribution::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NetworkAccessParameters_distribution::Class()), PInvalidCast);
#endif
  return new H245_NetworkAccessParameters_distribution(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_NetworkAccessParameters_networkAddress[]={
      {"q2931Address",0}
     ,{"e164Address",1}
     ,{"localAreaAddress",2}
};
#endif
//
// NetworkAccessParameters_networkAddress
//

H245_NetworkAccessParameters_networkAddress::H245_NetworkAccessParameters_networkAddress(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_NetworkAccessParameters_networkAddress,3
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_NetworkAccessParameters_networkAddress::operator H245_Q2931Address &() const
#else
H245_NetworkAccessParameters_networkAddress::operator H245_Q2931Address &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_Q2931Address), PInvalidCast);
#endif
  return *(H245_Q2931Address *)choice;
}


H245_NetworkAccessParameters_networkAddress::operator const H245_Q2931Address &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_Q2931Address), PInvalidCast);
#endif
  return *(H245_Q2931Address *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_NetworkAccessParameters_networkAddress::operator H245_TransportAddress &() const
#else
H245_NetworkAccessParameters_networkAddress::operator H245_TransportAddress &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_TransportAddress), PInvalidCast);
#endif
  return *(H245_TransportAddress *)choice;
}


H245_NetworkAccessParameters_networkAddress::operator const H245_TransportAddress &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_TransportAddress), PInvalidCast);
#endif
  return *(H245_TransportAddress *)choice;
}


BOOL H245_NetworkAccessParameters_networkAddress::CreateObject()
{
  switch (tag) {
    case e_q2931Address :
      choice = new H245_Q2931Address();
      return TRUE;
    case e_e164Address :
      choice = new PASN_IA5String();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 128);
      choice->SetCharacterSet(PASN_Object::FixedConstraint, "0123456789#*,");
      return TRUE;
    case e_localAreaAddress :
      choice = new H245_TransportAddress();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_NetworkAccessParameters_networkAddress::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NetworkAccessParameters_networkAddress::Class()), PInvalidCast);
#endif
  return new H245_NetworkAccessParameters_networkAddress(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_NetworkAccessParameters_t120SetupProcedure[]={
      {"originateCall",0}
     ,{"waitForCall",1}
     ,{"issueQuery",2}
};
#endif
//
// NetworkAccessParameters_t120SetupProcedure
//

H245_NetworkAccessParameters_t120SetupProcedure::H245_NetworkAccessParameters_t120SetupProcedure(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_NetworkAccessParameters_t120SetupProcedure,3
#endif
)
{
}


BOOL H245_NetworkAccessParameters_t120SetupProcedure::CreateObject()
{
  choice = (tag <= e_issueQuery) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_NetworkAccessParameters_t120SetupProcedure::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NetworkAccessParameters_t120SetupProcedure::Class()), PInvalidCast);
#endif
  return new H245_NetworkAccessParameters_t120SetupProcedure(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_Q2931Address_address[]={
      {"internationalNumber",0}
     ,{"nsapAddress",1}
};
#endif
//
// Q2931Address_address
//

H245_Q2931Address_address::H245_Q2931Address_address(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_Q2931Address_address,2
#endif
)
{
}


BOOL H245_Q2931Address_address::CreateObject()
{
  switch (tag) {
    case e_internationalNumber :
      choice = new PASN_NumericString();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 16);
      return TRUE;
    case e_nsapAddress :
      choice = new PASN_OctetString();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 20);
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_Q2931Address_address::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_Q2931Address_address::Class()), PInvalidCast);
#endif
  return new H245_Q2931Address_address(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_H235Media_mediaType[]={
      {"nonStandard",0}
     ,{"videoData",1}
     ,{"audioData",2}
     ,{"data",3}
     ,{"redundancyEncoding",4}
     ,{"multiplePayloadStream",5}
     ,{"depFec",6}
     ,{"fec",7}
};
#endif
//
// H235Media_mediaType
//

H245_H235Media_mediaType::H245_H235Media_mediaType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_H235Media_mediaType,8
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H235Media_mediaType::operator H245_NonStandardParameter &() const
#else
H245_H235Media_mediaType::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_H235Media_mediaType::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H235Media_mediaType::operator H245_VideoCapability &() const
#else
H245_H235Media_mediaType::operator H245_VideoCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_VideoCapability), PInvalidCast);
#endif
  return *(H245_VideoCapability *)choice;
}


H245_H235Media_mediaType::operator const H245_VideoCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_VideoCapability), PInvalidCast);
#endif
  return *(H245_VideoCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H235Media_mediaType::operator H245_AudioCapability &() const
#else
H245_H235Media_mediaType::operator H245_AudioCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_AudioCapability), PInvalidCast);
#endif
  return *(H245_AudioCapability *)choice;
}


H245_H235Media_mediaType::operator const H245_AudioCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_AudioCapability), PInvalidCast);
#endif
  return *(H245_AudioCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H235Media_mediaType::operator H245_DataApplicationCapability &() const
#else
H245_H235Media_mediaType::operator H245_DataApplicationCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DataApplicationCapability), PInvalidCast);
#endif
  return *(H245_DataApplicationCapability *)choice;
}


H245_H235Media_mediaType::operator const H245_DataApplicationCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DataApplicationCapability), PInvalidCast);
#endif
  return *(H245_DataApplicationCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H235Media_mediaType::operator H245_RedundancyEncoding &() const
#else
H245_H235Media_mediaType::operator H245_RedundancyEncoding &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RedundancyEncoding), PInvalidCast);
#endif
  return *(H245_RedundancyEncoding *)choice;
}


H245_H235Media_mediaType::operator const H245_RedundancyEncoding &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RedundancyEncoding), PInvalidCast);
#endif
  return *(H245_RedundancyEncoding *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H235Media_mediaType::operator H245_MultiplePayloadStream &() const
#else
H245_H235Media_mediaType::operator H245_MultiplePayloadStream &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultiplePayloadStream), PInvalidCast);
#endif
  return *(H245_MultiplePayloadStream *)choice;
}


H245_H235Media_mediaType::operator const H245_MultiplePayloadStream &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultiplePayloadStream), PInvalidCast);
#endif
  return *(H245_MultiplePayloadStream *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H235Media_mediaType::operator H245_DepFECData &() const
#else
H245_H235Media_mediaType::operator H245_DepFECData &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DepFECData), PInvalidCast);
#endif
  return *(H245_DepFECData *)choice;
}


H245_H235Media_mediaType::operator const H245_DepFECData &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DepFECData), PInvalidCast);
#endif
  return *(H245_DepFECData *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H235Media_mediaType::operator H245_FECData &() const
#else
H245_H235Media_mediaType::operator H245_FECData &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_FECData), PInvalidCast);
#endif
  return *(H245_FECData *)choice;
}


H245_H235Media_mediaType::operator const H245_FECData &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_FECData), PInvalidCast);
#endif
  return *(H245_FECData *)choice;
}


BOOL H245_H235Media_mediaType::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_videoData :
      choice = new H245_VideoCapability();
      return TRUE;
    case e_audioData :
      choice = new H245_AudioCapability();
      return TRUE;
    case e_data :
      choice = new H245_DataApplicationCapability();
      return TRUE;
    case e_redundancyEncoding :
      choice = new H245_RedundancyEncoding();
      return TRUE;
    case e_multiplePayloadStream :
      choice = new H245_MultiplePayloadStream();
      return TRUE;
    case e_depFec :
      choice = new H245_DepFECData();
      return TRUE;
    case e_fec :
      choice = new H245_FECData();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_H235Media_mediaType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H235Media_mediaType::Class()), PInvalidCast);
#endif
  return new H245_H235Media_mediaType(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_H223LogicalChannelParameters_adaptationLayerType[]={
      {"nonStandard",0}
     ,{"al1Framed",1}
     ,{"al1NotFramed",2}
     ,{"al2WithoutSequenceNumbers",3}
     ,{"al2WithSequenceNumbers",4}
     ,{"al3",5}
     ,{"al1M",6}
     ,{"al2M",7}
     ,{"al3M",8}
};
#endif
//
// H223LogicalChannelParameters_adaptationLayerType
//

H245_H223LogicalChannelParameters_adaptationLayerType::H245_H223LogicalChannelParameters_adaptationLayerType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 6, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_H223LogicalChannelParameters_adaptationLayerType,9
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H223LogicalChannelParameters_adaptationLayerType::operator H245_NonStandardParameter &() const
#else
H245_H223LogicalChannelParameters_adaptationLayerType::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_H223LogicalChannelParameters_adaptationLayerType::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H223LogicalChannelParameters_adaptationLayerType::operator H245_H223LogicalChannelParameters_adaptationLayerType_al3 &() const
#else
H245_H223LogicalChannelParameters_adaptationLayerType::operator H245_H223LogicalChannelParameters_adaptationLayerType_al3 &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H223LogicalChannelParameters_adaptationLayerType_al3), PInvalidCast);
#endif
  return *(H245_H223LogicalChannelParameters_adaptationLayerType_al3 *)choice;
}


H245_H223LogicalChannelParameters_adaptationLayerType::operator const H245_H223LogicalChannelParameters_adaptationLayerType_al3 &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H223LogicalChannelParameters_adaptationLayerType_al3), PInvalidCast);
#endif
  return *(H245_H223LogicalChannelParameters_adaptationLayerType_al3 *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H223LogicalChannelParameters_adaptationLayerType::operator H245_H223AL1MParameters &() const
#else
H245_H223LogicalChannelParameters_adaptationLayerType::operator H245_H223AL1MParameters &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H223AL1MParameters), PInvalidCast);
#endif
  return *(H245_H223AL1MParameters *)choice;
}


H245_H223LogicalChannelParameters_adaptationLayerType::operator const H245_H223AL1MParameters &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H223AL1MParameters), PInvalidCast);
#endif
  return *(H245_H223AL1MParameters *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H223LogicalChannelParameters_adaptationLayerType::operator H245_H223AL2MParameters &() const
#else
H245_H223LogicalChannelParameters_adaptationLayerType::operator H245_H223AL2MParameters &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H223AL2MParameters), PInvalidCast);
#endif
  return *(H245_H223AL2MParameters *)choice;
}


H245_H223LogicalChannelParameters_adaptationLayerType::operator const H245_H223AL2MParameters &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H223AL2MParameters), PInvalidCast);
#endif
  return *(H245_H223AL2MParameters *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H223LogicalChannelParameters_adaptationLayerType::operator H245_H223AL3MParameters &() const
#else
H245_H223LogicalChannelParameters_adaptationLayerType::operator H245_H223AL3MParameters &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H223AL3MParameters), PInvalidCast);
#endif
  return *(H245_H223AL3MParameters *)choice;
}


H245_H223LogicalChannelParameters_adaptationLayerType::operator const H245_H223AL3MParameters &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H223AL3MParameters), PInvalidCast);
#endif
  return *(H245_H223AL3MParameters *)choice;
}


BOOL H245_H223LogicalChannelParameters_adaptationLayerType::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_al1Framed :
    case e_al1NotFramed :
    case e_al2WithoutSequenceNumbers :
    case e_al2WithSequenceNumbers :
      choice = new PASN_Null();
      return TRUE;
    case e_al3 :
      choice = new H245_H223LogicalChannelParameters_adaptationLayerType_al3();
      return TRUE;
    case e_al1M :
      choice = new H245_H223AL1MParameters();
      return TRUE;
    case e_al2M :
      choice = new H245_H223AL2MParameters();
      return TRUE;
    case e_al3M :
      choice = new H245_H223AL3MParameters();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_H223LogicalChannelParameters_adaptationLayerType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223LogicalChannelParameters_adaptationLayerType::Class()), PInvalidCast);
#endif
  return new H245_H223LogicalChannelParameters_adaptationLayerType(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_H223AL1MParameters_transferMode[]={
      {"framed",0}
     ,{"unframed",1}
};
#endif
//
// H223AL1MParameters_transferMode
//

H245_H223AL1MParameters_transferMode::H245_H223AL1MParameters_transferMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_H223AL1MParameters_transferMode,2
#endif
)
{
}


BOOL H245_H223AL1MParameters_transferMode::CreateObject()
{
  choice = (tag <= e_unframed) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_H223AL1MParameters_transferMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223AL1MParameters_transferMode::Class()), PInvalidCast);
#endif
  return new H245_H223AL1MParameters_transferMode(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_H223AL1MParameters_headerFEC[]={
      {"sebch16_7",0}
     ,{"golay24_12",1}
};
#endif
//
// H223AL1MParameters_headerFEC
//

H245_H223AL1MParameters_headerFEC::H245_H223AL1MParameters_headerFEC(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_H223AL1MParameters_headerFEC,2
#endif
)
{
}


BOOL H245_H223AL1MParameters_headerFEC::CreateObject()
{
  choice = (tag <= e_golay24_12) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_H223AL1MParameters_headerFEC::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223AL1MParameters_headerFEC::Class()), PInvalidCast);
#endif
  return new H245_H223AL1MParameters_headerFEC(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_H223AL1MParameters_crcLength[]={
      {"crc4bit",0}
     ,{"crc12bit",1}
     ,{"crc20bit",2}
     ,{"crc28bit",3}
     ,{"crc8bit",4}
     ,{"crc16bit",5}
     ,{"crc32bit",6}
     ,{"crcNotUsed",7}
};
#endif
//
// H223AL1MParameters_crcLength
//

H245_H223AL1MParameters_crcLength::H245_H223AL1MParameters_crcLength(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_H223AL1MParameters_crcLength,8
#endif
)
{
}


BOOL H245_H223AL1MParameters_crcLength::CreateObject()
{
  choice = (tag <= e_crcNotUsed) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_H223AL1MParameters_crcLength::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223AL1MParameters_crcLength::Class()), PInvalidCast);
#endif
  return new H245_H223AL1MParameters_crcLength(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_H223AL1MParameters_arqType[]={
      {"noArq",0}
     ,{"typeIArq",1}
     ,{"typeIIArq",2}
};
#endif
//
// H223AL1MParameters_arqType
//

H245_H223AL1MParameters_arqType::H245_H223AL1MParameters_arqType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_H223AL1MParameters_arqType,3
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H223AL1MParameters_arqType::operator H245_H223AnnexCArqParameters &() const
#else
H245_H223AL1MParameters_arqType::operator H245_H223AnnexCArqParameters &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H223AnnexCArqParameters), PInvalidCast);
#endif
  return *(H245_H223AnnexCArqParameters *)choice;
}


H245_H223AL1MParameters_arqType::operator const H245_H223AnnexCArqParameters &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H223AnnexCArqParameters), PInvalidCast);
#endif
  return *(H245_H223AnnexCArqParameters *)choice;
}


BOOL H245_H223AL1MParameters_arqType::CreateObject()
{
  switch (tag) {
    case e_noArq :
      choice = new PASN_Null();
      return TRUE;
    case e_typeIArq :
    case e_typeIIArq :
      choice = new H245_H223AnnexCArqParameters();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_H223AL1MParameters_arqType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223AL1MParameters_arqType::Class()), PInvalidCast);
#endif
  return new H245_H223AL1MParameters_arqType(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_H223AL2MParameters_headerFEC[]={
      {"sebch16_5",0}
     ,{"golay24_12",1}
};
#endif
//
// H223AL2MParameters_headerFEC
//

H245_H223AL2MParameters_headerFEC::H245_H223AL2MParameters_headerFEC(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_H223AL2MParameters_headerFEC,2
#endif
)
{
}


BOOL H245_H223AL2MParameters_headerFEC::CreateObject()
{
  choice = (tag <= e_golay24_12) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_H223AL2MParameters_headerFEC::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223AL2MParameters_headerFEC::Class()), PInvalidCast);
#endif
  return new H245_H223AL2MParameters_headerFEC(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_H223AL3MParameters_headerFormat[]={
      {"sebch16_7",0}
     ,{"golay24_12",1}
};
#endif
//
// H223AL3MParameters_headerFormat
//

H245_H223AL3MParameters_headerFormat::H245_H223AL3MParameters_headerFormat(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_H223AL3MParameters_headerFormat,2
#endif
)
{
}


BOOL H245_H223AL3MParameters_headerFormat::CreateObject()
{
  choice = (tag <= e_golay24_12) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_H223AL3MParameters_headerFormat::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223AL3MParameters_headerFormat::Class()), PInvalidCast);
#endif
  return new H245_H223AL3MParameters_headerFormat(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_H223AL3MParameters_crcLength[]={
      {"crc4bit",0}
     ,{"crc12bit",1}
     ,{"crc20bit",2}
     ,{"crc28bit",3}
     ,{"crc8bit",4}
     ,{"crc16bit",5}
     ,{"crc32bit",6}
     ,{"crcNotUsed",7}
};
#endif
//
// H223AL3MParameters_crcLength
//

H245_H223AL3MParameters_crcLength::H245_H223AL3MParameters_crcLength(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_H223AL3MParameters_crcLength,8
#endif
)
{
}


BOOL H245_H223AL3MParameters_crcLength::CreateObject()
{
  choice = (tag <= e_crcNotUsed) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_H223AL3MParameters_crcLength::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223AL3MParameters_crcLength::Class()), PInvalidCast);
#endif
  return new H245_H223AL3MParameters_crcLength(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_H223AL3MParameters_arqType[]={
      {"noArq",0}
     ,{"typeIArq",1}
     ,{"typeIIArq",2}
};
#endif
//
// H223AL3MParameters_arqType
//

H245_H223AL3MParameters_arqType::H245_H223AL3MParameters_arqType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_H223AL3MParameters_arqType,3
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H223AL3MParameters_arqType::operator H245_H223AnnexCArqParameters &() const
#else
H245_H223AL3MParameters_arqType::operator H245_H223AnnexCArqParameters &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H223AnnexCArqParameters), PInvalidCast);
#endif
  return *(H245_H223AnnexCArqParameters *)choice;
}


H245_H223AL3MParameters_arqType::operator const H245_H223AnnexCArqParameters &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H223AnnexCArqParameters), PInvalidCast);
#endif
  return *(H245_H223AnnexCArqParameters *)choice;
}


BOOL H245_H223AL3MParameters_arqType::CreateObject()
{
  switch (tag) {
    case e_noArq :
      choice = new PASN_Null();
      return TRUE;
    case e_typeIArq :
    case e_typeIIArq :
      choice = new H245_H223AnnexCArqParameters();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_H223AL3MParameters_arqType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223AL3MParameters_arqType::Class()), PInvalidCast);
#endif
  return new H245_H223AL3MParameters_arqType(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_H223AnnexCArqParameters_numberOfRetransmissions[]={
      {"finite",0}
     ,{"infinite",1}
};
#endif
//
// H223AnnexCArqParameters_numberOfRetransmissions
//

H245_H223AnnexCArqParameters_numberOfRetransmissions::H245_H223AnnexCArqParameters_numberOfRetransmissions(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_H223AnnexCArqParameters_numberOfRetransmissions,2
#endif
)
{
}


BOOL H245_H223AnnexCArqParameters_numberOfRetransmissions::CreateObject()
{
  switch (tag) {
    case e_finite :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 0, 16);
      return TRUE;
    case e_infinite :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_H223AnnexCArqParameters_numberOfRetransmissions::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223AnnexCArqParameters_numberOfRetransmissions::Class()), PInvalidCast);
#endif
  return new H245_H223AnnexCArqParameters_numberOfRetransmissions(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_V76LogicalChannelParameters_suspendResume[]={
      {"noSuspendResume",0}
     ,{"suspendResumewAddress",1}
     ,{"suspendResumewoAddress",2}
};
#endif
//
// V76LogicalChannelParameters_suspendResume
//

H245_V76LogicalChannelParameters_suspendResume::H245_V76LogicalChannelParameters_suspendResume(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_V76LogicalChannelParameters_suspendResume,3
#endif
)
{
}


BOOL H245_V76LogicalChannelParameters_suspendResume::CreateObject()
{
  choice = (tag <= e_suspendResumewoAddress) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_V76LogicalChannelParameters_suspendResume::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_V76LogicalChannelParameters_suspendResume::Class()), PInvalidCast);
#endif
  return new H245_V76LogicalChannelParameters_suspendResume(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_V76LogicalChannelParameters_mode[]={
      {"eRM",0}
     ,{"uNERM",1}
};
#endif
//
// V76LogicalChannelParameters_mode
//

H245_V76LogicalChannelParameters_mode::H245_V76LogicalChannelParameters_mode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_V76LogicalChannelParameters_mode,2
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_V76LogicalChannelParameters_mode::operator H245_V76LogicalChannelParameters_mode_eRM &() const
#else
H245_V76LogicalChannelParameters_mode::operator H245_V76LogicalChannelParameters_mode_eRM &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_V76LogicalChannelParameters_mode_eRM), PInvalidCast);
#endif
  return *(H245_V76LogicalChannelParameters_mode_eRM *)choice;
}


H245_V76LogicalChannelParameters_mode::operator const H245_V76LogicalChannelParameters_mode_eRM &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_V76LogicalChannelParameters_mode_eRM), PInvalidCast);
#endif
  return *(H245_V76LogicalChannelParameters_mode_eRM *)choice;
}


BOOL H245_V76LogicalChannelParameters_mode::CreateObject()
{
  switch (tag) {
    case e_eRM :
      choice = new H245_V76LogicalChannelParameters_mode_eRM();
      return TRUE;
    case e_uNERM :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_V76LogicalChannelParameters_mode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_V76LogicalChannelParameters_mode::Class()), PInvalidCast);
#endif
  return new H245_V76LogicalChannelParameters_mode(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_H2250LogicalChannelParameters_mediaPacketization[]={
      {"h261aVideoPacketization",0}
     ,{"rtpPayloadType",1}
};
#endif
//
// H2250LogicalChannelParameters_mediaPacketization
//

H245_H2250LogicalChannelParameters_mediaPacketization::H245_H2250LogicalChannelParameters_mediaPacketization(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 1, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_H2250LogicalChannelParameters_mediaPacketization,2
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H2250LogicalChannelParameters_mediaPacketization::operator H245_RTPPayloadType &() const
#else
H245_H2250LogicalChannelParameters_mediaPacketization::operator H245_RTPPayloadType &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RTPPayloadType), PInvalidCast);
#endif
  return *(H245_RTPPayloadType *)choice;
}


H245_H2250LogicalChannelParameters_mediaPacketization::operator const H245_RTPPayloadType &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_RTPPayloadType), PInvalidCast);
#endif
  return *(H245_RTPPayloadType *)choice;
}


BOOL H245_H2250LogicalChannelParameters_mediaPacketization::CreateObject()
{
  switch (tag) {
    case e_h261aVideoPacketization :
      choice = new PASN_Null();
      return TRUE;
    case e_rtpPayloadType :
      choice = new H245_RTPPayloadType();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_H2250LogicalChannelParameters_mediaPacketization::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H2250LogicalChannelParameters_mediaPacketization::Class()), PInvalidCast);
#endif
  return new H245_H2250LogicalChannelParameters_mediaPacketization(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_RTPPayloadType_payloadDescriptor[]={
      {"nonStandardIdentifier",0}
     ,{"rfc_number",1}
     ,{"oid",2}
};
#endif
//
// RTPPayloadType_payloadDescriptor
//

H245_RTPPayloadType_payloadDescriptor::H245_RTPPayloadType_payloadDescriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_RTPPayloadType_payloadDescriptor,3
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RTPPayloadType_payloadDescriptor::operator H245_NonStandardParameter &() const
#else
H245_RTPPayloadType_payloadDescriptor::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_RTPPayloadType_payloadDescriptor::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


BOOL H245_RTPPayloadType_payloadDescriptor::CreateObject()
{
  switch (tag) {
    case e_nonStandardIdentifier :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_rfc_number :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::ExtendableConstraint, 1, 32768);
      return TRUE;
    case e_oid :
      choice = new PASN_ObjectId();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_RTPPayloadType_payloadDescriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RTPPayloadType_payloadDescriptor::Class()), PInvalidCast);
#endif
  return new H245_RTPPayloadType_payloadDescriptor(*this);
}


//
// ArrayOf_MultiplePayloadStreamElement
//

H245_ArrayOf_MultiplePayloadStreamElement::H245_ArrayOf_MultiplePayloadStreamElement(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_MultiplePayloadStreamElement::CreateObject() const
{
  return new H245_MultiplePayloadStreamElement;
}


H245_MultiplePayloadStreamElement & H245_ArrayOf_MultiplePayloadStreamElement::operator[](PINDEX i) const
{
  return (H245_MultiplePayloadStreamElement &)array[i];
}


PObject * H245_ArrayOf_MultiplePayloadStreamElement::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_MultiplePayloadStreamElement::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_MultiplePayloadStreamElement(*this);
}


//
// UnicastAddress_iPAddress
//

H245_UnicastAddress_iPAddress::H245_UnicastAddress_iPAddress(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_network.SetConstraints(PASN_Object::FixedConstraint, 4);
  m_tsapIdentifier.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void H245_UnicastAddress_iPAddress::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+10) << "network = " << setprecision(indent) << m_network << '\n';
  strm << setw(indent+17) << "tsapIdentifier = " << setprecision(indent) << m_tsapIdentifier << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_UnicastAddress_iPAddress::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_UnicastAddress_iPAddress), PInvalidCast);
#endif
  const H245_UnicastAddress_iPAddress & other = (const H245_UnicastAddress_iPAddress &)obj;

  Comparison result;

  if ((result = m_network.Compare(other.m_network)) != EqualTo)
    return result;
  if ((result = m_tsapIdentifier.Compare(other.m_tsapIdentifier)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_UnicastAddress_iPAddress::GetDataLength() const
{
  PINDEX length = 0;
  length += m_network.GetObjectLength();
  length += m_tsapIdentifier.GetObjectLength();
  return length;
}


BOOL H245_UnicastAddress_iPAddress::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_network.Decode(strm))
    return FALSE;
  if (!m_tsapIdentifier.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_UnicastAddress_iPAddress::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_network.Encode(strm);
  m_tsapIdentifier.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_UnicastAddress_iPAddress::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_UnicastAddress_iPAddress::Class()), PInvalidCast);
#endif
  return new H245_UnicastAddress_iPAddress(*this);
}


//
// UnicastAddress_iPXAddress
//

H245_UnicastAddress_iPXAddress::H245_UnicastAddress_iPXAddress(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_node.SetConstraints(PASN_Object::FixedConstraint, 6);
  m_netnum.SetConstraints(PASN_Object::FixedConstraint, 4);
  m_tsapIdentifier.SetConstraints(PASN_Object::FixedConstraint, 2);
}


#ifndef PASN_NOPRINTON
void H245_UnicastAddress_iPXAddress::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+7) << "node = " << setprecision(indent) << m_node << '\n';
  strm << setw(indent+9) << "netnum = " << setprecision(indent) << m_netnum << '\n';
  strm << setw(indent+17) << "tsapIdentifier = " << setprecision(indent) << m_tsapIdentifier << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_UnicastAddress_iPXAddress::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_UnicastAddress_iPXAddress), PInvalidCast);
#endif
  const H245_UnicastAddress_iPXAddress & other = (const H245_UnicastAddress_iPXAddress &)obj;

  Comparison result;

  if ((result = m_node.Compare(other.m_node)) != EqualTo)
    return result;
  if ((result = m_netnum.Compare(other.m_netnum)) != EqualTo)
    return result;
  if ((result = m_tsapIdentifier.Compare(other.m_tsapIdentifier)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_UnicastAddress_iPXAddress::GetDataLength() const
{
  PINDEX length = 0;
  length += m_node.GetObjectLength();
  length += m_netnum.GetObjectLength();
  length += m_tsapIdentifier.GetObjectLength();
  return length;
}


BOOL H245_UnicastAddress_iPXAddress::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_node.Decode(strm))
    return FALSE;
  if (!m_netnum.Decode(strm))
    return FALSE;
  if (!m_tsapIdentifier.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_UnicastAddress_iPXAddress::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_node.Encode(strm);
  m_netnum.Encode(strm);
  m_tsapIdentifier.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_UnicastAddress_iPXAddress::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_UnicastAddress_iPXAddress::Class()), PInvalidCast);
#endif
  return new H245_UnicastAddress_iPXAddress(*this);
}


//
// UnicastAddress_iP6Address
//

H245_UnicastAddress_iP6Address::H245_UnicastAddress_iP6Address(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_network.SetConstraints(PASN_Object::FixedConstraint, 16);
  m_tsapIdentifier.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void H245_UnicastAddress_iP6Address::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+10) << "network = " << setprecision(indent) << m_network << '\n';
  strm << setw(indent+17) << "tsapIdentifier = " << setprecision(indent) << m_tsapIdentifier << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_UnicastAddress_iP6Address::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_UnicastAddress_iP6Address), PInvalidCast);
#endif
  const H245_UnicastAddress_iP6Address & other = (const H245_UnicastAddress_iP6Address &)obj;

  Comparison result;

  if ((result = m_network.Compare(other.m_network)) != EqualTo)
    return result;
  if ((result = m_tsapIdentifier.Compare(other.m_tsapIdentifier)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_UnicastAddress_iP6Address::GetDataLength() const
{
  PINDEX length = 0;
  length += m_network.GetObjectLength();
  length += m_tsapIdentifier.GetObjectLength();
  return length;
}


BOOL H245_UnicastAddress_iP6Address::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_network.Decode(strm))
    return FALSE;
  if (!m_tsapIdentifier.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_UnicastAddress_iP6Address::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_network.Encode(strm);
  m_tsapIdentifier.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_UnicastAddress_iP6Address::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_UnicastAddress_iP6Address::Class()), PInvalidCast);
#endif
  return new H245_UnicastAddress_iP6Address(*this);
}


//
// MulticastAddress_iPAddress
//

H245_MulticastAddress_iPAddress::H245_MulticastAddress_iPAddress(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_network.SetConstraints(PASN_Object::FixedConstraint, 4);
  m_tsapIdentifier.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void H245_MulticastAddress_iPAddress::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+10) << "network = " << setprecision(indent) << m_network << '\n';
  strm << setw(indent+17) << "tsapIdentifier = " << setprecision(indent) << m_tsapIdentifier << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MulticastAddress_iPAddress::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MulticastAddress_iPAddress), PInvalidCast);
#endif
  const H245_MulticastAddress_iPAddress & other = (const H245_MulticastAddress_iPAddress &)obj;

  Comparison result;

  if ((result = m_network.Compare(other.m_network)) != EqualTo)
    return result;
  if ((result = m_tsapIdentifier.Compare(other.m_tsapIdentifier)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MulticastAddress_iPAddress::GetDataLength() const
{
  PINDEX length = 0;
  length += m_network.GetObjectLength();
  length += m_tsapIdentifier.GetObjectLength();
  return length;
}


BOOL H245_MulticastAddress_iPAddress::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_network.Decode(strm))
    return FALSE;
  if (!m_tsapIdentifier.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MulticastAddress_iPAddress::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_network.Encode(strm);
  m_tsapIdentifier.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MulticastAddress_iPAddress::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MulticastAddress_iPAddress::Class()), PInvalidCast);
#endif
  return new H245_MulticastAddress_iPAddress(*this);
}


//
// MulticastAddress_iP6Address
//

H245_MulticastAddress_iP6Address::H245_MulticastAddress_iP6Address(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_network.SetConstraints(PASN_Object::FixedConstraint, 16);
  m_tsapIdentifier.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void H245_MulticastAddress_iP6Address::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+10) << "network = " << setprecision(indent) << m_network << '\n';
  strm << setw(indent+17) << "tsapIdentifier = " << setprecision(indent) << m_tsapIdentifier << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MulticastAddress_iP6Address::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MulticastAddress_iP6Address), PInvalidCast);
#endif
  const H245_MulticastAddress_iP6Address & other = (const H245_MulticastAddress_iP6Address &)obj;

  Comparison result;

  if ((result = m_network.Compare(other.m_network)) != EqualTo)
    return result;
  if ((result = m_tsapIdentifier.Compare(other.m_tsapIdentifier)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MulticastAddress_iP6Address::GetDataLength() const
{
  PINDEX length = 0;
  length += m_network.GetObjectLength();
  length += m_tsapIdentifier.GetObjectLength();
  return length;
}


BOOL H245_MulticastAddress_iP6Address::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_network.Decode(strm))
    return FALSE;
  if (!m_tsapIdentifier.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MulticastAddress_iP6Address::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_network.Encode(strm);
  m_tsapIdentifier.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MulticastAddress_iP6Address::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MulticastAddress_iP6Address::Class()), PInvalidCast);
#endif
  return new H245_MulticastAddress_iP6Address(*this);
}


//
// ArrayOf_EscrowData
//

H245_ArrayOf_EscrowData::H245_ArrayOf_EscrowData(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_EscrowData::CreateObject() const
{
  return new H245_EscrowData;
}


H245_EscrowData & H245_ArrayOf_EscrowData::operator[](PINDEX i) const
{
  return (H245_EscrowData &)array[i];
}


PObject * H245_ArrayOf_EscrowData::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_EscrowData::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_EscrowData(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_OpenLogicalChannelAck_forwardMultiplexAckParameters[]={
      {"h2250LogicalChannelAckParameters",0}
};
#endif
//
// OpenLogicalChannelAck_forwardMultiplexAckParameters
//

H245_OpenLogicalChannelAck_forwardMultiplexAckParameters::H245_OpenLogicalChannelAck_forwardMultiplexAckParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 1, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_OpenLogicalChannelAck_forwardMultiplexAckParameters,1
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_OpenLogicalChannelAck_forwardMultiplexAckParameters::operator H245_H2250LogicalChannelAckParameters &() const
#else
H245_OpenLogicalChannelAck_forwardMultiplexAckParameters::operator H245_H2250LogicalChannelAckParameters &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H2250LogicalChannelAckParameters), PInvalidCast);
#endif
  return *(H245_H2250LogicalChannelAckParameters *)choice;
}


H245_OpenLogicalChannelAck_forwardMultiplexAckParameters::operator const H245_H2250LogicalChannelAckParameters &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H2250LogicalChannelAckParameters), PInvalidCast);
#endif
  return *(H245_H2250LogicalChannelAckParameters *)choice;
}


BOOL H245_OpenLogicalChannelAck_forwardMultiplexAckParameters::CreateObject()
{
  switch (tag) {
    case e_h2250LogicalChannelAckParameters :
      choice = new H245_H2250LogicalChannelAckParameters();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_OpenLogicalChannelAck_forwardMultiplexAckParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_OpenLogicalChannelAck_forwardMultiplexAckParameters::Class()), PInvalidCast);
#endif
  return new H245_OpenLogicalChannelAck_forwardMultiplexAckParameters(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_OpenLogicalChannelReject_cause[]={
      {"unspecified",0}
     ,{"unsuitableReverseParameters",1}
     ,{"dataTypeNotSupported",2}
     ,{"dataTypeNotAvailable",3}
     ,{"unknownDataType",4}
     ,{"dataTypeALCombinationNotSupported",5}
     ,{"multicastChannelNotAllowed",6}
     ,{"insufficientBandwidth",7}
     ,{"separateStackEstablishmentFailed",8}
     ,{"invalidSessionID",9}
     ,{"masterSlaveConflict",10}
     ,{"waitForCommunicationMode",11}
     ,{"invalidDependentChannel",12}
     ,{"replacementForRejected",13}
     ,{"securityDenied",14}
};
#endif
//
// OpenLogicalChannelReject_cause
//

H245_OpenLogicalChannelReject_cause::H245_OpenLogicalChannelReject_cause(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 6, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_OpenLogicalChannelReject_cause,15
#endif
)
{
}


BOOL H245_OpenLogicalChannelReject_cause::CreateObject()
{
  choice = (tag <= e_securityDenied) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_OpenLogicalChannelReject_cause::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_OpenLogicalChannelReject_cause::Class()), PInvalidCast);
#endif
  return new H245_OpenLogicalChannelReject_cause(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_CloseLogicalChannel_source[]={
      {"user",0}
     ,{"lcse",1}
};
#endif
//
// CloseLogicalChannel_source
//

H245_CloseLogicalChannel_source::H245_CloseLogicalChannel_source(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_CloseLogicalChannel_source,2
#endif
)
{
}


BOOL H245_CloseLogicalChannel_source::CreateObject()
{
  choice = (tag <= e_lcse) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_CloseLogicalChannel_source::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CloseLogicalChannel_source::Class()), PInvalidCast);
#endif
  return new H245_CloseLogicalChannel_source(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_CloseLogicalChannel_reason[]={
      {"unknown",0}
     ,{"reopen",1}
     ,{"reservationFailure",2}
};
#endif
//
// CloseLogicalChannel_reason
//

H245_CloseLogicalChannel_reason::H245_CloseLogicalChannel_reason(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_CloseLogicalChannel_reason,3
#endif
)
{
}


BOOL H245_CloseLogicalChannel_reason::CreateObject()
{
  choice = (tag <= e_reservationFailure) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_CloseLogicalChannel_reason::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CloseLogicalChannel_reason::Class()), PInvalidCast);
#endif
  return new H245_CloseLogicalChannel_reason(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_RequestChannelClose_reason[]={
      {"unknown",0}
     ,{"normal",1}
     ,{"reopen",2}
     ,{"reservationFailure",3}
};
#endif
//
// RequestChannelClose_reason
//

H245_RequestChannelClose_reason::H245_RequestChannelClose_reason(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_RequestChannelClose_reason,4
#endif
)
{
}


BOOL H245_RequestChannelClose_reason::CreateObject()
{
  choice = (tag <= e_reservationFailure) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_RequestChannelClose_reason::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RequestChannelClose_reason::Class()), PInvalidCast);
#endif
  return new H245_RequestChannelClose_reason(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_RequestChannelCloseReject_cause[]={
      {"unspecified",0}
};
#endif
//
// RequestChannelCloseReject_cause
//

H245_RequestChannelCloseReject_cause::H245_RequestChannelCloseReject_cause(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 1, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_RequestChannelCloseReject_cause,1
#endif
)
{
}


BOOL H245_RequestChannelCloseReject_cause::CreateObject()
{
  choice = (tag <= e_unspecified) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_RequestChannelCloseReject_cause::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RequestChannelCloseReject_cause::Class()), PInvalidCast);
#endif
  return new H245_RequestChannelCloseReject_cause(*this);
}


//
// ArrayOf_MultiplexEntryDescriptor
//

H245_ArrayOf_MultiplexEntryDescriptor::H245_ArrayOf_MultiplexEntryDescriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_MultiplexEntryDescriptor::CreateObject() const
{
  return new H245_MultiplexEntryDescriptor;
}


H245_MultiplexEntryDescriptor & H245_ArrayOf_MultiplexEntryDescriptor::operator[](PINDEX i) const
{
  return (H245_MultiplexEntryDescriptor &)array[i];
}


PObject * H245_ArrayOf_MultiplexEntryDescriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_MultiplexEntryDescriptor::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_MultiplexEntryDescriptor(*this);
}


//
// ArrayOf_MultiplexElement
//

H245_ArrayOf_MultiplexElement::H245_ArrayOf_MultiplexElement(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_MultiplexElement::CreateObject() const
{
  return new H245_MultiplexElement;
}


H245_MultiplexElement & H245_ArrayOf_MultiplexElement::operator[](PINDEX i) const
{
  return (H245_MultiplexElement &)array[i];
}


PObject * H245_ArrayOf_MultiplexElement::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_MultiplexElement::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_MultiplexElement(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_MultiplexElement_type[]={
      {"logicalChannelNumber",0}
     ,{"subElementList",1}
};
#endif
//
// MultiplexElement_type
//

H245_MultiplexElement_type::H245_MultiplexElement_type(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_MultiplexElement_type,2
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultiplexElement_type::operator H245_ArrayOf_MultiplexElement &() const
#else
H245_MultiplexElement_type::operator H245_ArrayOf_MultiplexElement &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ArrayOf_MultiplexElement), PInvalidCast);
#endif
  return *(H245_ArrayOf_MultiplexElement *)choice;
}


H245_MultiplexElement_type::operator const H245_ArrayOf_MultiplexElement &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ArrayOf_MultiplexElement), PInvalidCast);
#endif
  return *(H245_ArrayOf_MultiplexElement *)choice;
}


BOOL H245_MultiplexElement_type::CreateObject()
{
  switch (tag) {
    case e_logicalChannelNumber :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
      return TRUE;
    case e_subElementList :
      choice = new H245_ArrayOf_MultiplexElement();
      choice->SetConstraints(PASN_Object::FixedConstraint, 2, 255);
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_MultiplexElement_type::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultiplexElement_type::Class()), PInvalidCast);
#endif
  return new H245_MultiplexElement_type(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_MultiplexElement_repeatCount[]={
      {"finite",0}
     ,{"untilClosingFlag",1}
};
#endif
//
// MultiplexElement_repeatCount
//

H245_MultiplexElement_repeatCount::H245_MultiplexElement_repeatCount(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_MultiplexElement_repeatCount,2
#endif
)
{
}


BOOL H245_MultiplexElement_repeatCount::CreateObject()
{
  switch (tag) {
    case e_finite :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
      return TRUE;
    case e_untilClosingFlag :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_MultiplexElement_repeatCount::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultiplexElement_repeatCount::Class()), PInvalidCast);
#endif
  return new H245_MultiplexElement_repeatCount(*this);
}


//
// ArrayOf_MultiplexTableEntryNumber
//

H245_ArrayOf_MultiplexTableEntryNumber::H245_ArrayOf_MultiplexTableEntryNumber(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_MultiplexTableEntryNumber::CreateObject() const
{
  return new H245_MultiplexTableEntryNumber;
}


H245_MultiplexTableEntryNumber & H245_ArrayOf_MultiplexTableEntryNumber::operator[](PINDEX i) const
{
  return (H245_MultiplexTableEntryNumber &)array[i];
}


PObject * H245_ArrayOf_MultiplexTableEntryNumber::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_MultiplexTableEntryNumber::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_MultiplexTableEntryNumber(*this);
}


//
// ArrayOf_MultiplexEntryRejectionDescriptions
//

H245_ArrayOf_MultiplexEntryRejectionDescriptions::H245_ArrayOf_MultiplexEntryRejectionDescriptions(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_MultiplexEntryRejectionDescriptions::CreateObject() const
{
  return new H245_MultiplexEntryRejectionDescriptions;
}


H245_MultiplexEntryRejectionDescriptions & H245_ArrayOf_MultiplexEntryRejectionDescriptions::operator[](PINDEX i) const
{
  return (H245_MultiplexEntryRejectionDescriptions &)array[i];
}


PObject * H245_ArrayOf_MultiplexEntryRejectionDescriptions::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_MultiplexEntryRejectionDescriptions::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_MultiplexEntryRejectionDescriptions(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_MultiplexEntryRejectionDescriptions_cause[]={
      {"unspecifiedCause",0}
     ,{"descriptorTooComplex",1}
};
#endif
//
// MultiplexEntryRejectionDescriptions_cause
//

H245_MultiplexEntryRejectionDescriptions_cause::H245_MultiplexEntryRejectionDescriptions_cause(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_MultiplexEntryRejectionDescriptions_cause,2
#endif
)
{
}


BOOL H245_MultiplexEntryRejectionDescriptions_cause::CreateObject()
{
  choice = (tag <= e_descriptorTooComplex) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_MultiplexEntryRejectionDescriptions_cause::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultiplexEntryRejectionDescriptions_cause::Class()), PInvalidCast);
#endif
  return new H245_MultiplexEntryRejectionDescriptions_cause(*this);
}


//
// ArrayOf_RequestMultiplexEntryRejectionDescriptions
//

H245_ArrayOf_RequestMultiplexEntryRejectionDescriptions::H245_ArrayOf_RequestMultiplexEntryRejectionDescriptions(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_RequestMultiplexEntryRejectionDescriptions::CreateObject() const
{
  return new H245_RequestMultiplexEntryRejectionDescriptions;
}


H245_RequestMultiplexEntryRejectionDescriptions & H245_ArrayOf_RequestMultiplexEntryRejectionDescriptions::operator[](PINDEX i) const
{
  return (H245_RequestMultiplexEntryRejectionDescriptions &)array[i];
}


PObject * H245_ArrayOf_RequestMultiplexEntryRejectionDescriptions::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_RequestMultiplexEntryRejectionDescriptions::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_RequestMultiplexEntryRejectionDescriptions(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_RequestMultiplexEntryRejectionDescriptions_cause[]={
      {"unspecifiedCause",0}
};
#endif
//
// RequestMultiplexEntryRejectionDescriptions_cause
//

H245_RequestMultiplexEntryRejectionDescriptions_cause::H245_RequestMultiplexEntryRejectionDescriptions_cause(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 1, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_RequestMultiplexEntryRejectionDescriptions_cause,1
#endif
)
{
}


BOOL H245_RequestMultiplexEntryRejectionDescriptions_cause::CreateObject()
{
  choice = (tag <= e_unspecifiedCause) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_RequestMultiplexEntryRejectionDescriptions_cause::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RequestMultiplexEntryRejectionDescriptions_cause::Class()), PInvalidCast);
#endif
  return new H245_RequestMultiplexEntryRejectionDescriptions_cause(*this);
}


//
// ArrayOf_ModeDescription
//

H245_ArrayOf_ModeDescription::H245_ArrayOf_ModeDescription(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_ModeDescription::CreateObject() const
{
  return new H245_ModeDescription;
}


H245_ModeDescription & H245_ArrayOf_ModeDescription::operator[](PINDEX i) const
{
  return (H245_ModeDescription &)array[i];
}


PObject * H245_ArrayOf_ModeDescription::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_ModeDescription::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_ModeDescription(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_RequestModeAck_response[]={
      {"willTransmitMostPreferredMode",0}
     ,{"willTransmitLessPreferredMode",1}
};
#endif
//
// RequestModeAck_response
//

H245_RequestModeAck_response::H245_RequestModeAck_response(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_RequestModeAck_response,2
#endif
)
{
}


BOOL H245_RequestModeAck_response::CreateObject()
{
  choice = (tag <= e_willTransmitLessPreferredMode) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_RequestModeAck_response::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RequestModeAck_response::Class()), PInvalidCast);
#endif
  return new H245_RequestModeAck_response(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_RequestModeReject_cause[]={
      {"modeUnavailable",0}
     ,{"multipointConstraint",1}
     ,{"requestDenied",2}
};
#endif
//
// RequestModeReject_cause
//

H245_RequestModeReject_cause::H245_RequestModeReject_cause(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_RequestModeReject_cause,3
#endif
)
{
}


BOOL H245_RequestModeReject_cause::CreateObject()
{
  choice = (tag <= e_requestDenied) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_RequestModeReject_cause::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RequestModeReject_cause::Class()), PInvalidCast);
#endif
  return new H245_RequestModeReject_cause(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_H235Mode_mediaMode[]={
      {"nonStandard",0}
     ,{"videoMode",1}
     ,{"audioMode",2}
     ,{"dataMode",3}
};
#endif
//
// H235Mode_mediaMode
//

H245_H235Mode_mediaMode::H245_H235Mode_mediaMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_H235Mode_mediaMode,4
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H235Mode_mediaMode::operator H245_NonStandardParameter &() const
#else
H245_H235Mode_mediaMode::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_H235Mode_mediaMode::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H235Mode_mediaMode::operator H245_VideoMode &() const
#else
H245_H235Mode_mediaMode::operator H245_VideoMode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_VideoMode), PInvalidCast);
#endif
  return *(H245_VideoMode *)choice;
}


H245_H235Mode_mediaMode::operator const H245_VideoMode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_VideoMode), PInvalidCast);
#endif
  return *(H245_VideoMode *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H235Mode_mediaMode::operator H245_AudioMode &() const
#else
H245_H235Mode_mediaMode::operator H245_AudioMode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_AudioMode), PInvalidCast);
#endif
  return *(H245_AudioMode *)choice;
}


H245_H235Mode_mediaMode::operator const H245_AudioMode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_AudioMode), PInvalidCast);
#endif
  return *(H245_AudioMode *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H235Mode_mediaMode::operator H245_DataMode &() const
#else
H245_H235Mode_mediaMode::operator H245_DataMode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DataMode), PInvalidCast);
#endif
  return *(H245_DataMode *)choice;
}


H245_H235Mode_mediaMode::operator const H245_DataMode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DataMode), PInvalidCast);
#endif
  return *(H245_DataMode *)choice;
}


BOOL H245_H235Mode_mediaMode::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_videoMode :
      choice = new H245_VideoMode();
      return TRUE;
    case e_audioMode :
      choice = new H245_AudioMode();
      return TRUE;
    case e_dataMode :
      choice = new H245_DataMode();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_H235Mode_mediaMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H235Mode_mediaMode::Class()), PInvalidCast);
#endif
  return new H245_H235Mode_mediaMode(*this);
}


//
// ArrayOf_RedundancyEncodingDTModeElement
//

H245_ArrayOf_RedundancyEncodingDTModeElement::H245_ArrayOf_RedundancyEncodingDTModeElement(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_RedundancyEncodingDTModeElement::CreateObject() const
{
  return new H245_RedundancyEncodingDTModeElement;
}


H245_RedundancyEncodingDTModeElement & H245_ArrayOf_RedundancyEncodingDTModeElement::operator[](PINDEX i) const
{
  return (H245_RedundancyEncodingDTModeElement &)array[i];
}


PObject * H245_ArrayOf_RedundancyEncodingDTModeElement::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_RedundancyEncodingDTModeElement::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_RedundancyEncodingDTModeElement(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_RedundancyEncodingDTModeElement_type[]={
      {"nonStandard",0}
     ,{"videoMode",1}
     ,{"audioMode",2}
     ,{"dataMode",3}
     ,{"encryptionMode",4}
     ,{"h235Mode",5}
     ,{"fecMode",6}
};
#endif
//
// RedundancyEncodingDTModeElement_type
//

H245_RedundancyEncodingDTModeElement_type::H245_RedundancyEncodingDTModeElement_type(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 6, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_RedundancyEncodingDTModeElement_type,7
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RedundancyEncodingDTModeElement_type::operator H245_NonStandardParameter &() const
#else
H245_RedundancyEncodingDTModeElement_type::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_RedundancyEncodingDTModeElement_type::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RedundancyEncodingDTModeElement_type::operator H245_VideoMode &() const
#else
H245_RedundancyEncodingDTModeElement_type::operator H245_VideoMode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_VideoMode), PInvalidCast);
#endif
  return *(H245_VideoMode *)choice;
}


H245_RedundancyEncodingDTModeElement_type::operator const H245_VideoMode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_VideoMode), PInvalidCast);
#endif
  return *(H245_VideoMode *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RedundancyEncodingDTModeElement_type::operator H245_AudioMode &() const
#else
H245_RedundancyEncodingDTModeElement_type::operator H245_AudioMode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_AudioMode), PInvalidCast);
#endif
  return *(H245_AudioMode *)choice;
}


H245_RedundancyEncodingDTModeElement_type::operator const H245_AudioMode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_AudioMode), PInvalidCast);
#endif
  return *(H245_AudioMode *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RedundancyEncodingDTModeElement_type::operator H245_DataMode &() const
#else
H245_RedundancyEncodingDTModeElement_type::operator H245_DataMode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DataMode), PInvalidCast);
#endif
  return *(H245_DataMode *)choice;
}


H245_RedundancyEncodingDTModeElement_type::operator const H245_DataMode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DataMode), PInvalidCast);
#endif
  return *(H245_DataMode *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RedundancyEncodingDTModeElement_type::operator H245_EncryptionMode &() const
#else
H245_RedundancyEncodingDTModeElement_type::operator H245_EncryptionMode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_EncryptionMode), PInvalidCast);
#endif
  return *(H245_EncryptionMode *)choice;
}


H245_RedundancyEncodingDTModeElement_type::operator const H245_EncryptionMode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_EncryptionMode), PInvalidCast);
#endif
  return *(H245_EncryptionMode *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RedundancyEncodingDTModeElement_type::operator H245_H235Mode &() const
#else
H245_RedundancyEncodingDTModeElement_type::operator H245_H235Mode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H235Mode), PInvalidCast);
#endif
  return *(H245_H235Mode *)choice;
}


H245_RedundancyEncodingDTModeElement_type::operator const H245_H235Mode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H235Mode), PInvalidCast);
#endif
  return *(H245_H235Mode *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RedundancyEncodingDTModeElement_type::operator H245_FECMode &() const
#else
H245_RedundancyEncodingDTModeElement_type::operator H245_FECMode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_FECMode), PInvalidCast);
#endif
  return *(H245_FECMode *)choice;
}


H245_RedundancyEncodingDTModeElement_type::operator const H245_FECMode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_FECMode), PInvalidCast);
#endif
  return *(H245_FECMode *)choice;
}


BOOL H245_RedundancyEncodingDTModeElement_type::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_videoMode :
      choice = new H245_VideoMode();
      return TRUE;
    case e_audioMode :
      choice = new H245_AudioMode();
      return TRUE;
    case e_dataMode :
      choice = new H245_DataMode();
      return TRUE;
    case e_encryptionMode :
      choice = new H245_EncryptionMode();
      return TRUE;
    case e_h235Mode :
      choice = new H245_H235Mode();
      return TRUE;
    case e_fecMode :
      choice = new H245_FECMode();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_RedundancyEncodingDTModeElement_type::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RedundancyEncodingDTModeElement_type::Class()), PInvalidCast);
#endif
  return new H245_RedundancyEncodingDTModeElement_type(*this);
}


//
// ArrayOf_MultiplePayloadStreamElementMode
//

H245_ArrayOf_MultiplePayloadStreamElementMode::H245_ArrayOf_MultiplePayloadStreamElementMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_MultiplePayloadStreamElementMode::CreateObject() const
{
  return new H245_MultiplePayloadStreamElementMode;
}


H245_MultiplePayloadStreamElementMode & H245_ArrayOf_MultiplePayloadStreamElementMode::operator[](PINDEX i) const
{
  return (H245_MultiplePayloadStreamElementMode &)array[i];
}


PObject * H245_ArrayOf_MultiplePayloadStreamElementMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_MultiplePayloadStreamElementMode::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_MultiplePayloadStreamElementMode(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_FECMode_rfc2733Format[]={
      {"rfc2733rfc2198",0}
     ,{"rfc2733sameport",1}
     ,{"rfc2733diffport",2}
};
#endif
//
// FECMode_rfc2733Format
//

H245_FECMode_rfc2733Format::H245_FECMode_rfc2733Format(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_FECMode_rfc2733Format,3
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_FECMode_rfc2733Format::operator H245_MaxRedundancy &() const
#else
H245_FECMode_rfc2733Format::operator H245_MaxRedundancy &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MaxRedundancy), PInvalidCast);
#endif
  return *(H245_MaxRedundancy *)choice;
}


H245_FECMode_rfc2733Format::operator const H245_MaxRedundancy &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MaxRedundancy), PInvalidCast);
#endif
  return *(H245_MaxRedundancy *)choice;
}


BOOL H245_FECMode_rfc2733Format::CreateObject()
{
  switch (tag) {
    case e_rfc2733rfc2198 :
    case e_rfc2733sameport :
    case e_rfc2733diffport :
      choice = new H245_MaxRedundancy();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_FECMode_rfc2733Format::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_FECMode_rfc2733Format::Class()), PInvalidCast);
#endif
  return new H245_FECMode_rfc2733Format(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_H223ModeParameters_adaptationLayerType[]={
      {"nonStandard",0}
     ,{"al1Framed",1}
     ,{"al1NotFramed",2}
     ,{"al2WithoutSequenceNumbers",3}
     ,{"al2WithSequenceNumbers",4}
     ,{"al3",5}
     ,{"al1M",6}
     ,{"al2M",7}
     ,{"al3M",8}
};
#endif
//
// H223ModeParameters_adaptationLayerType
//

H245_H223ModeParameters_adaptationLayerType::H245_H223ModeParameters_adaptationLayerType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 6, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_H223ModeParameters_adaptationLayerType,9
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H223ModeParameters_adaptationLayerType::operator H245_NonStandardParameter &() const
#else
H245_H223ModeParameters_adaptationLayerType::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_H223ModeParameters_adaptationLayerType::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H223ModeParameters_adaptationLayerType::operator H245_H223ModeParameters_adaptationLayerType_al3 &() const
#else
H245_H223ModeParameters_adaptationLayerType::operator H245_H223ModeParameters_adaptationLayerType_al3 &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H223ModeParameters_adaptationLayerType_al3), PInvalidCast);
#endif
  return *(H245_H223ModeParameters_adaptationLayerType_al3 *)choice;
}


H245_H223ModeParameters_adaptationLayerType::operator const H245_H223ModeParameters_adaptationLayerType_al3 &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H223ModeParameters_adaptationLayerType_al3), PInvalidCast);
#endif
  return *(H245_H223ModeParameters_adaptationLayerType_al3 *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H223ModeParameters_adaptationLayerType::operator H245_H223AL1MParameters &() const
#else
H245_H223ModeParameters_adaptationLayerType::operator H245_H223AL1MParameters &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H223AL1MParameters), PInvalidCast);
#endif
  return *(H245_H223AL1MParameters *)choice;
}


H245_H223ModeParameters_adaptationLayerType::operator const H245_H223AL1MParameters &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H223AL1MParameters), PInvalidCast);
#endif
  return *(H245_H223AL1MParameters *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H223ModeParameters_adaptationLayerType::operator H245_H223AL2MParameters &() const
#else
H245_H223ModeParameters_adaptationLayerType::operator H245_H223AL2MParameters &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H223AL2MParameters), PInvalidCast);
#endif
  return *(H245_H223AL2MParameters *)choice;
}


H245_H223ModeParameters_adaptationLayerType::operator const H245_H223AL2MParameters &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H223AL2MParameters), PInvalidCast);
#endif
  return *(H245_H223AL2MParameters *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_H223ModeParameters_adaptationLayerType::operator H245_H223AL3MParameters &() const
#else
H245_H223ModeParameters_adaptationLayerType::operator H245_H223AL3MParameters &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H223AL3MParameters), PInvalidCast);
#endif
  return *(H245_H223AL3MParameters *)choice;
}


H245_H223ModeParameters_adaptationLayerType::operator const H245_H223AL3MParameters &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H223AL3MParameters), PInvalidCast);
#endif
  return *(H245_H223AL3MParameters *)choice;
}


BOOL H245_H223ModeParameters_adaptationLayerType::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_al1Framed :
    case e_al1NotFramed :
    case e_al2WithoutSequenceNumbers :
    case e_al2WithSequenceNumbers :
      choice = new PASN_Null();
      return TRUE;
    case e_al3 :
      choice = new H245_H223ModeParameters_adaptationLayerType_al3();
      return TRUE;
    case e_al1M :
      choice = new H245_H223AL1MParameters();
      return TRUE;
    case e_al2M :
      choice = new H245_H223AL2MParameters();
      return TRUE;
    case e_al3M :
      choice = new H245_H223AL3MParameters();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_H223ModeParameters_adaptationLayerType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223ModeParameters_adaptationLayerType::Class()), PInvalidCast);
#endif
  return new H245_H223ModeParameters_adaptationLayerType(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_RedundancyEncodingMode_secondaryEncoding[]={
      {"nonStandard",0}
     ,{"audioData",1}
};
#endif
//
// RedundancyEncodingMode_secondaryEncoding
//

H245_RedundancyEncodingMode_secondaryEncoding::H245_RedundancyEncodingMode_secondaryEncoding(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_RedundancyEncodingMode_secondaryEncoding,2
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RedundancyEncodingMode_secondaryEncoding::operator H245_NonStandardParameter &() const
#else
H245_RedundancyEncodingMode_secondaryEncoding::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_RedundancyEncodingMode_secondaryEncoding::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_RedundancyEncodingMode_secondaryEncoding::operator H245_AudioMode &() const
#else
H245_RedundancyEncodingMode_secondaryEncoding::operator H245_AudioMode &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_AudioMode), PInvalidCast);
#endif
  return *(H245_AudioMode *)choice;
}


H245_RedundancyEncodingMode_secondaryEncoding::operator const H245_AudioMode &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_AudioMode), PInvalidCast);
#endif
  return *(H245_AudioMode *)choice;
}


BOOL H245_RedundancyEncodingMode_secondaryEncoding::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_audioData :
      choice = new H245_AudioMode();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_RedundancyEncodingMode_secondaryEncoding::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RedundancyEncodingMode_secondaryEncoding::Class()), PInvalidCast);
#endif
  return new H245_RedundancyEncodingMode_secondaryEncoding(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_H261VideoMode_resolution[]={
      {"qcif",0}
     ,{"cif",1}
};
#endif
//
// H261VideoMode_resolution
//

H245_H261VideoMode_resolution::H245_H261VideoMode_resolution(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_H261VideoMode_resolution,2
#endif
)
{
}


BOOL H245_H261VideoMode_resolution::CreateObject()
{
  choice = (tag <= e_cif) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_H261VideoMode_resolution::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H261VideoMode_resolution::Class()), PInvalidCast);
#endif
  return new H245_H261VideoMode_resolution(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_H262VideoMode_profileAndLevel[]={
      {"profileAndLevel_SPatML",0}
     ,{"profileAndLevel_MPatLL",1}
     ,{"profileAndLevel_MPatML",2}
     ,{"profileAndLevel_MPatH_14",3}
     ,{"profileAndLevel_MPatHL",4}
     ,{"profileAndLevel_SNRatLL",5}
     ,{"profileAndLevel_SNRatML",6}
     ,{"profileAndLevel_SpatialatH_14",7}
     ,{"profileAndLevel_HPatML",8}
     ,{"profileAndLevel_HPatH_14",9}
     ,{"profileAndLevel_HPatHL",10}
};
#endif
//
// H262VideoMode_profileAndLevel
//

H245_H262VideoMode_profileAndLevel::H245_H262VideoMode_profileAndLevel(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 11, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_H262VideoMode_profileAndLevel,11
#endif
)
{
}


BOOL H245_H262VideoMode_profileAndLevel::CreateObject()
{
  choice = (tag <= e_profileAndLevel_HPatHL) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_H262VideoMode_profileAndLevel::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H262VideoMode_profileAndLevel::Class()), PInvalidCast);
#endif
  return new H245_H262VideoMode_profileAndLevel(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_H263VideoMode_resolution[]={
      {"sqcif",0}
     ,{"qcif",1}
     ,{"cif",2}
     ,{"cif4",3}
     ,{"cif16",4}
     ,{"custom",5}
};
#endif
//
// H263VideoMode_resolution
//

H245_H263VideoMode_resolution::H245_H263VideoMode_resolution(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 5, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_H263VideoMode_resolution,6
#endif
)
{
}


BOOL H245_H263VideoMode_resolution::CreateObject()
{
  choice = (tag <= e_custom) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_H263VideoMode_resolution::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H263VideoMode_resolution::Class()), PInvalidCast);
#endif
  return new H245_H263VideoMode_resolution(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_AudioMode_g7231[]={
      {"noSilenceSuppressionLowRate",0}
     ,{"noSilenceSuppressionHighRate",1}
     ,{"silenceSuppressionLowRate",2}
     ,{"silenceSuppressionHighRate",3}
};
#endif
//
// AudioMode_g7231
//

H245_AudioMode_g7231::H245_AudioMode_g7231(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_AudioMode_g7231,4
#endif
)
{
}


BOOL H245_AudioMode_g7231::CreateObject()
{
  choice = (tag <= e_silenceSuppressionHighRate) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_AudioMode_g7231::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_AudioMode_g7231::Class()), PInvalidCast);
#endif
  return new H245_AudioMode_g7231(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_IS11172AudioMode_audioLayer[]={
      {"audioLayer1",0}
     ,{"audioLayer2",1}
     ,{"audioLayer3",2}
};
#endif
//
// IS11172AudioMode_audioLayer
//

H245_IS11172AudioMode_audioLayer::H245_IS11172AudioMode_audioLayer(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_IS11172AudioMode_audioLayer,3
#endif
)
{
}


BOOL H245_IS11172AudioMode_audioLayer::CreateObject()
{
  choice = (tag <= e_audioLayer3) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_IS11172AudioMode_audioLayer::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_IS11172AudioMode_audioLayer::Class()), PInvalidCast);
#endif
  return new H245_IS11172AudioMode_audioLayer(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_IS11172AudioMode_audioSampling[]={
      {"audioSampling32k",0}
     ,{"audioSampling44k1",1}
     ,{"audioSampling48k",2}
};
#endif
//
// IS11172AudioMode_audioSampling
//

H245_IS11172AudioMode_audioSampling::H245_IS11172AudioMode_audioSampling(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_IS11172AudioMode_audioSampling,3
#endif
)
{
}


BOOL H245_IS11172AudioMode_audioSampling::CreateObject()
{
  choice = (tag <= e_audioSampling48k) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_IS11172AudioMode_audioSampling::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_IS11172AudioMode_audioSampling::Class()), PInvalidCast);
#endif
  return new H245_IS11172AudioMode_audioSampling(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_IS11172AudioMode_multichannelType[]={
      {"singleChannel",0}
     ,{"twoChannelStereo",1}
     ,{"twoChannelDual",2}
};
#endif
//
// IS11172AudioMode_multichannelType
//

H245_IS11172AudioMode_multichannelType::H245_IS11172AudioMode_multichannelType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_IS11172AudioMode_multichannelType,3
#endif
)
{
}


BOOL H245_IS11172AudioMode_multichannelType::CreateObject()
{
  choice = (tag <= e_twoChannelDual) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_IS11172AudioMode_multichannelType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_IS11172AudioMode_multichannelType::Class()), PInvalidCast);
#endif
  return new H245_IS11172AudioMode_multichannelType(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_IS13818AudioMode_audioLayer[]={
      {"audioLayer1",0}
     ,{"audioLayer2",1}
     ,{"audioLayer3",2}
};
#endif
//
// IS13818AudioMode_audioLayer
//

H245_IS13818AudioMode_audioLayer::H245_IS13818AudioMode_audioLayer(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_IS13818AudioMode_audioLayer,3
#endif
)
{
}


BOOL H245_IS13818AudioMode_audioLayer::CreateObject()
{
  choice = (tag <= e_audioLayer3) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_IS13818AudioMode_audioLayer::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_IS13818AudioMode_audioLayer::Class()), PInvalidCast);
#endif
  return new H245_IS13818AudioMode_audioLayer(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_IS13818AudioMode_audioSampling[]={
      {"audioSampling16k",0}
     ,{"audioSampling22k05",1}
     ,{"audioSampling24k",2}
     ,{"audioSampling32k",3}
     ,{"audioSampling44k1",4}
     ,{"audioSampling48k",5}
};
#endif
//
// IS13818AudioMode_audioSampling
//

H245_IS13818AudioMode_audioSampling::H245_IS13818AudioMode_audioSampling(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 6, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_IS13818AudioMode_audioSampling,6
#endif
)
{
}


BOOL H245_IS13818AudioMode_audioSampling::CreateObject()
{
  choice = (tag <= e_audioSampling48k) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_IS13818AudioMode_audioSampling::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_IS13818AudioMode_audioSampling::Class()), PInvalidCast);
#endif
  return new H245_IS13818AudioMode_audioSampling(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_IS13818AudioMode_multichannelType[]={
      {"singleChannel",0}
     ,{"twoChannelStereo",1}
     ,{"twoChannelDual",2}
     ,{"threeChannels2_1",3}
     ,{"threeChannels3_0",4}
     ,{"fourChannels2_0_2_0",5}
     ,{"fourChannels2_2",6}
     ,{"fourChannels3_1",7}
     ,{"fiveChannels3_0_2_0",8}
     ,{"fiveChannels3_2",9}
};
#endif
//
// IS13818AudioMode_multichannelType
//

H245_IS13818AudioMode_multichannelType::H245_IS13818AudioMode_multichannelType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 10, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_IS13818AudioMode_multichannelType,10
#endif
)
{
}


BOOL H245_IS13818AudioMode_multichannelType::CreateObject()
{
  choice = (tag <= e_fiveChannels3_2) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_IS13818AudioMode_multichannelType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_IS13818AudioMode_multichannelType::Class()), PInvalidCast);
#endif
  return new H245_IS13818AudioMode_multichannelType(*this);
}


//
// G7231AnnexCMode_g723AnnexCAudioMode
//

H245_G7231AnnexCMode_g723AnnexCAudioMode::H245_G7231AnnexCMode_g723AnnexCAudioMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_highRateMode0.SetConstraints(PASN_Object::FixedConstraint, 27, 78);
  m_highRateMode1.SetConstraints(PASN_Object::FixedConstraint, 27, 78);
  m_lowRateMode0.SetConstraints(PASN_Object::FixedConstraint, 23, 66);
  m_lowRateMode1.SetConstraints(PASN_Object::FixedConstraint, 23, 66);
  m_sidMode0.SetConstraints(PASN_Object::FixedConstraint, 6, 17);
  m_sidMode1.SetConstraints(PASN_Object::FixedConstraint, 6, 17);
}


#ifndef PASN_NOPRINTON
void H245_G7231AnnexCMode_g723AnnexCAudioMode::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "highRateMode0 = " << setprecision(indent) << m_highRateMode0 << '\n';
  strm << setw(indent+16) << "highRateMode1 = " << setprecision(indent) << m_highRateMode1 << '\n';
  strm << setw(indent+15) << "lowRateMode0 = " << setprecision(indent) << m_lowRateMode0 << '\n';
  strm << setw(indent+15) << "lowRateMode1 = " << setprecision(indent) << m_lowRateMode1 << '\n';
  strm << setw(indent+11) << "sidMode0 = " << setprecision(indent) << m_sidMode0 << '\n';
  strm << setw(indent+11) << "sidMode1 = " << setprecision(indent) << m_sidMode1 << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_G7231AnnexCMode_g723AnnexCAudioMode::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_G7231AnnexCMode_g723AnnexCAudioMode), PInvalidCast);
#endif
  const H245_G7231AnnexCMode_g723AnnexCAudioMode & other = (const H245_G7231AnnexCMode_g723AnnexCAudioMode &)obj;

  Comparison result;

  if ((result = m_highRateMode0.Compare(other.m_highRateMode0)) != EqualTo)
    return result;
  if ((result = m_highRateMode1.Compare(other.m_highRateMode1)) != EqualTo)
    return result;
  if ((result = m_lowRateMode0.Compare(other.m_lowRateMode0)) != EqualTo)
    return result;
  if ((result = m_lowRateMode1.Compare(other.m_lowRateMode1)) != EqualTo)
    return result;
  if ((result = m_sidMode0.Compare(other.m_sidMode0)) != EqualTo)
    return result;
  if ((result = m_sidMode1.Compare(other.m_sidMode1)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_G7231AnnexCMode_g723AnnexCAudioMode::GetDataLength() const
{
  PINDEX length = 0;
  length += m_highRateMode0.GetObjectLength();
  length += m_highRateMode1.GetObjectLength();
  length += m_lowRateMode0.GetObjectLength();
  length += m_lowRateMode1.GetObjectLength();
  length += m_sidMode0.GetObjectLength();
  length += m_sidMode1.GetObjectLength();
  return length;
}


BOOL H245_G7231AnnexCMode_g723AnnexCAudioMode::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_highRateMode0.Decode(strm))
    return FALSE;
  if (!m_highRateMode1.Decode(strm))
    return FALSE;
  if (!m_lowRateMode0.Decode(strm))
    return FALSE;
  if (!m_lowRateMode1.Decode(strm))
    return FALSE;
  if (!m_sidMode0.Decode(strm))
    return FALSE;
  if (!m_sidMode1.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_G7231AnnexCMode_g723AnnexCAudioMode::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_highRateMode0.Encode(strm);
  m_highRateMode1.Encode(strm);
  m_lowRateMode0.Encode(strm);
  m_lowRateMode1.Encode(strm);
  m_sidMode0.Encode(strm);
  m_sidMode1.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_G7231AnnexCMode_g723AnnexCAudioMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_G7231AnnexCMode_g723AnnexCAudioMode::Class()), PInvalidCast);
#endif
  return new H245_G7231AnnexCMode_g723AnnexCAudioMode(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_DataMode_application[]={
      {"nonStandard",0}
     ,{"t120",1}
     ,{"dsm_cc",2}
     ,{"userData",3}
     ,{"t84",4}
     ,{"t434",5}
     ,{"h224",6}
     ,{"nlpid",7}
     ,{"dsvdControl",8}
     ,{"h222DataPartitioning",9}
     ,{"t30fax",10}
     ,{"t140",11}
     ,{"t38fax",12}
     ,{"genericDataMode",13}
};
#endif
//
// DataMode_application
//

H245_DataMode_application::H245_DataMode_application(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 10, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_DataMode_application,14
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DataMode_application::operator H245_NonStandardParameter &() const
#else
H245_DataMode_application::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_DataMode_application::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DataMode_application::operator H245_DataProtocolCapability &() const
#else
H245_DataMode_application::operator H245_DataProtocolCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DataProtocolCapability), PInvalidCast);
#endif
  return *(H245_DataProtocolCapability *)choice;
}


H245_DataMode_application::operator const H245_DataProtocolCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DataProtocolCapability), PInvalidCast);
#endif
  return *(H245_DataProtocolCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DataMode_application::operator H245_DataMode_application_nlpid &() const
#else
H245_DataMode_application::operator H245_DataMode_application_nlpid &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DataMode_application_nlpid), PInvalidCast);
#endif
  return *(H245_DataMode_application_nlpid *)choice;
}


H245_DataMode_application::operator const H245_DataMode_application_nlpid &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DataMode_application_nlpid), PInvalidCast);
#endif
  return *(H245_DataMode_application_nlpid *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DataMode_application::operator H245_DataMode_application_t38fax &() const
#else
H245_DataMode_application::operator H245_DataMode_application_t38fax &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DataMode_application_t38fax), PInvalidCast);
#endif
  return *(H245_DataMode_application_t38fax *)choice;
}


H245_DataMode_application::operator const H245_DataMode_application_t38fax &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DataMode_application_t38fax), PInvalidCast);
#endif
  return *(H245_DataMode_application_t38fax *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DataMode_application::operator H245_GenericCapability &() const
#else
H245_DataMode_application::operator H245_GenericCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_GenericCapability), PInvalidCast);
#endif
  return *(H245_GenericCapability *)choice;
}


H245_DataMode_application::operator const H245_GenericCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_GenericCapability), PInvalidCast);
#endif
  return *(H245_GenericCapability *)choice;
}


BOOL H245_DataMode_application::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_t120 :
    case e_dsm_cc :
    case e_userData :
    case e_t84 :
    case e_t434 :
    case e_h224 :
    case e_h222DataPartitioning :
    case e_t30fax :
    case e_t140 :
      choice = new H245_DataProtocolCapability();
      return TRUE;
    case e_nlpid :
      choice = new H245_DataMode_application_nlpid();
      return TRUE;
    case e_dsvdControl :
      choice = new PASN_Null();
      return TRUE;
    case e_t38fax :
      choice = new H245_DataMode_application_t38fax();
      return TRUE;
    case e_genericDataMode :
      choice = new H245_GenericCapability();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_DataMode_application::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_DataMode_application::Class()), PInvalidCast);
#endif
  return new H245_DataMode_application(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_MaintenanceLoopRequest_type[]={
      {"systemLoop",0}
     ,{"mediaLoop",1}
     ,{"logicalChannelLoop",2}
};
#endif
//
// MaintenanceLoopRequest_type
//

H245_MaintenanceLoopRequest_type::H245_MaintenanceLoopRequest_type(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_MaintenanceLoopRequest_type,3
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MaintenanceLoopRequest_type::operator H245_LogicalChannelNumber &() const
#else
H245_MaintenanceLoopRequest_type::operator H245_LogicalChannelNumber &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_LogicalChannelNumber), PInvalidCast);
#endif
  return *(H245_LogicalChannelNumber *)choice;
}


H245_MaintenanceLoopRequest_type::operator const H245_LogicalChannelNumber &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_LogicalChannelNumber), PInvalidCast);
#endif
  return *(H245_LogicalChannelNumber *)choice;
}


BOOL H245_MaintenanceLoopRequest_type::CreateObject()
{
  switch (tag) {
    case e_systemLoop :
      choice = new PASN_Null();
      return TRUE;
    case e_mediaLoop :
    case e_logicalChannelLoop :
      choice = new H245_LogicalChannelNumber();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_MaintenanceLoopRequest_type::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MaintenanceLoopRequest_type::Class()), PInvalidCast);
#endif
  return new H245_MaintenanceLoopRequest_type(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_MaintenanceLoopAck_type[]={
      {"systemLoop",0}
     ,{"mediaLoop",1}
     ,{"logicalChannelLoop",2}
};
#endif
//
// MaintenanceLoopAck_type
//

H245_MaintenanceLoopAck_type::H245_MaintenanceLoopAck_type(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_MaintenanceLoopAck_type,3
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MaintenanceLoopAck_type::operator H245_LogicalChannelNumber &() const
#else
H245_MaintenanceLoopAck_type::operator H245_LogicalChannelNumber &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_LogicalChannelNumber), PInvalidCast);
#endif
  return *(H245_LogicalChannelNumber *)choice;
}


H245_MaintenanceLoopAck_type::operator const H245_LogicalChannelNumber &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_LogicalChannelNumber), PInvalidCast);
#endif
  return *(H245_LogicalChannelNumber *)choice;
}


BOOL H245_MaintenanceLoopAck_type::CreateObject()
{
  switch (tag) {
    case e_systemLoop :
      choice = new PASN_Null();
      return TRUE;
    case e_mediaLoop :
    case e_logicalChannelLoop :
      choice = new H245_LogicalChannelNumber();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_MaintenanceLoopAck_type::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MaintenanceLoopAck_type::Class()), PInvalidCast);
#endif
  return new H245_MaintenanceLoopAck_type(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_MaintenanceLoopReject_type[]={
      {"systemLoop",0}
     ,{"mediaLoop",1}
     ,{"logicalChannelLoop",2}
};
#endif
//
// MaintenanceLoopReject_type
//

H245_MaintenanceLoopReject_type::H245_MaintenanceLoopReject_type(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_MaintenanceLoopReject_type,3
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MaintenanceLoopReject_type::operator H245_LogicalChannelNumber &() const
#else
H245_MaintenanceLoopReject_type::operator H245_LogicalChannelNumber &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_LogicalChannelNumber), PInvalidCast);
#endif
  return *(H245_LogicalChannelNumber *)choice;
}


H245_MaintenanceLoopReject_type::operator const H245_LogicalChannelNumber &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_LogicalChannelNumber), PInvalidCast);
#endif
  return *(H245_LogicalChannelNumber *)choice;
}


BOOL H245_MaintenanceLoopReject_type::CreateObject()
{
  switch (tag) {
    case e_systemLoop :
      choice = new PASN_Null();
      return TRUE;
    case e_mediaLoop :
    case e_logicalChannelLoop :
      choice = new H245_LogicalChannelNumber();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_MaintenanceLoopReject_type::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MaintenanceLoopReject_type::Class()), PInvalidCast);
#endif
  return new H245_MaintenanceLoopReject_type(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_MaintenanceLoopReject_cause[]={
      {"canNotPerformLoop",0}
};
#endif
//
// MaintenanceLoopReject_cause
//

H245_MaintenanceLoopReject_cause::H245_MaintenanceLoopReject_cause(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 1, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_MaintenanceLoopReject_cause,1
#endif
)
{
}


BOOL H245_MaintenanceLoopReject_cause::CreateObject()
{
  choice = (tag <= e_canNotPerformLoop) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_MaintenanceLoopReject_cause::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MaintenanceLoopReject_cause::Class()), PInvalidCast);
#endif
  return new H245_MaintenanceLoopReject_cause(*this);
}


//
// ArrayOf_CommunicationModeTableEntry
//

H245_ArrayOf_CommunicationModeTableEntry::H245_ArrayOf_CommunicationModeTableEntry(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_CommunicationModeTableEntry::CreateObject() const
{
  return new H245_CommunicationModeTableEntry;
}


H245_CommunicationModeTableEntry & H245_ArrayOf_CommunicationModeTableEntry::operator[](PINDEX i) const
{
  return (H245_CommunicationModeTableEntry &)array[i];
}


PObject * H245_ArrayOf_CommunicationModeTableEntry::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_CommunicationModeTableEntry::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_CommunicationModeTableEntry(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_CommunicationModeTableEntry_dataType[]={
      {"videoData",0}
     ,{"audioData",1}
     ,{"data",2}
};
#endif
//
// CommunicationModeTableEntry_dataType
//

H245_CommunicationModeTableEntry_dataType::H245_CommunicationModeTableEntry_dataType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_CommunicationModeTableEntry_dataType,3
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_CommunicationModeTableEntry_dataType::operator H245_VideoCapability &() const
#else
H245_CommunicationModeTableEntry_dataType::operator H245_VideoCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_VideoCapability), PInvalidCast);
#endif
  return *(H245_VideoCapability *)choice;
}


H245_CommunicationModeTableEntry_dataType::operator const H245_VideoCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_VideoCapability), PInvalidCast);
#endif
  return *(H245_VideoCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_CommunicationModeTableEntry_dataType::operator H245_AudioCapability &() const
#else
H245_CommunicationModeTableEntry_dataType::operator H245_AudioCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_AudioCapability), PInvalidCast);
#endif
  return *(H245_AudioCapability *)choice;
}


H245_CommunicationModeTableEntry_dataType::operator const H245_AudioCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_AudioCapability), PInvalidCast);
#endif
  return *(H245_AudioCapability *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_CommunicationModeTableEntry_dataType::operator H245_DataApplicationCapability &() const
#else
H245_CommunicationModeTableEntry_dataType::operator H245_DataApplicationCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DataApplicationCapability), PInvalidCast);
#endif
  return *(H245_DataApplicationCapability *)choice;
}


H245_CommunicationModeTableEntry_dataType::operator const H245_DataApplicationCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DataApplicationCapability), PInvalidCast);
#endif
  return *(H245_DataApplicationCapability *)choice;
}


BOOL H245_CommunicationModeTableEntry_dataType::CreateObject()
{
  switch (tag) {
    case e_videoData :
      choice = new H245_VideoCapability();
      return TRUE;
    case e_audioData :
      choice = new H245_AudioCapability();
      return TRUE;
    case e_data :
      choice = new H245_DataApplicationCapability();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_CommunicationModeTableEntry_dataType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CommunicationModeTableEntry_dataType::Class()), PInvalidCast);
#endif
  return new H245_CommunicationModeTableEntry_dataType(*this);
}


//
// ArrayOf_TerminalLabel
//

H245_ArrayOf_TerminalLabel::H245_ArrayOf_TerminalLabel(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_TerminalLabel::CreateObject() const
{
  return new H245_TerminalLabel;
}


H245_TerminalLabel & H245_ArrayOf_TerminalLabel::operator[](PINDEX i) const
{
  return (H245_TerminalLabel &)array[i];
}


PObject * H245_ArrayOf_TerminalLabel::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_TerminalLabel::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_TerminalLabel(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_ConferenceResponse_makeMeChairResponse[]={
      {"grantedChairToken",0}
     ,{"deniedChairToken",1}
};
#endif
//
// ConferenceResponse_makeMeChairResponse
//

H245_ConferenceResponse_makeMeChairResponse::H245_ConferenceResponse_makeMeChairResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_ConferenceResponse_makeMeChairResponse,2
#endif
)
{
}


BOOL H245_ConferenceResponse_makeMeChairResponse::CreateObject()
{
  choice = (tag <= e_deniedChairToken) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_ConferenceResponse_makeMeChairResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ConferenceResponse_makeMeChairResponse::Class()), PInvalidCast);
#endif
  return new H245_ConferenceResponse_makeMeChairResponse(*this);
}


//
// ConferenceResponse_extensionAddressResponse
//

H245_ConferenceResponse_extensionAddressResponse::H245_ConferenceResponse_extensionAddressResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_ConferenceResponse_extensionAddressResponse::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+19) << "extensionAddress = " << setprecision(indent) << m_extensionAddress << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_ConferenceResponse_extensionAddressResponse::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_ConferenceResponse_extensionAddressResponse), PInvalidCast);
#endif
  const H245_ConferenceResponse_extensionAddressResponse & other = (const H245_ConferenceResponse_extensionAddressResponse &)obj;

  Comparison result;

  if ((result = m_extensionAddress.Compare(other.m_extensionAddress)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_ConferenceResponse_extensionAddressResponse::GetDataLength() const
{
  PINDEX length = 0;
  length += m_extensionAddress.GetObjectLength();
  return length;
}


BOOL H245_ConferenceResponse_extensionAddressResponse::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_extensionAddress.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_ConferenceResponse_extensionAddressResponse::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_extensionAddress.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_ConferenceResponse_extensionAddressResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ConferenceResponse_extensionAddressResponse::Class()), PInvalidCast);
#endif
  return new H245_ConferenceResponse_extensionAddressResponse(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_ConferenceResponse_broadcastMyLogicalChannelResponse[]={
      {"grantedBroadcastMyLogicalChannel",0}
     ,{"deniedBroadcastMyLogicalChannel",1}
};
#endif
//
// ConferenceResponse_broadcastMyLogicalChannelResponse
//

H245_ConferenceResponse_broadcastMyLogicalChannelResponse::H245_ConferenceResponse_broadcastMyLogicalChannelResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_ConferenceResponse_broadcastMyLogicalChannelResponse,2
#endif
)
{
}


BOOL H245_ConferenceResponse_broadcastMyLogicalChannelResponse::CreateObject()
{
  choice = (tag <= e_deniedBroadcastMyLogicalChannel) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_ConferenceResponse_broadcastMyLogicalChannelResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ConferenceResponse_broadcastMyLogicalChannelResponse::Class()), PInvalidCast);
#endif
  return new H245_ConferenceResponse_broadcastMyLogicalChannelResponse(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_ConferenceResponse_makeTerminalBroadcasterResponse[]={
      {"grantedMakeTerminalBroadcaster",0}
     ,{"deniedMakeTerminalBroadcaster",1}
};
#endif
//
// ConferenceResponse_makeTerminalBroadcasterResponse
//

H245_ConferenceResponse_makeTerminalBroadcasterResponse::H245_ConferenceResponse_makeTerminalBroadcasterResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_ConferenceResponse_makeTerminalBroadcasterResponse,2
#endif
)
{
}


BOOL H245_ConferenceResponse_makeTerminalBroadcasterResponse::CreateObject()
{
  choice = (tag <= e_deniedMakeTerminalBroadcaster) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_ConferenceResponse_makeTerminalBroadcasterResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ConferenceResponse_makeTerminalBroadcasterResponse::Class()), PInvalidCast);
#endif
  return new H245_ConferenceResponse_makeTerminalBroadcasterResponse(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_ConferenceResponse_sendThisSourceResponse[]={
      {"grantedSendThisSource",0}
     ,{"deniedSendThisSource",1}
};
#endif
//
// ConferenceResponse_sendThisSourceResponse
//

H245_ConferenceResponse_sendThisSourceResponse::H245_ConferenceResponse_sendThisSourceResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_ConferenceResponse_sendThisSourceResponse,2
#endif
)
{
}


BOOL H245_ConferenceResponse_sendThisSourceResponse::CreateObject()
{
  choice = (tag <= e_deniedSendThisSource) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_ConferenceResponse_sendThisSourceResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ConferenceResponse_sendThisSourceResponse::Class()), PInvalidCast);
#endif
  return new H245_ConferenceResponse_sendThisSourceResponse(*this);
}


//
// ArrayOf_TerminalInformation
//

H245_ArrayOf_TerminalInformation::H245_ArrayOf_TerminalInformation(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_TerminalInformation::CreateObject() const
{
  return new H245_TerminalInformation;
}


H245_TerminalInformation & H245_ArrayOf_TerminalInformation::operator[](PINDEX i) const
{
  return (H245_TerminalInformation &)array[i];
}


PObject * H245_ArrayOf_TerminalInformation::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_TerminalInformation::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_TerminalInformation(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_RemoteMCResponse_reject[]={
      {"unspecified",0}
     ,{"functionNotSupported",1}
};
#endif
//
// RemoteMCResponse_reject
//

H245_RemoteMCResponse_reject::H245_RemoteMCResponse_reject(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_RemoteMCResponse_reject,2
#endif
)
{
}


BOOL H245_RemoteMCResponse_reject::CreateObject()
{
  choice = (tag <= e_functionNotSupported) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_RemoteMCResponse_reject::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RemoteMCResponse_reject::Class()), PInvalidCast);
#endif
  return new H245_RemoteMCResponse_reject(*this);
}


//
// MultilinkRequest_callInformation
//

H245_MultilinkRequest_callInformation::H245_MultilinkRequest_callInformation(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_maxNumberOfAdditionalConnections.SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
}


#ifndef PASN_NOPRINTON
void H245_MultilinkRequest_callInformation::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+35) << "maxNumberOfAdditionalConnections = " << setprecision(indent) << m_maxNumberOfAdditionalConnections << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MultilinkRequest_callInformation::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MultilinkRequest_callInformation), PInvalidCast);
#endif
  const H245_MultilinkRequest_callInformation & other = (const H245_MultilinkRequest_callInformation &)obj;

  Comparison result;

  if ((result = m_maxNumberOfAdditionalConnections.Compare(other.m_maxNumberOfAdditionalConnections)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MultilinkRequest_callInformation::GetDataLength() const
{
  PINDEX length = 0;
  length += m_maxNumberOfAdditionalConnections.GetObjectLength();
  return length;
}


BOOL H245_MultilinkRequest_callInformation::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_maxNumberOfAdditionalConnections.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MultilinkRequest_callInformation::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_maxNumberOfAdditionalConnections.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MultilinkRequest_callInformation::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultilinkRequest_callInformation::Class()), PInvalidCast);
#endif
  return new H245_MultilinkRequest_callInformation(*this);
}


//
// MultilinkRequest_addConnection
//

H245_MultilinkRequest_addConnection::H245_MultilinkRequest_addConnection(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MultilinkRequest_addConnection::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "sequenceNumber = " << setprecision(indent) << m_sequenceNumber << '\n';
  strm << setw(indent+21) << "dialingInformation = " << setprecision(indent) << m_dialingInformation << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MultilinkRequest_addConnection::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MultilinkRequest_addConnection), PInvalidCast);
#endif
  const H245_MultilinkRequest_addConnection & other = (const H245_MultilinkRequest_addConnection &)obj;

  Comparison result;

  if ((result = m_sequenceNumber.Compare(other.m_sequenceNumber)) != EqualTo)
    return result;
  if ((result = m_dialingInformation.Compare(other.m_dialingInformation)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MultilinkRequest_addConnection::GetDataLength() const
{
  PINDEX length = 0;
  length += m_sequenceNumber.GetObjectLength();
  length += m_dialingInformation.GetObjectLength();
  return length;
}


BOOL H245_MultilinkRequest_addConnection::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_sequenceNumber.Decode(strm))
    return FALSE;
  if (!m_dialingInformation.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MultilinkRequest_addConnection::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_sequenceNumber.Encode(strm);
  m_dialingInformation.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MultilinkRequest_addConnection::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultilinkRequest_addConnection::Class()), PInvalidCast);
#endif
  return new H245_MultilinkRequest_addConnection(*this);
}


//
// MultilinkRequest_removeConnection
//

H245_MultilinkRequest_removeConnection::H245_MultilinkRequest_removeConnection(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MultilinkRequest_removeConnection::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+23) << "connectionIdentifier = " << setprecision(indent) << m_connectionIdentifier << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MultilinkRequest_removeConnection::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MultilinkRequest_removeConnection), PInvalidCast);
#endif
  const H245_MultilinkRequest_removeConnection & other = (const H245_MultilinkRequest_removeConnection &)obj;

  Comparison result;

  if ((result = m_connectionIdentifier.Compare(other.m_connectionIdentifier)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MultilinkRequest_removeConnection::GetDataLength() const
{
  PINDEX length = 0;
  length += m_connectionIdentifier.GetObjectLength();
  return length;
}


BOOL H245_MultilinkRequest_removeConnection::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_connectionIdentifier.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MultilinkRequest_removeConnection::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_connectionIdentifier.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MultilinkRequest_removeConnection::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultilinkRequest_removeConnection::Class()), PInvalidCast);
#endif
  return new H245_MultilinkRequest_removeConnection(*this);
}


//
// MultilinkResponse_callInformation
//

H245_MultilinkResponse_callInformation::H245_MultilinkResponse_callInformation(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_callAssociationNumber.SetConstraints(PASN_Object::FixedConstraint, 0, 4294967295U);
}


#ifndef PASN_NOPRINTON
void H245_MultilinkResponse_callInformation::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+21) << "dialingInformation = " << setprecision(indent) << m_dialingInformation << '\n';
  strm << setw(indent+24) << "callAssociationNumber = " << setprecision(indent) << m_callAssociationNumber << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MultilinkResponse_callInformation::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MultilinkResponse_callInformation), PInvalidCast);
#endif
  const H245_MultilinkResponse_callInformation & other = (const H245_MultilinkResponse_callInformation &)obj;

  Comparison result;

  if ((result = m_dialingInformation.Compare(other.m_dialingInformation)) != EqualTo)
    return result;
  if ((result = m_callAssociationNumber.Compare(other.m_callAssociationNumber)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MultilinkResponse_callInformation::GetDataLength() const
{
  PINDEX length = 0;
  length += m_dialingInformation.GetObjectLength();
  length += m_callAssociationNumber.GetObjectLength();
  return length;
}


BOOL H245_MultilinkResponse_callInformation::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_dialingInformation.Decode(strm))
    return FALSE;
  if (!m_callAssociationNumber.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MultilinkResponse_callInformation::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_dialingInformation.Encode(strm);
  m_callAssociationNumber.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MultilinkResponse_callInformation::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultilinkResponse_callInformation::Class()), PInvalidCast);
#endif
  return new H245_MultilinkResponse_callInformation(*this);
}


//
// MultilinkResponse_removeConnection
//

H245_MultilinkResponse_removeConnection::H245_MultilinkResponse_removeConnection(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MultilinkResponse_removeConnection::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+23) << "connectionIdentifier = " << setprecision(indent) << m_connectionIdentifier << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MultilinkResponse_removeConnection::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MultilinkResponse_removeConnection), PInvalidCast);
#endif
  const H245_MultilinkResponse_removeConnection & other = (const H245_MultilinkResponse_removeConnection &)obj;

  Comparison result;

  if ((result = m_connectionIdentifier.Compare(other.m_connectionIdentifier)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MultilinkResponse_removeConnection::GetDataLength() const
{
  PINDEX length = 0;
  length += m_connectionIdentifier.GetObjectLength();
  return length;
}


BOOL H245_MultilinkResponse_removeConnection::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_connectionIdentifier.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MultilinkResponse_removeConnection::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_connectionIdentifier.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MultilinkResponse_removeConnection::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultilinkResponse_removeConnection::Class()), PInvalidCast);
#endif
  return new H245_MultilinkResponse_removeConnection(*this);
}


//
// MultilinkResponse_maximumHeaderInterval
//

H245_MultilinkResponse_maximumHeaderInterval::H245_MultilinkResponse_maximumHeaderInterval(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_currentInterval.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void H245_MultilinkResponse_maximumHeaderInterval::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+18) << "currentInterval = " << setprecision(indent) << m_currentInterval << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MultilinkResponse_maximumHeaderInterval::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MultilinkResponse_maximumHeaderInterval), PInvalidCast);
#endif
  const H245_MultilinkResponse_maximumHeaderInterval & other = (const H245_MultilinkResponse_maximumHeaderInterval &)obj;

  Comparison result;

  if ((result = m_currentInterval.Compare(other.m_currentInterval)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MultilinkResponse_maximumHeaderInterval::GetDataLength() const
{
  PINDEX length = 0;
  length += m_currentInterval.GetObjectLength();
  return length;
}


BOOL H245_MultilinkResponse_maximumHeaderInterval::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_currentInterval.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MultilinkResponse_maximumHeaderInterval::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_currentInterval.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MultilinkResponse_maximumHeaderInterval::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultilinkResponse_maximumHeaderInterval::Class()), PInvalidCast);
#endif
  return new H245_MultilinkResponse_maximumHeaderInterval(*this);
}


//
// MultilinkIndication_crcDesired
//

H245_MultilinkIndication_crcDesired::H245_MultilinkIndication_crcDesired(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MultilinkIndication_crcDesired::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PINDEX H245_MultilinkIndication_crcDesired::GetDataLength() const
{
  PINDEX length = 0;
  return length;
}


BOOL H245_MultilinkIndication_crcDesired::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;


  return UnknownExtensionsDecode(strm);
}


void H245_MultilinkIndication_crcDesired::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);


  UnknownExtensionsEncode(strm);
}


PObject * H245_MultilinkIndication_crcDesired::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultilinkIndication_crcDesired::Class()), PInvalidCast);
#endif
  return new H245_MultilinkIndication_crcDesired(*this);
}


//
// MultilinkIndication_excessiveError
//

H245_MultilinkIndication_excessiveError::H245_MultilinkIndication_excessiveError(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_MultilinkIndication_excessiveError::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+23) << "connectionIdentifier = " << setprecision(indent) << m_connectionIdentifier << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MultilinkIndication_excessiveError::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MultilinkIndication_excessiveError), PInvalidCast);
#endif
  const H245_MultilinkIndication_excessiveError & other = (const H245_MultilinkIndication_excessiveError &)obj;

  Comparison result;

  if ((result = m_connectionIdentifier.Compare(other.m_connectionIdentifier)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MultilinkIndication_excessiveError::GetDataLength() const
{
  PINDEX length = 0;
  length += m_connectionIdentifier.GetObjectLength();
  return length;
}


BOOL H245_MultilinkIndication_excessiveError::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_connectionIdentifier.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MultilinkIndication_excessiveError::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_connectionIdentifier.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MultilinkIndication_excessiveError::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultilinkIndication_excessiveError::Class()), PInvalidCast);
#endif
  return new H245_MultilinkIndication_excessiveError(*this);
}


//
// ArrayOf_DialingInformationNumber
//

H245_ArrayOf_DialingInformationNumber::H245_ArrayOf_DialingInformationNumber(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_DialingInformationNumber::CreateObject() const
{
  return new H245_DialingInformationNumber;
}


H245_DialingInformationNumber & H245_ArrayOf_DialingInformationNumber::operator[](PINDEX i) const
{
  return (H245_DialingInformationNumber &)array[i];
}


PObject * H245_ArrayOf_DialingInformationNumber::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_DialingInformationNumber::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_DialingInformationNumber(*this);
}


//
// ArrayOf_DialingInformationNetworkType
//

H245_ArrayOf_DialingInformationNetworkType::H245_ArrayOf_DialingInformationNetworkType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_DialingInformationNetworkType::CreateObject() const
{
  return new H245_DialingInformationNetworkType;
}


H245_DialingInformationNetworkType & H245_ArrayOf_DialingInformationNetworkType::operator[](PINDEX i) const
{
  return (H245_DialingInformationNetworkType &)array[i];
}


PObject * H245_ArrayOf_DialingInformationNetworkType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_DialingInformationNetworkType::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_DialingInformationNetworkType(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_FlowControlCommand_scope[]={
      {"logicalChannelNumber",0}
     ,{"resourceID",1}
     ,{"wholeMultiplex",2}
};
#endif
//
// FlowControlCommand_scope
//

H245_FlowControlCommand_scope::H245_FlowControlCommand_scope(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_FlowControlCommand_scope,3
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_FlowControlCommand_scope::operator H245_LogicalChannelNumber &() const
#else
H245_FlowControlCommand_scope::operator H245_LogicalChannelNumber &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_LogicalChannelNumber), PInvalidCast);
#endif
  return *(H245_LogicalChannelNumber *)choice;
}


H245_FlowControlCommand_scope::operator const H245_LogicalChannelNumber &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_LogicalChannelNumber), PInvalidCast);
#endif
  return *(H245_LogicalChannelNumber *)choice;
}


BOOL H245_FlowControlCommand_scope::CreateObject()
{
  switch (tag) {
    case e_logicalChannelNumber :
      choice = new H245_LogicalChannelNumber();
      return TRUE;
    case e_resourceID :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
      return TRUE;
    case e_wholeMultiplex :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_FlowControlCommand_scope::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_FlowControlCommand_scope::Class()), PInvalidCast);
#endif
  return new H245_FlowControlCommand_scope(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_FlowControlCommand_restriction[]={
      {"maximumBitRate",0}
     ,{"noRestriction",1}
};
#endif
//
// FlowControlCommand_restriction
//

H245_FlowControlCommand_restriction::H245_FlowControlCommand_restriction(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_FlowControlCommand_restriction,2
#endif
)
{
}


BOOL H245_FlowControlCommand_restriction::CreateObject()
{
  switch (tag) {
    case e_maximumBitRate :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 0, 16777215);
      return TRUE;
    case e_noRestriction :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_FlowControlCommand_restriction::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_FlowControlCommand_restriction::Class()), PInvalidCast);
#endif
  return new H245_FlowControlCommand_restriction(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_EndSessionCommand_gstnOptions[]={
      {"telephonyMode",0}
     ,{"v8bis",1}
     ,{"v34DSVD",2}
     ,{"v34DuplexFAX",3}
     ,{"v34H324",4}
};
#endif
//
// EndSessionCommand_gstnOptions
//

H245_EndSessionCommand_gstnOptions::H245_EndSessionCommand_gstnOptions(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 5, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_EndSessionCommand_gstnOptions,5
#endif
)
{
}


BOOL H245_EndSessionCommand_gstnOptions::CreateObject()
{
  choice = (tag <= e_v34H324) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_EndSessionCommand_gstnOptions::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_EndSessionCommand_gstnOptions::Class()), PInvalidCast);
#endif
  return new H245_EndSessionCommand_gstnOptions(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_EndSessionCommand_isdnOptions[]={
      {"telephonyMode",0}
     ,{"v140",1}
     ,{"terminalOnHold",2}
};
#endif
//
// EndSessionCommand_isdnOptions
//

H245_EndSessionCommand_isdnOptions::H245_EndSessionCommand_isdnOptions(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_EndSessionCommand_isdnOptions,3
#endif
)
{
}


BOOL H245_EndSessionCommand_isdnOptions::CreateObject()
{
  choice = (tag <= e_terminalOnHold) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_EndSessionCommand_isdnOptions::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_EndSessionCommand_isdnOptions::Class()), PInvalidCast);
#endif
  return new H245_EndSessionCommand_isdnOptions(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_MiscellaneousCommand_type[]={
      {"equaliseDelay",0}
     ,{"zeroDelay",1}
     ,{"multipointModeCommand",2}
     ,{"cancelMultipointModeCommand",3}
     ,{"videoFreezePicture",4}
     ,{"videoFastUpdatePicture",5}
     ,{"videoFastUpdateGOB",6}
     ,{"videoTemporalSpatialTradeOff",7}
     ,{"videoSendSyncEveryGOB",8}
     ,{"videoSendSyncEveryGOBCancel",9}
     ,{"videoFastUpdateMB",10}
     ,{"maxH223MUXPDUsize",11}
     ,{"encryptionUpdate",12}
     ,{"encryptionUpdateRequest",13}
     ,{"switchReceiveMediaOff",14}
     ,{"switchReceiveMediaOn",15}
     ,{"progressiveRefinementStart",16}
     ,{"progressiveRefinementAbortOne",17}
     ,{"progressiveRefinementAbortContinuous",18}
     ,{"videoBadMBs",19}
     ,{"lostPicture",20}
     ,{"lostPartialPicture",21}
     ,{"recoveryReferencePicture",22}
     ,{"encryptionUpdateCommand",23}
     ,{"encryptionUpdateAck",24}
};
#endif
//
// MiscellaneousCommand_type
//

H245_MiscellaneousCommand_type::H245_MiscellaneousCommand_type(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 10, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_MiscellaneousCommand_type,25
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MiscellaneousCommand_type::operator H245_MiscellaneousCommand_type_videoFastUpdateGOB &() const
#else
H245_MiscellaneousCommand_type::operator H245_MiscellaneousCommand_type_videoFastUpdateGOB &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MiscellaneousCommand_type_videoFastUpdateGOB), PInvalidCast);
#endif
  return *(H245_MiscellaneousCommand_type_videoFastUpdateGOB *)choice;
}


H245_MiscellaneousCommand_type::operator const H245_MiscellaneousCommand_type_videoFastUpdateGOB &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MiscellaneousCommand_type_videoFastUpdateGOB), PInvalidCast);
#endif
  return *(H245_MiscellaneousCommand_type_videoFastUpdateGOB *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MiscellaneousCommand_type::operator H245_MiscellaneousCommand_type_videoFastUpdateMB &() const
#else
H245_MiscellaneousCommand_type::operator H245_MiscellaneousCommand_type_videoFastUpdateMB &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MiscellaneousCommand_type_videoFastUpdateMB), PInvalidCast);
#endif
  return *(H245_MiscellaneousCommand_type_videoFastUpdateMB *)choice;
}


H245_MiscellaneousCommand_type::operator const H245_MiscellaneousCommand_type_videoFastUpdateMB &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MiscellaneousCommand_type_videoFastUpdateMB), PInvalidCast);
#endif
  return *(H245_MiscellaneousCommand_type_videoFastUpdateMB *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MiscellaneousCommand_type::operator H245_EncryptionSync &() const
#else
H245_MiscellaneousCommand_type::operator H245_EncryptionSync &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_EncryptionSync), PInvalidCast);
#endif
  return *(H245_EncryptionSync *)choice;
}


H245_MiscellaneousCommand_type::operator const H245_EncryptionSync &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_EncryptionSync), PInvalidCast);
#endif
  return *(H245_EncryptionSync *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MiscellaneousCommand_type::operator H245_EncryptionUpdateRequest &() const
#else
H245_MiscellaneousCommand_type::operator H245_EncryptionUpdateRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_EncryptionUpdateRequest), PInvalidCast);
#endif
  return *(H245_EncryptionUpdateRequest *)choice;
}


H245_MiscellaneousCommand_type::operator const H245_EncryptionUpdateRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_EncryptionUpdateRequest), PInvalidCast);
#endif
  return *(H245_EncryptionUpdateRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MiscellaneousCommand_type::operator H245_MiscellaneousCommand_type_progressiveRefinementStart &() const
#else
H245_MiscellaneousCommand_type::operator H245_MiscellaneousCommand_type_progressiveRefinementStart &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MiscellaneousCommand_type_progressiveRefinementStart), PInvalidCast);
#endif
  return *(H245_MiscellaneousCommand_type_progressiveRefinementStart *)choice;
}


H245_MiscellaneousCommand_type::operator const H245_MiscellaneousCommand_type_progressiveRefinementStart &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MiscellaneousCommand_type_progressiveRefinementStart), PInvalidCast);
#endif
  return *(H245_MiscellaneousCommand_type_progressiveRefinementStart *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MiscellaneousCommand_type::operator H245_MiscellaneousCommand_type_videoBadMBs &() const
#else
H245_MiscellaneousCommand_type::operator H245_MiscellaneousCommand_type_videoBadMBs &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MiscellaneousCommand_type_videoBadMBs), PInvalidCast);
#endif
  return *(H245_MiscellaneousCommand_type_videoBadMBs *)choice;
}


H245_MiscellaneousCommand_type::operator const H245_MiscellaneousCommand_type_videoBadMBs &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MiscellaneousCommand_type_videoBadMBs), PInvalidCast);
#endif
  return *(H245_MiscellaneousCommand_type_videoBadMBs *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MiscellaneousCommand_type::operator H245_ArrayOf_PictureReference &() const
#else
H245_MiscellaneousCommand_type::operator H245_ArrayOf_PictureReference &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ArrayOf_PictureReference), PInvalidCast);
#endif
  return *(H245_ArrayOf_PictureReference *)choice;
}


H245_MiscellaneousCommand_type::operator const H245_ArrayOf_PictureReference &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_ArrayOf_PictureReference), PInvalidCast);
#endif
  return *(H245_ArrayOf_PictureReference *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MiscellaneousCommand_type::operator H245_MiscellaneousCommand_type_lostPartialPicture &() const
#else
H245_MiscellaneousCommand_type::operator H245_MiscellaneousCommand_type_lostPartialPicture &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MiscellaneousCommand_type_lostPartialPicture), PInvalidCast);
#endif
  return *(H245_MiscellaneousCommand_type_lostPartialPicture *)choice;
}


H245_MiscellaneousCommand_type::operator const H245_MiscellaneousCommand_type_lostPartialPicture &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MiscellaneousCommand_type_lostPartialPicture), PInvalidCast);
#endif
  return *(H245_MiscellaneousCommand_type_lostPartialPicture *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MiscellaneousCommand_type::operator H245_MiscellaneousCommand_type_encryptionUpdateCommand &() const
#else
H245_MiscellaneousCommand_type::operator H245_MiscellaneousCommand_type_encryptionUpdateCommand &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MiscellaneousCommand_type_encryptionUpdateCommand), PInvalidCast);
#endif
  return *(H245_MiscellaneousCommand_type_encryptionUpdateCommand *)choice;
}


H245_MiscellaneousCommand_type::operator const H245_MiscellaneousCommand_type_encryptionUpdateCommand &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MiscellaneousCommand_type_encryptionUpdateCommand), PInvalidCast);
#endif
  return *(H245_MiscellaneousCommand_type_encryptionUpdateCommand *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MiscellaneousCommand_type::operator H245_MiscellaneousCommand_type_encryptionUpdateAck &() const
#else
H245_MiscellaneousCommand_type::operator H245_MiscellaneousCommand_type_encryptionUpdateAck &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MiscellaneousCommand_type_encryptionUpdateAck), PInvalidCast);
#endif
  return *(H245_MiscellaneousCommand_type_encryptionUpdateAck *)choice;
}


H245_MiscellaneousCommand_type::operator const H245_MiscellaneousCommand_type_encryptionUpdateAck &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MiscellaneousCommand_type_encryptionUpdateAck), PInvalidCast);
#endif
  return *(H245_MiscellaneousCommand_type_encryptionUpdateAck *)choice;
}


BOOL H245_MiscellaneousCommand_type::CreateObject()
{
  switch (tag) {
    case e_equaliseDelay :
    case e_zeroDelay :
    case e_multipointModeCommand :
    case e_cancelMultipointModeCommand :
    case e_videoFreezePicture :
    case e_videoFastUpdatePicture :
    case e_videoSendSyncEveryGOB :
    case e_videoSendSyncEveryGOBCancel :
    case e_switchReceiveMediaOff :
    case e_switchReceiveMediaOn :
    case e_progressiveRefinementAbortOne :
    case e_progressiveRefinementAbortContinuous :
      choice = new PASN_Null();
      return TRUE;
    case e_videoFastUpdateGOB :
      choice = new H245_MiscellaneousCommand_type_videoFastUpdateGOB();
      return TRUE;
    case e_videoTemporalSpatialTradeOff :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 0, 31);
      return TRUE;
    case e_videoFastUpdateMB :
      choice = new H245_MiscellaneousCommand_type_videoFastUpdateMB();
      return TRUE;
    case e_maxH223MUXPDUsize :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
      return TRUE;
    case e_encryptionUpdate :
      choice = new H245_EncryptionSync();
      return TRUE;
    case e_encryptionUpdateRequest :
      choice = new H245_EncryptionUpdateRequest();
      return TRUE;
    case e_progressiveRefinementStart :
      choice = new H245_MiscellaneousCommand_type_progressiveRefinementStart();
      return TRUE;
    case e_videoBadMBs :
      choice = new H245_MiscellaneousCommand_type_videoBadMBs();
      return TRUE;
    case e_lostPicture :
    case e_recoveryReferencePicture :
      choice = new H245_ArrayOf_PictureReference();
      return TRUE;
    case e_lostPartialPicture :
      choice = new H245_MiscellaneousCommand_type_lostPartialPicture();
      return TRUE;
    case e_encryptionUpdateCommand :
      choice = new H245_MiscellaneousCommand_type_encryptionUpdateCommand();
      return TRUE;
    case e_encryptionUpdateAck :
      choice = new H245_MiscellaneousCommand_type_encryptionUpdateAck();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_MiscellaneousCommand_type::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MiscellaneousCommand_type::Class()), PInvalidCast);
#endif
  return new H245_MiscellaneousCommand_type(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_H223MultiplexReconfiguration_h223ModeChange[]={
      {"toLevel0",0}
     ,{"toLevel1",1}
     ,{"toLevel2",2}
     ,{"toLevel2withOptionalHeader",3}
};
#endif
//
// H223MultiplexReconfiguration_h223ModeChange
//

H245_H223MultiplexReconfiguration_h223ModeChange::H245_H223MultiplexReconfiguration_h223ModeChange(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_H223MultiplexReconfiguration_h223ModeChange,4
#endif
)
{
}


BOOL H245_H223MultiplexReconfiguration_h223ModeChange::CreateObject()
{
  choice = (tag <= e_toLevel2withOptionalHeader) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_H223MultiplexReconfiguration_h223ModeChange::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223MultiplexReconfiguration_h223ModeChange::Class()), PInvalidCast);
#endif
  return new H245_H223MultiplexReconfiguration_h223ModeChange(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_H223MultiplexReconfiguration_h223AnnexADoubleFlag[]={
      {"start",0}
     ,{"stop",1}
};
#endif
//
// H223MultiplexReconfiguration_h223AnnexADoubleFlag
//

H245_H223MultiplexReconfiguration_h223AnnexADoubleFlag::H245_H223MultiplexReconfiguration_h223AnnexADoubleFlag(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_H223MultiplexReconfiguration_h223AnnexADoubleFlag,2
#endif
)
{
}


BOOL H245_H223MultiplexReconfiguration_h223AnnexADoubleFlag::CreateObject()
{
  choice = (tag <= e_stop) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_H223MultiplexReconfiguration_h223AnnexADoubleFlag::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223MultiplexReconfiguration_h223AnnexADoubleFlag::Class()), PInvalidCast);
#endif
  return new H245_H223MultiplexReconfiguration_h223AnnexADoubleFlag(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_NewATMVCCommand_aal[]={
      {"aal1",0}
     ,{"aal5",1}
};
#endif
//
// NewATMVCCommand_aal
//

H245_NewATMVCCommand_aal::H245_NewATMVCCommand_aal(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_NewATMVCCommand_aal,2
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_NewATMVCCommand_aal::operator H245_NewATMVCCommand_aal_aal1 &() const
#else
H245_NewATMVCCommand_aal::operator H245_NewATMVCCommand_aal_aal1 &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NewATMVCCommand_aal_aal1), PInvalidCast);
#endif
  return *(H245_NewATMVCCommand_aal_aal1 *)choice;
}


H245_NewATMVCCommand_aal::operator const H245_NewATMVCCommand_aal_aal1 &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NewATMVCCommand_aal_aal1), PInvalidCast);
#endif
  return *(H245_NewATMVCCommand_aal_aal1 *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_NewATMVCCommand_aal::operator H245_NewATMVCCommand_aal_aal5 &() const
#else
H245_NewATMVCCommand_aal::operator H245_NewATMVCCommand_aal_aal5 &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NewATMVCCommand_aal_aal5), PInvalidCast);
#endif
  return *(H245_NewATMVCCommand_aal_aal5 *)choice;
}


H245_NewATMVCCommand_aal::operator const H245_NewATMVCCommand_aal_aal5 &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NewATMVCCommand_aal_aal5), PInvalidCast);
#endif
  return *(H245_NewATMVCCommand_aal_aal5 *)choice;
}


BOOL H245_NewATMVCCommand_aal::CreateObject()
{
  switch (tag) {
    case e_aal1 :
      choice = new H245_NewATMVCCommand_aal_aal1();
      return TRUE;
    case e_aal5 :
      choice = new H245_NewATMVCCommand_aal_aal5();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_NewATMVCCommand_aal::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NewATMVCCommand_aal::Class()), PInvalidCast);
#endif
  return new H245_NewATMVCCommand_aal(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_NewATMVCCommand_multiplex[]={
      {"noMultiplex",0}
     ,{"transportStream",1}
     ,{"programStream",2}
};
#endif
//
// NewATMVCCommand_multiplex
//

H245_NewATMVCCommand_multiplex::H245_NewATMVCCommand_multiplex(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_NewATMVCCommand_multiplex,3
#endif
)
{
}


BOOL H245_NewATMVCCommand_multiplex::CreateObject()
{
  choice = (tag <= e_programStream) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_NewATMVCCommand_multiplex::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NewATMVCCommand_multiplex::Class()), PInvalidCast);
#endif
  return new H245_NewATMVCCommand_multiplex(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_MobileMultilinkReconfigurationCommand_status[]={
      {"synchronized",0}
     ,{"reconfiguration",1}
};
#endif
//
// MobileMultilinkReconfigurationCommand_status
//

H245_MobileMultilinkReconfigurationCommand_status::H245_MobileMultilinkReconfigurationCommand_status(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_MobileMultilinkReconfigurationCommand_status,2
#endif
)
{
}


BOOL H245_MobileMultilinkReconfigurationCommand_status::CreateObject()
{
  choice = (tag <= e_reconfiguration) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_MobileMultilinkReconfigurationCommand_status::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MobileMultilinkReconfigurationCommand_status::Class()), PInvalidCast);
#endif
  return new H245_MobileMultilinkReconfigurationCommand_status(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_FunctionNotSupported_cause[]={
      {"syntaxError",0}
     ,{"semanticError",1}
     ,{"unknownFunction",2}
};
#endif
//
// FunctionNotSupported_cause
//

H245_FunctionNotSupported_cause::H245_FunctionNotSupported_cause(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_FunctionNotSupported_cause,3
#endif
)
{
}


BOOL H245_FunctionNotSupported_cause::CreateObject()
{
  choice = (tag <= e_unknownFunction) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_FunctionNotSupported_cause::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_FunctionNotSupported_cause::Class()), PInvalidCast);
#endif
  return new H245_FunctionNotSupported_cause(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_MiscellaneousIndication_type[]={
      {"logicalChannelActive",0}
     ,{"logicalChannelInactive",1}
     ,{"multipointConference",2}
     ,{"cancelMultipointConference",3}
     ,{"multipointZeroComm",4}
     ,{"cancelMultipointZeroComm",5}
     ,{"multipointSecondaryStatus",6}
     ,{"cancelMultipointSecondaryStatus",7}
     ,{"videoIndicateReadyToActivate",8}
     ,{"videoTemporalSpatialTradeOff",9}
     ,{"videoNotDecodedMBs",10}
     ,{"transportCapability",11}
};
#endif
//
// MiscellaneousIndication_type
//

H245_MiscellaneousIndication_type::H245_MiscellaneousIndication_type(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 10, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_MiscellaneousIndication_type,12
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MiscellaneousIndication_type::operator H245_MiscellaneousIndication_type_videoNotDecodedMBs &() const
#else
H245_MiscellaneousIndication_type::operator H245_MiscellaneousIndication_type_videoNotDecodedMBs &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MiscellaneousIndication_type_videoNotDecodedMBs), PInvalidCast);
#endif
  return *(H245_MiscellaneousIndication_type_videoNotDecodedMBs *)choice;
}


H245_MiscellaneousIndication_type::operator const H245_MiscellaneousIndication_type_videoNotDecodedMBs &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MiscellaneousIndication_type_videoNotDecodedMBs), PInvalidCast);
#endif
  return *(H245_MiscellaneousIndication_type_videoNotDecodedMBs *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MiscellaneousIndication_type::operator H245_TransportCapability &() const
#else
H245_MiscellaneousIndication_type::operator H245_TransportCapability &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_TransportCapability), PInvalidCast);
#endif
  return *(H245_TransportCapability *)choice;
}


H245_MiscellaneousIndication_type::operator const H245_TransportCapability &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_TransportCapability), PInvalidCast);
#endif
  return *(H245_TransportCapability *)choice;
}


BOOL H245_MiscellaneousIndication_type::CreateObject()
{
  switch (tag) {
    case e_logicalChannelActive :
    case e_logicalChannelInactive :
    case e_multipointConference :
    case e_cancelMultipointConference :
    case e_multipointZeroComm :
    case e_cancelMultipointZeroComm :
    case e_multipointSecondaryStatus :
    case e_cancelMultipointSecondaryStatus :
    case e_videoIndicateReadyToActivate :
      choice = new PASN_Null();
      return TRUE;
    case e_videoTemporalSpatialTradeOff :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 0, 31);
      return TRUE;
    case e_videoNotDecodedMBs :
      choice = new H245_MiscellaneousIndication_type_videoNotDecodedMBs();
      return TRUE;
    case e_transportCapability :
      choice = new H245_TransportCapability();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_MiscellaneousIndication_type::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MiscellaneousIndication_type::Class()), PInvalidCast);
#endif
  return new H245_MiscellaneousIndication_type(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_JitterIndication_scope[]={
      {"logicalChannelNumber",0}
     ,{"resourceID",1}
     ,{"wholeMultiplex",2}
};
#endif
//
// JitterIndication_scope
//

H245_JitterIndication_scope::H245_JitterIndication_scope(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_JitterIndication_scope,3
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_JitterIndication_scope::operator H245_LogicalChannelNumber &() const
#else
H245_JitterIndication_scope::operator H245_LogicalChannelNumber &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_LogicalChannelNumber), PInvalidCast);
#endif
  return *(H245_LogicalChannelNumber *)choice;
}


H245_JitterIndication_scope::operator const H245_LogicalChannelNumber &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_LogicalChannelNumber), PInvalidCast);
#endif
  return *(H245_LogicalChannelNumber *)choice;
}


BOOL H245_JitterIndication_scope::CreateObject()
{
  switch (tag) {
    case e_logicalChannelNumber :
      choice = new H245_LogicalChannelNumber();
      return TRUE;
    case e_resourceID :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
      return TRUE;
    case e_wholeMultiplex :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_JitterIndication_scope::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_JitterIndication_scope::Class()), PInvalidCast);
#endif
  return new H245_JitterIndication_scope(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_NewATMVCIndication_aal[]={
      {"aal1",0}
     ,{"aal5",1}
};
#endif
//
// NewATMVCIndication_aal
//

H245_NewATMVCIndication_aal::H245_NewATMVCIndication_aal(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_NewATMVCIndication_aal,2
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_NewATMVCIndication_aal::operator H245_NewATMVCIndication_aal_aal1 &() const
#else
H245_NewATMVCIndication_aal::operator H245_NewATMVCIndication_aal_aal1 &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NewATMVCIndication_aal_aal1), PInvalidCast);
#endif
  return *(H245_NewATMVCIndication_aal_aal1 *)choice;
}


H245_NewATMVCIndication_aal::operator const H245_NewATMVCIndication_aal_aal1 &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NewATMVCIndication_aal_aal1), PInvalidCast);
#endif
  return *(H245_NewATMVCIndication_aal_aal1 *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_NewATMVCIndication_aal::operator H245_NewATMVCIndication_aal_aal5 &() const
#else
H245_NewATMVCIndication_aal::operator H245_NewATMVCIndication_aal_aal5 &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NewATMVCIndication_aal_aal5), PInvalidCast);
#endif
  return *(H245_NewATMVCIndication_aal_aal5 *)choice;
}


H245_NewATMVCIndication_aal::operator const H245_NewATMVCIndication_aal_aal5 &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NewATMVCIndication_aal_aal5), PInvalidCast);
#endif
  return *(H245_NewATMVCIndication_aal_aal5 *)choice;
}


BOOL H245_NewATMVCIndication_aal::CreateObject()
{
  switch (tag) {
    case e_aal1 :
      choice = new H245_NewATMVCIndication_aal_aal1();
      return TRUE;
    case e_aal5 :
      choice = new H245_NewATMVCIndication_aal_aal5();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_NewATMVCIndication_aal::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NewATMVCIndication_aal::Class()), PInvalidCast);
#endif
  return new H245_NewATMVCIndication_aal(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_NewATMVCIndication_multiplex[]={
      {"noMultiplex",0}
     ,{"transportStream",1}
     ,{"programStream",2}
};
#endif
//
// NewATMVCIndication_multiplex
//

H245_NewATMVCIndication_multiplex::H245_NewATMVCIndication_multiplex(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_NewATMVCIndication_multiplex,3
#endif
)
{
}


BOOL H245_NewATMVCIndication_multiplex::CreateObject()
{
  choice = (tag <= e_programStream) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_NewATMVCIndication_multiplex::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NewATMVCIndication_multiplex::Class()), PInvalidCast);
#endif
  return new H245_NewATMVCIndication_multiplex(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_UserInputIndication_userInputSupportIndication[]={
      {"nonStandard",0}
     ,{"basicString",1}
     ,{"iA5String",2}
     ,{"generalString",3}
     ,{"encryptedBasicString",4}
     ,{"encryptedIA5String",5}
     ,{"encryptedGeneralString",6}
};
#endif
//
// UserInputIndication_userInputSupportIndication
//

H245_UserInputIndication_userInputSupportIndication::H245_UserInputIndication_userInputSupportIndication(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_UserInputIndication_userInputSupportIndication,7
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_UserInputIndication_userInputSupportIndication::operator H245_NonStandardParameter &() const
#else
H245_UserInputIndication_userInputSupportIndication::operator H245_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


H245_UserInputIndication_userInputSupportIndication::operator const H245_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_NonStandardParameter), PInvalidCast);
#endif
  return *(H245_NonStandardParameter *)choice;
}


BOOL H245_UserInputIndication_userInputSupportIndication::CreateObject()
{
  switch (tag) {
    case e_nonStandard :
      choice = new H245_NonStandardParameter();
      return TRUE;
    case e_basicString :
    case e_iA5String :
    case e_generalString :
    case e_encryptedBasicString :
    case e_encryptedIA5String :
    case e_encryptedGeneralString :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_UserInputIndication_userInputSupportIndication::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_UserInputIndication_userInputSupportIndication::Class()), PInvalidCast);
#endif
  return new H245_UserInputIndication_userInputSupportIndication(*this);
}


//
// UserInputIndication_encryptedAlphanumeric
//

H245_UserInputIndication_encryptedAlphanumeric::H245_UserInputIndication_encryptedAlphanumeric(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_UserInputIndication_encryptedAlphanumeric::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "algorithmOID = " << setprecision(indent) << m_algorithmOID << '\n';
  if (HasOptionalField(e_paramS))
    strm << setw(indent+9) << "paramS = " << setprecision(indent) << m_paramS << '\n';
  strm << setw(indent+12) << "encrypted = " << setprecision(indent) << m_encrypted << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_UserInputIndication_encryptedAlphanumeric::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_UserInputIndication_encryptedAlphanumeric), PInvalidCast);
#endif
  const H245_UserInputIndication_encryptedAlphanumeric & other = (const H245_UserInputIndication_encryptedAlphanumeric &)obj;

  Comparison result;

  if ((result = m_algorithmOID.Compare(other.m_algorithmOID)) != EqualTo)
    return result;
  if ((result = m_paramS.Compare(other.m_paramS)) != EqualTo)
    return result;
  if ((result = m_encrypted.Compare(other.m_encrypted)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_UserInputIndication_encryptedAlphanumeric::GetDataLength() const
{
  PINDEX length = 0;
  length += m_algorithmOID.GetObjectLength();
  if (HasOptionalField(e_paramS))
    length += m_paramS.GetObjectLength();
  length += m_encrypted.GetObjectLength();
  return length;
}


BOOL H245_UserInputIndication_encryptedAlphanumeric::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_algorithmOID.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_paramS) && !m_paramS.Decode(strm))
    return FALSE;
  if (!m_encrypted.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_UserInputIndication_encryptedAlphanumeric::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_algorithmOID.Encode(strm);
  if (HasOptionalField(e_paramS))
    m_paramS.Encode(strm);
  m_encrypted.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_UserInputIndication_encryptedAlphanumeric::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_UserInputIndication_encryptedAlphanumeric::Class()), PInvalidCast);
#endif
  return new H245_UserInputIndication_encryptedAlphanumeric(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_FlowControlIndication_scope[]={
      {"logicalChannelNumber",0}
     ,{"resourceID",1}
     ,{"wholeMultiplex",2}
};
#endif
//
// FlowControlIndication_scope
//

H245_FlowControlIndication_scope::H245_FlowControlIndication_scope(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_FlowControlIndication_scope,3
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_FlowControlIndication_scope::operator H245_LogicalChannelNumber &() const
#else
H245_FlowControlIndication_scope::operator H245_LogicalChannelNumber &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_LogicalChannelNumber), PInvalidCast);
#endif
  return *(H245_LogicalChannelNumber *)choice;
}


H245_FlowControlIndication_scope::operator const H245_LogicalChannelNumber &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_LogicalChannelNumber), PInvalidCast);
#endif
  return *(H245_LogicalChannelNumber *)choice;
}


BOOL H245_FlowControlIndication_scope::CreateObject()
{
  switch (tag) {
    case e_logicalChannelNumber :
      choice = new H245_LogicalChannelNumber();
      return TRUE;
    case e_resourceID :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
      return TRUE;
    case e_wholeMultiplex :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_FlowControlIndication_scope::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_FlowControlIndication_scope::Class()), PInvalidCast);
#endif
  return new H245_FlowControlIndication_scope(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_FlowControlIndication_restriction[]={
      {"maximumBitRate",0}
     ,{"noRestriction",1}
};
#endif
//
// FlowControlIndication_restriction
//

H245_FlowControlIndication_restriction::H245_FlowControlIndication_restriction(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_FlowControlIndication_restriction,2
#endif
)
{
}


BOOL H245_FlowControlIndication_restriction::CreateObject()
{
  switch (tag) {
    case e_maximumBitRate :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 0, 16777215);
      return TRUE;
    case e_noRestriction :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_FlowControlIndication_restriction::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_FlowControlIndication_restriction::Class()), PInvalidCast);
#endif
  return new H245_FlowControlIndication_restriction(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded[]={
      {"highestEntryNumberProcessed",0}
     ,{"noneProcessed",1}
};
#endif
//
// TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded
//

H245_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded::H245_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded,2
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded::operator H245_CapabilityTableEntryNumber &() const
#else
H245_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded::operator H245_CapabilityTableEntryNumber &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_CapabilityTableEntryNumber), PInvalidCast);
#endif
  return *(H245_CapabilityTableEntryNumber *)choice;
}


H245_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded::operator const H245_CapabilityTableEntryNumber &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_CapabilityTableEntryNumber), PInvalidCast);
#endif
  return *(H245_CapabilityTableEntryNumber *)choice;
}


BOOL H245_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded::CreateObject()
{
  switch (tag) {
    case e_highestEntryNumberProcessed :
      choice = new H245_CapabilityTableEntryNumber();
      return TRUE;
    case e_noneProcessed :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded::Class()), PInvalidCast);
#endif
  return new H245_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_VCCapability_availableBitRates_type[]={
      {"singleBitRate",0}
     ,{"rangeOfBitRates",1}
};
#endif
//
// VCCapability_availableBitRates_type
//

H245_VCCapability_availableBitRates_type::H245_VCCapability_availableBitRates_type(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_VCCapability_availableBitRates_type,2
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_VCCapability_availableBitRates_type::operator H245_VCCapability_availableBitRates_type_rangeOfBitRates &() const
#else
H245_VCCapability_availableBitRates_type::operator H245_VCCapability_availableBitRates_type_rangeOfBitRates &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_VCCapability_availableBitRates_type_rangeOfBitRates), PInvalidCast);
#endif
  return *(H245_VCCapability_availableBitRates_type_rangeOfBitRates *)choice;
}


H245_VCCapability_availableBitRates_type::operator const H245_VCCapability_availableBitRates_type_rangeOfBitRates &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_VCCapability_availableBitRates_type_rangeOfBitRates), PInvalidCast);
#endif
  return *(H245_VCCapability_availableBitRates_type_rangeOfBitRates *)choice;
}


BOOL H245_VCCapability_availableBitRates_type::CreateObject()
{
  switch (tag) {
    case e_singleBitRate :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
      return TRUE;
    case e_rangeOfBitRates :
      choice = new H245_VCCapability_availableBitRates_type_rangeOfBitRates();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_VCCapability_availableBitRates_type::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_VCCapability_availableBitRates_type::Class()), PInvalidCast);
#endif
  return new H245_VCCapability_availableBitRates_type(*this);
}


//
// ArrayOf_Q2931Address
//

H245_ArrayOf_Q2931Address::H245_ArrayOf_Q2931Address(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_Q2931Address::CreateObject() const
{
  return new H245_Q2931Address;
}


H245_Q2931Address & H245_ArrayOf_Q2931Address::operator[](PINDEX i) const
{
  return (H245_Q2931Address &)array[i];
}


PObject * H245_ArrayOf_Q2931Address::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_Q2931Address::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_Q2931Address(*this);
}


//
// H223Capability_h223MultiplexTableCapability_enhanced
//

H245_H223Capability_h223MultiplexTableCapability_enhanced::H245_H223Capability_h223MultiplexTableCapability_enhanced(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_maximumNestingDepth.SetConstraints(PASN_Object::FixedConstraint, 1, 15);
  m_maximumElementListSize.SetConstraints(PASN_Object::FixedConstraint, 2, 255);
  m_maximumSubElementListSize.SetConstraints(PASN_Object::FixedConstraint, 2, 255);
}


#ifndef PASN_NOPRINTON
void H245_H223Capability_h223MultiplexTableCapability_enhanced::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+22) << "maximumNestingDepth = " << setprecision(indent) << m_maximumNestingDepth << '\n';
  strm << setw(indent+25) << "maximumElementListSize = " << setprecision(indent) << m_maximumElementListSize << '\n';
  strm << setw(indent+28) << "maximumSubElementListSize = " << setprecision(indent) << m_maximumSubElementListSize << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_H223Capability_h223MultiplexTableCapability_enhanced::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_H223Capability_h223MultiplexTableCapability_enhanced), PInvalidCast);
#endif
  const H245_H223Capability_h223MultiplexTableCapability_enhanced & other = (const H245_H223Capability_h223MultiplexTableCapability_enhanced &)obj;

  Comparison result;

  if ((result = m_maximumNestingDepth.Compare(other.m_maximumNestingDepth)) != EqualTo)
    return result;
  if ((result = m_maximumElementListSize.Compare(other.m_maximumElementListSize)) != EqualTo)
    return result;
  if ((result = m_maximumSubElementListSize.Compare(other.m_maximumSubElementListSize)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H223Capability_h223MultiplexTableCapability_enhanced::GetDataLength() const
{
  PINDEX length = 0;
  length += m_maximumNestingDepth.GetObjectLength();
  length += m_maximumElementListSize.GetObjectLength();
  length += m_maximumSubElementListSize.GetObjectLength();
  return length;
}


BOOL H245_H223Capability_h223MultiplexTableCapability_enhanced::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_maximumNestingDepth.Decode(strm))
    return FALSE;
  if (!m_maximumElementListSize.Decode(strm))
    return FALSE;
  if (!m_maximumSubElementListSize.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_H223Capability_h223MultiplexTableCapability_enhanced::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_maximumNestingDepth.Encode(strm);
  m_maximumElementListSize.Encode(strm);
  m_maximumSubElementListSize.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_H223Capability_h223MultiplexTableCapability_enhanced::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223Capability_h223MultiplexTableCapability_enhanced::Class()), PInvalidCast);
#endif
  return new H245_H223Capability_h223MultiplexTableCapability_enhanced(*this);
}


//
// ArrayOf_RTPH263VideoRedundancyFrameMapping
//

H245_ArrayOf_RTPH263VideoRedundancyFrameMapping::H245_ArrayOf_RTPH263VideoRedundancyFrameMapping(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_RTPH263VideoRedundancyFrameMapping::CreateObject() const
{
  return new H245_RTPH263VideoRedundancyFrameMapping;
}


H245_RTPH263VideoRedundancyFrameMapping & H245_ArrayOf_RTPH263VideoRedundancyFrameMapping::operator[](PINDEX i) const
{
  return (H245_RTPH263VideoRedundancyFrameMapping &)array[i];
}


PObject * H245_ArrayOf_RTPH263VideoRedundancyFrameMapping::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_RTPH263VideoRedundancyFrameMapping::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_RTPH263VideoRedundancyFrameMapping(*this);
}


//
// RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters
//

H245_RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters::H245_RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_mpuHorizMBs.SetConstraints(PASN_Object::FixedConstraint, 1, 128);
  m_mpuVertMBs.SetConstraints(PASN_Object::FixedConstraint, 1, 72);
  m_mpuTotalNumber.SetConstraints(PASN_Object::FixedConstraint, 1, 65536);
}


#ifndef PASN_NOPRINTON
void H245_RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+14) << "mpuHorizMBs = " << setprecision(indent) << m_mpuHorizMBs << '\n';
  strm << setw(indent+13) << "mpuVertMBs = " << setprecision(indent) << m_mpuVertMBs << '\n';
  strm << setw(indent+17) << "mpuTotalNumber = " << setprecision(indent) << m_mpuTotalNumber << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters), PInvalidCast);
#endif
  const H245_RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters & other = (const H245_RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters &)obj;

  Comparison result;

  if ((result = m_mpuHorizMBs.Compare(other.m_mpuHorizMBs)) != EqualTo)
    return result;
  if ((result = m_mpuVertMBs.Compare(other.m_mpuVertMBs)) != EqualTo)
    return result;
  if ((result = m_mpuTotalNumber.Compare(other.m_mpuTotalNumber)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters::GetDataLength() const
{
  PINDEX length = 0;
  length += m_mpuHorizMBs.GetObjectLength();
  length += m_mpuVertMBs.GetObjectLength();
  length += m_mpuTotalNumber.GetObjectLength();
  return length;
}


BOOL H245_RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_mpuHorizMBs.Decode(strm))
    return FALSE;
  if (!m_mpuVertMBs.Decode(strm))
    return FALSE;
  if (!m_mpuTotalNumber.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_mpuHorizMBs.Encode(strm);
  m_mpuVertMBs.Encode(strm);
  m_mpuTotalNumber.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters::Class()), PInvalidCast);
#endif
  return new H245_RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters(*this);
}


//
// CustomPictureFormat_mPI_customPCF
//

H245_CustomPictureFormat_mPI_customPCF::H245_CustomPictureFormat_mPI_customPCF(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 16);
}


PASN_Object * H245_CustomPictureFormat_mPI_customPCF::CreateObject() const
{
  return new H245_CustomPictureFormat_mPI_customPCF_subtype;
}


H245_CustomPictureFormat_mPI_customPCF_subtype & H245_CustomPictureFormat_mPI_customPCF::operator[](PINDEX i) const
{
  return (H245_CustomPictureFormat_mPI_customPCF_subtype &)array[i];
}


PObject * H245_CustomPictureFormat_mPI_customPCF::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CustomPictureFormat_mPI_customPCF::Class()), PInvalidCast);
#endif
  return new H245_CustomPictureFormat_mPI_customPCF(*this);
}


//
// CustomPictureFormat_pixelAspectInformation_pixelAspectCode
//

H245_CustomPictureFormat_pixelAspectInformation_pixelAspectCode::H245_CustomPictureFormat_pixelAspectInformation_pixelAspectCode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 14);
}


PASN_Object * H245_CustomPictureFormat_pixelAspectInformation_pixelAspectCode::CreateObject() const
{
  PASN_Integer * obj = new PASN_Integer;
  obj->SetConstraints(PASN_Object::FixedConstraint, 1, 14);
  return obj;
}


PASN_Integer & H245_CustomPictureFormat_pixelAspectInformation_pixelAspectCode::operator[](PINDEX i) const
{
  return (PASN_Integer &)array[i];
}


PObject * H245_CustomPictureFormat_pixelAspectInformation_pixelAspectCode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CustomPictureFormat_pixelAspectInformation_pixelAspectCode::Class()), PInvalidCast);
#endif
  return new H245_CustomPictureFormat_pixelAspectInformation_pixelAspectCode(*this);
}


//
// CustomPictureFormat_pixelAspectInformation_extendedPAR
//

H245_CustomPictureFormat_pixelAspectInformation_extendedPAR::H245_CustomPictureFormat_pixelAspectInformation_extendedPAR(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


PASN_Object * H245_CustomPictureFormat_pixelAspectInformation_extendedPAR::CreateObject() const
{
  return new H245_CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype;
}


H245_CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype & H245_CustomPictureFormat_pixelAspectInformation_extendedPAR::operator[](PINDEX i) const
{
  return (H245_CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype &)array[i];
}


PObject * H245_CustomPictureFormat_pixelAspectInformation_extendedPAR::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CustomPictureFormat_pixelAspectInformation_extendedPAR::Class()), PInvalidCast);
#endif
  return new H245_CustomPictureFormat_pixelAspectInformation_extendedPAR(*this);
}


//
// DataApplicationCapability_application_t84
//

H245_DataApplicationCapability_application_t84::H245_DataApplicationCapability_application_t84(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_DataApplicationCapability_application_t84::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+14) << "t84Protocol = " << setprecision(indent) << m_t84Protocol << '\n';
  strm << setw(indent+13) << "t84Profile = " << setprecision(indent) << m_t84Profile << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_DataApplicationCapability_application_t84::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_DataApplicationCapability_application_t84), PInvalidCast);
#endif
  const H245_DataApplicationCapability_application_t84 & other = (const H245_DataApplicationCapability_application_t84 &)obj;

  Comparison result;

  if ((result = m_t84Protocol.Compare(other.m_t84Protocol)) != EqualTo)
    return result;
  if ((result = m_t84Profile.Compare(other.m_t84Profile)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_DataApplicationCapability_application_t84::GetDataLength() const
{
  PINDEX length = 0;
  length += m_t84Protocol.GetObjectLength();
  length += m_t84Profile.GetObjectLength();
  return length;
}


BOOL H245_DataApplicationCapability_application_t84::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_t84Protocol.Decode(strm))
    return FALSE;
  if (!m_t84Profile.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_DataApplicationCapability_application_t84::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_t84Protocol.Encode(strm);
  m_t84Profile.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_DataApplicationCapability_application_t84::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_DataApplicationCapability_application_t84::Class()), PInvalidCast);
#endif
  return new H245_DataApplicationCapability_application_t84(*this);
}


//
// DataApplicationCapability_application_nlpid
//

H245_DataApplicationCapability_application_nlpid::H245_DataApplicationCapability_application_nlpid(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_DataApplicationCapability_application_nlpid::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "nlpidProtocol = " << setprecision(indent) << m_nlpidProtocol << '\n';
  strm << setw(indent+12) << "nlpidData = " << setprecision(indent) << m_nlpidData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_DataApplicationCapability_application_nlpid::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_DataApplicationCapability_application_nlpid), PInvalidCast);
#endif
  const H245_DataApplicationCapability_application_nlpid & other = (const H245_DataApplicationCapability_application_nlpid &)obj;

  Comparison result;

  if ((result = m_nlpidProtocol.Compare(other.m_nlpidProtocol)) != EqualTo)
    return result;
  if ((result = m_nlpidData.Compare(other.m_nlpidData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_DataApplicationCapability_application_nlpid::GetDataLength() const
{
  PINDEX length = 0;
  length += m_nlpidProtocol.GetObjectLength();
  length += m_nlpidData.GetObjectLength();
  return length;
}


BOOL H245_DataApplicationCapability_application_nlpid::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_nlpidProtocol.Decode(strm))
    return FALSE;
  if (!m_nlpidData.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_DataApplicationCapability_application_nlpid::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_nlpidProtocol.Encode(strm);
  m_nlpidData.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_DataApplicationCapability_application_nlpid::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_DataApplicationCapability_application_nlpid::Class()), PInvalidCast);
#endif
  return new H245_DataApplicationCapability_application_nlpid(*this);
}


//
// DepFECCapability_rfc2733_separateStream
//

H245_DepFECCapability_rfc2733_separateStream::H245_DepFECCapability_rfc2733_separateStream(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_DepFECCapability_rfc2733_separateStream::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "separatePort = " << setprecision(indent) << m_separatePort << '\n';
  strm << setw(indent+11) << "samePort = " << setprecision(indent) << m_samePort << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_DepFECCapability_rfc2733_separateStream::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_DepFECCapability_rfc2733_separateStream), PInvalidCast);
#endif
  const H245_DepFECCapability_rfc2733_separateStream & other = (const H245_DepFECCapability_rfc2733_separateStream &)obj;

  Comparison result;

  if ((result = m_separatePort.Compare(other.m_separatePort)) != EqualTo)
    return result;
  if ((result = m_samePort.Compare(other.m_samePort)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_DepFECCapability_rfc2733_separateStream::GetDataLength() const
{
  PINDEX length = 0;
  length += m_separatePort.GetObjectLength();
  length += m_samePort.GetObjectLength();
  return length;
}


BOOL H245_DepFECCapability_rfc2733_separateStream::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_separatePort.Decode(strm))
    return FALSE;
  if (!m_samePort.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_DepFECCapability_rfc2733_separateStream::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_separatePort.Encode(strm);
  m_samePort.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_DepFECCapability_rfc2733_separateStream::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_DepFECCapability_rfc2733_separateStream::Class()), PInvalidCast);
#endif
  return new H245_DepFECCapability_rfc2733_separateStream(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters[]={
      {"h222LogicalChannelParameters",0}
     ,{"h223LogicalChannelParameters",1}
     ,{"v76LogicalChannelParameters",2}
     ,{"h2250LogicalChannelParameters",3}
     ,{"none",4}
};
#endif
//
// OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters
//

H245_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters::H245_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters,5
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters::operator H245_H222LogicalChannelParameters &() const
#else
H245_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters::operator H245_H222LogicalChannelParameters &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H222LogicalChannelParameters), PInvalidCast);
#endif
  return *(H245_H222LogicalChannelParameters *)choice;
}


H245_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters::operator const H245_H222LogicalChannelParameters &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H222LogicalChannelParameters), PInvalidCast);
#endif
  return *(H245_H222LogicalChannelParameters *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters::operator H245_H223LogicalChannelParameters &() const
#else
H245_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters::operator H245_H223LogicalChannelParameters &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H223LogicalChannelParameters), PInvalidCast);
#endif
  return *(H245_H223LogicalChannelParameters *)choice;
}


H245_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters::operator const H245_H223LogicalChannelParameters &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H223LogicalChannelParameters), PInvalidCast);
#endif
  return *(H245_H223LogicalChannelParameters *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters::operator H245_V76LogicalChannelParameters &() const
#else
H245_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters::operator H245_V76LogicalChannelParameters &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_V76LogicalChannelParameters), PInvalidCast);
#endif
  return *(H245_V76LogicalChannelParameters *)choice;
}


H245_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters::operator const H245_V76LogicalChannelParameters &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_V76LogicalChannelParameters), PInvalidCast);
#endif
  return *(H245_V76LogicalChannelParameters *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters::operator H245_H2250LogicalChannelParameters &() const
#else
H245_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters::operator H245_H2250LogicalChannelParameters &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H2250LogicalChannelParameters), PInvalidCast);
#endif
  return *(H245_H2250LogicalChannelParameters *)choice;
}


H245_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters::operator const H245_H2250LogicalChannelParameters &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H2250LogicalChannelParameters), PInvalidCast);
#endif
  return *(H245_H2250LogicalChannelParameters *)choice;
}


BOOL H245_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters::CreateObject()
{
  switch (tag) {
    case e_h222LogicalChannelParameters :
      choice = new H245_H222LogicalChannelParameters();
      return TRUE;
    case e_h223LogicalChannelParameters :
      choice = new H245_H223LogicalChannelParameters();
      return TRUE;
    case e_v76LogicalChannelParameters :
      choice = new H245_V76LogicalChannelParameters();
      return TRUE;
    case e_h2250LogicalChannelParameters :
      choice = new H245_H2250LogicalChannelParameters();
      return TRUE;
    case e_none :
      choice = new PASN_Null();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters::Class()), PInvalidCast);
#endif
  return new H245_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters[]={
      {"h223LogicalChannelParameters",0}
     ,{"v76LogicalChannelParameters",1}
     ,{"h2250LogicalChannelParameters",2}
};
#endif
//
// OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters
//

H245_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters::H245_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters,3
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters::operator H245_H223LogicalChannelParameters &() const
#else
H245_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters::operator H245_H223LogicalChannelParameters &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H223LogicalChannelParameters), PInvalidCast);
#endif
  return *(H245_H223LogicalChannelParameters *)choice;
}


H245_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters::operator const H245_H223LogicalChannelParameters &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H223LogicalChannelParameters), PInvalidCast);
#endif
  return *(H245_H223LogicalChannelParameters *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters::operator H245_V76LogicalChannelParameters &() const
#else
H245_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters::operator H245_V76LogicalChannelParameters &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_V76LogicalChannelParameters), PInvalidCast);
#endif
  return *(H245_V76LogicalChannelParameters *)choice;
}


H245_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters::operator const H245_V76LogicalChannelParameters &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_V76LogicalChannelParameters), PInvalidCast);
#endif
  return *(H245_V76LogicalChannelParameters *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters::operator H245_H2250LogicalChannelParameters &() const
#else
H245_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters::operator H245_H2250LogicalChannelParameters &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H2250LogicalChannelParameters), PInvalidCast);
#endif
  return *(H245_H2250LogicalChannelParameters *)choice;
}


H245_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters::operator const H245_H2250LogicalChannelParameters &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H2250LogicalChannelParameters), PInvalidCast);
#endif
  return *(H245_H2250LogicalChannelParameters *)choice;
}


BOOL H245_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters::CreateObject()
{
  switch (tag) {
    case e_h223LogicalChannelParameters :
      choice = new H245_H223LogicalChannelParameters();
      return TRUE;
    case e_v76LogicalChannelParameters :
      choice = new H245_V76LogicalChannelParameters();
      return TRUE;
    case e_h2250LogicalChannelParameters :
      choice = new H245_H2250LogicalChannelParameters();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters::Class()), PInvalidCast);
#endif
  return new H245_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(*this);
}


//
// H223LogicalChannelParameters_adaptationLayerType_al3
//

H245_H223LogicalChannelParameters_adaptationLayerType_al3::H245_H223LogicalChannelParameters_adaptationLayerType_al3(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
  m_controlFieldOctets.SetConstraints(PASN_Object::FixedConstraint, 0, 2);
  m_sendBufferSize.SetConstraints(PASN_Object::FixedConstraint, 0, 16777215);
}


#ifndef PASN_NOPRINTON
void H245_H223LogicalChannelParameters_adaptationLayerType_al3::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+21) << "controlFieldOctets = " << setprecision(indent) << m_controlFieldOctets << '\n';
  strm << setw(indent+17) << "sendBufferSize = " << setprecision(indent) << m_sendBufferSize << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_H223LogicalChannelParameters_adaptationLayerType_al3::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_H223LogicalChannelParameters_adaptationLayerType_al3), PInvalidCast);
#endif
  const H245_H223LogicalChannelParameters_adaptationLayerType_al3 & other = (const H245_H223LogicalChannelParameters_adaptationLayerType_al3 &)obj;

  Comparison result;

  if ((result = m_controlFieldOctets.Compare(other.m_controlFieldOctets)) != EqualTo)
    return result;
  if ((result = m_sendBufferSize.Compare(other.m_sendBufferSize)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H223LogicalChannelParameters_adaptationLayerType_al3::GetDataLength() const
{
  PINDEX length = 0;
  length += m_controlFieldOctets.GetObjectLength();
  length += m_sendBufferSize.GetObjectLength();
  return length;
}


BOOL H245_H223LogicalChannelParameters_adaptationLayerType_al3::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_controlFieldOctets.Decode(strm))
    return FALSE;
  if (!m_sendBufferSize.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_H223LogicalChannelParameters_adaptationLayerType_al3::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_controlFieldOctets.Encode(strm);
  m_sendBufferSize.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_H223LogicalChannelParameters_adaptationLayerType_al3::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223LogicalChannelParameters_adaptationLayerType_al3::Class()), PInvalidCast);
#endif
  return new H245_H223LogicalChannelParameters_adaptationLayerType_al3(*this);
}


//
// ArrayOf_RedundancyEncodingElement
//

H245_ArrayOf_RedundancyEncodingElement::H245_ArrayOf_RedundancyEncodingElement(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_RedundancyEncodingElement::CreateObject() const
{
  return new H245_RedundancyEncodingElement;
}


H245_RedundancyEncodingElement & H245_ArrayOf_RedundancyEncodingElement::operator[](PINDEX i) const
{
  return (H245_RedundancyEncodingElement &)array[i];
}


PObject * H245_ArrayOf_RedundancyEncodingElement::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_RedundancyEncodingElement::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_RedundancyEncodingElement(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_DepFECData_rfc2733_mode[]={
      {"redundancyEncoding",0}
     ,{"separateStream",1}
};
#endif
//
// DepFECData_rfc2733_mode
//

H245_DepFECData_rfc2733_mode::H245_DepFECData_rfc2733_mode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_DepFECData_rfc2733_mode,2
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DepFECData_rfc2733_mode::operator H245_DepFECData_rfc2733_mode_separateStream &() const
#else
H245_DepFECData_rfc2733_mode::operator H245_DepFECData_rfc2733_mode_separateStream &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DepFECData_rfc2733_mode_separateStream), PInvalidCast);
#endif
  return *(H245_DepFECData_rfc2733_mode_separateStream *)choice;
}


H245_DepFECData_rfc2733_mode::operator const H245_DepFECData_rfc2733_mode_separateStream &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DepFECData_rfc2733_mode_separateStream), PInvalidCast);
#endif
  return *(H245_DepFECData_rfc2733_mode_separateStream *)choice;
}


BOOL H245_DepFECData_rfc2733_mode::CreateObject()
{
  switch (tag) {
    case e_redundancyEncoding :
      choice = new PASN_Null();
      return TRUE;
    case e_separateStream :
      choice = new H245_DepFECData_rfc2733_mode_separateStream();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_DepFECData_rfc2733_mode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_DepFECData_rfc2733_mode::Class()), PInvalidCast);
#endif
  return new H245_DepFECData_rfc2733_mode(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_FECData_rfc2733_pktMode[]={
      {"rfc2198coding",0}
     ,{"rfc2733sameport",1}
     ,{"rfc2733diffport",2}
};
#endif
//
// FECData_rfc2733_pktMode
//

H245_FECData_rfc2733_pktMode::H245_FECData_rfc2733_pktMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_FECData_rfc2733_pktMode,3
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_FECData_rfc2733_pktMode::operator H245_FECData_rfc2733_pktMode_rfc2733sameport &() const
#else
H245_FECData_rfc2733_pktMode::operator H245_FECData_rfc2733_pktMode_rfc2733sameport &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_FECData_rfc2733_pktMode_rfc2733sameport), PInvalidCast);
#endif
  return *(H245_FECData_rfc2733_pktMode_rfc2733sameport *)choice;
}


H245_FECData_rfc2733_pktMode::operator const H245_FECData_rfc2733_pktMode_rfc2733sameport &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_FECData_rfc2733_pktMode_rfc2733sameport), PInvalidCast);
#endif
  return *(H245_FECData_rfc2733_pktMode_rfc2733sameport *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_FECData_rfc2733_pktMode::operator H245_FECData_rfc2733_pktMode_rfc2733diffport &() const
#else
H245_FECData_rfc2733_pktMode::operator H245_FECData_rfc2733_pktMode_rfc2733diffport &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_FECData_rfc2733_pktMode_rfc2733diffport), PInvalidCast);
#endif
  return *(H245_FECData_rfc2733_pktMode_rfc2733diffport *)choice;
}


H245_FECData_rfc2733_pktMode::operator const H245_FECData_rfc2733_pktMode_rfc2733diffport &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_FECData_rfc2733_pktMode_rfc2733diffport), PInvalidCast);
#endif
  return *(H245_FECData_rfc2733_pktMode_rfc2733diffport *)choice;
}


BOOL H245_FECData_rfc2733_pktMode::CreateObject()
{
  switch (tag) {
    case e_rfc2198coding :
      choice = new PASN_Null();
      return TRUE;
    case e_rfc2733sameport :
      choice = new H245_FECData_rfc2733_pktMode_rfc2733sameport();
      return TRUE;
    case e_rfc2733diffport :
      choice = new H245_FECData_rfc2733_pktMode_rfc2733diffport();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_FECData_rfc2733_pktMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_FECData_rfc2733_pktMode::Class()), PInvalidCast);
#endif
  return new H245_FECData_rfc2733_pktMode(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_UnicastAddress_iPSourceRouteAddress_routing[]={
      {"strict",0}
     ,{"loose",1}
};
#endif
//
// UnicastAddress_iPSourceRouteAddress_routing
//

H245_UnicastAddress_iPSourceRouteAddress_routing::H245_UnicastAddress_iPSourceRouteAddress_routing(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_UnicastAddress_iPSourceRouteAddress_routing,2
#endif
)
{
}


BOOL H245_UnicastAddress_iPSourceRouteAddress_routing::CreateObject()
{
  choice = (tag <= e_loose) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_UnicastAddress_iPSourceRouteAddress_routing::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_UnicastAddress_iPSourceRouteAddress_routing::Class()), PInvalidCast);
#endif
  return new H245_UnicastAddress_iPSourceRouteAddress_routing(*this);
}


//
// UnicastAddress_iPSourceRouteAddress_route
//

H245_UnicastAddress_iPSourceRouteAddress_route::H245_UnicastAddress_iPSourceRouteAddress_route(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_UnicastAddress_iPSourceRouteAddress_route::CreateObject() const
{
  PASN_OctetString * obj = new PASN_OctetString;
  obj->SetConstraints(PASN_Object::FixedConstraint, 4);
  return obj;
}


PASN_OctetString & H245_UnicastAddress_iPSourceRouteAddress_route::operator[](PINDEX i) const
{
  return (PASN_OctetString &)array[i];
}


PObject * H245_UnicastAddress_iPSourceRouteAddress_route::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_UnicastAddress_iPSourceRouteAddress_route::Class()), PInvalidCast);
#endif
  return new H245_UnicastAddress_iPSourceRouteAddress_route(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters[]={
      {"h222LogicalChannelParameters",0}
     ,{"h2250LogicalChannelParameters",1}
};
#endif
//
// OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters
//

H245_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters::H245_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 1, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters,2
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters::operator H245_H222LogicalChannelParameters &() const
#else
H245_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters::operator H245_H222LogicalChannelParameters &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H222LogicalChannelParameters), PInvalidCast);
#endif
  return *(H245_H222LogicalChannelParameters *)choice;
}


H245_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters::operator const H245_H222LogicalChannelParameters &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H222LogicalChannelParameters), PInvalidCast);
#endif
  return *(H245_H222LogicalChannelParameters *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters::operator H245_H2250LogicalChannelParameters &() const
#else
H245_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters::operator H245_H2250LogicalChannelParameters &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H2250LogicalChannelParameters), PInvalidCast);
#endif
  return *(H245_H2250LogicalChannelParameters *)choice;
}


H245_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters::operator const H245_H2250LogicalChannelParameters &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_H2250LogicalChannelParameters), PInvalidCast);
#endif
  return *(H245_H2250LogicalChannelParameters *)choice;
}


BOOL H245_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters::CreateObject()
{
  switch (tag) {
    case e_h222LogicalChannelParameters :
      choice = new H245_H222LogicalChannelParameters();
      return TRUE;
    case e_h2250LogicalChannelParameters :
      choice = new H245_H2250LogicalChannelParameters();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters::Class()), PInvalidCast);
#endif
  return new H245_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_DepFECMode_rfc2733Mode_mode[]={
      {"redundancyEncoding",0}
     ,{"separateStream",1}
};
#endif
//
// DepFECMode_rfc2733Mode_mode
//

H245_DepFECMode_rfc2733Mode_mode::H245_DepFECMode_rfc2733Mode_mode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_DepFECMode_rfc2733Mode_mode,2
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DepFECMode_rfc2733Mode_mode::operator H245_DepFECMode_rfc2733Mode_mode_separateStream &() const
#else
H245_DepFECMode_rfc2733Mode_mode::operator H245_DepFECMode_rfc2733Mode_mode_separateStream &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DepFECMode_rfc2733Mode_mode_separateStream), PInvalidCast);
#endif
  return *(H245_DepFECMode_rfc2733Mode_mode_separateStream *)choice;
}


H245_DepFECMode_rfc2733Mode_mode::operator const H245_DepFECMode_rfc2733Mode_mode_separateStream &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DepFECMode_rfc2733Mode_mode_separateStream), PInvalidCast);
#endif
  return *(H245_DepFECMode_rfc2733Mode_mode_separateStream *)choice;
}


BOOL H245_DepFECMode_rfc2733Mode_mode::CreateObject()
{
  switch (tag) {
    case e_redundancyEncoding :
      choice = new PASN_Null();
      return TRUE;
    case e_separateStream :
      choice = new H245_DepFECMode_rfc2733Mode_mode_separateStream();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_DepFECMode_rfc2733Mode_mode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_DepFECMode_rfc2733Mode_mode::Class()), PInvalidCast);
#endif
  return new H245_DepFECMode_rfc2733Mode_mode(*this);
}


//
// H223ModeParameters_adaptationLayerType_al3
//

H245_H223ModeParameters_adaptationLayerType_al3::H245_H223ModeParameters_adaptationLayerType_al3(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
  m_controlFieldOctets.SetConstraints(PASN_Object::FixedConstraint, 0, 2);
  m_sendBufferSize.SetConstraints(PASN_Object::FixedConstraint, 0, 16777215);
}


#ifndef PASN_NOPRINTON
void H245_H223ModeParameters_adaptationLayerType_al3::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+21) << "controlFieldOctets = " << setprecision(indent) << m_controlFieldOctets << '\n';
  strm << setw(indent+17) << "sendBufferSize = " << setprecision(indent) << m_sendBufferSize << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_H223ModeParameters_adaptationLayerType_al3::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_H223ModeParameters_adaptationLayerType_al3), PInvalidCast);
#endif
  const H245_H223ModeParameters_adaptationLayerType_al3 & other = (const H245_H223ModeParameters_adaptationLayerType_al3 &)obj;

  Comparison result;

  if ((result = m_controlFieldOctets.Compare(other.m_controlFieldOctets)) != EqualTo)
    return result;
  if ((result = m_sendBufferSize.Compare(other.m_sendBufferSize)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_H223ModeParameters_adaptationLayerType_al3::GetDataLength() const
{
  PINDEX length = 0;
  length += m_controlFieldOctets.GetObjectLength();
  length += m_sendBufferSize.GetObjectLength();
  return length;
}


BOOL H245_H223ModeParameters_adaptationLayerType_al3::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_controlFieldOctets.Decode(strm))
    return FALSE;
  if (!m_sendBufferSize.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_H223ModeParameters_adaptationLayerType_al3::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_controlFieldOctets.Encode(strm);
  m_sendBufferSize.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_H223ModeParameters_adaptationLayerType_al3::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_H223ModeParameters_adaptationLayerType_al3::Class()), PInvalidCast);
#endif
  return new H245_H223ModeParameters_adaptationLayerType_al3(*this);
}


//
// DataMode_application_nlpid
//

H245_DataMode_application_nlpid::H245_DataMode_application_nlpid(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_DataMode_application_nlpid::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "nlpidProtocol = " << setprecision(indent) << m_nlpidProtocol << '\n';
  strm << setw(indent+12) << "nlpidData = " << setprecision(indent) << m_nlpidData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_DataMode_application_nlpid::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_DataMode_application_nlpid), PInvalidCast);
#endif
  const H245_DataMode_application_nlpid & other = (const H245_DataMode_application_nlpid &)obj;

  Comparison result;

  if ((result = m_nlpidProtocol.Compare(other.m_nlpidProtocol)) != EqualTo)
    return result;
  if ((result = m_nlpidData.Compare(other.m_nlpidData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_DataMode_application_nlpid::GetDataLength() const
{
  PINDEX length = 0;
  length += m_nlpidProtocol.GetObjectLength();
  length += m_nlpidData.GetObjectLength();
  return length;
}


BOOL H245_DataMode_application_nlpid::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_nlpidProtocol.Decode(strm))
    return FALSE;
  if (!m_nlpidData.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_DataMode_application_nlpid::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_nlpidProtocol.Encode(strm);
  m_nlpidData.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_DataMode_application_nlpid::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_DataMode_application_nlpid::Class()), PInvalidCast);
#endif
  return new H245_DataMode_application_nlpid(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_MultilinkRequest_maximumHeaderInterval_requestType[]={
      {"currentIntervalInformation",0}
     ,{"requestedInterval",1}
};
#endif
//
// MultilinkRequest_maximumHeaderInterval_requestType
//

H245_MultilinkRequest_maximumHeaderInterval_requestType::H245_MultilinkRequest_maximumHeaderInterval_requestType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_MultilinkRequest_maximumHeaderInterval_requestType,2
#endif
)
{
}


BOOL H245_MultilinkRequest_maximumHeaderInterval_requestType::CreateObject()
{
  switch (tag) {
    case e_currentIntervalInformation :
      choice = new PASN_Null();
      return TRUE;
    case e_requestedInterval :
      choice = new PASN_Integer();
      choice->SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_MultilinkRequest_maximumHeaderInterval_requestType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultilinkRequest_maximumHeaderInterval_requestType::Class()), PInvalidCast);
#endif
  return new H245_MultilinkRequest_maximumHeaderInterval_requestType(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_MultilinkResponse_addConnection_responseCode[]={
      {"accepted",0}
     ,{"rejected",1}
};
#endif
//
// MultilinkResponse_addConnection_responseCode
//

H245_MultilinkResponse_addConnection_responseCode::H245_MultilinkResponse_addConnection_responseCode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_MultilinkResponse_addConnection_responseCode,2
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_MultilinkResponse_addConnection_responseCode::operator H245_MultilinkResponse_addConnection_responseCode_rejected &() const
#else
H245_MultilinkResponse_addConnection_responseCode::operator H245_MultilinkResponse_addConnection_responseCode_rejected &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultilinkResponse_addConnection_responseCode_rejected), PInvalidCast);
#endif
  return *(H245_MultilinkResponse_addConnection_responseCode_rejected *)choice;
}


H245_MultilinkResponse_addConnection_responseCode::operator const H245_MultilinkResponse_addConnection_responseCode_rejected &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_MultilinkResponse_addConnection_responseCode_rejected), PInvalidCast);
#endif
  return *(H245_MultilinkResponse_addConnection_responseCode_rejected *)choice;
}


BOOL H245_MultilinkResponse_addConnection_responseCode::CreateObject()
{
  switch (tag) {
    case e_accepted :
      choice = new PASN_Null();
      return TRUE;
    case e_rejected :
      choice = new H245_MultilinkResponse_addConnection_responseCode_rejected();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_MultilinkResponse_addConnection_responseCode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MultilinkResponse_addConnection_responseCode::Class()), PInvalidCast);
#endif
  return new H245_MultilinkResponse_addConnection_responseCode(*this);
}


//
// ArrayOf_CapabilityDescriptorNumber
//

H245_ArrayOf_CapabilityDescriptorNumber::H245_ArrayOf_CapabilityDescriptorNumber(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_CapabilityDescriptorNumber::CreateObject() const
{
  return new H245_CapabilityDescriptorNumber;
}


H245_CapabilityDescriptorNumber & H245_ArrayOf_CapabilityDescriptorNumber::operator[](PINDEX i) const
{
  return (H245_CapabilityDescriptorNumber &)array[i];
}


PObject * H245_ArrayOf_CapabilityDescriptorNumber::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_CapabilityDescriptorNumber::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_CapabilityDescriptorNumber(*this);
}


//
// MiscellaneousCommand_type_videoFastUpdateGOB
//

H245_MiscellaneousCommand_type_videoFastUpdateGOB::H245_MiscellaneousCommand_type_videoFastUpdateGOB(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
  m_firstGOB.SetConstraints(PASN_Object::FixedConstraint, 0, 17);
  m_numberOfGOBs.SetConstraints(PASN_Object::FixedConstraint, 1, 18);
}


#ifndef PASN_NOPRINTON
void H245_MiscellaneousCommand_type_videoFastUpdateGOB::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "firstGOB = " << setprecision(indent) << m_firstGOB << '\n';
  strm << setw(indent+15) << "numberOfGOBs = " << setprecision(indent) << m_numberOfGOBs << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MiscellaneousCommand_type_videoFastUpdateGOB::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MiscellaneousCommand_type_videoFastUpdateGOB), PInvalidCast);
#endif
  const H245_MiscellaneousCommand_type_videoFastUpdateGOB & other = (const H245_MiscellaneousCommand_type_videoFastUpdateGOB &)obj;

  Comparison result;

  if ((result = m_firstGOB.Compare(other.m_firstGOB)) != EqualTo)
    return result;
  if ((result = m_numberOfGOBs.Compare(other.m_numberOfGOBs)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MiscellaneousCommand_type_videoFastUpdateGOB::GetDataLength() const
{
  PINDEX length = 0;
  length += m_firstGOB.GetObjectLength();
  length += m_numberOfGOBs.GetObjectLength();
  return length;
}


BOOL H245_MiscellaneousCommand_type_videoFastUpdateGOB::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_firstGOB.Decode(strm))
    return FALSE;
  if (!m_numberOfGOBs.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MiscellaneousCommand_type_videoFastUpdateGOB::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_firstGOB.Encode(strm);
  m_numberOfGOBs.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MiscellaneousCommand_type_videoFastUpdateGOB::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MiscellaneousCommand_type_videoFastUpdateGOB::Class()), PInvalidCast);
#endif
  return new H245_MiscellaneousCommand_type_videoFastUpdateGOB(*this);
}


//
// MiscellaneousCommand_type_videoFastUpdateMB
//

H245_MiscellaneousCommand_type_videoFastUpdateMB::H245_MiscellaneousCommand_type_videoFastUpdateMB(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
  m_firstGOB.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
  m_firstMB.SetConstraints(PASN_Object::FixedConstraint, 1, 8192);
  m_numberOfMBs.SetConstraints(PASN_Object::FixedConstraint, 1, 8192);
}


#ifndef PASN_NOPRINTON
void H245_MiscellaneousCommand_type_videoFastUpdateMB::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_firstGOB))
    strm << setw(indent+11) << "firstGOB = " << setprecision(indent) << m_firstGOB << '\n';
  if (HasOptionalField(e_firstMB))
    strm << setw(indent+10) << "firstMB = " << setprecision(indent) << m_firstMB << '\n';
  strm << setw(indent+14) << "numberOfMBs = " << setprecision(indent) << m_numberOfMBs << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MiscellaneousCommand_type_videoFastUpdateMB::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MiscellaneousCommand_type_videoFastUpdateMB), PInvalidCast);
#endif
  const H245_MiscellaneousCommand_type_videoFastUpdateMB & other = (const H245_MiscellaneousCommand_type_videoFastUpdateMB &)obj;

  Comparison result;

  if ((result = m_firstGOB.Compare(other.m_firstGOB)) != EqualTo)
    return result;
  if ((result = m_firstMB.Compare(other.m_firstMB)) != EqualTo)
    return result;
  if ((result = m_numberOfMBs.Compare(other.m_numberOfMBs)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MiscellaneousCommand_type_videoFastUpdateMB::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_firstGOB))
    length += m_firstGOB.GetObjectLength();
  if (HasOptionalField(e_firstMB))
    length += m_firstMB.GetObjectLength();
  length += m_numberOfMBs.GetObjectLength();
  return length;
}


BOOL H245_MiscellaneousCommand_type_videoFastUpdateMB::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_firstGOB) && !m_firstGOB.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_firstMB) && !m_firstMB.Decode(strm))
    return FALSE;
  if (!m_numberOfMBs.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MiscellaneousCommand_type_videoFastUpdateMB::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_firstGOB))
    m_firstGOB.Encode(strm);
  if (HasOptionalField(e_firstMB))
    m_firstMB.Encode(strm);
  m_numberOfMBs.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MiscellaneousCommand_type_videoFastUpdateMB::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MiscellaneousCommand_type_videoFastUpdateMB::Class()), PInvalidCast);
#endif
  return new H245_MiscellaneousCommand_type_videoFastUpdateMB(*this);
}


//
// MiscellaneousCommand_type_videoBadMBs
//

H245_MiscellaneousCommand_type_videoBadMBs::H245_MiscellaneousCommand_type_videoBadMBs(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_firstMB.SetConstraints(PASN_Object::FixedConstraint, 1, 9216);
  m_numberOfMBs.SetConstraints(PASN_Object::FixedConstraint, 1, 9216);
  m_temporalReference.SetConstraints(PASN_Object::FixedConstraint, 0, 1023);
}


#ifndef PASN_NOPRINTON
void H245_MiscellaneousCommand_type_videoBadMBs::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+10) << "firstMB = " << setprecision(indent) << m_firstMB << '\n';
  strm << setw(indent+14) << "numberOfMBs = " << setprecision(indent) << m_numberOfMBs << '\n';
  strm << setw(indent+20) << "temporalReference = " << setprecision(indent) << m_temporalReference << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MiscellaneousCommand_type_videoBadMBs::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MiscellaneousCommand_type_videoBadMBs), PInvalidCast);
#endif
  const H245_MiscellaneousCommand_type_videoBadMBs & other = (const H245_MiscellaneousCommand_type_videoBadMBs &)obj;

  Comparison result;

  if ((result = m_firstMB.Compare(other.m_firstMB)) != EqualTo)
    return result;
  if ((result = m_numberOfMBs.Compare(other.m_numberOfMBs)) != EqualTo)
    return result;
  if ((result = m_temporalReference.Compare(other.m_temporalReference)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MiscellaneousCommand_type_videoBadMBs::GetDataLength() const
{
  PINDEX length = 0;
  length += m_firstMB.GetObjectLength();
  length += m_numberOfMBs.GetObjectLength();
  length += m_temporalReference.GetObjectLength();
  return length;
}


BOOL H245_MiscellaneousCommand_type_videoBadMBs::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_firstMB.Decode(strm))
    return FALSE;
  if (!m_numberOfMBs.Decode(strm))
    return FALSE;
  if (!m_temporalReference.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MiscellaneousCommand_type_videoBadMBs::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_firstMB.Encode(strm);
  m_numberOfMBs.Encode(strm);
  m_temporalReference.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MiscellaneousCommand_type_videoBadMBs::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MiscellaneousCommand_type_videoBadMBs::Class()), PInvalidCast);
#endif
  return new H245_MiscellaneousCommand_type_videoBadMBs(*this);
}


//
// ArrayOf_PictureReference
//

H245_ArrayOf_PictureReference::H245_ArrayOf_PictureReference(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H245_ArrayOf_PictureReference::CreateObject() const
{
  return new H245_PictureReference;
}


H245_PictureReference & H245_ArrayOf_PictureReference::operator[](PINDEX i) const
{
  return (H245_PictureReference &)array[i];
}


PObject * H245_ArrayOf_PictureReference::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_ArrayOf_PictureReference::Class()), PInvalidCast);
#endif
  return new H245_ArrayOf_PictureReference(*this);
}


//
// MiscellaneousCommand_type_lostPartialPicture
//

H245_MiscellaneousCommand_type_lostPartialPicture::H245_MiscellaneousCommand_type_lostPartialPicture(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_firstMB.SetConstraints(PASN_Object::FixedConstraint, 1, 9216);
  m_numberOfMBs.SetConstraints(PASN_Object::FixedConstraint, 1, 9216);
}


#ifndef PASN_NOPRINTON
void H245_MiscellaneousCommand_type_lostPartialPicture::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+19) << "pictureReference = " << setprecision(indent) << m_pictureReference << '\n';
  strm << setw(indent+10) << "firstMB = " << setprecision(indent) << m_firstMB << '\n';
  strm << setw(indent+14) << "numberOfMBs = " << setprecision(indent) << m_numberOfMBs << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MiscellaneousCommand_type_lostPartialPicture::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MiscellaneousCommand_type_lostPartialPicture), PInvalidCast);
#endif
  const H245_MiscellaneousCommand_type_lostPartialPicture & other = (const H245_MiscellaneousCommand_type_lostPartialPicture &)obj;

  Comparison result;

  if ((result = m_pictureReference.Compare(other.m_pictureReference)) != EqualTo)
    return result;
  if ((result = m_firstMB.Compare(other.m_firstMB)) != EqualTo)
    return result;
  if ((result = m_numberOfMBs.Compare(other.m_numberOfMBs)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MiscellaneousCommand_type_lostPartialPicture::GetDataLength() const
{
  PINDEX length = 0;
  length += m_pictureReference.GetObjectLength();
  length += m_firstMB.GetObjectLength();
  length += m_numberOfMBs.GetObjectLength();
  return length;
}


BOOL H245_MiscellaneousCommand_type_lostPartialPicture::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_pictureReference.Decode(strm))
    return FALSE;
  if (!m_firstMB.Decode(strm))
    return FALSE;
  if (!m_numberOfMBs.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MiscellaneousCommand_type_lostPartialPicture::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_pictureReference.Encode(strm);
  m_firstMB.Encode(strm);
  m_numberOfMBs.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MiscellaneousCommand_type_lostPartialPicture::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MiscellaneousCommand_type_lostPartialPicture::Class()), PInvalidCast);
#endif
  return new H245_MiscellaneousCommand_type_lostPartialPicture(*this);
}


//
// MiscellaneousCommand_type_encryptionUpdateAck
//

H245_MiscellaneousCommand_type_encryptionUpdateAck::H245_MiscellaneousCommand_type_encryptionUpdateAck(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_synchFlag.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H245_MiscellaneousCommand_type_encryptionUpdateAck::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+12) << "synchFlag = " << setprecision(indent) << m_synchFlag << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MiscellaneousCommand_type_encryptionUpdateAck::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MiscellaneousCommand_type_encryptionUpdateAck), PInvalidCast);
#endif
  const H245_MiscellaneousCommand_type_encryptionUpdateAck & other = (const H245_MiscellaneousCommand_type_encryptionUpdateAck &)obj;

  Comparison result;

  if ((result = m_synchFlag.Compare(other.m_synchFlag)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MiscellaneousCommand_type_encryptionUpdateAck::GetDataLength() const
{
  PINDEX length = 0;
  length += m_synchFlag.GetObjectLength();
  return length;
}


BOOL H245_MiscellaneousCommand_type_encryptionUpdateAck::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_synchFlag.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MiscellaneousCommand_type_encryptionUpdateAck::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_synchFlag.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MiscellaneousCommand_type_encryptionUpdateAck::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MiscellaneousCommand_type_encryptionUpdateAck::Class()), PInvalidCast);
#endif
  return new H245_MiscellaneousCommand_type_encryptionUpdateAck(*this);
}


//
// NewATMVCCommand_aal_aal5
//

H245_NewATMVCCommand_aal_aal5::H245_NewATMVCCommand_aal_aal5(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_forwardMaximumSDUSize.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
  m_backwardMaximumSDUSize.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void H245_NewATMVCCommand_aal_aal5::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+24) << "forwardMaximumSDUSize = " << setprecision(indent) << m_forwardMaximumSDUSize << '\n';
  strm << setw(indent+25) << "backwardMaximumSDUSize = " << setprecision(indent) << m_backwardMaximumSDUSize << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_NewATMVCCommand_aal_aal5::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_NewATMVCCommand_aal_aal5), PInvalidCast);
#endif
  const H245_NewATMVCCommand_aal_aal5 & other = (const H245_NewATMVCCommand_aal_aal5 &)obj;

  Comparison result;

  if ((result = m_forwardMaximumSDUSize.Compare(other.m_forwardMaximumSDUSize)) != EqualTo)
    return result;
  if ((result = m_backwardMaximumSDUSize.Compare(other.m_backwardMaximumSDUSize)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_NewATMVCCommand_aal_aal5::GetDataLength() const
{
  PINDEX length = 0;
  length += m_forwardMaximumSDUSize.GetObjectLength();
  length += m_backwardMaximumSDUSize.GetObjectLength();
  return length;
}


BOOL H245_NewATMVCCommand_aal_aal5::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_forwardMaximumSDUSize.Decode(strm))
    return FALSE;
  if (!m_backwardMaximumSDUSize.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_NewATMVCCommand_aal_aal5::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_forwardMaximumSDUSize.Encode(strm);
  m_backwardMaximumSDUSize.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_NewATMVCCommand_aal_aal5::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NewATMVCCommand_aal_aal5::Class()), PInvalidCast);
#endif
  return new H245_NewATMVCCommand_aal_aal5(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_NewATMVCCommand_reverseParameters_multiplex[]={
      {"noMultiplex",0}
     ,{"transportStream",1}
     ,{"programStream",2}
};
#endif
//
// NewATMVCCommand_reverseParameters_multiplex
//

H245_NewATMVCCommand_reverseParameters_multiplex::H245_NewATMVCCommand_reverseParameters_multiplex(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_NewATMVCCommand_reverseParameters_multiplex,3
#endif
)
{
}


BOOL H245_NewATMVCCommand_reverseParameters_multiplex::CreateObject()
{
  choice = (tag <= e_programStream) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_NewATMVCCommand_reverseParameters_multiplex::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NewATMVCCommand_reverseParameters_multiplex::Class()), PInvalidCast);
#endif
  return new H245_NewATMVCCommand_reverseParameters_multiplex(*this);
}


//
// MiscellaneousIndication_type_videoNotDecodedMBs
//

H245_MiscellaneousIndication_type_videoNotDecodedMBs::H245_MiscellaneousIndication_type_videoNotDecodedMBs(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_firstMB.SetConstraints(PASN_Object::FixedConstraint, 1, 8192);
  m_numberOfMBs.SetConstraints(PASN_Object::FixedConstraint, 1, 8192);
  m_temporalReference.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H245_MiscellaneousIndication_type_videoNotDecodedMBs::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+10) << "firstMB = " << setprecision(indent) << m_firstMB << '\n';
  strm << setw(indent+14) << "numberOfMBs = " << setprecision(indent) << m_numberOfMBs << '\n';
  strm << setw(indent+20) << "temporalReference = " << setprecision(indent) << m_temporalReference << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_MiscellaneousIndication_type_videoNotDecodedMBs::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_MiscellaneousIndication_type_videoNotDecodedMBs), PInvalidCast);
#endif
  const H245_MiscellaneousIndication_type_videoNotDecodedMBs & other = (const H245_MiscellaneousIndication_type_videoNotDecodedMBs &)obj;

  Comparison result;

  if ((result = m_firstMB.Compare(other.m_firstMB)) != EqualTo)
    return result;
  if ((result = m_numberOfMBs.Compare(other.m_numberOfMBs)) != EqualTo)
    return result;
  if ((result = m_temporalReference.Compare(other.m_temporalReference)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_MiscellaneousIndication_type_videoNotDecodedMBs::GetDataLength() const
{
  PINDEX length = 0;
  length += m_firstMB.GetObjectLength();
  length += m_numberOfMBs.GetObjectLength();
  length += m_temporalReference.GetObjectLength();
  return length;
}


BOOL H245_MiscellaneousIndication_type_videoNotDecodedMBs::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_firstMB.Decode(strm))
    return FALSE;
  if (!m_numberOfMBs.Decode(strm))
    return FALSE;
  if (!m_temporalReference.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_MiscellaneousIndication_type_videoNotDecodedMBs::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_firstMB.Encode(strm);
  m_numberOfMBs.Encode(strm);
  m_temporalReference.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_MiscellaneousIndication_type_videoNotDecodedMBs::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_MiscellaneousIndication_type_videoNotDecodedMBs::Class()), PInvalidCast);
#endif
  return new H245_MiscellaneousIndication_type_videoNotDecodedMBs(*this);
}


//
// NewATMVCIndication_aal_aal5
//

H245_NewATMVCIndication_aal_aal5::H245_NewATMVCIndication_aal_aal5(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_forwardMaximumSDUSize.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
  m_backwardMaximumSDUSize.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void H245_NewATMVCIndication_aal_aal5::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+24) << "forwardMaximumSDUSize = " << setprecision(indent) << m_forwardMaximumSDUSize << '\n';
  strm << setw(indent+25) << "backwardMaximumSDUSize = " << setprecision(indent) << m_backwardMaximumSDUSize << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_NewATMVCIndication_aal_aal5::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_NewATMVCIndication_aal_aal5), PInvalidCast);
#endif
  const H245_NewATMVCIndication_aal_aal5 & other = (const H245_NewATMVCIndication_aal_aal5 &)obj;

  Comparison result;

  if ((result = m_forwardMaximumSDUSize.Compare(other.m_forwardMaximumSDUSize)) != EqualTo)
    return result;
  if ((result = m_backwardMaximumSDUSize.Compare(other.m_backwardMaximumSDUSize)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_NewATMVCIndication_aal_aal5::GetDataLength() const
{
  PINDEX length = 0;
  length += m_forwardMaximumSDUSize.GetObjectLength();
  length += m_backwardMaximumSDUSize.GetObjectLength();
  return length;
}


BOOL H245_NewATMVCIndication_aal_aal5::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_forwardMaximumSDUSize.Decode(strm))
    return FALSE;
  if (!m_backwardMaximumSDUSize.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_NewATMVCIndication_aal_aal5::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_forwardMaximumSDUSize.Encode(strm);
  m_backwardMaximumSDUSize.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_NewATMVCIndication_aal_aal5::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NewATMVCIndication_aal_aal5::Class()), PInvalidCast);
#endif
  return new H245_NewATMVCIndication_aal_aal5(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_NewATMVCIndication_reverseParameters_multiplex[]={
      {"noMultiplex",0}
     ,{"transportStream",1}
     ,{"programStream",2}
};
#endif
//
// NewATMVCIndication_reverseParameters_multiplex
//

H245_NewATMVCIndication_reverseParameters_multiplex::H245_NewATMVCIndication_reverseParameters_multiplex(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_NewATMVCIndication_reverseParameters_multiplex,3
#endif
)
{
}


BOOL H245_NewATMVCIndication_reverseParameters_multiplex::CreateObject()
{
  choice = (tag <= e_programStream) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_NewATMVCIndication_reverseParameters_multiplex::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_NewATMVCIndication_reverseParameters_multiplex::Class()), PInvalidCast);
#endif
  return new H245_NewATMVCIndication_reverseParameters_multiplex(*this);
}


//
// UserInputIndication_signal_rtp
//

H245_UserInputIndication_signal_rtp::H245_UserInputIndication_signal_rtp(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
  m_timestamp.SetConstraints(PASN_Object::FixedConstraint, 0, 4294967295U);
  m_expirationTime.SetConstraints(PASN_Object::FixedConstraint, 0, 4294967295U);
}


#ifndef PASN_NOPRINTON
void H245_UserInputIndication_signal_rtp::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_timestamp))
    strm << setw(indent+12) << "timestamp = " << setprecision(indent) << m_timestamp << '\n';
  if (HasOptionalField(e_expirationTime))
    strm << setw(indent+17) << "expirationTime = " << setprecision(indent) << m_expirationTime << '\n';
  strm << setw(indent+23) << "logicalChannelNumber = " << setprecision(indent) << m_logicalChannelNumber << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_UserInputIndication_signal_rtp::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_UserInputIndication_signal_rtp), PInvalidCast);
#endif
  const H245_UserInputIndication_signal_rtp & other = (const H245_UserInputIndication_signal_rtp &)obj;

  Comparison result;

  if ((result = m_timestamp.Compare(other.m_timestamp)) != EqualTo)
    return result;
  if ((result = m_expirationTime.Compare(other.m_expirationTime)) != EqualTo)
    return result;
  if ((result = m_logicalChannelNumber.Compare(other.m_logicalChannelNumber)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_UserInputIndication_signal_rtp::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_timestamp))
    length += m_timestamp.GetObjectLength();
  if (HasOptionalField(e_expirationTime))
    length += m_expirationTime.GetObjectLength();
  length += m_logicalChannelNumber.GetObjectLength();
  return length;
}


BOOL H245_UserInputIndication_signal_rtp::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_timestamp) && !m_timestamp.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_expirationTime) && !m_expirationTime.Decode(strm))
    return FALSE;
  if (!m_logicalChannelNumber.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_UserInputIndication_signal_rtp::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_timestamp))
    m_timestamp.Encode(strm);
  if (HasOptionalField(e_expirationTime))
    m_expirationTime.Encode(strm);
  m_logicalChannelNumber.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_UserInputIndication_signal_rtp::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_UserInputIndication_signal_rtp::Class()), PInvalidCast);
#endif
  return new H245_UserInputIndication_signal_rtp(*this);
}


//
// UserInputIndication_signalUpdate_rtp
//

H245_UserInputIndication_signalUpdate_rtp::H245_UserInputIndication_signalUpdate_rtp(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_UserInputIndication_signalUpdate_rtp::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+23) << "logicalChannelNumber = " << setprecision(indent) << m_logicalChannelNumber << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_UserInputIndication_signalUpdate_rtp::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_UserInputIndication_signalUpdate_rtp), PInvalidCast);
#endif
  const H245_UserInputIndication_signalUpdate_rtp & other = (const H245_UserInputIndication_signalUpdate_rtp &)obj;

  Comparison result;

  if ((result = m_logicalChannelNumber.Compare(other.m_logicalChannelNumber)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_UserInputIndication_signalUpdate_rtp::GetDataLength() const
{
  PINDEX length = 0;
  length += m_logicalChannelNumber.GetObjectLength();
  return length;
}


BOOL H245_UserInputIndication_signalUpdate_rtp::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_logicalChannelNumber.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_UserInputIndication_signalUpdate_rtp::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_logicalChannelNumber.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_UserInputIndication_signalUpdate_rtp::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_UserInputIndication_signalUpdate_rtp::Class()), PInvalidCast);
#endif
  return new H245_UserInputIndication_signalUpdate_rtp(*this);
}


//
// UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric
//

H245_UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric::H245_UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "algorithmOID = " << setprecision(indent) << m_algorithmOID << '\n';
  if (HasOptionalField(e_paramS))
    strm << setw(indent+9) << "paramS = " << setprecision(indent) << m_paramS << '\n';
  strm << setw(indent+12) << "encrypted = " << setprecision(indent) << m_encrypted << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric), PInvalidCast);
#endif
  const H245_UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric & other = (const H245_UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric &)obj;

  Comparison result;

  if ((result = m_algorithmOID.Compare(other.m_algorithmOID)) != EqualTo)
    return result;
  if ((result = m_paramS.Compare(other.m_paramS)) != EqualTo)
    return result;
  if ((result = m_encrypted.Compare(other.m_encrypted)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric::GetDataLength() const
{
  PINDEX length = 0;
  length += m_algorithmOID.GetObjectLength();
  if (HasOptionalField(e_paramS))
    length += m_paramS.GetObjectLength();
  length += m_encrypted.GetObjectLength();
  return length;
}


BOOL H245_UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_algorithmOID.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_paramS) && !m_paramS.Decode(strm))
    return FALSE;
  if (!m_encrypted.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_algorithmOID.Encode(strm);
  if (HasOptionalField(e_paramS))
    m_paramS.Encode(strm);
  m_encrypted.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric::Class()), PInvalidCast);
#endif
  return new H245_UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric(*this);
}


//
// VCCapability_availableBitRates_type_rangeOfBitRates
//

H245_VCCapability_availableBitRates_type_rangeOfBitRates::H245_VCCapability_availableBitRates_type_rangeOfBitRates(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
  m_lowerBitRate.SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
  m_higherBitRate.SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
}


#ifndef PASN_NOPRINTON
void H245_VCCapability_availableBitRates_type_rangeOfBitRates::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "lowerBitRate = " << setprecision(indent) << m_lowerBitRate << '\n';
  strm << setw(indent+16) << "higherBitRate = " << setprecision(indent) << m_higherBitRate << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_VCCapability_availableBitRates_type_rangeOfBitRates::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_VCCapability_availableBitRates_type_rangeOfBitRates), PInvalidCast);
#endif
  const H245_VCCapability_availableBitRates_type_rangeOfBitRates & other = (const H245_VCCapability_availableBitRates_type_rangeOfBitRates &)obj;

  Comparison result;

  if ((result = m_lowerBitRate.Compare(other.m_lowerBitRate)) != EqualTo)
    return result;
  if ((result = m_higherBitRate.Compare(other.m_higherBitRate)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_VCCapability_availableBitRates_type_rangeOfBitRates::GetDataLength() const
{
  PINDEX length = 0;
  length += m_lowerBitRate.GetObjectLength();
  length += m_higherBitRate.GetObjectLength();
  return length;
}


BOOL H245_VCCapability_availableBitRates_type_rangeOfBitRates::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_lowerBitRate.Decode(strm))
    return FALSE;
  if (!m_higherBitRate.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_VCCapability_availableBitRates_type_rangeOfBitRates::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_lowerBitRate.Encode(strm);
  m_higherBitRate.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_VCCapability_availableBitRates_type_rangeOfBitRates::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_VCCapability_availableBitRates_type_rangeOfBitRates::Class()), PInvalidCast);
#endif
  return new H245_VCCapability_availableBitRates_type_rangeOfBitRates(*this);
}


//
// CustomPictureFormat_mPI_customPCF_subtype
//

H245_CustomPictureFormat_mPI_customPCF_subtype::H245_CustomPictureFormat_mPI_customPCF_subtype(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_clockConversionCode.SetConstraints(PASN_Object::FixedConstraint, 1000, 1001);
  m_clockDivisor.SetConstraints(PASN_Object::FixedConstraint, 1, 127);
  m_customMPI.SetConstraints(PASN_Object::FixedConstraint, 1, 2048);
}


#ifndef PASN_NOPRINTON
void H245_CustomPictureFormat_mPI_customPCF_subtype::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+22) << "clockConversionCode = " << setprecision(indent) << m_clockConversionCode << '\n';
  strm << setw(indent+15) << "clockDivisor = " << setprecision(indent) << m_clockDivisor << '\n';
  strm << setw(indent+12) << "customMPI = " << setprecision(indent) << m_customMPI << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_CustomPictureFormat_mPI_customPCF_subtype::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_CustomPictureFormat_mPI_customPCF_subtype), PInvalidCast);
#endif
  const H245_CustomPictureFormat_mPI_customPCF_subtype & other = (const H245_CustomPictureFormat_mPI_customPCF_subtype &)obj;

  Comparison result;

  if ((result = m_clockConversionCode.Compare(other.m_clockConversionCode)) != EqualTo)
    return result;
  if ((result = m_clockDivisor.Compare(other.m_clockDivisor)) != EqualTo)
    return result;
  if ((result = m_customMPI.Compare(other.m_customMPI)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_CustomPictureFormat_mPI_customPCF_subtype::GetDataLength() const
{
  PINDEX length = 0;
  length += m_clockConversionCode.GetObjectLength();
  length += m_clockDivisor.GetObjectLength();
  length += m_customMPI.GetObjectLength();
  return length;
}


BOOL H245_CustomPictureFormat_mPI_customPCF_subtype::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_clockConversionCode.Decode(strm))
    return FALSE;
  if (!m_clockDivisor.Decode(strm))
    return FALSE;
  if (!m_customMPI.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_CustomPictureFormat_mPI_customPCF_subtype::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_clockConversionCode.Encode(strm);
  m_clockDivisor.Encode(strm);
  m_customMPI.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_CustomPictureFormat_mPI_customPCF_subtype::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CustomPictureFormat_mPI_customPCF_subtype::Class()), PInvalidCast);
#endif
  return new H245_CustomPictureFormat_mPI_customPCF_subtype(*this);
}


//
// CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype
//

H245_CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype::H245_CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_width.SetConstraints(PASN_Object::FixedConstraint, 1, 255);
  m_height.SetConstraints(PASN_Object::FixedConstraint, 1, 255);
}


#ifndef PASN_NOPRINTON
void H245_CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+8) << "width = " << setprecision(indent) << m_width << '\n';
  strm << setw(indent+9) << "height = " << setprecision(indent) << m_height << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H245_CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H245_CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype), PInvalidCast);
#endif
  const H245_CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype & other = (const H245_CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype &)obj;

  Comparison result;

  if ((result = m_width.Compare(other.m_width)) != EqualTo)
    return result;
  if ((result = m_height.Compare(other.m_height)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H245_CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype::GetDataLength() const
{
  PINDEX length = 0;
  length += m_width.GetObjectLength();
  length += m_height.GetObjectLength();
  return length;
}


BOOL H245_CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_width.Decode(strm))
    return FALSE;
  if (!m_height.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H245_CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_width.Encode(strm);
  m_height.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H245_CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype::Class()), PInvalidCast);
#endif
  return new H245_CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_V76LogicalChannelParameters_mode_eRM_recovery[]={
      {"rej",0}
     ,{"sREJ",1}
     ,{"mSREJ",2}
};
#endif
//
// V76LogicalChannelParameters_mode_eRM_recovery
//

H245_V76LogicalChannelParameters_mode_eRM_recovery::H245_V76LogicalChannelParameters_mode_eRM_recovery(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_V76LogicalChannelParameters_mode_eRM_recovery,3
#endif
)
{
}


BOOL H245_V76LogicalChannelParameters_mode_eRM_recovery::CreateObject()
{
  choice = (tag <= e_mSREJ) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H245_V76LogicalChannelParameters_mode_eRM_recovery::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_V76LogicalChannelParameters_mode_eRM_recovery::Class()), PInvalidCast);
#endif
  return new H245_V76LogicalChannelParameters_mode_eRM_recovery(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H245_DepFECData_rfc2733_mode_separateStream[]={
      {"differentPort",0}
     ,{"samePort",1}
};
#endif
//
// DepFECData_rfc2733_mode_separateStream
//

H245_DepFECData_rfc2733_mode_separateStream::H245_DepFECData_rfc2733_mode_separateStream(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H245_DepFECData_rfc2733_mode_separateStream,2
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DepFECData_rfc2733_mode_separateStream::operator H245_DepFECData_rfc2733_mode_separateStream_differentPort &() const
#else
H245_DepFECData_rfc2733_mode_separateStream::operator H245_DepFECData_rfc2733_mode_separateStream_differentPort &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DepFECData_rfc2733_mode_separateStream_differentPort), PInvalidCast);
#endif
  return *(H245_DepFECData_rfc2733_mode_separateStream_differentPort *)choice;
}


H245_DepFECData_rfc2733_mode_separateStream::operator const H245_DepFECData_rfc2733_mode_separateStream_differentPort &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DepFECData_rfc2733_mode_separateStream_differentPort), PInvalidCast);
#endif
  return *(H245_DepFECData_rfc2733_mode_separateStream_differentPort *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H245_DepFECData_rfc2733_mode_separateStream::operator H245_DepFECData_rfc2733_mode_separateStream_samePort &() const
#else
H245_DepFECData_rfc2733_mode_separateStream::operator H245_DepFECData_rfc2733_mode_separateStream_samePort &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DepFECData_rfc2733_mode_separateStream_samePort), PInvalidCast);
#endif
  return *(H245_DepFECData_rfc2733_mode_separateStream_samePort *)choice;
}


H245_DepFECData_rfc2733_mode_separateStream::operator const H245_DepFECData_rfc2733_mode_separateStream_samePort &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H245_DepFECData_rfc2733_mode_separateStream_samePort), PInvalidCast);
#endif
  return *(H245_DepFECData_rfc2733_mode_separateStream_samePort *)choice;
}


BOOL H245_DepFECData_rfc2733_mode_separateStream::CreateObject()
{
  switch (tag) {
    case e_differentPort :
      choice = new H245_DepFECData_rfc2733_mode_separateStream_differentPort();
      return TRUE;
    case e_samePort :
      choice = new H245_DepFECData_rfc2733_mode_separateStream_samePort();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H245_DepFECData_rfc2733_mode_separateStream::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_DepFECData_rfc2733_mode_separateStream::Class()), PInvalidCast);
#endif
  return new H245_DepFECData_rfc2733_mode_separateStream(*this);
}


//
// FECData_rfc2733_pktMode_rfc2733sameport
//

H245_FECData_rfc2733_pktMode_rfc2733sameport::H245_FECData_rfc2733_pktMode_rfc2733sameport(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H245_FECData_rfc2733_pktMode_rfc2733sameport::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PINDEX H245_FECData_rfc2733_pktMode_rfc2733sameport::GetDataLength() const
{
  PINDEX length = 0;
  return length;
}


BOOL H245_FECData_rfc2733_pktMode_rfc2733sameport::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;


  return UnknownExtensionsDecode(strm);
}


void H245_FECData_rfc2733_pktMode_rfc2733sameport::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);


  UnknownExtensionsEncode(strm);
}


PObject * H245_FECData_rfc2733_pktMode_rfc2733sameport::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H245_FECData_rfc2733_pktMode_rfc2733sameport::Class()), PInvalidCast);
#endif
  return new H245_FECData_rfc2733_pktMode_rfc2733sameport(*this);
}


#endif // if ! H323_DISABLE_H245


// End of h245_2.cxx
