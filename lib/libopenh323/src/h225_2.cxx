//
// h225_2.cxx
//
// Code automatically generated by asnparse.
//

#include <ptlib.h>
#include "h225.h"

#define new PNEW


#if ! H323_DISABLE_H225

//
// ArrayOf_EnumeratedParameter
//

H225_ArrayOf_EnumeratedParameter::H225_ArrayOf_EnumeratedParameter(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H225_ArrayOf_EnumeratedParameter::CreateObject() const
{
  return new H225_EnumeratedParameter;
}


H225_EnumeratedParameter & H225_ArrayOf_EnumeratedParameter::operator[](PINDEX i) const
{
  return (H225_EnumeratedParameter &)array[i];
}


PObject * H225_ArrayOf_EnumeratedParameter::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ArrayOf_EnumeratedParameter::Class()), PInvalidCast);
#endif
  return new H225_ArrayOf_EnumeratedParameter(*this);
}


//
// RTPSession_associatedSessionIds
//

H225_RTPSession_associatedSessionIds::H225_RTPSession_associatedSessionIds(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H225_RTPSession_associatedSessionIds::CreateObject() const
{
  PASN_Integer * obj = new PASN_Integer;
  obj->SetConstraints(PASN_Object::FixedConstraint, 1, 255);
  return obj;
}


PASN_Integer & H225_RTPSession_associatedSessionIds::operator[](PINDEX i) const
{
  return (PASN_Integer &)array[i];
}


PObject * H225_RTPSession_associatedSessionIds::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_RTPSession_associatedSessionIds::Class()), PInvalidCast);
#endif
  return new H225_RTPSession_associatedSessionIds(*this);
}


//
// ArrayOf_AdmissionConfirm
//

H225_ArrayOf_AdmissionConfirm::H225_ArrayOf_AdmissionConfirm(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H225_ArrayOf_AdmissionConfirm::CreateObject() const
{
  return new H225_AdmissionConfirm;
}


H225_AdmissionConfirm & H225_ArrayOf_AdmissionConfirm::operator[](PINDEX i) const
{
  return (H225_AdmissionConfirm &)array[i];
}


PObject * H225_ArrayOf_AdmissionConfirm::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ArrayOf_AdmissionConfirm::Class()), PInvalidCast);
#endif
  return new H225_ArrayOf_AdmissionConfirm(*this);
}


//
// ArrayOf_Endpoint
//

H225_ArrayOf_Endpoint::H225_ArrayOf_Endpoint(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H225_ArrayOf_Endpoint::CreateObject() const
{
  return new H225_Endpoint;
}


H225_Endpoint & H225_ArrayOf_Endpoint::operator[](PINDEX i) const
{
  return (H225_Endpoint &)array[i];
}


PObject * H225_ArrayOf_Endpoint::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ArrayOf_Endpoint::Class()), PInvalidCast);
#endif
  return new H225_ArrayOf_Endpoint(*this);
}


//
// ArrayOf_AuthenticationMechanism
//

H225_ArrayOf_AuthenticationMechanism::H225_ArrayOf_AuthenticationMechanism(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H225_ArrayOf_AuthenticationMechanism::CreateObject() const
{
  return new H235_AuthenticationMechanism;
}


H235_AuthenticationMechanism & H225_ArrayOf_AuthenticationMechanism::operator[](PINDEX i) const
{
  return (H235_AuthenticationMechanism &)array[i];
}


PObject * H225_ArrayOf_AuthenticationMechanism::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ArrayOf_AuthenticationMechanism::Class()), PInvalidCast);
#endif
  return new H225_ArrayOf_AuthenticationMechanism(*this);
}


//
// ArrayOf_PASN_ObjectId
//

H225_ArrayOf_PASN_ObjectId::H225_ArrayOf_PASN_ObjectId(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H225_ArrayOf_PASN_ObjectId::CreateObject() const
{
  return new PASN_ObjectId;
}


PASN_ObjectId & H225_ArrayOf_PASN_ObjectId::operator[](PINDEX i) const
{
  return (PASN_ObjectId &)array[i];
}


PObject * H225_ArrayOf_PASN_ObjectId::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ArrayOf_PASN_ObjectId::Class()), PInvalidCast);
#endif
  return new H225_ArrayOf_PASN_ObjectId(*this);
}


//
// ArrayOf_IntegrityMechanism
//

H225_ArrayOf_IntegrityMechanism::H225_ArrayOf_IntegrityMechanism(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H225_ArrayOf_IntegrityMechanism::CreateObject() const
{
  return new H225_IntegrityMechanism;
}


H225_IntegrityMechanism & H225_ArrayOf_IntegrityMechanism::operator[](PINDEX i) const
{
  return (H225_IntegrityMechanism &)array[i];
}


PObject * H225_ArrayOf_IntegrityMechanism::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ArrayOf_IntegrityMechanism::Class()), PInvalidCast);
#endif
  return new H225_ArrayOf_IntegrityMechanism(*this);
}


//
// ArrayOf_AddressPattern
//

H225_ArrayOf_AddressPattern::H225_ArrayOf_AddressPattern(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H225_ArrayOf_AddressPattern::CreateObject() const
{
  return new H225_AddressPattern;
}


H225_AddressPattern & H225_ArrayOf_AddressPattern::operator[](PINDEX i) const
{
  return (H225_AddressPattern &)array[i];
}


PObject * H225_ArrayOf_AddressPattern::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ArrayOf_AddressPattern::Class()), PInvalidCast);
#endif
  return new H225_ArrayOf_AddressPattern(*this);
}


//
// ArrayOf_H248PackagesDescriptor
//

H225_ArrayOf_H248PackagesDescriptor::H225_ArrayOf_H248PackagesDescriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H225_ArrayOf_H248PackagesDescriptor::CreateObject() const
{
  return new H225_H248PackagesDescriptor;
}


H225_H248PackagesDescriptor & H225_ArrayOf_H248PackagesDescriptor::operator[](PINDEX i) const
{
  return (H225_H248PackagesDescriptor &)array[i];
}


PObject * H225_ArrayOf_H248PackagesDescriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ArrayOf_H248PackagesDescriptor::Class()), PInvalidCast);
#endif
  return new H225_ArrayOf_H248PackagesDescriptor(*this);
}


//
// ArrayOf_RasUsageSpecification
//

H225_ArrayOf_RasUsageSpecification::H225_ArrayOf_RasUsageSpecification(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H225_ArrayOf_RasUsageSpecification::CreateObject() const
{
  return new H225_RasUsageSpecification;
}


H225_RasUsageSpecification & H225_ArrayOf_RasUsageSpecification::operator[](PINDEX i) const
{
  return (H225_RasUsageSpecification &)array[i];
}


PObject * H225_ArrayOf_RasUsageSpecification::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ArrayOf_RasUsageSpecification::Class()), PInvalidCast);
#endif
  return new H225_ArrayOf_RasUsageSpecification(*this);
}


//
// RegistrationRejectReason_invalidTerminalAliases
//

H225_RegistrationRejectReason_invalidTerminalAliases::H225_RegistrationRejectReason_invalidTerminalAliases(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_RegistrationRejectReason_invalidTerminalAliases::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_terminalAlias))
    strm << setw(indent+16) << "terminalAlias = " << setprecision(indent) << m_terminalAlias << '\n';
  if (HasOptionalField(e_terminalAliasPattern))
    strm << setw(indent+23) << "terminalAliasPattern = " << setprecision(indent) << m_terminalAliasPattern << '\n';
  if (HasOptionalField(e_supportedPrefixes))
    strm << setw(indent+20) << "supportedPrefixes = " << setprecision(indent) << m_supportedPrefixes << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_RegistrationRejectReason_invalidTerminalAliases::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_RegistrationRejectReason_invalidTerminalAliases), PInvalidCast);
#endif
  const H225_RegistrationRejectReason_invalidTerminalAliases & other = (const H225_RegistrationRejectReason_invalidTerminalAliases &)obj;

  Comparison result;

  if ((result = m_terminalAlias.Compare(other.m_terminalAlias)) != EqualTo)
    return result;
  if ((result = m_terminalAliasPattern.Compare(other.m_terminalAliasPattern)) != EqualTo)
    return result;
  if ((result = m_supportedPrefixes.Compare(other.m_supportedPrefixes)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_RegistrationRejectReason_invalidTerminalAliases::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_terminalAlias))
    length += m_terminalAlias.GetObjectLength();
  if (HasOptionalField(e_terminalAliasPattern))
    length += m_terminalAliasPattern.GetObjectLength();
  if (HasOptionalField(e_supportedPrefixes))
    length += m_supportedPrefixes.GetObjectLength();
  return length;
}


BOOL H225_RegistrationRejectReason_invalidTerminalAliases::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_terminalAlias) && !m_terminalAlias.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_terminalAliasPattern) && !m_terminalAliasPattern.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_supportedPrefixes) && !m_supportedPrefixes.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_RegistrationRejectReason_invalidTerminalAliases::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_terminalAlias))
    m_terminalAlias.Encode(strm);
  if (HasOptionalField(e_terminalAliasPattern))
    m_terminalAliasPattern.Encode(strm);
  if (HasOptionalField(e_supportedPrefixes))
    m_supportedPrefixes.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_RegistrationRejectReason_invalidTerminalAliases::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_RegistrationRejectReason_invalidTerminalAliases::Class()), PInvalidCast);
#endif
  return new H225_RegistrationRejectReason_invalidTerminalAliases(*this);
}


//
// AdmissionConfirm_language
//

H225_AdmissionConfirm_language::H225_AdmissionConfirm_language(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H225_AdmissionConfirm_language::CreateObject() const
{
  PASN_IA5String * obj = new PASN_IA5String;
  obj->SetConstraints(PASN_Object::FixedConstraint, 1, 32);
  return obj;
}


PASN_IA5String & H225_AdmissionConfirm_language::operator[](PINDEX i) const
{
  return (PASN_IA5String &)array[i];
}


PObject * H225_AdmissionConfirm_language::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_AdmissionConfirm_language::Class()), PInvalidCast);
#endif
  return new H225_AdmissionConfirm_language(*this);
}


//
// ArrayOf_PartyNumber
//

H225_ArrayOf_PartyNumber::H225_ArrayOf_PartyNumber(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H225_ArrayOf_PartyNumber::CreateObject() const
{
  return new H225_PartyNumber;
}


H225_PartyNumber & H225_ArrayOf_PartyNumber::operator[](PINDEX i) const
{
  return (H225_PartyNumber &)array[i];
}


PObject * H225_ArrayOf_PartyNumber::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ArrayOf_PartyNumber::Class()), PInvalidCast);
#endif
  return new H225_ArrayOf_PartyNumber(*this);
}


//
// ArrayOf_BandwidthDetails
//

H225_ArrayOf_BandwidthDetails::H225_ArrayOf_BandwidthDetails(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H225_ArrayOf_BandwidthDetails::CreateObject() const
{
  return new H225_BandwidthDetails;
}


H225_BandwidthDetails & H225_ArrayOf_BandwidthDetails::operator[](PINDEX i) const
{
  return (H225_BandwidthDetails &)array[i];
}


PObject * H225_ArrayOf_BandwidthDetails::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ArrayOf_BandwidthDetails::Class()), PInvalidCast);
#endif
  return new H225_ArrayOf_BandwidthDetails(*this);
}


//
// InfoRequestResponse_perCallInfo
//

H225_InfoRequestResponse_perCallInfo::H225_InfoRequestResponse_perCallInfo(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H225_InfoRequestResponse_perCallInfo::CreateObject() const
{
  return new H225_InfoRequestResponse_perCallInfo_subtype;
}


H225_InfoRequestResponse_perCallInfo_subtype & H225_InfoRequestResponse_perCallInfo::operator[](PINDEX i) const
{
  return (H225_InfoRequestResponse_perCallInfo_subtype &)array[i];
}


PObject * H225_InfoRequestResponse_perCallInfo::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_InfoRequestResponse_perCallInfo::Class()), PInvalidCast);
#endif
  return new H225_InfoRequestResponse_perCallInfo(*this);
}


//
// ServiceControlIndication_callSpecific
//

H225_ServiceControlIndication_callSpecific::H225_ServiceControlIndication_callSpecific(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_ServiceControlIndication_callSpecific::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "callIdentifier = " << setprecision(indent) << m_callIdentifier << '\n';
  strm << setw(indent+15) << "conferenceID = " << setprecision(indent) << m_conferenceID << '\n';
  strm << setw(indent+15) << "answeredCall = " << setprecision(indent) << m_answeredCall << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_ServiceControlIndication_callSpecific::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_ServiceControlIndication_callSpecific), PInvalidCast);
#endif
  const H225_ServiceControlIndication_callSpecific & other = (const H225_ServiceControlIndication_callSpecific &)obj;

  Comparison result;

  if ((result = m_callIdentifier.Compare(other.m_callIdentifier)) != EqualTo)
    return result;
  if ((result = m_conferenceID.Compare(other.m_conferenceID)) != EqualTo)
    return result;
  if ((result = m_answeredCall.Compare(other.m_answeredCall)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_ServiceControlIndication_callSpecific::GetDataLength() const
{
  PINDEX length = 0;
  length += m_callIdentifier.GetObjectLength();
  length += m_conferenceID.GetObjectLength();
  length += m_answeredCall.GetObjectLength();
  return length;
}


BOOL H225_ServiceControlIndication_callSpecific::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_callIdentifier.Decode(strm))
    return FALSE;
  if (!m_conferenceID.Decode(strm))
    return FALSE;
  if (!m_answeredCall.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_ServiceControlIndication_callSpecific::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_callIdentifier.Encode(strm);
  m_conferenceID.Encode(strm);
  m_answeredCall.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_ServiceControlIndication_callSpecific::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ServiceControlIndication_callSpecific::Class()), PInvalidCast);
#endif
  return new H225_ServiceControlIndication_callSpecific(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H225_ServiceControlResponse_result[]={
      {"started",0}
     ,{"failed",1}
     ,{"stopped",2}
     ,{"notAvailable",3}
     ,{"neededFeatureNotSupported",4}
};
#endif
//
// ServiceControlResponse_result
//

H225_ServiceControlResponse_result::H225_ServiceControlResponse_result(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 5, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H225_ServiceControlResponse_result,5
#endif
)
{
}


BOOL H225_ServiceControlResponse_result::CreateObject()
{
  choice = (tag <= e_neededFeatureNotSupported) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H225_ServiceControlResponse_result::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ServiceControlResponse_result::Class()), PInvalidCast);
#endif
  return new H225_ServiceControlResponse_result(*this);
}


//
// TransportAddress_ipSourceRoute_route
//

H225_TransportAddress_ipSourceRoute_route::H225_TransportAddress_ipSourceRoute_route(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H225_TransportAddress_ipSourceRoute_route::CreateObject() const
{
  PASN_OctetString * obj = new PASN_OctetString;
  obj->SetConstraints(PASN_Object::FixedConstraint, 4);
  return obj;
}


PASN_OctetString & H225_TransportAddress_ipSourceRoute_route::operator[](PINDEX i) const
{
  return (PASN_OctetString &)array[i];
}


PObject * H225_TransportAddress_ipSourceRoute_route::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_TransportAddress_ipSourceRoute_route::Class()), PInvalidCast);
#endif
  return new H225_TransportAddress_ipSourceRoute_route(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H225_TransportAddress_ipSourceRoute_routing[]={
      {"strict",0}
     ,{"loose",1}
};
#endif
//
// TransportAddress_ipSourceRoute_routing
//

H225_TransportAddress_ipSourceRoute_routing::H225_TransportAddress_ipSourceRoute_routing(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H225_TransportAddress_ipSourceRoute_routing,2
#endif
)
{
}


BOOL H225_TransportAddress_ipSourceRoute_routing::CreateObject()
{
  choice = (tag <= e_loose) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H225_TransportAddress_ipSourceRoute_routing::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_TransportAddress_ipSourceRoute_routing::Class()), PInvalidCast);
#endif
  return new H225_TransportAddress_ipSourceRoute_routing(*this);
}


//
// ArrayOf_RTPSession
//

H225_ArrayOf_RTPSession::H225_ArrayOf_RTPSession(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H225_ArrayOf_RTPSession::CreateObject() const
{
  return new H225_RTPSession;
}


H225_RTPSession & H225_ArrayOf_RTPSession::operator[](PINDEX i) const
{
  return (H225_RTPSession &)array[i];
}


PObject * H225_ArrayOf_RTPSession::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ArrayOf_RTPSession::Class()), PInvalidCast);
#endif
  return new H225_ArrayOf_RTPSession(*this);
}


//
// ArrayOf_TransportChannelInfo
//

H225_ArrayOf_TransportChannelInfo::H225_ArrayOf_TransportChannelInfo(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H225_ArrayOf_TransportChannelInfo::CreateObject() const
{
  return new H225_TransportChannelInfo;
}


H225_TransportChannelInfo & H225_ArrayOf_TransportChannelInfo::operator[](PINDEX i) const
{
  return (H225_TransportChannelInfo &)array[i];
}


PObject * H225_ArrayOf_TransportChannelInfo::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ArrayOf_TransportChannelInfo::Class()), PInvalidCast);
#endif
  return new H225_ArrayOf_TransportChannelInfo(*this);
}


//
// ArrayOf_ConferenceIdentifier
//

H225_ArrayOf_ConferenceIdentifier::H225_ArrayOf_ConferenceIdentifier(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H225_ArrayOf_ConferenceIdentifier::CreateObject() const
{
  return new H225_ConferenceIdentifier;
}


H225_ConferenceIdentifier & H225_ArrayOf_ConferenceIdentifier::operator[](PINDEX i) const
{
  return (H225_ConferenceIdentifier &)array[i];
}


PObject * H225_ArrayOf_ConferenceIdentifier::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ArrayOf_ConferenceIdentifier::Class()), PInvalidCast);
#endif
  return new H225_ArrayOf_ConferenceIdentifier(*this);
}


//
// InfoRequestResponse_perCallInfo_subtype_pdu
//

H225_InfoRequestResponse_perCallInfo_subtype_pdu::H225_InfoRequestResponse_perCallInfo_subtype_pdu(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H225_InfoRequestResponse_perCallInfo_subtype_pdu::CreateObject() const
{
  return new H225_InfoRequestResponse_perCallInfo_subtype_pdu_subtype;
}


H225_InfoRequestResponse_perCallInfo_subtype_pdu_subtype & H225_InfoRequestResponse_perCallInfo_subtype_pdu::operator[](PINDEX i) const
{
  return (H225_InfoRequestResponse_perCallInfo_subtype_pdu_subtype &)array[i];
}


PObject * H225_InfoRequestResponse_perCallInfo_subtype_pdu::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_InfoRequestResponse_perCallInfo_subtype_pdu::Class()), PInvalidCast);
#endif
  return new H225_InfoRequestResponse_perCallInfo_subtype_pdu(*this);
}


//
// Status-UUIE
//

H225_Status_UUIE::H225_Status_UUIE(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_Status_UUIE::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+21) << "protocolIdentifier = " << setprecision(indent) << m_protocolIdentifier << '\n';
  strm << setw(indent+17) << "callIdentifier = " << setprecision(indent) << m_callIdentifier << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_Status_UUIE::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_Status_UUIE), PInvalidCast);
#endif
  const H225_Status_UUIE & other = (const H225_Status_UUIE &)obj;

  Comparison result;

  if ((result = m_protocolIdentifier.Compare(other.m_protocolIdentifier)) != EqualTo)
    return result;
  if ((result = m_callIdentifier.Compare(other.m_callIdentifier)) != EqualTo)
    return result;
  if ((result = m_tokens.Compare(other.m_tokens)) != EqualTo)
    return result;
  if ((result = m_cryptoTokens.Compare(other.m_cryptoTokens)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_Status_UUIE::GetDataLength() const
{
  PINDEX length = 0;
  length += m_protocolIdentifier.GetObjectLength();
  length += m_callIdentifier.GetObjectLength();
  if (HasOptionalField(e_tokens))
    length += m_tokens.GetObjectLength();
  if (HasOptionalField(e_cryptoTokens))
    length += m_cryptoTokens.GetObjectLength();
  return length;
}


BOOL H225_Status_UUIE::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_protocolIdentifier.Decode(strm))
    return FALSE;
  if (!m_callIdentifier.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_tokens) && !m_tokens.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_cryptoTokens) && !m_cryptoTokens.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_Status_UUIE::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_protocolIdentifier.Encode(strm);
  m_callIdentifier.Encode(strm);
  if (HasOptionalField(e_tokens))
    m_tokens.Encode(strm);
  if (HasOptionalField(e_cryptoTokens))
    m_cryptoTokens.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_Status_UUIE::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_Status_UUIE::Class()), PInvalidCast);
#endif
  return new H225_Status_UUIE(*this);
}


//
// StatusInquiry-UUIE
//

H225_StatusInquiry_UUIE::H225_StatusInquiry_UUIE(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_StatusInquiry_UUIE::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+21) << "protocolIdentifier = " << setprecision(indent) << m_protocolIdentifier << '\n';
  strm << setw(indent+17) << "callIdentifier = " << setprecision(indent) << m_callIdentifier << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_StatusInquiry_UUIE::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_StatusInquiry_UUIE), PInvalidCast);
#endif
  const H225_StatusInquiry_UUIE & other = (const H225_StatusInquiry_UUIE &)obj;

  Comparison result;

  if ((result = m_protocolIdentifier.Compare(other.m_protocolIdentifier)) != EqualTo)
    return result;
  if ((result = m_callIdentifier.Compare(other.m_callIdentifier)) != EqualTo)
    return result;
  if ((result = m_tokens.Compare(other.m_tokens)) != EqualTo)
    return result;
  if ((result = m_cryptoTokens.Compare(other.m_cryptoTokens)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_StatusInquiry_UUIE::GetDataLength() const
{
  PINDEX length = 0;
  length += m_protocolIdentifier.GetObjectLength();
  length += m_callIdentifier.GetObjectLength();
  if (HasOptionalField(e_tokens))
    length += m_tokens.GetObjectLength();
  if (HasOptionalField(e_cryptoTokens))
    length += m_cryptoTokens.GetObjectLength();
  return length;
}


BOOL H225_StatusInquiry_UUIE::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_protocolIdentifier.Decode(strm))
    return FALSE;
  if (!m_callIdentifier.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_tokens) && !m_tokens.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_cryptoTokens) && !m_cryptoTokens.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_StatusInquiry_UUIE::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_protocolIdentifier.Encode(strm);
  m_callIdentifier.Encode(strm);
  if (HasOptionalField(e_tokens))
    m_tokens.Encode(strm);
  if (HasOptionalField(e_cryptoTokens))
    m_cryptoTokens.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_StatusInquiry_UUIE::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_StatusInquiry_UUIE::Class()), PInvalidCast);
#endif
  return new H225_StatusInquiry_UUIE(*this);
}


//
// SetupAcknowledge-UUIE
//

H225_SetupAcknowledge_UUIE::H225_SetupAcknowledge_UUIE(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_SetupAcknowledge_UUIE::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+21) << "protocolIdentifier = " << setprecision(indent) << m_protocolIdentifier << '\n';
  strm << setw(indent+17) << "callIdentifier = " << setprecision(indent) << m_callIdentifier << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_SetupAcknowledge_UUIE::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_SetupAcknowledge_UUIE), PInvalidCast);
#endif
  const H225_SetupAcknowledge_UUIE & other = (const H225_SetupAcknowledge_UUIE &)obj;

  Comparison result;

  if ((result = m_protocolIdentifier.Compare(other.m_protocolIdentifier)) != EqualTo)
    return result;
  if ((result = m_callIdentifier.Compare(other.m_callIdentifier)) != EqualTo)
    return result;
  if ((result = m_tokens.Compare(other.m_tokens)) != EqualTo)
    return result;
  if ((result = m_cryptoTokens.Compare(other.m_cryptoTokens)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_SetupAcknowledge_UUIE::GetDataLength() const
{
  PINDEX length = 0;
  length += m_protocolIdentifier.GetObjectLength();
  length += m_callIdentifier.GetObjectLength();
  if (HasOptionalField(e_tokens))
    length += m_tokens.GetObjectLength();
  if (HasOptionalField(e_cryptoTokens))
    length += m_cryptoTokens.GetObjectLength();
  return length;
}


BOOL H225_SetupAcknowledge_UUIE::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_protocolIdentifier.Decode(strm))
    return FALSE;
  if (!m_callIdentifier.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_tokens) && !m_tokens.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_cryptoTokens) && !m_cryptoTokens.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_SetupAcknowledge_UUIE::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_protocolIdentifier.Encode(strm);
  m_callIdentifier.Encode(strm);
  if (HasOptionalField(e_tokens))
    m_tokens.Encode(strm);
  if (HasOptionalField(e_cryptoTokens))
    m_cryptoTokens.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_SetupAcknowledge_UUIE::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_SetupAcknowledge_UUIE::Class()), PInvalidCast);
#endif
  return new H225_SetupAcknowledge_UUIE(*this);
}


//
// Notify-UUIE
//

H225_Notify_UUIE::H225_Notify_UUIE(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_Notify_UUIE::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+21) << "protocolIdentifier = " << setprecision(indent) << m_protocolIdentifier << '\n';
  strm << setw(indent+17) << "callIdentifier = " << setprecision(indent) << m_callIdentifier << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_Notify_UUIE::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_Notify_UUIE), PInvalidCast);
#endif
  const H225_Notify_UUIE & other = (const H225_Notify_UUIE &)obj;

  Comparison result;

  if ((result = m_protocolIdentifier.Compare(other.m_protocolIdentifier)) != EqualTo)
    return result;
  if ((result = m_callIdentifier.Compare(other.m_callIdentifier)) != EqualTo)
    return result;
  if ((result = m_tokens.Compare(other.m_tokens)) != EqualTo)
    return result;
  if ((result = m_cryptoTokens.Compare(other.m_cryptoTokens)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_Notify_UUIE::GetDataLength() const
{
  PINDEX length = 0;
  length += m_protocolIdentifier.GetObjectLength();
  length += m_callIdentifier.GetObjectLength();
  if (HasOptionalField(e_tokens))
    length += m_tokens.GetObjectLength();
  if (HasOptionalField(e_cryptoTokens))
    length += m_cryptoTokens.GetObjectLength();
  return length;
}


BOOL H225_Notify_UUIE::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_protocolIdentifier.Decode(strm))
    return FALSE;
  if (!m_callIdentifier.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_tokens) && !m_tokens.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_cryptoTokens) && !m_cryptoTokens.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_Notify_UUIE::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_protocolIdentifier.Encode(strm);
  m_callIdentifier.Encode(strm);
  if (HasOptionalField(e_tokens))
    m_tokens.Encode(strm);
  if (HasOptionalField(e_cryptoTokens))
    m_cryptoTokens.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_Notify_UUIE::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_Notify_UUIE::Class()), PInvalidCast);
#endif
  return new H225_Notify_UUIE(*this);
}


//
// VendorIdentifier
//

H225_VendorIdentifier::H225_VendorIdentifier(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 1)
{
  m_productId.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
  m_versionId.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H225_VendorIdentifier::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+9) << "vendor = " << setprecision(indent) << m_vendor << '\n';
  if (HasOptionalField(e_productId))
    strm << setw(indent+12) << "productId = " << setprecision(indent) << m_productId << '\n';
  if (HasOptionalField(e_versionId))
    strm << setw(indent+12) << "versionId = " << setprecision(indent) << m_versionId << '\n';
  if (HasOptionalField(e_enterpriseNumber))
    strm << setw(indent+19) << "enterpriseNumber = " << setprecision(indent) << m_enterpriseNumber << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_VendorIdentifier::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_VendorIdentifier), PInvalidCast);
#endif
  const H225_VendorIdentifier & other = (const H225_VendorIdentifier &)obj;

  Comparison result;

  if ((result = m_vendor.Compare(other.m_vendor)) != EqualTo)
    return result;
  if ((result = m_productId.Compare(other.m_productId)) != EqualTo)
    return result;
  if ((result = m_versionId.Compare(other.m_versionId)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_VendorIdentifier::GetDataLength() const
{
  PINDEX length = 0;
  length += m_vendor.GetObjectLength();
  if (HasOptionalField(e_productId))
    length += m_productId.GetObjectLength();
  if (HasOptionalField(e_versionId))
    length += m_versionId.GetObjectLength();
  return length;
}


BOOL H225_VendorIdentifier::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_vendor.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_productId) && !m_productId.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_versionId) && !m_versionId.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_enterpriseNumber, m_enterpriseNumber))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_VendorIdentifier::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_vendor.Encode(strm);
  if (HasOptionalField(e_productId))
    m_productId.Encode(strm);
  if (HasOptionalField(e_versionId))
    m_versionId.Encode(strm);
  KnownExtensionEncode(strm, e_enterpriseNumber, m_enterpriseNumber);

  UnknownExtensionsEncode(strm);
}


PObject * H225_VendorIdentifier::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_VendorIdentifier::Class()), PInvalidCast);
#endif
  return new H225_VendorIdentifier(*this);
}


//
// TunnelledProtocol
//

H225_TunnelledProtocol::H225_TunnelledProtocol(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_subIdentifier.SetConstraints(PASN_Object::FixedConstraint, 1, 64);
}


#ifndef PASN_NOPRINTON
void H225_TunnelledProtocol::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+5) << "id = " << setprecision(indent) << m_id << '\n';
  if (HasOptionalField(e_subIdentifier))
    strm << setw(indent+16) << "subIdentifier = " << setprecision(indent) << m_subIdentifier << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_TunnelledProtocol::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_TunnelledProtocol), PInvalidCast);
#endif
  const H225_TunnelledProtocol & other = (const H225_TunnelledProtocol &)obj;

  Comparison result;

  if ((result = m_id.Compare(other.m_id)) != EqualTo)
    return result;
  if ((result = m_subIdentifier.Compare(other.m_subIdentifier)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_TunnelledProtocol::GetDataLength() const
{
  PINDEX length = 0;
  length += m_id.GetObjectLength();
  if (HasOptionalField(e_subIdentifier))
    length += m_subIdentifier.GetObjectLength();
  return length;
}


BOOL H225_TunnelledProtocol::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_id.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_subIdentifier) && !m_subIdentifier.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_TunnelledProtocol::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_id.Encode(strm);
  if (HasOptionalField(e_subIdentifier))
    m_subIdentifier.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_TunnelledProtocol::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_TunnelledProtocol::Class()), PInvalidCast);
#endif
  return new H225_TunnelledProtocol(*this);
}


//
// NonStandardParameter
//

H225_NonStandardParameter::H225_NonStandardParameter(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_NonStandardParameter::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+24) << "nonStandardIdentifier = " << setprecision(indent) << m_nonStandardIdentifier << '\n';
  strm << setw(indent+7) << "data = " << setprecision(indent) << m_data << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_NonStandardParameter::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_NonStandardParameter), PInvalidCast);
#endif
  const H225_NonStandardParameter & other = (const H225_NonStandardParameter &)obj;

  Comparison result;

  if ((result = m_nonStandardIdentifier.Compare(other.m_nonStandardIdentifier)) != EqualTo)
    return result;
  if ((result = m_data.Compare(other.m_data)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_NonStandardParameter::GetDataLength() const
{
  PINDEX length = 0;
  length += m_nonStandardIdentifier.GetObjectLength();
  length += m_data.GetObjectLength();
  return length;
}


BOOL H225_NonStandardParameter::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_nonStandardIdentifier.Decode(strm))
    return FALSE;
  if (!m_data.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_NonStandardParameter::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_nonStandardIdentifier.Encode(strm);
  m_data.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_NonStandardParameter::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_NonStandardParameter::Class()), PInvalidCast);
#endif
  return new H225_NonStandardParameter(*this);
}


//
// PublicPartyNumber
//

H225_PublicPartyNumber::H225_PublicPartyNumber(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_PublicPartyNumber::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+21) << "publicTypeOfNumber = " << setprecision(indent) << m_publicTypeOfNumber << '\n';
  strm << setw(indent+21) << "publicNumberDigits = " << setprecision(indent) << m_publicNumberDigits << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_PublicPartyNumber::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_PublicPartyNumber), PInvalidCast);
#endif
  const H225_PublicPartyNumber & other = (const H225_PublicPartyNumber &)obj;

  Comparison result;

  if ((result = m_publicTypeOfNumber.Compare(other.m_publicTypeOfNumber)) != EqualTo)
    return result;
  if ((result = m_publicNumberDigits.Compare(other.m_publicNumberDigits)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_PublicPartyNumber::GetDataLength() const
{
  PINDEX length = 0;
  length += m_publicTypeOfNumber.GetObjectLength();
  length += m_publicNumberDigits.GetObjectLength();
  return length;
}


BOOL H225_PublicPartyNumber::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_publicTypeOfNumber.Decode(strm))
    return FALSE;
  if (!m_publicNumberDigits.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_PublicPartyNumber::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_publicTypeOfNumber.Encode(strm);
  m_publicNumberDigits.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_PublicPartyNumber::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_PublicPartyNumber::Class()), PInvalidCast);
#endif
  return new H225_PublicPartyNumber(*this);
}


//
// PrivatePartyNumber
//

H225_PrivatePartyNumber::H225_PrivatePartyNumber(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_PrivatePartyNumber::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+22) << "privateTypeOfNumber = " << setprecision(indent) << m_privateTypeOfNumber << '\n';
  strm << setw(indent+22) << "privateNumberDigits = " << setprecision(indent) << m_privateNumberDigits << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_PrivatePartyNumber::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_PrivatePartyNumber), PInvalidCast);
#endif
  const H225_PrivatePartyNumber & other = (const H225_PrivatePartyNumber &)obj;

  Comparison result;

  if ((result = m_privateTypeOfNumber.Compare(other.m_privateTypeOfNumber)) != EqualTo)
    return result;
  if ((result = m_privateNumberDigits.Compare(other.m_privateNumberDigits)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_PrivatePartyNumber::GetDataLength() const
{
  PINDEX length = 0;
  length += m_privateTypeOfNumber.GetObjectLength();
  length += m_privateNumberDigits.GetObjectLength();
  return length;
}


BOOL H225_PrivatePartyNumber::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_privateTypeOfNumber.Decode(strm))
    return FALSE;
  if (!m_privateNumberDigits.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_PrivatePartyNumber::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_privateTypeOfNumber.Encode(strm);
  m_privateNumberDigits.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_PrivatePartyNumber::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_PrivatePartyNumber::Class()), PInvalidCast);
#endif
  return new H225_PrivatePartyNumber(*this);
}


//
// ANSI-41-UIM
//

H225_ANSI_41_UIM::H225_ANSI_41_UIM(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 11, TRUE, 0)
{
  m_imsi.SetConstraints(PASN_Object::FixedConstraint, 3, 16);
  m_min.SetConstraints(PASN_Object::FixedConstraint, 3, 16);
  m_mdn.SetConstraints(PASN_Object::FixedConstraint, 3, 16);
  m_msisdn.SetConstraints(PASN_Object::FixedConstraint, 3, 16);
  m_esn.SetConstraints(PASN_Object::FixedConstraint, 16);
  m_mscid.SetConstraints(PASN_Object::FixedConstraint, 3, 16);
  m_systemMyTypeCode.SetConstraints(PASN_Object::FixedConstraint, 1);
  m_systemAccessType.SetConstraints(PASN_Object::FixedConstraint, 1);
  m_qualificationInformationCode.SetConstraints(PASN_Object::FixedConstraint, 1);
  m_sesn.SetConstraints(PASN_Object::FixedConstraint, 16);
  m_soc.SetConstraints(PASN_Object::FixedConstraint, 3, 16);
}


#ifndef PASN_NOPRINTON
void H225_ANSI_41_UIM::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_imsi))
    strm << setw(indent+7) << "imsi = " << setprecision(indent) << m_imsi << '\n';
  if (HasOptionalField(e_min))
    strm << setw(indent+6) << "min = " << setprecision(indent) << m_min << '\n';
  if (HasOptionalField(e_mdn))
    strm << setw(indent+6) << "mdn = " << setprecision(indent) << m_mdn << '\n';
  if (HasOptionalField(e_msisdn))
    strm << setw(indent+9) << "msisdn = " << setprecision(indent) << m_msisdn << '\n';
  if (HasOptionalField(e_esn))
    strm << setw(indent+6) << "esn = " << setprecision(indent) << m_esn << '\n';
  if (HasOptionalField(e_mscid))
    strm << setw(indent+8) << "mscid = " << setprecision(indent) << m_mscid << '\n';
  strm << setw(indent+12) << "system_id = " << setprecision(indent) << m_system_id << '\n';
  if (HasOptionalField(e_systemMyTypeCode))
    strm << setw(indent+19) << "systemMyTypeCode = " << setprecision(indent) << m_systemMyTypeCode << '\n';
  if (HasOptionalField(e_systemAccessType))
    strm << setw(indent+19) << "systemAccessType = " << setprecision(indent) << m_systemAccessType << '\n';
  if (HasOptionalField(e_qualificationInformationCode))
    strm << setw(indent+31) << "qualificationInformationCode = " << setprecision(indent) << m_qualificationInformationCode << '\n';
  if (HasOptionalField(e_sesn))
    strm << setw(indent+7) << "sesn = " << setprecision(indent) << m_sesn << '\n';
  if (HasOptionalField(e_soc))
    strm << setw(indent+6) << "soc = " << setprecision(indent) << m_soc << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_ANSI_41_UIM::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_ANSI_41_UIM), PInvalidCast);
#endif
  const H225_ANSI_41_UIM & other = (const H225_ANSI_41_UIM &)obj;

  Comparison result;

  if ((result = m_imsi.Compare(other.m_imsi)) != EqualTo)
    return result;
  if ((result = m_min.Compare(other.m_min)) != EqualTo)
    return result;
  if ((result = m_mdn.Compare(other.m_mdn)) != EqualTo)
    return result;
  if ((result = m_msisdn.Compare(other.m_msisdn)) != EqualTo)
    return result;
  if ((result = m_esn.Compare(other.m_esn)) != EqualTo)
    return result;
  if ((result = m_mscid.Compare(other.m_mscid)) != EqualTo)
    return result;
  if ((result = m_system_id.Compare(other.m_system_id)) != EqualTo)
    return result;
  if ((result = m_systemMyTypeCode.Compare(other.m_systemMyTypeCode)) != EqualTo)
    return result;
  if ((result = m_systemAccessType.Compare(other.m_systemAccessType)) != EqualTo)
    return result;
  if ((result = m_qualificationInformationCode.Compare(other.m_qualificationInformationCode)) != EqualTo)
    return result;
  if ((result = m_sesn.Compare(other.m_sesn)) != EqualTo)
    return result;
  if ((result = m_soc.Compare(other.m_soc)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_ANSI_41_UIM::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_imsi))
    length += m_imsi.GetObjectLength();
  if (HasOptionalField(e_min))
    length += m_min.GetObjectLength();
  if (HasOptionalField(e_mdn))
    length += m_mdn.GetObjectLength();
  if (HasOptionalField(e_msisdn))
    length += m_msisdn.GetObjectLength();
  if (HasOptionalField(e_esn))
    length += m_esn.GetObjectLength();
  if (HasOptionalField(e_mscid))
    length += m_mscid.GetObjectLength();
  length += m_system_id.GetObjectLength();
  if (HasOptionalField(e_systemMyTypeCode))
    length += m_systemMyTypeCode.GetObjectLength();
  if (HasOptionalField(e_systemAccessType))
    length += m_systemAccessType.GetObjectLength();
  if (HasOptionalField(e_qualificationInformationCode))
    length += m_qualificationInformationCode.GetObjectLength();
  if (HasOptionalField(e_sesn))
    length += m_sesn.GetObjectLength();
  if (HasOptionalField(e_soc))
    length += m_soc.GetObjectLength();
  return length;
}


BOOL H225_ANSI_41_UIM::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_imsi) && !m_imsi.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_min) && !m_min.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_mdn) && !m_mdn.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_msisdn) && !m_msisdn.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_esn) && !m_esn.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_mscid) && !m_mscid.Decode(strm))
    return FALSE;
  if (!m_system_id.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_systemMyTypeCode) && !m_systemMyTypeCode.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_systemAccessType) && !m_systemAccessType.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_qualificationInformationCode) && !m_qualificationInformationCode.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_sesn) && !m_sesn.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_soc) && !m_soc.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_ANSI_41_UIM::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_imsi))
    m_imsi.Encode(strm);
  if (HasOptionalField(e_min))
    m_min.Encode(strm);
  if (HasOptionalField(e_mdn))
    m_mdn.Encode(strm);
  if (HasOptionalField(e_msisdn))
    m_msisdn.Encode(strm);
  if (HasOptionalField(e_esn))
    m_esn.Encode(strm);
  if (HasOptionalField(e_mscid))
    m_mscid.Encode(strm);
  m_system_id.Encode(strm);
  if (HasOptionalField(e_systemMyTypeCode))
    m_systemMyTypeCode.Encode(strm);
  if (HasOptionalField(e_systemAccessType))
    m_systemAccessType.Encode(strm);
  if (HasOptionalField(e_qualificationInformationCode))
    m_qualificationInformationCode.Encode(strm);
  if (HasOptionalField(e_sesn))
    m_sesn.Encode(strm);
  if (HasOptionalField(e_soc))
    m_soc.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_ANSI_41_UIM::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ANSI_41_UIM::Class()), PInvalidCast);
#endif
  return new H225_ANSI_41_UIM(*this);
}


//
// AlternateTransportAddresses
//

H225_AlternateTransportAddresses::H225_AlternateTransportAddresses(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 1)
{
}


#ifndef PASN_NOPRINTON
void H225_AlternateTransportAddresses::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_annexE))
    strm << setw(indent+9) << "annexE = " << setprecision(indent) << m_annexE << '\n';
  if (HasOptionalField(e_sctp))
    strm << setw(indent+7) << "sctp = " << setprecision(indent) << m_sctp << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_AlternateTransportAddresses::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_AlternateTransportAddresses), PInvalidCast);
#endif
  const H225_AlternateTransportAddresses & other = (const H225_AlternateTransportAddresses &)obj;

  Comparison result;

  if ((result = m_annexE.Compare(other.m_annexE)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_AlternateTransportAddresses::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_annexE))
    length += m_annexE.GetObjectLength();
  return length;
}


BOOL H225_AlternateTransportAddresses::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_annexE) && !m_annexE.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_sctp, m_sctp))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_AlternateTransportAddresses::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_annexE))
    m_annexE.Encode(strm);
  KnownExtensionEncode(strm, e_sctp, m_sctp);

  UnknownExtensionsEncode(strm);
}


PObject * H225_AlternateTransportAddresses::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_AlternateTransportAddresses::Class()), PInvalidCast);
#endif
  return new H225_AlternateTransportAddresses(*this);
}


//
// AlternateGK
//

H225_AlternateGK::H225_AlternateGK(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_priority.SetConstraints(PASN_Object::FixedConstraint, 0, 127);
}


#ifndef PASN_NOPRINTON
void H225_AlternateGK::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+13) << "rasAddress = " << setprecision(indent) << m_rasAddress << '\n';
  if (HasOptionalField(e_gatekeeperIdentifier))
    strm << setw(indent+23) << "gatekeeperIdentifier = " << setprecision(indent) << m_gatekeeperIdentifier << '\n';
  strm << setw(indent+17) << "needToRegister = " << setprecision(indent) << m_needToRegister << '\n';
  strm << setw(indent+11) << "priority = " << setprecision(indent) << m_priority << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_AlternateGK::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_AlternateGK), PInvalidCast);
#endif
  const H225_AlternateGK & other = (const H225_AlternateGK &)obj;

  Comparison result;

  if ((result = m_rasAddress.Compare(other.m_rasAddress)) != EqualTo)
    return result;
  if ((result = m_gatekeeperIdentifier.Compare(other.m_gatekeeperIdentifier)) != EqualTo)
    return result;
  if ((result = m_needToRegister.Compare(other.m_needToRegister)) != EqualTo)
    return result;
  if ((result = m_priority.Compare(other.m_priority)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_AlternateGK::GetDataLength() const
{
  PINDEX length = 0;
  length += m_rasAddress.GetObjectLength();
  if (HasOptionalField(e_gatekeeperIdentifier))
    length += m_gatekeeperIdentifier.GetObjectLength();
  length += m_needToRegister.GetObjectLength();
  length += m_priority.GetObjectLength();
  return length;
}


BOOL H225_AlternateGK::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_rasAddress.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_gatekeeperIdentifier) && !m_gatekeeperIdentifier.Decode(strm))
    return FALSE;
  if (!m_needToRegister.Decode(strm))
    return FALSE;
  if (!m_priority.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_AlternateGK::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_rasAddress.Encode(strm);
  if (HasOptionalField(e_gatekeeperIdentifier))
    m_gatekeeperIdentifier.Encode(strm);
  m_needToRegister.Encode(strm);
  m_priority.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_AlternateGK::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_AlternateGK::Class()), PInvalidCast);
#endif
  return new H225_AlternateGK(*this);
}


//
// AltGKInfo
//

H225_AltGKInfo::H225_AltGKInfo(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_AltGKInfo::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+22) << "alternateGatekeeper = " << setprecision(indent) << m_alternateGatekeeper << '\n';
  strm << setw(indent+19) << "altGKisPermanent = " << setprecision(indent) << m_altGKisPermanent << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_AltGKInfo::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_AltGKInfo), PInvalidCast);
#endif
  const H225_AltGKInfo & other = (const H225_AltGKInfo &)obj;

  Comparison result;

  if ((result = m_alternateGatekeeper.Compare(other.m_alternateGatekeeper)) != EqualTo)
    return result;
  if ((result = m_altGKisPermanent.Compare(other.m_altGKisPermanent)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_AltGKInfo::GetDataLength() const
{
  PINDEX length = 0;
  length += m_alternateGatekeeper.GetObjectLength();
  length += m_altGKisPermanent.GetObjectLength();
  return length;
}


BOOL H225_AltGKInfo::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_alternateGatekeeper.Decode(strm))
    return FALSE;
  if (!m_altGKisPermanent.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_AltGKInfo::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_alternateGatekeeper.Encode(strm);
  m_altGKisPermanent.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_AltGKInfo::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_AltGKInfo::Class()), PInvalidCast);
#endif
  return new H225_AltGKInfo(*this);
}


//
// SecurityCapabilities
//

H225_SecurityCapabilities::H225_SecurityCapabilities(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_SecurityCapabilities::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandard))
    strm << setw(indent+14) << "nonStandard = " << setprecision(indent) << m_nonStandard << '\n';
  strm << setw(indent+13) << "encryption = " << setprecision(indent) << m_encryption << '\n';
  strm << setw(indent+16) << "authenticaton = " << setprecision(indent) << m_authenticaton << '\n';
  strm << setw(indent+12) << "integrity = " << setprecision(indent) << m_integrity << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_SecurityCapabilities::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_SecurityCapabilities), PInvalidCast);
#endif
  const H225_SecurityCapabilities & other = (const H225_SecurityCapabilities &)obj;

  Comparison result;

  if ((result = m_nonStandard.Compare(other.m_nonStandard)) != EqualTo)
    return result;
  if ((result = m_encryption.Compare(other.m_encryption)) != EqualTo)
    return result;
  if ((result = m_authenticaton.Compare(other.m_authenticaton)) != EqualTo)
    return result;
  if ((result = m_integrity.Compare(other.m_integrity)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_SecurityCapabilities::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_nonStandard))
    length += m_nonStandard.GetObjectLength();
  length += m_encryption.GetObjectLength();
  length += m_authenticaton.GetObjectLength();
  length += m_integrity.GetObjectLength();
  return length;
}


BOOL H225_SecurityCapabilities::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_nonStandard) && !m_nonStandard.Decode(strm))
    return FALSE;
  if (!m_encryption.Decode(strm))
    return FALSE;
  if (!m_authenticaton.Decode(strm))
    return FALSE;
  if (!m_integrity.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_SecurityCapabilities::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandard))
    m_nonStandard.Encode(strm);
  m_encryption.Encode(strm);
  m_authenticaton.Encode(strm);
  m_integrity.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_SecurityCapabilities::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_SecurityCapabilities::Class()), PInvalidCast);
#endif
  return new H225_SecurityCapabilities(*this);
}


//
// QseriesOptions
//

H225_QseriesOptions::H225_QseriesOptions(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_QseriesOptions::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "q932Full = " << setprecision(indent) << m_q932Full << '\n';
  strm << setw(indent+11) << "q951Full = " << setprecision(indent) << m_q951Full << '\n';
  strm << setw(indent+11) << "q952Full = " << setprecision(indent) << m_q952Full << '\n';
  strm << setw(indent+11) << "q953Full = " << setprecision(indent) << m_q953Full << '\n';
  strm << setw(indent+11) << "q955Full = " << setprecision(indent) << m_q955Full << '\n';
  strm << setw(indent+11) << "q956Full = " << setprecision(indent) << m_q956Full << '\n';
  strm << setw(indent+11) << "q957Full = " << setprecision(indent) << m_q957Full << '\n';
  strm << setw(indent+11) << "q954Info = " << setprecision(indent) << m_q954Info << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_QseriesOptions::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_QseriesOptions), PInvalidCast);
#endif
  const H225_QseriesOptions & other = (const H225_QseriesOptions &)obj;

  Comparison result;

  if ((result = m_q932Full.Compare(other.m_q932Full)) != EqualTo)
    return result;
  if ((result = m_q951Full.Compare(other.m_q951Full)) != EqualTo)
    return result;
  if ((result = m_q952Full.Compare(other.m_q952Full)) != EqualTo)
    return result;
  if ((result = m_q953Full.Compare(other.m_q953Full)) != EqualTo)
    return result;
  if ((result = m_q955Full.Compare(other.m_q955Full)) != EqualTo)
    return result;
  if ((result = m_q956Full.Compare(other.m_q956Full)) != EqualTo)
    return result;
  if ((result = m_q957Full.Compare(other.m_q957Full)) != EqualTo)
    return result;
  if ((result = m_q954Info.Compare(other.m_q954Info)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_QseriesOptions::GetDataLength() const
{
  PINDEX length = 0;
  length += m_q932Full.GetObjectLength();
  length += m_q951Full.GetObjectLength();
  length += m_q952Full.GetObjectLength();
  length += m_q953Full.GetObjectLength();
  length += m_q955Full.GetObjectLength();
  length += m_q956Full.GetObjectLength();
  length += m_q957Full.GetObjectLength();
  length += m_q954Info.GetObjectLength();
  return length;
}


BOOL H225_QseriesOptions::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_q932Full.Decode(strm))
    return FALSE;
  if (!m_q951Full.Decode(strm))
    return FALSE;
  if (!m_q952Full.Decode(strm))
    return FALSE;
  if (!m_q953Full.Decode(strm))
    return FALSE;
  if (!m_q955Full.Decode(strm))
    return FALSE;
  if (!m_q956Full.Decode(strm))
    return FALSE;
  if (!m_q957Full.Decode(strm))
    return FALSE;
  if (!m_q954Info.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_QseriesOptions::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_q932Full.Encode(strm);
  m_q951Full.Encode(strm);
  m_q952Full.Encode(strm);
  m_q953Full.Encode(strm);
  m_q955Full.Encode(strm);
  m_q956Full.Encode(strm);
  m_q957Full.Encode(strm);
  m_q954Info.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_QseriesOptions::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_QseriesOptions::Class()), PInvalidCast);
#endif
  return new H225_QseriesOptions(*this);
}


//
// DataRate
//

H225_DataRate::H225_DataRate(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
  m_channelMultiplier.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H225_DataRate::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  strm << setw(indent+14) << "channelRate = " << setprecision(indent) << m_channelRate << '\n';
  if (HasOptionalField(e_channelMultiplier))
    strm << setw(indent+20) << "channelMultiplier = " << setprecision(indent) << m_channelMultiplier << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_DataRate::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_DataRate), PInvalidCast);
#endif
  const H225_DataRate & other = (const H225_DataRate &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_channelRate.Compare(other.m_channelRate)) != EqualTo)
    return result;
  if ((result = m_channelMultiplier.Compare(other.m_channelMultiplier)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_DataRate::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  length += m_channelRate.GetObjectLength();
  if (HasOptionalField(e_channelMultiplier))
    length += m_channelMultiplier.GetObjectLength();
  return length;
}


BOOL H225_DataRate::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (!m_channelRate.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_channelMultiplier) && !m_channelMultiplier.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_DataRate::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  m_channelRate.Encode(strm);
  if (HasOptionalField(e_channelMultiplier))
    m_channelMultiplier.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_DataRate::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_DataRate::Class()), PInvalidCast);
#endif
  return new H225_DataRate(*this);
}


//
// SupportedPrefix
//

H225_SupportedPrefix::H225_SupportedPrefix(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_SupportedPrefix::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  strm << setw(indent+9) << "prefix = " << setprecision(indent) << m_prefix << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_SupportedPrefix::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_SupportedPrefix), PInvalidCast);
#endif
  const H225_SupportedPrefix & other = (const H225_SupportedPrefix &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_prefix.Compare(other.m_prefix)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_SupportedPrefix::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  length += m_prefix.GetObjectLength();
  return length;
}


BOOL H225_SupportedPrefix::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (!m_prefix.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_SupportedPrefix::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  m_prefix.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_SupportedPrefix::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_SupportedPrefix::Class()), PInvalidCast);
#endif
  return new H225_SupportedPrefix(*this);
}


//
// CapacityReportingSpecification
//

H225_CapacityReportingSpecification::H225_CapacityReportingSpecification(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_CapacityReportingSpecification::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+7) << "when = " << setprecision(indent) << m_when << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_CapacityReportingSpecification::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_CapacityReportingSpecification), PInvalidCast);
#endif
  const H225_CapacityReportingSpecification & other = (const H225_CapacityReportingSpecification &)obj;

  Comparison result;

  if ((result = m_when.Compare(other.m_when)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_CapacityReportingSpecification::GetDataLength() const
{
  PINDEX length = 0;
  length += m_when.GetObjectLength();
  return length;
}


BOOL H225_CapacityReportingSpecification::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_when.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_CapacityReportingSpecification::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_when.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_CapacityReportingSpecification::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_CapacityReportingSpecification::Class()), PInvalidCast);
#endif
  return new H225_CapacityReportingSpecification(*this);
}


//
// CallCapacityInfo
//

H225_CallCapacityInfo::H225_CallCapacityInfo(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 11, TRUE, 1)
{
}


#ifndef PASN_NOPRINTON
void H225_CallCapacityInfo::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_voiceGwCallsAvailable))
    strm << setw(indent+24) << "voiceGwCallsAvailable = " << setprecision(indent) << m_voiceGwCallsAvailable << '\n';
  if (HasOptionalField(e_h310GwCallsAvailable))
    strm << setw(indent+23) << "h310GwCallsAvailable = " << setprecision(indent) << m_h310GwCallsAvailable << '\n';
  if (HasOptionalField(e_h320GwCallsAvailable))
    strm << setw(indent+23) << "h320GwCallsAvailable = " << setprecision(indent) << m_h320GwCallsAvailable << '\n';
  if (HasOptionalField(e_h321GwCallsAvailable))
    strm << setw(indent+23) << "h321GwCallsAvailable = " << setprecision(indent) << m_h321GwCallsAvailable << '\n';
  if (HasOptionalField(e_h322GwCallsAvailable))
    strm << setw(indent+23) << "h322GwCallsAvailable = " << setprecision(indent) << m_h322GwCallsAvailable << '\n';
  if (HasOptionalField(e_h323GwCallsAvailable))
    strm << setw(indent+23) << "h323GwCallsAvailable = " << setprecision(indent) << m_h323GwCallsAvailable << '\n';
  if (HasOptionalField(e_h324GwCallsAvailable))
    strm << setw(indent+23) << "h324GwCallsAvailable = " << setprecision(indent) << m_h324GwCallsAvailable << '\n';
  if (HasOptionalField(e_t120OnlyGwCallsAvailable))
    strm << setw(indent+27) << "t120OnlyGwCallsAvailable = " << setprecision(indent) << m_t120OnlyGwCallsAvailable << '\n';
  if (HasOptionalField(e_t38FaxAnnexbOnlyGwCallsAvailable))
    strm << setw(indent+35) << "t38FaxAnnexbOnlyGwCallsAvailable = " << setprecision(indent) << m_t38FaxAnnexbOnlyGwCallsAvailable << '\n';
  if (HasOptionalField(e_terminalCallsAvailable))
    strm << setw(indent+25) << "terminalCallsAvailable = " << setprecision(indent) << m_terminalCallsAvailable << '\n';
  if (HasOptionalField(e_mcuCallsAvailable))
    strm << setw(indent+20) << "mcuCallsAvailable = " << setprecision(indent) << m_mcuCallsAvailable << '\n';
  if (HasOptionalField(e_sipGwCallsAvailable))
    strm << setw(indent+22) << "sipGwCallsAvailable = " << setprecision(indent) << m_sipGwCallsAvailable << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_CallCapacityInfo::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_CallCapacityInfo), PInvalidCast);
#endif
  const H225_CallCapacityInfo & other = (const H225_CallCapacityInfo &)obj;

  Comparison result;

  if ((result = m_voiceGwCallsAvailable.Compare(other.m_voiceGwCallsAvailable)) != EqualTo)
    return result;
  if ((result = m_h310GwCallsAvailable.Compare(other.m_h310GwCallsAvailable)) != EqualTo)
    return result;
  if ((result = m_h320GwCallsAvailable.Compare(other.m_h320GwCallsAvailable)) != EqualTo)
    return result;
  if ((result = m_h321GwCallsAvailable.Compare(other.m_h321GwCallsAvailable)) != EqualTo)
    return result;
  if ((result = m_h322GwCallsAvailable.Compare(other.m_h322GwCallsAvailable)) != EqualTo)
    return result;
  if ((result = m_h323GwCallsAvailable.Compare(other.m_h323GwCallsAvailable)) != EqualTo)
    return result;
  if ((result = m_h324GwCallsAvailable.Compare(other.m_h324GwCallsAvailable)) != EqualTo)
    return result;
  if ((result = m_t120OnlyGwCallsAvailable.Compare(other.m_t120OnlyGwCallsAvailable)) != EqualTo)
    return result;
  if ((result = m_t38FaxAnnexbOnlyGwCallsAvailable.Compare(other.m_t38FaxAnnexbOnlyGwCallsAvailable)) != EqualTo)
    return result;
  if ((result = m_terminalCallsAvailable.Compare(other.m_terminalCallsAvailable)) != EqualTo)
    return result;
  if ((result = m_mcuCallsAvailable.Compare(other.m_mcuCallsAvailable)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_CallCapacityInfo::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_voiceGwCallsAvailable))
    length += m_voiceGwCallsAvailable.GetObjectLength();
  if (HasOptionalField(e_h310GwCallsAvailable))
    length += m_h310GwCallsAvailable.GetObjectLength();
  if (HasOptionalField(e_h320GwCallsAvailable))
    length += m_h320GwCallsAvailable.GetObjectLength();
  if (HasOptionalField(e_h321GwCallsAvailable))
    length += m_h321GwCallsAvailable.GetObjectLength();
  if (HasOptionalField(e_h322GwCallsAvailable))
    length += m_h322GwCallsAvailable.GetObjectLength();
  if (HasOptionalField(e_h323GwCallsAvailable))
    length += m_h323GwCallsAvailable.GetObjectLength();
  if (HasOptionalField(e_h324GwCallsAvailable))
    length += m_h324GwCallsAvailable.GetObjectLength();
  if (HasOptionalField(e_t120OnlyGwCallsAvailable))
    length += m_t120OnlyGwCallsAvailable.GetObjectLength();
  if (HasOptionalField(e_t38FaxAnnexbOnlyGwCallsAvailable))
    length += m_t38FaxAnnexbOnlyGwCallsAvailable.GetObjectLength();
  if (HasOptionalField(e_terminalCallsAvailable))
    length += m_terminalCallsAvailable.GetObjectLength();
  if (HasOptionalField(e_mcuCallsAvailable))
    length += m_mcuCallsAvailable.GetObjectLength();
  return length;
}


BOOL H225_CallCapacityInfo::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_voiceGwCallsAvailable) && !m_voiceGwCallsAvailable.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_h310GwCallsAvailable) && !m_h310GwCallsAvailable.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_h320GwCallsAvailable) && !m_h320GwCallsAvailable.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_h321GwCallsAvailable) && !m_h321GwCallsAvailable.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_h322GwCallsAvailable) && !m_h322GwCallsAvailable.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_h323GwCallsAvailable) && !m_h323GwCallsAvailable.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_h324GwCallsAvailable) && !m_h324GwCallsAvailable.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_t120OnlyGwCallsAvailable) && !m_t120OnlyGwCallsAvailable.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_t38FaxAnnexbOnlyGwCallsAvailable) && !m_t38FaxAnnexbOnlyGwCallsAvailable.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_terminalCallsAvailable) && !m_terminalCallsAvailable.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_mcuCallsAvailable) && !m_mcuCallsAvailable.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_sipGwCallsAvailable, m_sipGwCallsAvailable))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_CallCapacityInfo::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_voiceGwCallsAvailable))
    m_voiceGwCallsAvailable.Encode(strm);
  if (HasOptionalField(e_h310GwCallsAvailable))
    m_h310GwCallsAvailable.Encode(strm);
  if (HasOptionalField(e_h320GwCallsAvailable))
    m_h320GwCallsAvailable.Encode(strm);
  if (HasOptionalField(e_h321GwCallsAvailable))
    m_h321GwCallsAvailable.Encode(strm);
  if (HasOptionalField(e_h322GwCallsAvailable))
    m_h322GwCallsAvailable.Encode(strm);
  if (HasOptionalField(e_h323GwCallsAvailable))
    m_h323GwCallsAvailable.Encode(strm);
  if (HasOptionalField(e_h324GwCallsAvailable))
    m_h324GwCallsAvailable.Encode(strm);
  if (HasOptionalField(e_t120OnlyGwCallsAvailable))
    m_t120OnlyGwCallsAvailable.Encode(strm);
  if (HasOptionalField(e_t38FaxAnnexbOnlyGwCallsAvailable))
    m_t38FaxAnnexbOnlyGwCallsAvailable.Encode(strm);
  if (HasOptionalField(e_terminalCallsAvailable))
    m_terminalCallsAvailable.Encode(strm);
  if (HasOptionalField(e_mcuCallsAvailable))
    m_mcuCallsAvailable.Encode(strm);
  KnownExtensionEncode(strm, e_sipGwCallsAvailable, m_sipGwCallsAvailable);

  UnknownExtensionsEncode(strm);
}


PObject * H225_CallCapacityInfo::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_CallCapacityInfo::Class()), PInvalidCast);
#endif
  return new H225_CallCapacityInfo(*this);
}


//
// CallsAvailable
//

H225_CallsAvailable::H225_CallsAvailable(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 1)
{
  m_calls.SetConstraints(PASN_Object::FixedConstraint, 0, 4294967295U);
  m_group.SetConstraints(PASN_Object::FixedConstraint, 1, 128);
}


#ifndef PASN_NOPRINTON
void H225_CallsAvailable::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+8) << "calls = " << setprecision(indent) << m_calls << '\n';
  if (HasOptionalField(e_group))
    strm << setw(indent+8) << "group = " << setprecision(indent) << m_group << '\n';
  if (HasOptionalField(e_carrier))
    strm << setw(indent+10) << "carrier = " << setprecision(indent) << m_carrier << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_CallsAvailable::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_CallsAvailable), PInvalidCast);
#endif
  const H225_CallsAvailable & other = (const H225_CallsAvailable &)obj;

  Comparison result;

  if ((result = m_calls.Compare(other.m_calls)) != EqualTo)
    return result;
  if ((result = m_group.Compare(other.m_group)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_CallsAvailable::GetDataLength() const
{
  PINDEX length = 0;
  length += m_calls.GetObjectLength();
  if (HasOptionalField(e_group))
    length += m_group.GetObjectLength();
  return length;
}


BOOL H225_CallsAvailable::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_calls.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_group) && !m_group.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_carrier, m_carrier))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_CallsAvailable::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_calls.Encode(strm);
  if (HasOptionalField(e_group))
    m_group.Encode(strm);
  KnownExtensionEncode(strm, e_carrier, m_carrier);

  UnknownExtensionsEncode(strm);
}


PObject * H225_CallsAvailable::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_CallsAvailable::Class()), PInvalidCast);
#endif
  return new H225_CallsAvailable(*this);
}


//
// CicInfo
//

H225_CicInfo::H225_CicInfo(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_pointCode.SetConstraints(PASN_Object::FixedConstraint, 2, 5);
}


#ifndef PASN_NOPRINTON
void H225_CicInfo::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+6) << "cic = " << setprecision(indent) << m_cic << '\n';
  strm << setw(indent+12) << "pointCode = " << setprecision(indent) << m_pointCode << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_CicInfo::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_CicInfo), PInvalidCast);
#endif
  const H225_CicInfo & other = (const H225_CicInfo &)obj;

  Comparison result;

  if ((result = m_cic.Compare(other.m_cic)) != EqualTo)
    return result;
  if ((result = m_pointCode.Compare(other.m_pointCode)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_CicInfo::GetDataLength() const
{
  PINDEX length = 0;
  length += m_cic.GetObjectLength();
  length += m_pointCode.GetObjectLength();
  return length;
}


BOOL H225_CicInfo::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_cic.Decode(strm))
    return FALSE;
  if (!m_pointCode.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_CicInfo::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_cic.Encode(strm);
  m_pointCode.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_CicInfo::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_CicInfo::Class()), PInvalidCast);
#endif
  return new H225_CicInfo(*this);
}


//
// GroupID
//

H225_GroupID::H225_GroupID(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_group.SetConstraints(PASN_Object::FixedConstraint, 1, 128);
}


#ifndef PASN_NOPRINTON
void H225_GroupID::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_member))
    strm << setw(indent+9) << "member = " << setprecision(indent) << m_member << '\n';
  strm << setw(indent+8) << "group = " << setprecision(indent) << m_group << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_GroupID::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_GroupID), PInvalidCast);
#endif
  const H225_GroupID & other = (const H225_GroupID &)obj;

  Comparison result;

  if ((result = m_member.Compare(other.m_member)) != EqualTo)
    return result;
  if ((result = m_group.Compare(other.m_group)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_GroupID::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_member))
    length += m_member.GetObjectLength();
  length += m_group.GetObjectLength();
  return length;
}


BOOL H225_GroupID::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_member) && !m_member.Decode(strm))
    return FALSE;
  if (!m_group.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_GroupID::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_member))
    m_member.Encode(strm);
  m_group.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_GroupID::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_GroupID::Class()), PInvalidCast);
#endif
  return new H225_GroupID(*this);
}


//
// ServiceControlSession
//

H225_ServiceControlSession::H225_ServiceControlSession(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_sessionId.SetConstraints(PASN_Object::FixedConstraint, 0, 255);
}


#ifndef PASN_NOPRINTON
void H225_ServiceControlSession::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+12) << "sessionId = " << setprecision(indent) << m_sessionId << '\n';
  if (HasOptionalField(e_contents))
    strm << setw(indent+11) << "contents = " << setprecision(indent) << m_contents << '\n';
  strm << setw(indent+9) << "reason = " << setprecision(indent) << m_reason << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_ServiceControlSession::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_ServiceControlSession), PInvalidCast);
#endif
  const H225_ServiceControlSession & other = (const H225_ServiceControlSession &)obj;

  Comparison result;

  if ((result = m_sessionId.Compare(other.m_sessionId)) != EqualTo)
    return result;
  if ((result = m_contents.Compare(other.m_contents)) != EqualTo)
    return result;
  if ((result = m_reason.Compare(other.m_reason)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_ServiceControlSession::GetDataLength() const
{
  PINDEX length = 0;
  length += m_sessionId.GetObjectLength();
  if (HasOptionalField(e_contents))
    length += m_contents.GetObjectLength();
  length += m_reason.GetObjectLength();
  return length;
}


BOOL H225_ServiceControlSession::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_sessionId.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_contents) && !m_contents.Decode(strm))
    return FALSE;
  if (!m_reason.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_ServiceControlSession::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_sessionId.Encode(strm);
  if (HasOptionalField(e_contents))
    m_contents.Encode(strm);
  m_reason.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_ServiceControlSession::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ServiceControlSession::Class()), PInvalidCast);
#endif
  return new H225_ServiceControlSession(*this);
}


//
// RasUsageInfoTypes
//

H225_RasUsageInfoTypes::H225_RasUsageInfoTypes(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_RasUsageInfoTypes::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+24) << "nonStandardUsageTypes = " << setprecision(indent) << m_nonStandardUsageTypes << '\n';
  if (HasOptionalField(e_startTime))
    strm << setw(indent+12) << "startTime = " << setprecision(indent) << m_startTime << '\n';
  if (HasOptionalField(e_endTime))
    strm << setw(indent+10) << "endTime = " << setprecision(indent) << m_endTime << '\n';
  if (HasOptionalField(e_terminationCause))
    strm << setw(indent+19) << "terminationCause = " << setprecision(indent) << m_terminationCause << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_RasUsageInfoTypes::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_RasUsageInfoTypes), PInvalidCast);
#endif
  const H225_RasUsageInfoTypes & other = (const H225_RasUsageInfoTypes &)obj;

  Comparison result;

  if ((result = m_nonStandardUsageTypes.Compare(other.m_nonStandardUsageTypes)) != EqualTo)
    return result;
  if ((result = m_startTime.Compare(other.m_startTime)) != EqualTo)
    return result;
  if ((result = m_endTime.Compare(other.m_endTime)) != EqualTo)
    return result;
  if ((result = m_terminationCause.Compare(other.m_terminationCause)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_RasUsageInfoTypes::GetDataLength() const
{
  PINDEX length = 0;
  length += m_nonStandardUsageTypes.GetObjectLength();
  if (HasOptionalField(e_startTime))
    length += m_startTime.GetObjectLength();
  if (HasOptionalField(e_endTime))
    length += m_endTime.GetObjectLength();
  if (HasOptionalField(e_terminationCause))
    length += m_terminationCause.GetObjectLength();
  return length;
}


BOOL H225_RasUsageInfoTypes::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_nonStandardUsageTypes.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_startTime) && !m_startTime.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_endTime) && !m_endTime.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_terminationCause) && !m_terminationCause.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_RasUsageInfoTypes::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_nonStandardUsageTypes.Encode(strm);
  if (HasOptionalField(e_startTime))
    m_startTime.Encode(strm);
  if (HasOptionalField(e_endTime))
    m_endTime.Encode(strm);
  if (HasOptionalField(e_terminationCause))
    m_terminationCause.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_RasUsageInfoTypes::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_RasUsageInfoTypes::Class()), PInvalidCast);
#endif
  return new H225_RasUsageInfoTypes(*this);
}


//
// RasUsageSpecification
//

H225_RasUsageSpecification::H225_RasUsageSpecification(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_RasUsageSpecification::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+7) << "when = " << setprecision(indent) << m_when << '\n';
  if (HasOptionalField(e_callStartingPoint))
    strm << setw(indent+20) << "callStartingPoint = " << setprecision(indent) << m_callStartingPoint << '\n';
  strm << setw(indent+11) << "required = " << setprecision(indent) << m_required << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_RasUsageSpecification::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_RasUsageSpecification), PInvalidCast);
#endif
  const H225_RasUsageSpecification & other = (const H225_RasUsageSpecification &)obj;

  Comparison result;

  if ((result = m_when.Compare(other.m_when)) != EqualTo)
    return result;
  if ((result = m_callStartingPoint.Compare(other.m_callStartingPoint)) != EqualTo)
    return result;
  if ((result = m_required.Compare(other.m_required)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_RasUsageSpecification::GetDataLength() const
{
  PINDEX length = 0;
  length += m_when.GetObjectLength();
  if (HasOptionalField(e_callStartingPoint))
    length += m_callStartingPoint.GetObjectLength();
  length += m_required.GetObjectLength();
  return length;
}


BOOL H225_RasUsageSpecification::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_when.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_callStartingPoint) && !m_callStartingPoint.Decode(strm))
    return FALSE;
  if (!m_required.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_RasUsageSpecification::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_when.Encode(strm);
  if (HasOptionalField(e_callStartingPoint))
    m_callStartingPoint.Encode(strm);
  m_required.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_RasUsageSpecification::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_RasUsageSpecification::Class()), PInvalidCast);
#endif
  return new H225_RasUsageSpecification(*this);
}


//
// RasUsageInformation
//

H225_RasUsageInformation::H225_RasUsageInformation(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_RasUsageInformation::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+25) << "nonStandardUsageFields = " << setprecision(indent) << m_nonStandardUsageFields << '\n';
  if (HasOptionalField(e_alertingTime))
    strm << setw(indent+15) << "alertingTime = " << setprecision(indent) << m_alertingTime << '\n';
  if (HasOptionalField(e_connectTime))
    strm << setw(indent+14) << "connectTime = " << setprecision(indent) << m_connectTime << '\n';
  if (HasOptionalField(e_endTime))
    strm << setw(indent+10) << "endTime = " << setprecision(indent) << m_endTime << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_RasUsageInformation::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_RasUsageInformation), PInvalidCast);
#endif
  const H225_RasUsageInformation & other = (const H225_RasUsageInformation &)obj;

  Comparison result;

  if ((result = m_nonStandardUsageFields.Compare(other.m_nonStandardUsageFields)) != EqualTo)
    return result;
  if ((result = m_alertingTime.Compare(other.m_alertingTime)) != EqualTo)
    return result;
  if ((result = m_connectTime.Compare(other.m_connectTime)) != EqualTo)
    return result;
  if ((result = m_endTime.Compare(other.m_endTime)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_RasUsageInformation::GetDataLength() const
{
  PINDEX length = 0;
  length += m_nonStandardUsageFields.GetObjectLength();
  if (HasOptionalField(e_alertingTime))
    length += m_alertingTime.GetObjectLength();
  if (HasOptionalField(e_connectTime))
    length += m_connectTime.GetObjectLength();
  if (HasOptionalField(e_endTime))
    length += m_endTime.GetObjectLength();
  return length;
}


BOOL H225_RasUsageInformation::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_nonStandardUsageFields.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_alertingTime) && !m_alertingTime.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_connectTime) && !m_connectTime.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_endTime) && !m_endTime.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_RasUsageInformation::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_nonStandardUsageFields.Encode(strm);
  if (HasOptionalField(e_alertingTime))
    m_alertingTime.Encode(strm);
  if (HasOptionalField(e_connectTime))
    m_connectTime.Encode(strm);
  if (HasOptionalField(e_endTime))
    m_endTime.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_RasUsageInformation::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_RasUsageInformation::Class()), PInvalidCast);
#endif
  return new H225_RasUsageInformation(*this);
}


//
// BandwidthDetails
//

H225_BandwidthDetails::H225_BandwidthDetails(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_BandwidthDetails::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+9) << "sender = " << setprecision(indent) << m_sender << '\n';
  strm << setw(indent+12) << "multicast = " << setprecision(indent) << m_multicast << '\n';
  strm << setw(indent+12) << "bandwidth = " << setprecision(indent) << m_bandwidth << '\n';
  strm << setw(indent+16) << "rtcpAddresses = " << setprecision(indent) << m_rtcpAddresses << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_BandwidthDetails::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_BandwidthDetails), PInvalidCast);
#endif
  const H225_BandwidthDetails & other = (const H225_BandwidthDetails &)obj;

  Comparison result;

  if ((result = m_sender.Compare(other.m_sender)) != EqualTo)
    return result;
  if ((result = m_multicast.Compare(other.m_multicast)) != EqualTo)
    return result;
  if ((result = m_bandwidth.Compare(other.m_bandwidth)) != EqualTo)
    return result;
  if ((result = m_rtcpAddresses.Compare(other.m_rtcpAddresses)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_BandwidthDetails::GetDataLength() const
{
  PINDEX length = 0;
  length += m_sender.GetObjectLength();
  length += m_multicast.GetObjectLength();
  length += m_bandwidth.GetObjectLength();
  length += m_rtcpAddresses.GetObjectLength();
  return length;
}


BOOL H225_BandwidthDetails::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_sender.Decode(strm))
    return FALSE;
  if (!m_multicast.Decode(strm))
    return FALSE;
  if (!m_bandwidth.Decode(strm))
    return FALSE;
  if (!m_rtcpAddresses.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_BandwidthDetails::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_sender.Encode(strm);
  m_multicast.Encode(strm);
  m_bandwidth.Encode(strm);
  m_rtcpAddresses.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_BandwidthDetails::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_BandwidthDetails::Class()), PInvalidCast);
#endif
  return new H225_BandwidthDetails(*this);
}


//
// CallCreditServiceControl
//

H225_CallCreditServiceControl::H225_CallCreditServiceControl(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 5, TRUE, 0)
{
  m_amountString.SetConstraints(PASN_Object::FixedConstraint, 1, 512);
  m_callDurationLimit.SetConstraints(PASN_Object::FixedConstraint, 1, 4294967295U);
}


#ifndef PASN_NOPRINTON
void H225_CallCreditServiceControl::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_amountString))
    strm << setw(indent+15) << "amountString = " << setprecision(indent) << m_amountString << '\n';
  if (HasOptionalField(e_billingMode))
    strm << setw(indent+14) << "billingMode = " << setprecision(indent) << m_billingMode << '\n';
  if (HasOptionalField(e_callDurationLimit))
    strm << setw(indent+20) << "callDurationLimit = " << setprecision(indent) << m_callDurationLimit << '\n';
  if (HasOptionalField(e_enforceCallDurationLimit))
    strm << setw(indent+27) << "enforceCallDurationLimit = " << setprecision(indent) << m_enforceCallDurationLimit << '\n';
  if (HasOptionalField(e_callStartingPoint))
    strm << setw(indent+20) << "callStartingPoint = " << setprecision(indent) << m_callStartingPoint << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_CallCreditServiceControl::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_CallCreditServiceControl), PInvalidCast);
#endif
  const H225_CallCreditServiceControl & other = (const H225_CallCreditServiceControl &)obj;

  Comparison result;

  if ((result = m_amountString.Compare(other.m_amountString)) != EqualTo)
    return result;
  if ((result = m_billingMode.Compare(other.m_billingMode)) != EqualTo)
    return result;
  if ((result = m_callDurationLimit.Compare(other.m_callDurationLimit)) != EqualTo)
    return result;
  if ((result = m_enforceCallDurationLimit.Compare(other.m_enforceCallDurationLimit)) != EqualTo)
    return result;
  if ((result = m_callStartingPoint.Compare(other.m_callStartingPoint)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_CallCreditServiceControl::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_amountString))
    length += m_amountString.GetObjectLength();
  if (HasOptionalField(e_billingMode))
    length += m_billingMode.GetObjectLength();
  if (HasOptionalField(e_callDurationLimit))
    length += m_callDurationLimit.GetObjectLength();
  if (HasOptionalField(e_enforceCallDurationLimit))
    length += m_enforceCallDurationLimit.GetObjectLength();
  if (HasOptionalField(e_callStartingPoint))
    length += m_callStartingPoint.GetObjectLength();
  return length;
}


BOOL H225_CallCreditServiceControl::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_amountString) && !m_amountString.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_billingMode) && !m_billingMode.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_callDurationLimit) && !m_callDurationLimit.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_enforceCallDurationLimit) && !m_enforceCallDurationLimit.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_callStartingPoint) && !m_callStartingPoint.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_CallCreditServiceControl::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_amountString))
    m_amountString.Encode(strm);
  if (HasOptionalField(e_billingMode))
    m_billingMode.Encode(strm);
  if (HasOptionalField(e_callDurationLimit))
    m_callDurationLimit.Encode(strm);
  if (HasOptionalField(e_enforceCallDurationLimit))
    m_enforceCallDurationLimit.Encode(strm);
  if (HasOptionalField(e_callStartingPoint))
    m_callStartingPoint.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_CallCreditServiceControl::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_CallCreditServiceControl::Class()), PInvalidCast);
#endif
  return new H225_CallCreditServiceControl(*this);
}


//
// GenericData
//

H225_GenericData::H225_GenericData(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_parameters.SetConstraints(PASN_Object::FixedConstraint, 1, 512);
}


#ifndef PASN_NOPRINTON
void H225_GenericData::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+5) << "id = " << setprecision(indent) << m_id << '\n';
  if (HasOptionalField(e_parameters))
    strm << setw(indent+13) << "parameters = " << setprecision(indent) << m_parameters << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_GenericData::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_GenericData), PInvalidCast);
#endif
  const H225_GenericData & other = (const H225_GenericData &)obj;

  Comparison result;

  if ((result = m_id.Compare(other.m_id)) != EqualTo)
    return result;
  if ((result = m_parameters.Compare(other.m_parameters)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_GenericData::GetDataLength() const
{
  PINDEX length = 0;
  length += m_id.GetObjectLength();
  if (HasOptionalField(e_parameters))
    length += m_parameters.GetObjectLength();
  return length;
}


BOOL H225_GenericData::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_id.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_parameters) && !m_parameters.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_GenericData::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_id.Encode(strm);
  if (HasOptionalField(e_parameters))
    m_parameters.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_GenericData::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_GenericData::Class()), PInvalidCast);
#endif
  return new H225_GenericData(*this);
}


//
// EnumeratedParameter
//

H225_EnumeratedParameter::H225_EnumeratedParameter(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_EnumeratedParameter::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+5) << "id = " << setprecision(indent) << m_id << '\n';
  if (HasOptionalField(e_content))
    strm << setw(indent+10) << "content = " << setprecision(indent) << m_content << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_EnumeratedParameter::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_EnumeratedParameter), PInvalidCast);
#endif
  const H225_EnumeratedParameter & other = (const H225_EnumeratedParameter &)obj;

  Comparison result;

  if ((result = m_id.Compare(other.m_id)) != EqualTo)
    return result;
  if ((result = m_content.Compare(other.m_content)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_EnumeratedParameter::GetDataLength() const
{
  PINDEX length = 0;
  length += m_id.GetObjectLength();
  if (HasOptionalField(e_content))
    length += m_content.GetObjectLength();
  return length;
}


BOOL H225_EnumeratedParameter::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_id.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_content) && !m_content.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_EnumeratedParameter::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_id.Encode(strm);
  if (HasOptionalField(e_content))
    m_content.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_EnumeratedParameter::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_EnumeratedParameter::Class()), PInvalidCast);
#endif
  return new H225_EnumeratedParameter(*this);
}


//
// FeatureSet
//

H225_FeatureSet::H225_FeatureSet(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_FeatureSet::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+24) << "replacementFeatureSet = " << setprecision(indent) << m_replacementFeatureSet << '\n';
  if (HasOptionalField(e_neededFeatures))
    strm << setw(indent+17) << "neededFeatures = " << setprecision(indent) << m_neededFeatures << '\n';
  if (HasOptionalField(e_desiredFeatures))
    strm << setw(indent+18) << "desiredFeatures = " << setprecision(indent) << m_desiredFeatures << '\n';
  if (HasOptionalField(e_supportedFeatures))
    strm << setw(indent+20) << "supportedFeatures = " << setprecision(indent) << m_supportedFeatures << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_FeatureSet::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_FeatureSet), PInvalidCast);
#endif
  const H225_FeatureSet & other = (const H225_FeatureSet &)obj;

  Comparison result;

  if ((result = m_replacementFeatureSet.Compare(other.m_replacementFeatureSet)) != EqualTo)
    return result;
  if ((result = m_neededFeatures.Compare(other.m_neededFeatures)) != EqualTo)
    return result;
  if ((result = m_desiredFeatures.Compare(other.m_desiredFeatures)) != EqualTo)
    return result;
  if ((result = m_supportedFeatures.Compare(other.m_supportedFeatures)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_FeatureSet::GetDataLength() const
{
  PINDEX length = 0;
  length += m_replacementFeatureSet.GetObjectLength();
  if (HasOptionalField(e_neededFeatures))
    length += m_neededFeatures.GetObjectLength();
  if (HasOptionalField(e_desiredFeatures))
    length += m_desiredFeatures.GetObjectLength();
  if (HasOptionalField(e_supportedFeatures))
    length += m_supportedFeatures.GetObjectLength();
  return length;
}


BOOL H225_FeatureSet::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_replacementFeatureSet.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_neededFeatures) && !m_neededFeatures.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_desiredFeatures) && !m_desiredFeatures.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_supportedFeatures) && !m_supportedFeatures.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_FeatureSet::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_replacementFeatureSet.Encode(strm);
  if (HasOptionalField(e_neededFeatures))
    m_neededFeatures.Encode(strm);
  if (HasOptionalField(e_desiredFeatures))
    m_desiredFeatures.Encode(strm);
  if (HasOptionalField(e_supportedFeatures))
    m_supportedFeatures.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_FeatureSet::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_FeatureSet::Class()), PInvalidCast);
#endif
  return new H225_FeatureSet(*this);
}


//
// RTPSession
//

H225_RTPSession::H225_RTPSession(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 2)
{
  m_ssrc.SetConstraints(PASN_Object::FixedConstraint, 1, 4294967295U);
  m_sessionId.SetConstraints(PASN_Object::FixedConstraint, 1, 255);
}


#ifndef PASN_NOPRINTON
void H225_RTPSession::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+13) << "rtpAddress = " << setprecision(indent) << m_rtpAddress << '\n';
  strm << setw(indent+14) << "rtcpAddress = " << setprecision(indent) << m_rtcpAddress << '\n';
  strm << setw(indent+8) << "cname = " << setprecision(indent) << m_cname << '\n';
  strm << setw(indent+7) << "ssrc = " << setprecision(indent) << m_ssrc << '\n';
  strm << setw(indent+12) << "sessionId = " << setprecision(indent) << m_sessionId << '\n';
  strm << setw(indent+23) << "associatedSessionIds = " << setprecision(indent) << m_associatedSessionIds << '\n';
  if (HasOptionalField(e_multicast))
    strm << setw(indent+12) << "multicast = " << setprecision(indent) << m_multicast << '\n';
  if (HasOptionalField(e_bandwidth))
    strm << setw(indent+12) << "bandwidth = " << setprecision(indent) << m_bandwidth << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_RTPSession::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_RTPSession), PInvalidCast);
#endif
  const H225_RTPSession & other = (const H225_RTPSession &)obj;

  Comparison result;

  if ((result = m_rtpAddress.Compare(other.m_rtpAddress)) != EqualTo)
    return result;
  if ((result = m_rtcpAddress.Compare(other.m_rtcpAddress)) != EqualTo)
    return result;
  if ((result = m_cname.Compare(other.m_cname)) != EqualTo)
    return result;
  if ((result = m_ssrc.Compare(other.m_ssrc)) != EqualTo)
    return result;
  if ((result = m_sessionId.Compare(other.m_sessionId)) != EqualTo)
    return result;
  if ((result = m_associatedSessionIds.Compare(other.m_associatedSessionIds)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_RTPSession::GetDataLength() const
{
  PINDEX length = 0;
  length += m_rtpAddress.GetObjectLength();
  length += m_rtcpAddress.GetObjectLength();
  length += m_cname.GetObjectLength();
  length += m_ssrc.GetObjectLength();
  length += m_sessionId.GetObjectLength();
  length += m_associatedSessionIds.GetObjectLength();
  return length;
}


BOOL H225_RTPSession::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_rtpAddress.Decode(strm))
    return FALSE;
  if (!m_rtcpAddress.Decode(strm))
    return FALSE;
  if (!m_cname.Decode(strm))
    return FALSE;
  if (!m_ssrc.Decode(strm))
    return FALSE;
  if (!m_sessionId.Decode(strm))
    return FALSE;
  if (!m_associatedSessionIds.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_multicast, m_multicast))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_bandwidth, m_bandwidth))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_RTPSession::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_rtpAddress.Encode(strm);
  m_rtcpAddress.Encode(strm);
  m_cname.Encode(strm);
  m_ssrc.Encode(strm);
  m_sessionId.Encode(strm);
  m_associatedSessionIds.Encode(strm);
  KnownExtensionEncode(strm, e_multicast, m_multicast);
  KnownExtensionEncode(strm, e_bandwidth, m_bandwidth);

  UnknownExtensionsEncode(strm);
}


PObject * H225_RTPSession::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_RTPSession::Class()), PInvalidCast);
#endif
  return new H225_RTPSession(*this);
}


//
// GatekeeperConfirm
//

H225_GatekeeperConfirm::H225_GatekeeperConfirm(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 9)
{
}


#ifndef PASN_NOPRINTON
void H225_GatekeeperConfirm::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  strm << setw(indent+21) << "protocolIdentifier = " << setprecision(indent) << m_protocolIdentifier << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_gatekeeperIdentifier))
    strm << setw(indent+23) << "gatekeeperIdentifier = " << setprecision(indent) << m_gatekeeperIdentifier << '\n';
  strm << setw(indent+13) << "rasAddress = " << setprecision(indent) << m_rasAddress << '\n';
  if (HasOptionalField(e_alternateGatekeeper))
    strm << setw(indent+22) << "alternateGatekeeper = " << setprecision(indent) << m_alternateGatekeeper << '\n';
  if (HasOptionalField(e_authenticationMode))
    strm << setw(indent+21) << "authenticationMode = " << setprecision(indent) << m_authenticationMode << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_algorithmOID))
    strm << setw(indent+15) << "algorithmOID = " << setprecision(indent) << m_algorithmOID << '\n';
  if (HasOptionalField(e_integrity))
    strm << setw(indent+12) << "integrity = " << setprecision(indent) << m_integrity << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  if (HasOptionalField(e_featureSet))
    strm << setw(indent+13) << "featureSet = " << setprecision(indent) << m_featureSet << '\n';
  if (HasOptionalField(e_genericData))
    strm << setw(indent+14) << "genericData = " << setprecision(indent) << m_genericData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_GatekeeperConfirm::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_GatekeeperConfirm), PInvalidCast);
#endif
  const H225_GatekeeperConfirm & other = (const H225_GatekeeperConfirm &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_protocolIdentifier.Compare(other.m_protocolIdentifier)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_gatekeeperIdentifier.Compare(other.m_gatekeeperIdentifier)) != EqualTo)
    return result;
  if ((result = m_rasAddress.Compare(other.m_rasAddress)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_GatekeeperConfirm::GetDataLength() const
{
  PINDEX length = 0;
  length += m_requestSeqNum.GetObjectLength();
  length += m_protocolIdentifier.GetObjectLength();
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  if (HasOptionalField(e_gatekeeperIdentifier))
    length += m_gatekeeperIdentifier.GetObjectLength();
  length += m_rasAddress.GetObjectLength();
  return length;
}


BOOL H225_GatekeeperConfirm::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_requestSeqNum.Decode(strm))
    return FALSE;
  if (!m_protocolIdentifier.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_gatekeeperIdentifier) && !m_gatekeeperIdentifier.Decode(strm))
    return FALSE;
  if (!m_rasAddress.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_alternateGatekeeper, m_alternateGatekeeper))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_authenticationMode, m_authenticationMode))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_tokens, m_tokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_cryptoTokens, m_cryptoTokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_algorithmOID, m_algorithmOID))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_integrity, m_integrity))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_integrityCheckValue, m_integrityCheckValue))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_featureSet, m_featureSet))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_genericData, m_genericData))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_GatekeeperConfirm::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  m_protocolIdentifier.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  if (HasOptionalField(e_gatekeeperIdentifier))
    m_gatekeeperIdentifier.Encode(strm);
  m_rasAddress.Encode(strm);
  KnownExtensionEncode(strm, e_alternateGatekeeper, m_alternateGatekeeper);
  KnownExtensionEncode(strm, e_authenticationMode, m_authenticationMode);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_algorithmOID, m_algorithmOID);
  KnownExtensionEncode(strm, e_integrity, m_integrity);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);
  KnownExtensionEncode(strm, e_featureSet, m_featureSet);
  KnownExtensionEncode(strm, e_genericData, m_genericData);

  UnknownExtensionsEncode(strm);
}


PObject * H225_GatekeeperConfirm::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_GatekeeperConfirm::Class()), PInvalidCast);
#endif
  return new H225_GatekeeperConfirm(*this);
}


//
// GatekeeperReject
//

H225_GatekeeperReject::H225_GatekeeperReject(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 6)
{
}


#ifndef PASN_NOPRINTON
void H225_GatekeeperReject::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  strm << setw(indent+21) << "protocolIdentifier = " << setprecision(indent) << m_protocolIdentifier << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_gatekeeperIdentifier))
    strm << setw(indent+23) << "gatekeeperIdentifier = " << setprecision(indent) << m_gatekeeperIdentifier << '\n';
  strm << setw(indent+15) << "rejectReason = " << setprecision(indent) << m_rejectReason << '\n';
  if (HasOptionalField(e_altGKInfo))
    strm << setw(indent+12) << "altGKInfo = " << setprecision(indent) << m_altGKInfo << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  if (HasOptionalField(e_featureSet))
    strm << setw(indent+13) << "featureSet = " << setprecision(indent) << m_featureSet << '\n';
  if (HasOptionalField(e_genericData))
    strm << setw(indent+14) << "genericData = " << setprecision(indent) << m_genericData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_GatekeeperReject::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_GatekeeperReject), PInvalidCast);
#endif
  const H225_GatekeeperReject & other = (const H225_GatekeeperReject &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_protocolIdentifier.Compare(other.m_protocolIdentifier)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_gatekeeperIdentifier.Compare(other.m_gatekeeperIdentifier)) != EqualTo)
    return result;
  if ((result = m_rejectReason.Compare(other.m_rejectReason)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_GatekeeperReject::GetDataLength() const
{
  PINDEX length = 0;
  length += m_requestSeqNum.GetObjectLength();
  length += m_protocolIdentifier.GetObjectLength();
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  if (HasOptionalField(e_gatekeeperIdentifier))
    length += m_gatekeeperIdentifier.GetObjectLength();
  length += m_rejectReason.GetObjectLength();
  return length;
}


BOOL H225_GatekeeperReject::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_requestSeqNum.Decode(strm))
    return FALSE;
  if (!m_protocolIdentifier.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_gatekeeperIdentifier) && !m_gatekeeperIdentifier.Decode(strm))
    return FALSE;
  if (!m_rejectReason.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_altGKInfo, m_altGKInfo))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_tokens, m_tokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_cryptoTokens, m_cryptoTokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_integrityCheckValue, m_integrityCheckValue))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_featureSet, m_featureSet))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_genericData, m_genericData))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_GatekeeperReject::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  m_protocolIdentifier.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  if (HasOptionalField(e_gatekeeperIdentifier))
    m_gatekeeperIdentifier.Encode(strm);
  m_rejectReason.Encode(strm);
  KnownExtensionEncode(strm, e_altGKInfo, m_altGKInfo);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);
  KnownExtensionEncode(strm, e_featureSet, m_featureSet);
  KnownExtensionEncode(strm, e_genericData, m_genericData);

  UnknownExtensionsEncode(strm);
}


PObject * H225_GatekeeperReject::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_GatekeeperReject::Class()), PInvalidCast);
#endif
  return new H225_GatekeeperReject(*this);
}


//
// RegistrationReject
//

H225_RegistrationReject::H225_RegistrationReject(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 6)
{
}


#ifndef PASN_NOPRINTON
void H225_RegistrationReject::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  strm << setw(indent+21) << "protocolIdentifier = " << setprecision(indent) << m_protocolIdentifier << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  strm << setw(indent+15) << "rejectReason = " << setprecision(indent) << m_rejectReason << '\n';
  if (HasOptionalField(e_gatekeeperIdentifier))
    strm << setw(indent+23) << "gatekeeperIdentifier = " << setprecision(indent) << m_gatekeeperIdentifier << '\n';
  if (HasOptionalField(e_altGKInfo))
    strm << setw(indent+12) << "altGKInfo = " << setprecision(indent) << m_altGKInfo << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  if (HasOptionalField(e_featureSet))
    strm << setw(indent+13) << "featureSet = " << setprecision(indent) << m_featureSet << '\n';
  if (HasOptionalField(e_genericData))
    strm << setw(indent+14) << "genericData = " << setprecision(indent) << m_genericData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_RegistrationReject::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_RegistrationReject), PInvalidCast);
#endif
  const H225_RegistrationReject & other = (const H225_RegistrationReject &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_protocolIdentifier.Compare(other.m_protocolIdentifier)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_rejectReason.Compare(other.m_rejectReason)) != EqualTo)
    return result;
  if ((result = m_gatekeeperIdentifier.Compare(other.m_gatekeeperIdentifier)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_RegistrationReject::GetDataLength() const
{
  PINDEX length = 0;
  length += m_requestSeqNum.GetObjectLength();
  length += m_protocolIdentifier.GetObjectLength();
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  length += m_rejectReason.GetObjectLength();
  if (HasOptionalField(e_gatekeeperIdentifier))
    length += m_gatekeeperIdentifier.GetObjectLength();
  return length;
}


BOOL H225_RegistrationReject::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_requestSeqNum.Decode(strm))
    return FALSE;
  if (!m_protocolIdentifier.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (!m_rejectReason.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_gatekeeperIdentifier) && !m_gatekeeperIdentifier.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_altGKInfo, m_altGKInfo))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_tokens, m_tokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_cryptoTokens, m_cryptoTokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_integrityCheckValue, m_integrityCheckValue))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_featureSet, m_featureSet))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_genericData, m_genericData))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_RegistrationReject::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  m_protocolIdentifier.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  m_rejectReason.Encode(strm);
  if (HasOptionalField(e_gatekeeperIdentifier))
    m_gatekeeperIdentifier.Encode(strm);
  KnownExtensionEncode(strm, e_altGKInfo, m_altGKInfo);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);
  KnownExtensionEncode(strm, e_featureSet, m_featureSet);
  KnownExtensionEncode(strm, e_genericData, m_genericData);

  UnknownExtensionsEncode(strm);
}


PObject * H225_RegistrationReject::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_RegistrationReject::Class()), PInvalidCast);
#endif
  return new H225_RegistrationReject(*this);
}


//
// UnregistrationRequest
//

H225_UnregistrationRequest::H225_UnregistrationRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 10)
{
}


#ifndef PASN_NOPRINTON
void H225_UnregistrationRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  strm << setw(indent+20) << "callSignalAddress = " << setprecision(indent) << m_callSignalAddress << '\n';
  if (HasOptionalField(e_endpointAlias))
    strm << setw(indent+16) << "endpointAlias = " << setprecision(indent) << m_endpointAlias << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_endpointIdentifier))
    strm << setw(indent+21) << "endpointIdentifier = " << setprecision(indent) << m_endpointIdentifier << '\n';
  if (HasOptionalField(e_alternateEndpoints))
    strm << setw(indent+21) << "alternateEndpoints = " << setprecision(indent) << m_alternateEndpoints << '\n';
  if (HasOptionalField(e_gatekeeperIdentifier))
    strm << setw(indent+23) << "gatekeeperIdentifier = " << setprecision(indent) << m_gatekeeperIdentifier << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  if (HasOptionalField(e_reason))
    strm << setw(indent+9) << "reason = " << setprecision(indent) << m_reason << '\n';
  if (HasOptionalField(e_endpointAliasPattern))
    strm << setw(indent+23) << "endpointAliasPattern = " << setprecision(indent) << m_endpointAliasPattern << '\n';
  if (HasOptionalField(e_supportedPrefixes))
    strm << setw(indent+20) << "supportedPrefixes = " << setprecision(indent) << m_supportedPrefixes << '\n';
  if (HasOptionalField(e_alternateGatekeeper))
    strm << setw(indent+22) << "alternateGatekeeper = " << setprecision(indent) << m_alternateGatekeeper << '\n';
  if (HasOptionalField(e_genericData))
    strm << setw(indent+14) << "genericData = " << setprecision(indent) << m_genericData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_UnregistrationRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_UnregistrationRequest), PInvalidCast);
#endif
  const H225_UnregistrationRequest & other = (const H225_UnregistrationRequest &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_callSignalAddress.Compare(other.m_callSignalAddress)) != EqualTo)
    return result;
  if ((result = m_endpointAlias.Compare(other.m_endpointAlias)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_endpointIdentifier.Compare(other.m_endpointIdentifier)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_UnregistrationRequest::GetDataLength() const
{
  PINDEX length = 0;
  length += m_requestSeqNum.GetObjectLength();
  length += m_callSignalAddress.GetObjectLength();
  if (HasOptionalField(e_endpointAlias))
    length += m_endpointAlias.GetObjectLength();
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  if (HasOptionalField(e_endpointIdentifier))
    length += m_endpointIdentifier.GetObjectLength();
  return length;
}


BOOL H225_UnregistrationRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_requestSeqNum.Decode(strm))
    return FALSE;
  if (!m_callSignalAddress.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_endpointAlias) && !m_endpointAlias.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_endpointIdentifier) && !m_endpointIdentifier.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_alternateEndpoints, m_alternateEndpoints))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_gatekeeperIdentifier, m_gatekeeperIdentifier))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_tokens, m_tokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_cryptoTokens, m_cryptoTokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_integrityCheckValue, m_integrityCheckValue))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_reason, m_reason))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_endpointAliasPattern, m_endpointAliasPattern))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_supportedPrefixes, m_supportedPrefixes))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_alternateGatekeeper, m_alternateGatekeeper))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_genericData, m_genericData))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_UnregistrationRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  m_callSignalAddress.Encode(strm);
  if (HasOptionalField(e_endpointAlias))
    m_endpointAlias.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  if (HasOptionalField(e_endpointIdentifier))
    m_endpointIdentifier.Encode(strm);
  KnownExtensionEncode(strm, e_alternateEndpoints, m_alternateEndpoints);
  KnownExtensionEncode(strm, e_gatekeeperIdentifier, m_gatekeeperIdentifier);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);
  KnownExtensionEncode(strm, e_reason, m_reason);
  KnownExtensionEncode(strm, e_endpointAliasPattern, m_endpointAliasPattern);
  KnownExtensionEncode(strm, e_supportedPrefixes, m_supportedPrefixes);
  KnownExtensionEncode(strm, e_alternateGatekeeper, m_alternateGatekeeper);
  KnownExtensionEncode(strm, e_genericData, m_genericData);

  UnknownExtensionsEncode(strm);
}


PObject * H225_UnregistrationRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_UnregistrationRequest::Class()), PInvalidCast);
#endif
  return new H225_UnregistrationRequest(*this);
}


//
// UnregistrationConfirm
//

H225_UnregistrationConfirm::H225_UnregistrationConfirm(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 4)
{
}


#ifndef PASN_NOPRINTON
void H225_UnregistrationConfirm::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  if (HasOptionalField(e_genericData))
    strm << setw(indent+14) << "genericData = " << setprecision(indent) << m_genericData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_UnregistrationConfirm::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_UnregistrationConfirm), PInvalidCast);
#endif
  const H225_UnregistrationConfirm & other = (const H225_UnregistrationConfirm &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_UnregistrationConfirm::GetDataLength() const
{
  PINDEX length = 0;
  length += m_requestSeqNum.GetObjectLength();
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  return length;
}


BOOL H225_UnregistrationConfirm::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_requestSeqNum.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_tokens, m_tokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_cryptoTokens, m_cryptoTokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_integrityCheckValue, m_integrityCheckValue))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_genericData, m_genericData))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_UnregistrationConfirm::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);
  KnownExtensionEncode(strm, e_genericData, m_genericData);

  UnknownExtensionsEncode(strm);
}


PObject * H225_UnregistrationConfirm::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_UnregistrationConfirm::Class()), PInvalidCast);
#endif
  return new H225_UnregistrationConfirm(*this);
}


//
// UnregistrationReject
//

H225_UnregistrationReject::H225_UnregistrationReject(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 5)
{
}


#ifndef PASN_NOPRINTON
void H225_UnregistrationReject::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  strm << setw(indent+15) << "rejectReason = " << setprecision(indent) << m_rejectReason << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_altGKInfo))
    strm << setw(indent+12) << "altGKInfo = " << setprecision(indent) << m_altGKInfo << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  if (HasOptionalField(e_genericData))
    strm << setw(indent+14) << "genericData = " << setprecision(indent) << m_genericData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_UnregistrationReject::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_UnregistrationReject), PInvalidCast);
#endif
  const H225_UnregistrationReject & other = (const H225_UnregistrationReject &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_rejectReason.Compare(other.m_rejectReason)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_UnregistrationReject::GetDataLength() const
{
  PINDEX length = 0;
  length += m_requestSeqNum.GetObjectLength();
  length += m_rejectReason.GetObjectLength();
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  return length;
}


BOOL H225_UnregistrationReject::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_requestSeqNum.Decode(strm))
    return FALSE;
  if (!m_rejectReason.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_altGKInfo, m_altGKInfo))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_tokens, m_tokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_cryptoTokens, m_cryptoTokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_integrityCheckValue, m_integrityCheckValue))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_genericData, m_genericData))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_UnregistrationReject::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  m_rejectReason.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  KnownExtensionEncode(strm, e_altGKInfo, m_altGKInfo);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);
  KnownExtensionEncode(strm, e_genericData, m_genericData);

  UnknownExtensionsEncode(strm);
}


PObject * H225_UnregistrationReject::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_UnregistrationReject::Class()), PInvalidCast);
#endif
  return new H225_UnregistrationReject(*this);
}


//
// AdmissionReject
//

H225_AdmissionReject::H225_AdmissionReject(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 8)
{
}


#ifndef PASN_NOPRINTON
void H225_AdmissionReject::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  strm << setw(indent+15) << "rejectReason = " << setprecision(indent) << m_rejectReason << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_altGKInfo))
    strm << setw(indent+12) << "altGKInfo = " << setprecision(indent) << m_altGKInfo << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_callSignalAddress))
    strm << setw(indent+20) << "callSignalAddress = " << setprecision(indent) << m_callSignalAddress << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  if (HasOptionalField(e_serviceControl))
    strm << setw(indent+17) << "serviceControl = " << setprecision(indent) << m_serviceControl << '\n';
  if (HasOptionalField(e_featureSet))
    strm << setw(indent+13) << "featureSet = " << setprecision(indent) << m_featureSet << '\n';
  if (HasOptionalField(e_genericData))
    strm << setw(indent+14) << "genericData = " << setprecision(indent) << m_genericData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_AdmissionReject::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_AdmissionReject), PInvalidCast);
#endif
  const H225_AdmissionReject & other = (const H225_AdmissionReject &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_rejectReason.Compare(other.m_rejectReason)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_AdmissionReject::GetDataLength() const
{
  PINDEX length = 0;
  length += m_requestSeqNum.GetObjectLength();
  length += m_rejectReason.GetObjectLength();
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  return length;
}


BOOL H225_AdmissionReject::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_requestSeqNum.Decode(strm))
    return FALSE;
  if (!m_rejectReason.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_altGKInfo, m_altGKInfo))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_tokens, m_tokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_cryptoTokens, m_cryptoTokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_callSignalAddress, m_callSignalAddress))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_integrityCheckValue, m_integrityCheckValue))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_serviceControl, m_serviceControl))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_featureSet, m_featureSet))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_genericData, m_genericData))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_AdmissionReject::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  m_rejectReason.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  KnownExtensionEncode(strm, e_altGKInfo, m_altGKInfo);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_callSignalAddress, m_callSignalAddress);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);
  KnownExtensionEncode(strm, e_serviceControl, m_serviceControl);
  KnownExtensionEncode(strm, e_featureSet, m_featureSet);
  KnownExtensionEncode(strm, e_genericData, m_genericData);

  UnknownExtensionsEncode(strm);
}


PObject * H225_AdmissionReject::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_AdmissionReject::Class()), PInvalidCast);
#endif
  return new H225_AdmissionReject(*this);
}


//
// BandwidthReject
//

H225_BandwidthReject::H225_BandwidthReject(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 5)
{
}


#ifndef PASN_NOPRINTON
void H225_BandwidthReject::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  strm << setw(indent+15) << "rejectReason = " << setprecision(indent) << m_rejectReason << '\n';
  strm << setw(indent+19) << "allowedBandWidth = " << setprecision(indent) << m_allowedBandWidth << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_altGKInfo))
    strm << setw(indent+12) << "altGKInfo = " << setprecision(indent) << m_altGKInfo << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  if (HasOptionalField(e_genericData))
    strm << setw(indent+14) << "genericData = " << setprecision(indent) << m_genericData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_BandwidthReject::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_BandwidthReject), PInvalidCast);
#endif
  const H225_BandwidthReject & other = (const H225_BandwidthReject &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_rejectReason.Compare(other.m_rejectReason)) != EqualTo)
    return result;
  if ((result = m_allowedBandWidth.Compare(other.m_allowedBandWidth)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_BandwidthReject::GetDataLength() const
{
  PINDEX length = 0;
  length += m_requestSeqNum.GetObjectLength();
  length += m_rejectReason.GetObjectLength();
  length += m_allowedBandWidth.GetObjectLength();
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  return length;
}


BOOL H225_BandwidthReject::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_requestSeqNum.Decode(strm))
    return FALSE;
  if (!m_rejectReason.Decode(strm))
    return FALSE;
  if (!m_allowedBandWidth.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_altGKInfo, m_altGKInfo))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_tokens, m_tokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_cryptoTokens, m_cryptoTokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_integrityCheckValue, m_integrityCheckValue))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_genericData, m_genericData))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_BandwidthReject::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  m_rejectReason.Encode(strm);
  m_allowedBandWidth.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  KnownExtensionEncode(strm, e_altGKInfo, m_altGKInfo);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);
  KnownExtensionEncode(strm, e_genericData, m_genericData);

  UnknownExtensionsEncode(strm);
}


PObject * H225_BandwidthReject::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_BandwidthReject::Class()), PInvalidCast);
#endif
  return new H225_BandwidthReject(*this);
}


//
// LocationReject
//

H225_LocationReject::H225_LocationReject(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 7)
{
}


#ifndef PASN_NOPRINTON
void H225_LocationReject::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  strm << setw(indent+15) << "rejectReason = " << setprecision(indent) << m_rejectReason << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_altGKInfo))
    strm << setw(indent+12) << "altGKInfo = " << setprecision(indent) << m_altGKInfo << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  if (HasOptionalField(e_featureSet))
    strm << setw(indent+13) << "featureSet = " << setprecision(indent) << m_featureSet << '\n';
  if (HasOptionalField(e_genericData))
    strm << setw(indent+14) << "genericData = " << setprecision(indent) << m_genericData << '\n';
  if (HasOptionalField(e_serviceControl))
    strm << setw(indent+17) << "serviceControl = " << setprecision(indent) << m_serviceControl << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_LocationReject::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_LocationReject), PInvalidCast);
#endif
  const H225_LocationReject & other = (const H225_LocationReject &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_rejectReason.Compare(other.m_rejectReason)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_LocationReject::GetDataLength() const
{
  PINDEX length = 0;
  length += m_requestSeqNum.GetObjectLength();
  length += m_rejectReason.GetObjectLength();
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  return length;
}


BOOL H225_LocationReject::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_requestSeqNum.Decode(strm))
    return FALSE;
  if (!m_rejectReason.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_altGKInfo, m_altGKInfo))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_tokens, m_tokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_cryptoTokens, m_cryptoTokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_integrityCheckValue, m_integrityCheckValue))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_featureSet, m_featureSet))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_genericData, m_genericData))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_serviceControl, m_serviceControl))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_LocationReject::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  m_rejectReason.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  KnownExtensionEncode(strm, e_altGKInfo, m_altGKInfo);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);
  KnownExtensionEncode(strm, e_featureSet, m_featureSet);
  KnownExtensionEncode(strm, e_genericData, m_genericData);
  KnownExtensionEncode(strm, e_serviceControl, m_serviceControl);

  UnknownExtensionsEncode(strm);
}


PObject * H225_LocationReject::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_LocationReject::Class()), PInvalidCast);
#endif
  return new H225_LocationReject(*this);
}


//
// DisengageReject
//

H225_DisengageReject::H225_DisengageReject(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 5)
{
}


#ifndef PASN_NOPRINTON
void H225_DisengageReject::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  strm << setw(indent+15) << "rejectReason = " << setprecision(indent) << m_rejectReason << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_altGKInfo))
    strm << setw(indent+12) << "altGKInfo = " << setprecision(indent) << m_altGKInfo << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  if (HasOptionalField(e_genericData))
    strm << setw(indent+14) << "genericData = " << setprecision(indent) << m_genericData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_DisengageReject::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_DisengageReject), PInvalidCast);
#endif
  const H225_DisengageReject & other = (const H225_DisengageReject &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_rejectReason.Compare(other.m_rejectReason)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_DisengageReject::GetDataLength() const
{
  PINDEX length = 0;
  length += m_requestSeqNum.GetObjectLength();
  length += m_rejectReason.GetObjectLength();
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  return length;
}


BOOL H225_DisengageReject::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_requestSeqNum.Decode(strm))
    return FALSE;
  if (!m_rejectReason.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_altGKInfo, m_altGKInfo))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_tokens, m_tokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_cryptoTokens, m_cryptoTokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_integrityCheckValue, m_integrityCheckValue))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_genericData, m_genericData))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_DisengageReject::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  m_rejectReason.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  KnownExtensionEncode(strm, e_altGKInfo, m_altGKInfo);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);
  KnownExtensionEncode(strm, e_genericData, m_genericData);

  UnknownExtensionsEncode(strm);
}


PObject * H225_DisengageReject::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_DisengageReject::Class()), PInvalidCast);
#endif
  return new H225_DisengageReject(*this);
}


//
// InfoRequest
//

H225_InfoRequest::H225_InfoRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 11)
{
  IncludeOptionalField(e_callIdentifier);
  m_nextSegmentRequested.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void H225_InfoRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  strm << setw(indent+21) << "callReferenceValue = " << setprecision(indent) << m_callReferenceValue << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_replyAddress))
    strm << setw(indent+15) << "replyAddress = " << setprecision(indent) << m_replyAddress << '\n';
  if (HasOptionalField(e_callIdentifier))
    strm << setw(indent+17) << "callIdentifier = " << setprecision(indent) << m_callIdentifier << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  if (HasOptionalField(e_uuiesRequested))
    strm << setw(indent+17) << "uuiesRequested = " << setprecision(indent) << m_uuiesRequested << '\n';
  if (HasOptionalField(e_callLinkage))
    strm << setw(indent+14) << "callLinkage = " << setprecision(indent) << m_callLinkage << '\n';
  if (HasOptionalField(e_usageInfoRequested))
    strm << setw(indent+21) << "usageInfoRequested = " << setprecision(indent) << m_usageInfoRequested << '\n';
  if (HasOptionalField(e_segmentedResponseSupported))
    strm << setw(indent+29) << "segmentedResponseSupported = " << setprecision(indent) << m_segmentedResponseSupported << '\n';
  if (HasOptionalField(e_nextSegmentRequested))
    strm << setw(indent+23) << "nextSegmentRequested = " << setprecision(indent) << m_nextSegmentRequested << '\n';
  if (HasOptionalField(e_capacityInfoRequested))
    strm << setw(indent+24) << "capacityInfoRequested = " << setprecision(indent) << m_capacityInfoRequested << '\n';
  if (HasOptionalField(e_genericData))
    strm << setw(indent+14) << "genericData = " << setprecision(indent) << m_genericData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_InfoRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_InfoRequest), PInvalidCast);
#endif
  const H225_InfoRequest & other = (const H225_InfoRequest &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_callReferenceValue.Compare(other.m_callReferenceValue)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_replyAddress.Compare(other.m_replyAddress)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_InfoRequest::GetDataLength() const
{
  PINDEX length = 0;
  length += m_requestSeqNum.GetObjectLength();
  length += m_callReferenceValue.GetObjectLength();
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  if (HasOptionalField(e_replyAddress))
    length += m_replyAddress.GetObjectLength();
  return length;
}


BOOL H225_InfoRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_requestSeqNum.Decode(strm))
    return FALSE;
  if (!m_callReferenceValue.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_replyAddress) && !m_replyAddress.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_callIdentifier, m_callIdentifier))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_tokens, m_tokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_cryptoTokens, m_cryptoTokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_integrityCheckValue, m_integrityCheckValue))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_uuiesRequested, m_uuiesRequested))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_callLinkage, m_callLinkage))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_usageInfoRequested, m_usageInfoRequested))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_segmentedResponseSupported, m_segmentedResponseSupported))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_nextSegmentRequested, m_nextSegmentRequested))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_capacityInfoRequested, m_capacityInfoRequested))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_genericData, m_genericData))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_InfoRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  m_callReferenceValue.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  if (HasOptionalField(e_replyAddress))
    m_replyAddress.Encode(strm);
  KnownExtensionEncode(strm, e_callIdentifier, m_callIdentifier);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);
  KnownExtensionEncode(strm, e_uuiesRequested, m_uuiesRequested);
  KnownExtensionEncode(strm, e_callLinkage, m_callLinkage);
  KnownExtensionEncode(strm, e_usageInfoRequested, m_usageInfoRequested);
  KnownExtensionEncode(strm, e_segmentedResponseSupported, m_segmentedResponseSupported);
  KnownExtensionEncode(strm, e_nextSegmentRequested, m_nextSegmentRequested);
  KnownExtensionEncode(strm, e_capacityInfoRequested, m_capacityInfoRequested);
  KnownExtensionEncode(strm, e_genericData, m_genericData);

  UnknownExtensionsEncode(strm);
}


PObject * H225_InfoRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_InfoRequest::Class()), PInvalidCast);
#endif
  return new H225_InfoRequest(*this);
}


//
// InfoRequestAck
//

H225_InfoRequestAck::H225_InfoRequestAck(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 4, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_InfoRequestAck::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_InfoRequestAck::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_InfoRequestAck), PInvalidCast);
#endif
  const H225_InfoRequestAck & other = (const H225_InfoRequestAck &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_tokens.Compare(other.m_tokens)) != EqualTo)
    return result;
  if ((result = m_cryptoTokens.Compare(other.m_cryptoTokens)) != EqualTo)
    return result;
  if ((result = m_integrityCheckValue.Compare(other.m_integrityCheckValue)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_InfoRequestAck::GetDataLength() const
{
  PINDEX length = 0;
  length += m_requestSeqNum.GetObjectLength();
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  if (HasOptionalField(e_tokens))
    length += m_tokens.GetObjectLength();
  if (HasOptionalField(e_cryptoTokens))
    length += m_cryptoTokens.GetObjectLength();
  if (HasOptionalField(e_integrityCheckValue))
    length += m_integrityCheckValue.GetObjectLength();
  return length;
}


BOOL H225_InfoRequestAck::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_requestSeqNum.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_tokens) && !m_tokens.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_cryptoTokens) && !m_cryptoTokens.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_integrityCheckValue) && !m_integrityCheckValue.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_InfoRequestAck::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  if (HasOptionalField(e_tokens))
    m_tokens.Encode(strm);
  if (HasOptionalField(e_cryptoTokens))
    m_cryptoTokens.Encode(strm);
  if (HasOptionalField(e_integrityCheckValue))
    m_integrityCheckValue.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_InfoRequestAck::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_InfoRequestAck::Class()), PInvalidCast);
#endif
  return new H225_InfoRequestAck(*this);
}


//
// InfoRequestNak
//

H225_InfoRequestNak::H225_InfoRequestNak(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 5, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_InfoRequestNak::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  strm << setw(indent+12) << "nakReason = " << setprecision(indent) << m_nakReason << '\n';
  if (HasOptionalField(e_altGKInfo))
    strm << setw(indent+12) << "altGKInfo = " << setprecision(indent) << m_altGKInfo << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_InfoRequestNak::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_InfoRequestNak), PInvalidCast);
#endif
  const H225_InfoRequestNak & other = (const H225_InfoRequestNak &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_nakReason.Compare(other.m_nakReason)) != EqualTo)
    return result;
  if ((result = m_altGKInfo.Compare(other.m_altGKInfo)) != EqualTo)
    return result;
  if ((result = m_tokens.Compare(other.m_tokens)) != EqualTo)
    return result;
  if ((result = m_cryptoTokens.Compare(other.m_cryptoTokens)) != EqualTo)
    return result;
  if ((result = m_integrityCheckValue.Compare(other.m_integrityCheckValue)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_InfoRequestNak::GetDataLength() const
{
  PINDEX length = 0;
  length += m_requestSeqNum.GetObjectLength();
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  length += m_nakReason.GetObjectLength();
  if (HasOptionalField(e_altGKInfo))
    length += m_altGKInfo.GetObjectLength();
  if (HasOptionalField(e_tokens))
    length += m_tokens.GetObjectLength();
  if (HasOptionalField(e_cryptoTokens))
    length += m_cryptoTokens.GetObjectLength();
  if (HasOptionalField(e_integrityCheckValue))
    length += m_integrityCheckValue.GetObjectLength();
  return length;
}


BOOL H225_InfoRequestNak::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_requestSeqNum.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (!m_nakReason.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_altGKInfo) && !m_altGKInfo.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_tokens) && !m_tokens.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_cryptoTokens) && !m_cryptoTokens.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_integrityCheckValue) && !m_integrityCheckValue.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_InfoRequestNak::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  m_nakReason.Encode(strm);
  if (HasOptionalField(e_altGKInfo))
    m_altGKInfo.Encode(strm);
  if (HasOptionalField(e_tokens))
    m_tokens.Encode(strm);
  if (HasOptionalField(e_cryptoTokens))
    m_cryptoTokens.Encode(strm);
  if (HasOptionalField(e_integrityCheckValue))
    m_integrityCheckValue.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_InfoRequestNak::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_InfoRequestNak::Class()), PInvalidCast);
#endif
  return new H225_InfoRequestNak(*this);
}


//
// NonStandardMessage
//

H225_NonStandardMessage::H225_NonStandardMessage(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 5)
{
}


#ifndef PASN_NOPRINTON
void H225_NonStandardMessage::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  if (HasOptionalField(e_featureSet))
    strm << setw(indent+13) << "featureSet = " << setprecision(indent) << m_featureSet << '\n';
  if (HasOptionalField(e_genericData))
    strm << setw(indent+14) << "genericData = " << setprecision(indent) << m_genericData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_NonStandardMessage::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_NonStandardMessage), PInvalidCast);
#endif
  const H225_NonStandardMessage & other = (const H225_NonStandardMessage &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_NonStandardMessage::GetDataLength() const
{
  PINDEX length = 0;
  length += m_requestSeqNum.GetObjectLength();
  length += m_nonStandardData.GetObjectLength();
  return length;
}


BOOL H225_NonStandardMessage::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_requestSeqNum.Decode(strm))
    return FALSE;
  if (!m_nonStandardData.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_tokens, m_tokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_cryptoTokens, m_cryptoTokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_integrityCheckValue, m_integrityCheckValue))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_featureSet, m_featureSet))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_genericData, m_genericData))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_NonStandardMessage::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  m_nonStandardData.Encode(strm);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);
  KnownExtensionEncode(strm, e_featureSet, m_featureSet);
  KnownExtensionEncode(strm, e_genericData, m_genericData);

  UnknownExtensionsEncode(strm);
}


PObject * H225_NonStandardMessage::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_NonStandardMessage::Class()), PInvalidCast);
#endif
  return new H225_NonStandardMessage(*this);
}


//
// UnknownMessageResponse
//

H225_UnknownMessageResponse::H225_UnknownMessageResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 4)
{
  IncludeOptionalField(e_messageNotUnderstood);
}


#ifndef PASN_NOPRINTON
void H225_UnknownMessageResponse::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  if (HasOptionalField(e_messageNotUnderstood))
    strm << setw(indent+23) << "messageNotUnderstood = " << setprecision(indent) << m_messageNotUnderstood << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_UnknownMessageResponse::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_UnknownMessageResponse), PInvalidCast);
#endif
  const H225_UnknownMessageResponse & other = (const H225_UnknownMessageResponse &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_UnknownMessageResponse::GetDataLength() const
{
  PINDEX length = 0;
  length += m_requestSeqNum.GetObjectLength();
  return length;
}


BOOL H225_UnknownMessageResponse::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_requestSeqNum.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_tokens, m_tokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_cryptoTokens, m_cryptoTokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_integrityCheckValue, m_integrityCheckValue))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_messageNotUnderstood, m_messageNotUnderstood))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_UnknownMessageResponse::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);
  KnownExtensionEncode(strm, e_messageNotUnderstood, m_messageNotUnderstood);

  UnknownExtensionsEncode(strm);
}


PObject * H225_UnknownMessageResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_UnknownMessageResponse::Class()), PInvalidCast);
#endif
  return new H225_UnknownMessageResponse(*this);
}


//
// RequestInProgress
//

H225_RequestInProgress::H225_RequestInProgress(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 4, TRUE, 0)
{
  m_delay.SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
}


#ifndef PASN_NOPRINTON
void H225_RequestInProgress::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  strm << setw(indent+8) << "delay = " << setprecision(indent) << m_delay << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_RequestInProgress::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_RequestInProgress), PInvalidCast);
#endif
  const H225_RequestInProgress & other = (const H225_RequestInProgress &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_tokens.Compare(other.m_tokens)) != EqualTo)
    return result;
  if ((result = m_cryptoTokens.Compare(other.m_cryptoTokens)) != EqualTo)
    return result;
  if ((result = m_integrityCheckValue.Compare(other.m_integrityCheckValue)) != EqualTo)
    return result;
  if ((result = m_delay.Compare(other.m_delay)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_RequestInProgress::GetDataLength() const
{
  PINDEX length = 0;
  length += m_requestSeqNum.GetObjectLength();
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  if (HasOptionalField(e_tokens))
    length += m_tokens.GetObjectLength();
  if (HasOptionalField(e_cryptoTokens))
    length += m_cryptoTokens.GetObjectLength();
  if (HasOptionalField(e_integrityCheckValue))
    length += m_integrityCheckValue.GetObjectLength();
  length += m_delay.GetObjectLength();
  return length;
}


BOOL H225_RequestInProgress::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_requestSeqNum.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_tokens) && !m_tokens.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_cryptoTokens) && !m_cryptoTokens.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_integrityCheckValue) && !m_integrityCheckValue.Decode(strm))
    return FALSE;
  if (!m_delay.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_RequestInProgress::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  if (HasOptionalField(e_tokens))
    m_tokens.Encode(strm);
  if (HasOptionalField(e_cryptoTokens))
    m_cryptoTokens.Encode(strm);
  if (HasOptionalField(e_integrityCheckValue))
    m_integrityCheckValue.Encode(strm);
  m_delay.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_RequestInProgress::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_RequestInProgress::Class()), PInvalidCast);
#endif
  return new H225_RequestInProgress(*this);
}


//
// ResourcesAvailableConfirm
//

H225_ResourcesAvailableConfirm::H225_ResourcesAvailableConfirm(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 4, TRUE, 1)
{
}


#ifndef PASN_NOPRINTON
void H225_ResourcesAvailableConfirm::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  strm << setw(indent+21) << "protocolIdentifier = " << setprecision(indent) << m_protocolIdentifier << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  if (HasOptionalField(e_genericData))
    strm << setw(indent+14) << "genericData = " << setprecision(indent) << m_genericData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_ResourcesAvailableConfirm::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_ResourcesAvailableConfirm), PInvalidCast);
#endif
  const H225_ResourcesAvailableConfirm & other = (const H225_ResourcesAvailableConfirm &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_protocolIdentifier.Compare(other.m_protocolIdentifier)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_tokens.Compare(other.m_tokens)) != EqualTo)
    return result;
  if ((result = m_cryptoTokens.Compare(other.m_cryptoTokens)) != EqualTo)
    return result;
  if ((result = m_integrityCheckValue.Compare(other.m_integrityCheckValue)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_ResourcesAvailableConfirm::GetDataLength() const
{
  PINDEX length = 0;
  length += m_requestSeqNum.GetObjectLength();
  length += m_protocolIdentifier.GetObjectLength();
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  if (HasOptionalField(e_tokens))
    length += m_tokens.GetObjectLength();
  if (HasOptionalField(e_cryptoTokens))
    length += m_cryptoTokens.GetObjectLength();
  if (HasOptionalField(e_integrityCheckValue))
    length += m_integrityCheckValue.GetObjectLength();
  return length;
}


BOOL H225_ResourcesAvailableConfirm::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_requestSeqNum.Decode(strm))
    return FALSE;
  if (!m_protocolIdentifier.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_tokens) && !m_tokens.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_cryptoTokens) && !m_cryptoTokens.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_integrityCheckValue) && !m_integrityCheckValue.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_genericData, m_genericData))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_ResourcesAvailableConfirm::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  m_protocolIdentifier.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  if (HasOptionalField(e_tokens))
    m_tokens.Encode(strm);
  if (HasOptionalField(e_cryptoTokens))
    m_cryptoTokens.Encode(strm);
  if (HasOptionalField(e_integrityCheckValue))
    m_integrityCheckValue.Encode(strm);
  KnownExtensionEncode(strm, e_genericData, m_genericData);

  UnknownExtensionsEncode(strm);
}


PObject * H225_ResourcesAvailableConfirm::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ResourcesAvailableConfirm::Class()), PInvalidCast);
#endif
  return new H225_ResourcesAvailableConfirm(*this);
}


//
// ServiceControlIndication
//

H225_ServiceControlIndication::H225_ServiceControlIndication(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 8, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_ServiceControlIndication::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  strm << setw(indent+17) << "serviceControl = " << setprecision(indent) << m_serviceControl << '\n';
  if (HasOptionalField(e_endpointIdentifier))
    strm << setw(indent+21) << "endpointIdentifier = " << setprecision(indent) << m_endpointIdentifier << '\n';
  if (HasOptionalField(e_callSpecific))
    strm << setw(indent+15) << "callSpecific = " << setprecision(indent) << m_callSpecific << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  if (HasOptionalField(e_featureSet))
    strm << setw(indent+13) << "featureSet = " << setprecision(indent) << m_featureSet << '\n';
  if (HasOptionalField(e_genericData))
    strm << setw(indent+14) << "genericData = " << setprecision(indent) << m_genericData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_ServiceControlIndication::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_ServiceControlIndication), PInvalidCast);
#endif
  const H225_ServiceControlIndication & other = (const H225_ServiceControlIndication &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_serviceControl.Compare(other.m_serviceControl)) != EqualTo)
    return result;
  if ((result = m_endpointIdentifier.Compare(other.m_endpointIdentifier)) != EqualTo)
    return result;
  if ((result = m_callSpecific.Compare(other.m_callSpecific)) != EqualTo)
    return result;
  if ((result = m_tokens.Compare(other.m_tokens)) != EqualTo)
    return result;
  if ((result = m_cryptoTokens.Compare(other.m_cryptoTokens)) != EqualTo)
    return result;
  if ((result = m_integrityCheckValue.Compare(other.m_integrityCheckValue)) != EqualTo)
    return result;
  if ((result = m_featureSet.Compare(other.m_featureSet)) != EqualTo)
    return result;
  if ((result = m_genericData.Compare(other.m_genericData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_ServiceControlIndication::GetDataLength() const
{
  PINDEX length = 0;
  length += m_requestSeqNum.GetObjectLength();
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  length += m_serviceControl.GetObjectLength();
  if (HasOptionalField(e_endpointIdentifier))
    length += m_endpointIdentifier.GetObjectLength();
  if (HasOptionalField(e_callSpecific))
    length += m_callSpecific.GetObjectLength();
  if (HasOptionalField(e_tokens))
    length += m_tokens.GetObjectLength();
  if (HasOptionalField(e_cryptoTokens))
    length += m_cryptoTokens.GetObjectLength();
  if (HasOptionalField(e_integrityCheckValue))
    length += m_integrityCheckValue.GetObjectLength();
  if (HasOptionalField(e_featureSet))
    length += m_featureSet.GetObjectLength();
  if (HasOptionalField(e_genericData))
    length += m_genericData.GetObjectLength();
  return length;
}


BOOL H225_ServiceControlIndication::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_requestSeqNum.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (!m_serviceControl.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_endpointIdentifier) && !m_endpointIdentifier.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_callSpecific) && !m_callSpecific.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_tokens) && !m_tokens.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_cryptoTokens) && !m_cryptoTokens.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_integrityCheckValue) && !m_integrityCheckValue.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_featureSet) && !m_featureSet.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_genericData) && !m_genericData.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_ServiceControlIndication::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  m_serviceControl.Encode(strm);
  if (HasOptionalField(e_endpointIdentifier))
    m_endpointIdentifier.Encode(strm);
  if (HasOptionalField(e_callSpecific))
    m_callSpecific.Encode(strm);
  if (HasOptionalField(e_tokens))
    m_tokens.Encode(strm);
  if (HasOptionalField(e_cryptoTokens))
    m_cryptoTokens.Encode(strm);
  if (HasOptionalField(e_integrityCheckValue))
    m_integrityCheckValue.Encode(strm);
  if (HasOptionalField(e_featureSet))
    m_featureSet.Encode(strm);
  if (HasOptionalField(e_genericData))
    m_genericData.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_ServiceControlIndication::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ServiceControlIndication::Class()), PInvalidCast);
#endif
  return new H225_ServiceControlIndication(*this);
}


//
// ServiceControlResponse
//

H225_ServiceControlResponse::H225_ServiceControlResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 7, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_ServiceControlResponse::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  if (HasOptionalField(e_result))
    strm << setw(indent+9) << "result = " << setprecision(indent) << m_result << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  if (HasOptionalField(e_featureSet))
    strm << setw(indent+13) << "featureSet = " << setprecision(indent) << m_featureSet << '\n';
  if (HasOptionalField(e_genericData))
    strm << setw(indent+14) << "genericData = " << setprecision(indent) << m_genericData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_ServiceControlResponse::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_ServiceControlResponse), PInvalidCast);
#endif
  const H225_ServiceControlResponse & other = (const H225_ServiceControlResponse &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_result.Compare(other.m_result)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_tokens.Compare(other.m_tokens)) != EqualTo)
    return result;
  if ((result = m_cryptoTokens.Compare(other.m_cryptoTokens)) != EqualTo)
    return result;
  if ((result = m_integrityCheckValue.Compare(other.m_integrityCheckValue)) != EqualTo)
    return result;
  if ((result = m_featureSet.Compare(other.m_featureSet)) != EqualTo)
    return result;
  if ((result = m_genericData.Compare(other.m_genericData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_ServiceControlResponse::GetDataLength() const
{
  PINDEX length = 0;
  length += m_requestSeqNum.GetObjectLength();
  if (HasOptionalField(e_result))
    length += m_result.GetObjectLength();
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  if (HasOptionalField(e_tokens))
    length += m_tokens.GetObjectLength();
  if (HasOptionalField(e_cryptoTokens))
    length += m_cryptoTokens.GetObjectLength();
  if (HasOptionalField(e_integrityCheckValue))
    length += m_integrityCheckValue.GetObjectLength();
  if (HasOptionalField(e_featureSet))
    length += m_featureSet.GetObjectLength();
  if (HasOptionalField(e_genericData))
    length += m_genericData.GetObjectLength();
  return length;
}


BOOL H225_ServiceControlResponse::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_requestSeqNum.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_result) && !m_result.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_tokens) && !m_tokens.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_cryptoTokens) && !m_cryptoTokens.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_integrityCheckValue) && !m_integrityCheckValue.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_featureSet) && !m_featureSet.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_genericData) && !m_genericData.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_ServiceControlResponse::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  if (HasOptionalField(e_result))
    m_result.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  if (HasOptionalField(e_tokens))
    m_tokens.Encode(strm);
  if (HasOptionalField(e_cryptoTokens))
    m_cryptoTokens.Encode(strm);
  if (HasOptionalField(e_integrityCheckValue))
    m_integrityCheckValue.Encode(strm);
  if (HasOptionalField(e_featureSet))
    m_featureSet.Encode(strm);
  if (HasOptionalField(e_genericData))
    m_genericData.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_ServiceControlResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ServiceControlResponse::Class()), PInvalidCast);
#endif
  return new H225_ServiceControlResponse(*this);
}


//
// H323-UU-PDU_tunnelledSignallingMessage
//

H225_H323_UU_PDU_tunnelledSignallingMessage::H225_H323_UU_PDU_tunnelledSignallingMessage(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_H323_UU_PDU_tunnelledSignallingMessage::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+22) << "tunnelledProtocolID = " << setprecision(indent) << m_tunnelledProtocolID << '\n';
  strm << setw(indent+17) << "messageContent = " << setprecision(indent) << m_messageContent << '\n';
  if (HasOptionalField(e_tunnellingRequired))
    strm << setw(indent+21) << "tunnellingRequired = " << setprecision(indent) << m_tunnellingRequired << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_H323_UU_PDU_tunnelledSignallingMessage::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_H323_UU_PDU_tunnelledSignallingMessage), PInvalidCast);
#endif
  const H225_H323_UU_PDU_tunnelledSignallingMessage & other = (const H225_H323_UU_PDU_tunnelledSignallingMessage &)obj;

  Comparison result;

  if ((result = m_tunnelledProtocolID.Compare(other.m_tunnelledProtocolID)) != EqualTo)
    return result;
  if ((result = m_messageContent.Compare(other.m_messageContent)) != EqualTo)
    return result;
  if ((result = m_tunnellingRequired.Compare(other.m_tunnellingRequired)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_H323_UU_PDU_tunnelledSignallingMessage::GetDataLength() const
{
  PINDEX length = 0;
  length += m_tunnelledProtocolID.GetObjectLength();
  length += m_messageContent.GetObjectLength();
  if (HasOptionalField(e_tunnellingRequired))
    length += m_tunnellingRequired.GetObjectLength();
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  return length;
}


BOOL H225_H323_UU_PDU_tunnelledSignallingMessage::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_tunnelledProtocolID.Decode(strm))
    return FALSE;
  if (!m_messageContent.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_tunnellingRequired) && !m_tunnellingRequired.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_H323_UU_PDU_tunnelledSignallingMessage::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_tunnelledProtocolID.Encode(strm);
  m_messageContent.Encode(strm);
  if (HasOptionalField(e_tunnellingRequired))
    m_tunnellingRequired.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_H323_UU_PDU_tunnelledSignallingMessage::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_H323_UU_PDU_tunnelledSignallingMessage::Class()), PInvalidCast);
#endif
  return new H225_H323_UU_PDU_tunnelledSignallingMessage(*this);
}


//
// TransportAddress_ipSourceRoute
//

H225_TransportAddress_ipSourceRoute::H225_TransportAddress_ipSourceRoute(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_ip.SetConstraints(PASN_Object::FixedConstraint, 4);
  m_port.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
}


#ifndef PASN_NOPRINTON
void H225_TransportAddress_ipSourceRoute::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+5) << "ip = " << setprecision(indent) << m_ip << '\n';
  strm << setw(indent+7) << "port = " << setprecision(indent) << m_port << '\n';
  strm << setw(indent+8) << "route = " << setprecision(indent) << m_route << '\n';
  strm << setw(indent+10) << "routing = " << setprecision(indent) << m_routing << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_TransportAddress_ipSourceRoute::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_TransportAddress_ipSourceRoute), PInvalidCast);
#endif
  const H225_TransportAddress_ipSourceRoute & other = (const H225_TransportAddress_ipSourceRoute &)obj;

  Comparison result;

  if ((result = m_ip.Compare(other.m_ip)) != EqualTo)
    return result;
  if ((result = m_port.Compare(other.m_port)) != EqualTo)
    return result;
  if ((result = m_route.Compare(other.m_route)) != EqualTo)
    return result;
  if ((result = m_routing.Compare(other.m_routing)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_TransportAddress_ipSourceRoute::GetDataLength() const
{
  PINDEX length = 0;
  length += m_ip.GetObjectLength();
  length += m_port.GetObjectLength();
  length += m_route.GetObjectLength();
  length += m_routing.GetObjectLength();
  return length;
}


BOOL H225_TransportAddress_ipSourceRoute::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_ip.Decode(strm))
    return FALSE;
  if (!m_port.Decode(strm))
    return FALSE;
  if (!m_route.Decode(strm))
    return FALSE;
  if (!m_routing.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_TransportAddress_ipSourceRoute::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_ip.Encode(strm);
  m_port.Encode(strm);
  m_route.Encode(strm);
  m_routing.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_TransportAddress_ipSourceRoute::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_TransportAddress_ipSourceRoute::Class()), PInvalidCast);
#endif
  return new H225_TransportAddress_ipSourceRoute(*this);
}


//
// RegistrationConfirm_preGrantedARQ
//

H225_RegistrationConfirm_preGrantedARQ::H225_RegistrationConfirm_preGrantedARQ(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 4)
{
  m_irrFrequencyInCall.SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
}


#ifndef PASN_NOPRINTON
void H225_RegistrationConfirm_preGrantedARQ::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "makeCall = " << setprecision(indent) << m_makeCall << '\n';
  strm << setw(indent+35) << "useGKCallSignalAddressToMakeCall = " << setprecision(indent) << m_useGKCallSignalAddressToMakeCall << '\n';
  strm << setw(indent+13) << "answerCall = " << setprecision(indent) << m_answerCall << '\n';
  strm << setw(indent+33) << "useGKCallSignalAddressToAnswer = " << setprecision(indent) << m_useGKCallSignalAddressToAnswer << '\n';
  if (HasOptionalField(e_irrFrequencyInCall))
    strm << setw(indent+21) << "irrFrequencyInCall = " << setprecision(indent) << m_irrFrequencyInCall << '\n';
  if (HasOptionalField(e_totalBandwidthRestriction))
    strm << setw(indent+28) << "totalBandwidthRestriction = " << setprecision(indent) << m_totalBandwidthRestriction << '\n';
  if (HasOptionalField(e_alternateTransportAddresses))
    strm << setw(indent+30) << "alternateTransportAddresses = " << setprecision(indent) << m_alternateTransportAddresses << '\n';
  if (HasOptionalField(e_useSpecifiedTransport))
    strm << setw(indent+24) << "useSpecifiedTransport = " << setprecision(indent) << m_useSpecifiedTransport << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_RegistrationConfirm_preGrantedARQ::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_RegistrationConfirm_preGrantedARQ), PInvalidCast);
#endif
  const H225_RegistrationConfirm_preGrantedARQ & other = (const H225_RegistrationConfirm_preGrantedARQ &)obj;

  Comparison result;

  if ((result = m_makeCall.Compare(other.m_makeCall)) != EqualTo)
    return result;
  if ((result = m_useGKCallSignalAddressToMakeCall.Compare(other.m_useGKCallSignalAddressToMakeCall)) != EqualTo)
    return result;
  if ((result = m_answerCall.Compare(other.m_answerCall)) != EqualTo)
    return result;
  if ((result = m_useGKCallSignalAddressToAnswer.Compare(other.m_useGKCallSignalAddressToAnswer)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_RegistrationConfirm_preGrantedARQ::GetDataLength() const
{
  PINDEX length = 0;
  length += m_makeCall.GetObjectLength();
  length += m_useGKCallSignalAddressToMakeCall.GetObjectLength();
  length += m_answerCall.GetObjectLength();
  length += m_useGKCallSignalAddressToAnswer.GetObjectLength();
  return length;
}


BOOL H225_RegistrationConfirm_preGrantedARQ::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_makeCall.Decode(strm))
    return FALSE;
  if (!m_useGKCallSignalAddressToMakeCall.Decode(strm))
    return FALSE;
  if (!m_answerCall.Decode(strm))
    return FALSE;
  if (!m_useGKCallSignalAddressToAnswer.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_irrFrequencyInCall, m_irrFrequencyInCall))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_totalBandwidthRestriction, m_totalBandwidthRestriction))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_alternateTransportAddresses, m_alternateTransportAddresses))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_useSpecifiedTransport, m_useSpecifiedTransport))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_RegistrationConfirm_preGrantedARQ::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_makeCall.Encode(strm);
  m_useGKCallSignalAddressToMakeCall.Encode(strm);
  m_answerCall.Encode(strm);
  m_useGKCallSignalAddressToAnswer.Encode(strm);
  KnownExtensionEncode(strm, e_irrFrequencyInCall, m_irrFrequencyInCall);
  KnownExtensionEncode(strm, e_totalBandwidthRestriction, m_totalBandwidthRestriction);
  KnownExtensionEncode(strm, e_alternateTransportAddresses, m_alternateTransportAddresses);
  KnownExtensionEncode(strm, e_useSpecifiedTransport, m_useSpecifiedTransport);

  UnknownExtensionsEncode(strm);
}


PObject * H225_RegistrationConfirm_preGrantedARQ::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_RegistrationConfirm_preGrantedARQ::Class()), PInvalidCast);
#endif
  return new H225_RegistrationConfirm_preGrantedARQ(*this);
}


//
// StimulusControl
//

H225_StimulusControl::H225_StimulusControl(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_StimulusControl::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandard))
    strm << setw(indent+14) << "nonStandard = " << setprecision(indent) << m_nonStandard << '\n';
  if (HasOptionalField(e_isText))
    strm << setw(indent+9) << "isText = " << setprecision(indent) << m_isText << '\n';
  if (HasOptionalField(e_h248Message))
    strm << setw(indent+14) << "h248Message = " << setprecision(indent) << m_h248Message << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_StimulusControl::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_StimulusControl), PInvalidCast);
#endif
  const H225_StimulusControl & other = (const H225_StimulusControl &)obj;

  Comparison result;

  if ((result = m_nonStandard.Compare(other.m_nonStandard)) != EqualTo)
    return result;
  if ((result = m_isText.Compare(other.m_isText)) != EqualTo)
    return result;
  if ((result = m_h248Message.Compare(other.m_h248Message)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_StimulusControl::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_nonStandard))
    length += m_nonStandard.GetObjectLength();
  if (HasOptionalField(e_isText))
    length += m_isText.GetObjectLength();
  if (HasOptionalField(e_h248Message))
    length += m_h248Message.GetObjectLength();
  return length;
}


BOOL H225_StimulusControl::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_nonStandard) && !m_nonStandard.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_isText) && !m_isText.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_h248Message) && !m_h248Message.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_StimulusControl::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandard))
    m_nonStandard.Encode(strm);
  if (HasOptionalField(e_isText))
    m_isText.Encode(strm);
  if (HasOptionalField(e_h248Message))
    m_h248Message.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_StimulusControl::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_StimulusControl::Class()), PInvalidCast);
#endif
  return new H225_StimulusControl(*this);
}


//
// ConferenceList
//

H225_ConferenceList::H225_ConferenceList(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_ConferenceList::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_conferenceID))
    strm << setw(indent+15) << "conferenceID = " << setprecision(indent) << m_conferenceID << '\n';
  if (HasOptionalField(e_conferenceAlias))
    strm << setw(indent+18) << "conferenceAlias = " << setprecision(indent) << m_conferenceAlias << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_ConferenceList::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_ConferenceList), PInvalidCast);
#endif
  const H225_ConferenceList & other = (const H225_ConferenceList &)obj;

  Comparison result;

  if ((result = m_conferenceID.Compare(other.m_conferenceID)) != EqualTo)
    return result;
  if ((result = m_conferenceAlias.Compare(other.m_conferenceAlias)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_ConferenceList::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_conferenceID))
    length += m_conferenceID.GetObjectLength();
  if (HasOptionalField(e_conferenceAlias))
    length += m_conferenceAlias.GetObjectLength();
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  return length;
}


BOOL H225_ConferenceList::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_conferenceID) && !m_conferenceID.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_conferenceAlias) && !m_conferenceAlias.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_ConferenceList::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_conferenceID))
    m_conferenceID.Encode(strm);
  if (HasOptionalField(e_conferenceAlias))
    m_conferenceAlias.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_ConferenceList::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ConferenceList::Class()), PInvalidCast);
#endif
  return new H225_ConferenceList(*this);
}


//
// GatewayInfo
//

H225_GatewayInfo::H225_GatewayInfo(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_GatewayInfo::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_protocol))
    strm << setw(indent+11) << "protocol = " << setprecision(indent) << m_protocol << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_GatewayInfo::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_GatewayInfo), PInvalidCast);
#endif
  const H225_GatewayInfo & other = (const H225_GatewayInfo &)obj;

  Comparison result;

  if ((result = m_protocol.Compare(other.m_protocol)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_GatewayInfo::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_protocol))
    length += m_protocol.GetObjectLength();
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  return length;
}


BOOL H225_GatewayInfo::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_protocol) && !m_protocol.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_GatewayInfo::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_protocol))
    m_protocol.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_GatewayInfo::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_GatewayInfo::Class()), PInvalidCast);
#endif
  return new H225_GatewayInfo(*this);
}


//
// H310Caps
//

H225_H310Caps::H225_H310Caps(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 2)
{
  IncludeOptionalField(e_supportedPrefixes);
}


#ifndef PASN_NOPRINTON
void H225_H310Caps::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_dataRatesSupported))
    strm << setw(indent+21) << "dataRatesSupported = " << setprecision(indent) << m_dataRatesSupported << '\n';
  if (HasOptionalField(e_supportedPrefixes))
    strm << setw(indent+20) << "supportedPrefixes = " << setprecision(indent) << m_supportedPrefixes << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_H310Caps::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_H310Caps), PInvalidCast);
#endif
  const H225_H310Caps & other = (const H225_H310Caps &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_H310Caps::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  return length;
}


BOOL H225_H310Caps::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_dataRatesSupported, m_dataRatesSupported))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_supportedPrefixes, m_supportedPrefixes))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_H310Caps::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  KnownExtensionEncode(strm, e_dataRatesSupported, m_dataRatesSupported);
  KnownExtensionEncode(strm, e_supportedPrefixes, m_supportedPrefixes);

  UnknownExtensionsEncode(strm);
}


PObject * H225_H310Caps::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_H310Caps::Class()), PInvalidCast);
#endif
  return new H225_H310Caps(*this);
}


//
// H320Caps
//

H225_H320Caps::H225_H320Caps(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 2)
{
  IncludeOptionalField(e_supportedPrefixes);
}


#ifndef PASN_NOPRINTON
void H225_H320Caps::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_dataRatesSupported))
    strm << setw(indent+21) << "dataRatesSupported = " << setprecision(indent) << m_dataRatesSupported << '\n';
  if (HasOptionalField(e_supportedPrefixes))
    strm << setw(indent+20) << "supportedPrefixes = " << setprecision(indent) << m_supportedPrefixes << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_H320Caps::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_H320Caps), PInvalidCast);
#endif
  const H225_H320Caps & other = (const H225_H320Caps &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_H320Caps::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  return length;
}


BOOL H225_H320Caps::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_dataRatesSupported, m_dataRatesSupported))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_supportedPrefixes, m_supportedPrefixes))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_H320Caps::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  KnownExtensionEncode(strm, e_dataRatesSupported, m_dataRatesSupported);
  KnownExtensionEncode(strm, e_supportedPrefixes, m_supportedPrefixes);

  UnknownExtensionsEncode(strm);
}


PObject * H225_H320Caps::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_H320Caps::Class()), PInvalidCast);
#endif
  return new H225_H320Caps(*this);
}


//
// H321Caps
//

H225_H321Caps::H225_H321Caps(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 2)
{
  IncludeOptionalField(e_supportedPrefixes);
}


#ifndef PASN_NOPRINTON
void H225_H321Caps::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_dataRatesSupported))
    strm << setw(indent+21) << "dataRatesSupported = " << setprecision(indent) << m_dataRatesSupported << '\n';
  if (HasOptionalField(e_supportedPrefixes))
    strm << setw(indent+20) << "supportedPrefixes = " << setprecision(indent) << m_supportedPrefixes << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_H321Caps::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_H321Caps), PInvalidCast);
#endif
  const H225_H321Caps & other = (const H225_H321Caps &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_H321Caps::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  return length;
}


BOOL H225_H321Caps::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_dataRatesSupported, m_dataRatesSupported))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_supportedPrefixes, m_supportedPrefixes))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_H321Caps::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  KnownExtensionEncode(strm, e_dataRatesSupported, m_dataRatesSupported);
  KnownExtensionEncode(strm, e_supportedPrefixes, m_supportedPrefixes);

  UnknownExtensionsEncode(strm);
}


PObject * H225_H321Caps::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_H321Caps::Class()), PInvalidCast);
#endif
  return new H225_H321Caps(*this);
}


//
// H322Caps
//

H225_H322Caps::H225_H322Caps(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 2)
{
  IncludeOptionalField(e_supportedPrefixes);
}


#ifndef PASN_NOPRINTON
void H225_H322Caps::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_dataRatesSupported))
    strm << setw(indent+21) << "dataRatesSupported = " << setprecision(indent) << m_dataRatesSupported << '\n';
  if (HasOptionalField(e_supportedPrefixes))
    strm << setw(indent+20) << "supportedPrefixes = " << setprecision(indent) << m_supportedPrefixes << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_H322Caps::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_H322Caps), PInvalidCast);
#endif
  const H225_H322Caps & other = (const H225_H322Caps &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_H322Caps::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  return length;
}


BOOL H225_H322Caps::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_dataRatesSupported, m_dataRatesSupported))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_supportedPrefixes, m_supportedPrefixes))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_H322Caps::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  KnownExtensionEncode(strm, e_dataRatesSupported, m_dataRatesSupported);
  KnownExtensionEncode(strm, e_supportedPrefixes, m_supportedPrefixes);

  UnknownExtensionsEncode(strm);
}


PObject * H225_H322Caps::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_H322Caps::Class()), PInvalidCast);
#endif
  return new H225_H322Caps(*this);
}


//
// H323Caps
//

H225_H323Caps::H225_H323Caps(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 2)
{
  IncludeOptionalField(e_supportedPrefixes);
}


#ifndef PASN_NOPRINTON
void H225_H323Caps::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_dataRatesSupported))
    strm << setw(indent+21) << "dataRatesSupported = " << setprecision(indent) << m_dataRatesSupported << '\n';
  if (HasOptionalField(e_supportedPrefixes))
    strm << setw(indent+20) << "supportedPrefixes = " << setprecision(indent) << m_supportedPrefixes << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_H323Caps::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_H323Caps), PInvalidCast);
#endif
  const H225_H323Caps & other = (const H225_H323Caps &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_H323Caps::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  return length;
}


BOOL H225_H323Caps::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_dataRatesSupported, m_dataRatesSupported))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_supportedPrefixes, m_supportedPrefixes))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_H323Caps::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  KnownExtensionEncode(strm, e_dataRatesSupported, m_dataRatesSupported);
  KnownExtensionEncode(strm, e_supportedPrefixes, m_supportedPrefixes);

  UnknownExtensionsEncode(strm);
}


PObject * H225_H323Caps::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_H323Caps::Class()), PInvalidCast);
#endif
  return new H225_H323Caps(*this);
}


//
// H324Caps
//

H225_H324Caps::H225_H324Caps(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 2)
{
  IncludeOptionalField(e_supportedPrefixes);
}


#ifndef PASN_NOPRINTON
void H225_H324Caps::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_dataRatesSupported))
    strm << setw(indent+21) << "dataRatesSupported = " << setprecision(indent) << m_dataRatesSupported << '\n';
  if (HasOptionalField(e_supportedPrefixes))
    strm << setw(indent+20) << "supportedPrefixes = " << setprecision(indent) << m_supportedPrefixes << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_H324Caps::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_H324Caps), PInvalidCast);
#endif
  const H225_H324Caps & other = (const H225_H324Caps &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_H324Caps::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  return length;
}


BOOL H225_H324Caps::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_dataRatesSupported, m_dataRatesSupported))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_supportedPrefixes, m_supportedPrefixes))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_H324Caps::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  KnownExtensionEncode(strm, e_dataRatesSupported, m_dataRatesSupported);
  KnownExtensionEncode(strm, e_supportedPrefixes, m_supportedPrefixes);

  UnknownExtensionsEncode(strm);
}


PObject * H225_H324Caps::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_H324Caps::Class()), PInvalidCast);
#endif
  return new H225_H324Caps(*this);
}


//
// VoiceCaps
//

H225_VoiceCaps::H225_VoiceCaps(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 2)
{
  IncludeOptionalField(e_supportedPrefixes);
}


#ifndef PASN_NOPRINTON
void H225_VoiceCaps::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_dataRatesSupported))
    strm << setw(indent+21) << "dataRatesSupported = " << setprecision(indent) << m_dataRatesSupported << '\n';
  if (HasOptionalField(e_supportedPrefixes))
    strm << setw(indent+20) << "supportedPrefixes = " << setprecision(indent) << m_supportedPrefixes << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_VoiceCaps::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_VoiceCaps), PInvalidCast);
#endif
  const H225_VoiceCaps & other = (const H225_VoiceCaps &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_VoiceCaps::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  return length;
}


BOOL H225_VoiceCaps::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_dataRatesSupported, m_dataRatesSupported))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_supportedPrefixes, m_supportedPrefixes))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_VoiceCaps::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  KnownExtensionEncode(strm, e_dataRatesSupported, m_dataRatesSupported);
  KnownExtensionEncode(strm, e_supportedPrefixes, m_supportedPrefixes);

  UnknownExtensionsEncode(strm);
}


PObject * H225_VoiceCaps::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_VoiceCaps::Class()), PInvalidCast);
#endif
  return new H225_VoiceCaps(*this);
}


//
// T120OnlyCaps
//

H225_T120OnlyCaps::H225_T120OnlyCaps(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 2)
{
  IncludeOptionalField(e_supportedPrefixes);
}


#ifndef PASN_NOPRINTON
void H225_T120OnlyCaps::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_dataRatesSupported))
    strm << setw(indent+21) << "dataRatesSupported = " << setprecision(indent) << m_dataRatesSupported << '\n';
  if (HasOptionalField(e_supportedPrefixes))
    strm << setw(indent+20) << "supportedPrefixes = " << setprecision(indent) << m_supportedPrefixes << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_T120OnlyCaps::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_T120OnlyCaps), PInvalidCast);
#endif
  const H225_T120OnlyCaps & other = (const H225_T120OnlyCaps &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_T120OnlyCaps::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  return length;
}


BOOL H225_T120OnlyCaps::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_dataRatesSupported, m_dataRatesSupported))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_supportedPrefixes, m_supportedPrefixes))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_T120OnlyCaps::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  KnownExtensionEncode(strm, e_dataRatesSupported, m_dataRatesSupported);
  KnownExtensionEncode(strm, e_supportedPrefixes, m_supportedPrefixes);

  UnknownExtensionsEncode(strm);
}


PObject * H225_T120OnlyCaps::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_T120OnlyCaps::Class()), PInvalidCast);
#endif
  return new H225_T120OnlyCaps(*this);
}


//
// NonStandardProtocol
//

H225_NonStandardProtocol::H225_NonStandardProtocol(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_NonStandardProtocol::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_dataRatesSupported))
    strm << setw(indent+21) << "dataRatesSupported = " << setprecision(indent) << m_dataRatesSupported << '\n';
  strm << setw(indent+20) << "supportedPrefixes = " << setprecision(indent) << m_supportedPrefixes << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_NonStandardProtocol::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_NonStandardProtocol), PInvalidCast);
#endif
  const H225_NonStandardProtocol & other = (const H225_NonStandardProtocol &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_dataRatesSupported.Compare(other.m_dataRatesSupported)) != EqualTo)
    return result;
  if ((result = m_supportedPrefixes.Compare(other.m_supportedPrefixes)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_NonStandardProtocol::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  if (HasOptionalField(e_dataRatesSupported))
    length += m_dataRatesSupported.GetObjectLength();
  length += m_supportedPrefixes.GetObjectLength();
  return length;
}


BOOL H225_NonStandardProtocol::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_dataRatesSupported) && !m_dataRatesSupported.Decode(strm))
    return FALSE;
  if (!m_supportedPrefixes.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_NonStandardProtocol::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  if (HasOptionalField(e_dataRatesSupported))
    m_dataRatesSupported.Encode(strm);
  m_supportedPrefixes.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_NonStandardProtocol::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_NonStandardProtocol::Class()), PInvalidCast);
#endif
  return new H225_NonStandardProtocol(*this);
}


//
// T38FaxAnnexbOnlyCaps
//

H225_T38FaxAnnexbOnlyCaps::H225_T38FaxAnnexbOnlyCaps(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_T38FaxAnnexbOnlyCaps::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_dataRatesSupported))
    strm << setw(indent+21) << "dataRatesSupported = " << setprecision(indent) << m_dataRatesSupported << '\n';
  strm << setw(indent+20) << "supportedPrefixes = " << setprecision(indent) << m_supportedPrefixes << '\n';
  strm << setw(indent+17) << "t38FaxProtocol = " << setprecision(indent) << m_t38FaxProtocol << '\n';
  strm << setw(indent+16) << "t38FaxProfile = " << setprecision(indent) << m_t38FaxProfile << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_T38FaxAnnexbOnlyCaps::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_T38FaxAnnexbOnlyCaps), PInvalidCast);
#endif
  const H225_T38FaxAnnexbOnlyCaps & other = (const H225_T38FaxAnnexbOnlyCaps &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_dataRatesSupported.Compare(other.m_dataRatesSupported)) != EqualTo)
    return result;
  if ((result = m_supportedPrefixes.Compare(other.m_supportedPrefixes)) != EqualTo)
    return result;
  if ((result = m_t38FaxProtocol.Compare(other.m_t38FaxProtocol)) != EqualTo)
    return result;
  if ((result = m_t38FaxProfile.Compare(other.m_t38FaxProfile)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_T38FaxAnnexbOnlyCaps::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  if (HasOptionalField(e_dataRatesSupported))
    length += m_dataRatesSupported.GetObjectLength();
  length += m_supportedPrefixes.GetObjectLength();
  length += m_t38FaxProtocol.GetObjectLength();
  length += m_t38FaxProfile.GetObjectLength();
  return length;
}


BOOL H225_T38FaxAnnexbOnlyCaps::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_dataRatesSupported) && !m_dataRatesSupported.Decode(strm))
    return FALSE;
  if (!m_supportedPrefixes.Decode(strm))
    return FALSE;
  if (!m_t38FaxProtocol.Decode(strm))
    return FALSE;
  if (!m_t38FaxProfile.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_T38FaxAnnexbOnlyCaps::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  if (HasOptionalField(e_dataRatesSupported))
    m_dataRatesSupported.Encode(strm);
  m_supportedPrefixes.Encode(strm);
  m_t38FaxProtocol.Encode(strm);
  m_t38FaxProfile.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_T38FaxAnnexbOnlyCaps::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_T38FaxAnnexbOnlyCaps::Class()), PInvalidCast);
#endif
  return new H225_T38FaxAnnexbOnlyCaps(*this);
}


//
// SIPCaps
//

H225_SIPCaps::H225_SIPCaps(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_SIPCaps::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_dataRatesSupported))
    strm << setw(indent+21) << "dataRatesSupported = " << setprecision(indent) << m_dataRatesSupported << '\n';
  if (HasOptionalField(e_supportedPrefixes))
    strm << setw(indent+20) << "supportedPrefixes = " << setprecision(indent) << m_supportedPrefixes << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_SIPCaps::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_SIPCaps), PInvalidCast);
#endif
  const H225_SIPCaps & other = (const H225_SIPCaps &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_dataRatesSupported.Compare(other.m_dataRatesSupported)) != EqualTo)
    return result;
  if ((result = m_supportedPrefixes.Compare(other.m_supportedPrefixes)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_SIPCaps::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  if (HasOptionalField(e_dataRatesSupported))
    length += m_dataRatesSupported.GetObjectLength();
  if (HasOptionalField(e_supportedPrefixes))
    length += m_supportedPrefixes.GetObjectLength();
  return length;
}


BOOL H225_SIPCaps::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_dataRatesSupported) && !m_dataRatesSupported.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_supportedPrefixes) && !m_supportedPrefixes.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_SIPCaps::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  if (HasOptionalField(e_dataRatesSupported))
    m_dataRatesSupported.Encode(strm);
  if (HasOptionalField(e_supportedPrefixes))
    m_supportedPrefixes.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_SIPCaps::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_SIPCaps::Class()), PInvalidCast);
#endif
  return new H225_SIPCaps(*this);
}


//
// McuInfo
//

H225_McuInfo::H225_McuInfo(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 1)
{
}


#ifndef PASN_NOPRINTON
void H225_McuInfo::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_protocol))
    strm << setw(indent+11) << "protocol = " << setprecision(indent) << m_protocol << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_McuInfo::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_McuInfo), PInvalidCast);
#endif
  const H225_McuInfo & other = (const H225_McuInfo &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_McuInfo::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  return length;
}


BOOL H225_McuInfo::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_protocol, m_protocol))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_McuInfo::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  KnownExtensionEncode(strm, e_protocol, m_protocol);

  UnknownExtensionsEncode(strm);
}


PObject * H225_McuInfo::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_McuInfo::Class()), PInvalidCast);
#endif
  return new H225_McuInfo(*this);
}


//
// TerminalInfo
//

H225_TerminalInfo::H225_TerminalInfo(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_TerminalInfo::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_TerminalInfo::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_TerminalInfo), PInvalidCast);
#endif
  const H225_TerminalInfo & other = (const H225_TerminalInfo &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_TerminalInfo::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  return length;
}


BOOL H225_TerminalInfo::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_TerminalInfo::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_TerminalInfo::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_TerminalInfo::Class()), PInvalidCast);
#endif
  return new H225_TerminalInfo(*this);
}


//
// GatekeeperInfo
//

H225_GatekeeperInfo::H225_GatekeeperInfo(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_GatekeeperInfo::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_GatekeeperInfo::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_GatekeeperInfo), PInvalidCast);
#endif
  const H225_GatekeeperInfo & other = (const H225_GatekeeperInfo &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_GatekeeperInfo::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  return length;
}


BOOL H225_GatekeeperInfo::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_GatekeeperInfo::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_GatekeeperInfo::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_GatekeeperInfo::Class()), PInvalidCast);
#endif
  return new H225_GatekeeperInfo(*this);
}


//
// FeatureDescriptor
//

H225_FeatureDescriptor::H225_FeatureDescriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : H225_GenericData(tag, tagClass)
{
}


PObject * H225_FeatureDescriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_FeatureDescriptor::Class()), PInvalidCast);
#endif
  return new H225_FeatureDescriptor(*this);
}


//
// CallCapacity
//

H225_CallCapacity::H225_CallCapacity(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_CallCapacity::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_maximumCallCapacity))
    strm << setw(indent+22) << "maximumCallCapacity = " << setprecision(indent) << m_maximumCallCapacity << '\n';
  if (HasOptionalField(e_currentCallCapacity))
    strm << setw(indent+22) << "currentCallCapacity = " << setprecision(indent) << m_currentCallCapacity << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_CallCapacity::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_CallCapacity), PInvalidCast);
#endif
  const H225_CallCapacity & other = (const H225_CallCapacity &)obj;

  Comparison result;

  if ((result = m_maximumCallCapacity.Compare(other.m_maximumCallCapacity)) != EqualTo)
    return result;
  if ((result = m_currentCallCapacity.Compare(other.m_currentCallCapacity)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_CallCapacity::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_maximumCallCapacity))
    length += m_maximumCallCapacity.GetObjectLength();
  if (HasOptionalField(e_currentCallCapacity))
    length += m_currentCallCapacity.GetObjectLength();
  return length;
}


BOOL H225_CallCapacity::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_maximumCallCapacity) && !m_maximumCallCapacity.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_currentCallCapacity) && !m_currentCallCapacity.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_CallCapacity::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_maximumCallCapacity))
    m_maximumCallCapacity.Encode(strm);
  if (HasOptionalField(e_currentCallCapacity))
    m_currentCallCapacity.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_CallCapacity::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_CallCapacity::Class()), PInvalidCast);
#endif
  return new H225_CallCapacity(*this);
}


//
// CircuitIdentifier
//

H225_CircuitIdentifier::H225_CircuitIdentifier(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 1)
{
}


#ifndef PASN_NOPRINTON
void H225_CircuitIdentifier::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_cic))
    strm << setw(indent+6) << "cic = " << setprecision(indent) << m_cic << '\n';
  if (HasOptionalField(e_group))
    strm << setw(indent+8) << "group = " << setprecision(indent) << m_group << '\n';
  if (HasOptionalField(e_carrier))
    strm << setw(indent+10) << "carrier = " << setprecision(indent) << m_carrier << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_CircuitIdentifier::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_CircuitIdentifier), PInvalidCast);
#endif
  const H225_CircuitIdentifier & other = (const H225_CircuitIdentifier &)obj;

  Comparison result;

  if ((result = m_cic.Compare(other.m_cic)) != EqualTo)
    return result;
  if ((result = m_group.Compare(other.m_group)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_CircuitIdentifier::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_cic))
    length += m_cic.GetObjectLength();
  if (HasOptionalField(e_group))
    length += m_group.GetObjectLength();
  return length;
}


BOOL H225_CircuitIdentifier::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_cic) && !m_cic.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_group) && !m_group.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_carrier, m_carrier))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_CircuitIdentifier::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_cic))
    m_cic.Encode(strm);
  if (HasOptionalField(e_group))
    m_group.Encode(strm);
  KnownExtensionEncode(strm, e_carrier, m_carrier);

  UnknownExtensionsEncode(strm);
}


PObject * H225_CircuitIdentifier::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_CircuitIdentifier::Class()), PInvalidCast);
#endif
  return new H225_CircuitIdentifier(*this);
}


//
// RegistrationConfirm
//

H225_RegistrationConfirm::H225_RegistrationConfirm(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 17)
{
  IncludeOptionalField(e_willRespondToIRR);
  IncludeOptionalField(e_maintainConnection);
}


#ifndef PASN_NOPRINTON
void H225_RegistrationConfirm::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  strm << setw(indent+21) << "protocolIdentifier = " << setprecision(indent) << m_protocolIdentifier << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  strm << setw(indent+20) << "callSignalAddress = " << setprecision(indent) << m_callSignalAddress << '\n';
  if (HasOptionalField(e_terminalAlias))
    strm << setw(indent+16) << "terminalAlias = " << setprecision(indent) << m_terminalAlias << '\n';
  if (HasOptionalField(e_gatekeeperIdentifier))
    strm << setw(indent+23) << "gatekeeperIdentifier = " << setprecision(indent) << m_gatekeeperIdentifier << '\n';
  strm << setw(indent+21) << "endpointIdentifier = " << setprecision(indent) << m_endpointIdentifier << '\n';
  if (HasOptionalField(e_alternateGatekeeper))
    strm << setw(indent+22) << "alternateGatekeeper = " << setprecision(indent) << m_alternateGatekeeper << '\n';
  if (HasOptionalField(e_timeToLive))
    strm << setw(indent+13) << "timeToLive = " << setprecision(indent) << m_timeToLive << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  if (HasOptionalField(e_willRespondToIRR))
    strm << setw(indent+19) << "willRespondToIRR = " << setprecision(indent) << m_willRespondToIRR << '\n';
  if (HasOptionalField(e_preGrantedARQ))
    strm << setw(indent+16) << "preGrantedARQ = " << setprecision(indent) << m_preGrantedARQ << '\n';
  if (HasOptionalField(e_maintainConnection))
    strm << setw(indent+21) << "maintainConnection = " << setprecision(indent) << m_maintainConnection << '\n';
  if (HasOptionalField(e_serviceControl))
    strm << setw(indent+17) << "serviceControl = " << setprecision(indent) << m_serviceControl << '\n';
  if (HasOptionalField(e_supportsAdditiveRegistration))
    strm << setw(indent+31) << "supportsAdditiveRegistration = " << setprecision(indent) << m_supportsAdditiveRegistration << '\n';
  if (HasOptionalField(e_terminalAliasPattern))
    strm << setw(indent+23) << "terminalAliasPattern = " << setprecision(indent) << m_terminalAliasPattern << '\n';
  if (HasOptionalField(e_supportedPrefixes))
    strm << setw(indent+20) << "supportedPrefixes = " << setprecision(indent) << m_supportedPrefixes << '\n';
  if (HasOptionalField(e_usageSpec))
    strm << setw(indent+12) << "usageSpec = " << setprecision(indent) << m_usageSpec << '\n';
  if (HasOptionalField(e_featureServerAlias))
    strm << setw(indent+21) << "featureServerAlias = " << setprecision(indent) << m_featureServerAlias << '\n';
  if (HasOptionalField(e_capacityReportingSpec))
    strm << setw(indent+24) << "capacityReportingSpec = " << setprecision(indent) << m_capacityReportingSpec << '\n';
  if (HasOptionalField(e_featureSet))
    strm << setw(indent+13) << "featureSet = " << setprecision(indent) << m_featureSet << '\n';
  if (HasOptionalField(e_genericData))
    strm << setw(indent+14) << "genericData = " << setprecision(indent) << m_genericData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_RegistrationConfirm::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_RegistrationConfirm), PInvalidCast);
#endif
  const H225_RegistrationConfirm & other = (const H225_RegistrationConfirm &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_protocolIdentifier.Compare(other.m_protocolIdentifier)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_callSignalAddress.Compare(other.m_callSignalAddress)) != EqualTo)
    return result;
  if ((result = m_terminalAlias.Compare(other.m_terminalAlias)) != EqualTo)
    return result;
  if ((result = m_gatekeeperIdentifier.Compare(other.m_gatekeeperIdentifier)) != EqualTo)
    return result;
  if ((result = m_endpointIdentifier.Compare(other.m_endpointIdentifier)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_RegistrationConfirm::GetDataLength() const
{
  PINDEX length = 0;
  length += m_requestSeqNum.GetObjectLength();
  length += m_protocolIdentifier.GetObjectLength();
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  length += m_callSignalAddress.GetObjectLength();
  if (HasOptionalField(e_terminalAlias))
    length += m_terminalAlias.GetObjectLength();
  if (HasOptionalField(e_gatekeeperIdentifier))
    length += m_gatekeeperIdentifier.GetObjectLength();
  length += m_endpointIdentifier.GetObjectLength();
  return length;
}


BOOL H225_RegistrationConfirm::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_requestSeqNum.Decode(strm))
    return FALSE;
  if (!m_protocolIdentifier.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (!m_callSignalAddress.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_terminalAlias) && !m_terminalAlias.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_gatekeeperIdentifier) && !m_gatekeeperIdentifier.Decode(strm))
    return FALSE;
  if (!m_endpointIdentifier.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_alternateGatekeeper, m_alternateGatekeeper))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_timeToLive, m_timeToLive))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_tokens, m_tokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_cryptoTokens, m_cryptoTokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_integrityCheckValue, m_integrityCheckValue))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_willRespondToIRR, m_willRespondToIRR))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_preGrantedARQ, m_preGrantedARQ))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_maintainConnection, m_maintainConnection))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_serviceControl, m_serviceControl))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_supportsAdditiveRegistration, m_supportsAdditiveRegistration))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_terminalAliasPattern, m_terminalAliasPattern))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_supportedPrefixes, m_supportedPrefixes))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_usageSpec, m_usageSpec))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_featureServerAlias, m_featureServerAlias))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_capacityReportingSpec, m_capacityReportingSpec))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_featureSet, m_featureSet))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_genericData, m_genericData))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_RegistrationConfirm::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  m_protocolIdentifier.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  m_callSignalAddress.Encode(strm);
  if (HasOptionalField(e_terminalAlias))
    m_terminalAlias.Encode(strm);
  if (HasOptionalField(e_gatekeeperIdentifier))
    m_gatekeeperIdentifier.Encode(strm);
  m_endpointIdentifier.Encode(strm);
  KnownExtensionEncode(strm, e_alternateGatekeeper, m_alternateGatekeeper);
  KnownExtensionEncode(strm, e_timeToLive, m_timeToLive);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);
  KnownExtensionEncode(strm, e_willRespondToIRR, m_willRespondToIRR);
  KnownExtensionEncode(strm, e_preGrantedARQ, m_preGrantedARQ);
  KnownExtensionEncode(strm, e_maintainConnection, m_maintainConnection);
  KnownExtensionEncode(strm, e_serviceControl, m_serviceControl);
  KnownExtensionEncode(strm, e_supportsAdditiveRegistration, m_supportsAdditiveRegistration);
  KnownExtensionEncode(strm, e_terminalAliasPattern, m_terminalAliasPattern);
  KnownExtensionEncode(strm, e_supportedPrefixes, m_supportedPrefixes);
  KnownExtensionEncode(strm, e_usageSpec, m_usageSpec);
  KnownExtensionEncode(strm, e_featureServerAlias, m_featureServerAlias);
  KnownExtensionEncode(strm, e_capacityReportingSpec, m_capacityReportingSpec);
  KnownExtensionEncode(strm, e_featureSet, m_featureSet);
  KnownExtensionEncode(strm, e_genericData, m_genericData);

  UnknownExtensionsEncode(strm);
}


PObject * H225_RegistrationConfirm::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_RegistrationConfirm::Class()), PInvalidCast);
#endif
  return new H225_RegistrationConfirm(*this);
}


//
// BandwidthRequest
//

H225_BandwidthRequest::H225_BandwidthRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 11)
{
  IncludeOptionalField(e_callIdentifier);
  IncludeOptionalField(e_answeredCall);
}


#ifndef PASN_NOPRINTON
void H225_BandwidthRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  strm << setw(indent+21) << "endpointIdentifier = " << setprecision(indent) << m_endpointIdentifier << '\n';
  strm << setw(indent+15) << "conferenceID = " << setprecision(indent) << m_conferenceID << '\n';
  strm << setw(indent+21) << "callReferenceValue = " << setprecision(indent) << m_callReferenceValue << '\n';
  if (HasOptionalField(e_callType))
    strm << setw(indent+11) << "callType = " << setprecision(indent) << m_callType << '\n';
  strm << setw(indent+12) << "bandWidth = " << setprecision(indent) << m_bandWidth << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_callIdentifier))
    strm << setw(indent+17) << "callIdentifier = " << setprecision(indent) << m_callIdentifier << '\n';
  if (HasOptionalField(e_gatekeeperIdentifier))
    strm << setw(indent+23) << "gatekeeperIdentifier = " << setprecision(indent) << m_gatekeeperIdentifier << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  if (HasOptionalField(e_answeredCall))
    strm << setw(indent+15) << "answeredCall = " << setprecision(indent) << m_answeredCall << '\n';
  if (HasOptionalField(e_callLinkage))
    strm << setw(indent+14) << "callLinkage = " << setprecision(indent) << m_callLinkage << '\n';
  if (HasOptionalField(e_capacity))
    strm << setw(indent+11) << "capacity = " << setprecision(indent) << m_capacity << '\n';
  if (HasOptionalField(e_usageInformation))
    strm << setw(indent+19) << "usageInformation = " << setprecision(indent) << m_usageInformation << '\n';
  if (HasOptionalField(e_bandwidthDetails))
    strm << setw(indent+19) << "bandwidthDetails = " << setprecision(indent) << m_bandwidthDetails << '\n';
  if (HasOptionalField(e_genericData))
    strm << setw(indent+14) << "genericData = " << setprecision(indent) << m_genericData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_BandwidthRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_BandwidthRequest), PInvalidCast);
#endif
  const H225_BandwidthRequest & other = (const H225_BandwidthRequest &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_endpointIdentifier.Compare(other.m_endpointIdentifier)) != EqualTo)
    return result;
  if ((result = m_conferenceID.Compare(other.m_conferenceID)) != EqualTo)
    return result;
  if ((result = m_callReferenceValue.Compare(other.m_callReferenceValue)) != EqualTo)
    return result;
  if ((result = m_callType.Compare(other.m_callType)) != EqualTo)
    return result;
  if ((result = m_bandWidth.Compare(other.m_bandWidth)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_BandwidthRequest::GetDataLength() const
{
  PINDEX length = 0;
  length += m_requestSeqNum.GetObjectLength();
  length += m_endpointIdentifier.GetObjectLength();
  length += m_conferenceID.GetObjectLength();
  length += m_callReferenceValue.GetObjectLength();
  if (HasOptionalField(e_callType))
    length += m_callType.GetObjectLength();
  length += m_bandWidth.GetObjectLength();
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  return length;
}


BOOL H225_BandwidthRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_requestSeqNum.Decode(strm))
    return FALSE;
  if (!m_endpointIdentifier.Decode(strm))
    return FALSE;
  if (!m_conferenceID.Decode(strm))
    return FALSE;
  if (!m_callReferenceValue.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_callType) && !m_callType.Decode(strm))
    return FALSE;
  if (!m_bandWidth.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_callIdentifier, m_callIdentifier))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_gatekeeperIdentifier, m_gatekeeperIdentifier))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_tokens, m_tokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_cryptoTokens, m_cryptoTokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_integrityCheckValue, m_integrityCheckValue))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_answeredCall, m_answeredCall))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_callLinkage, m_callLinkage))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_capacity, m_capacity))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_usageInformation, m_usageInformation))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_bandwidthDetails, m_bandwidthDetails))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_genericData, m_genericData))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_BandwidthRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  m_endpointIdentifier.Encode(strm);
  m_conferenceID.Encode(strm);
  m_callReferenceValue.Encode(strm);
  if (HasOptionalField(e_callType))
    m_callType.Encode(strm);
  m_bandWidth.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  KnownExtensionEncode(strm, e_callIdentifier, m_callIdentifier);
  KnownExtensionEncode(strm, e_gatekeeperIdentifier, m_gatekeeperIdentifier);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);
  KnownExtensionEncode(strm, e_answeredCall, m_answeredCall);
  KnownExtensionEncode(strm, e_callLinkage, m_callLinkage);
  KnownExtensionEncode(strm, e_capacity, m_capacity);
  KnownExtensionEncode(strm, e_usageInformation, m_usageInformation);
  KnownExtensionEncode(strm, e_bandwidthDetails, m_bandwidthDetails);
  KnownExtensionEncode(strm, e_genericData, m_genericData);

  UnknownExtensionsEncode(strm);
}


PObject * H225_BandwidthRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_BandwidthRequest::Class()), PInvalidCast);
#endif
  return new H225_BandwidthRequest(*this);
}


//
// BandwidthConfirm
//

H225_BandwidthConfirm::H225_BandwidthConfirm(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 5)
{
}


#ifndef PASN_NOPRINTON
void H225_BandwidthConfirm::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  strm << setw(indent+12) << "bandWidth = " << setprecision(indent) << m_bandWidth << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  if (HasOptionalField(e_capacity))
    strm << setw(indent+11) << "capacity = " << setprecision(indent) << m_capacity << '\n';
  if (HasOptionalField(e_genericData))
    strm << setw(indent+14) << "genericData = " << setprecision(indent) << m_genericData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_BandwidthConfirm::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_BandwidthConfirm), PInvalidCast);
#endif
  const H225_BandwidthConfirm & other = (const H225_BandwidthConfirm &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_bandWidth.Compare(other.m_bandWidth)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_BandwidthConfirm::GetDataLength() const
{
  PINDEX length = 0;
  length += m_requestSeqNum.GetObjectLength();
  length += m_bandWidth.GetObjectLength();
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  return length;
}


BOOL H225_BandwidthConfirm::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_requestSeqNum.Decode(strm))
    return FALSE;
  if (!m_bandWidth.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_tokens, m_tokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_cryptoTokens, m_cryptoTokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_integrityCheckValue, m_integrityCheckValue))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_capacity, m_capacity))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_genericData, m_genericData))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_BandwidthConfirm::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  m_bandWidth.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);
  KnownExtensionEncode(strm, e_capacity, m_capacity);
  KnownExtensionEncode(strm, e_genericData, m_genericData);

  UnknownExtensionsEncode(strm);
}


PObject * H225_BandwidthConfirm::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_BandwidthConfirm::Class()), PInvalidCast);
#endif
  return new H225_BandwidthConfirm(*this);
}


//
// ResourcesAvailableIndicate
//

H225_ResourcesAvailableIndicate::H225_ResourcesAvailableIndicate(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 4, TRUE, 2)
{
}


#ifndef PASN_NOPRINTON
void H225_ResourcesAvailableIndicate::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  strm << setw(indent+21) << "protocolIdentifier = " << setprecision(indent) << m_protocolIdentifier << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  strm << setw(indent+21) << "endpointIdentifier = " << setprecision(indent) << m_endpointIdentifier << '\n';
  strm << setw(indent+12) << "protocols = " << setprecision(indent) << m_protocols << '\n';
  strm << setw(indent+23) << "almostOutOfResources = " << setprecision(indent) << m_almostOutOfResources << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  if (HasOptionalField(e_capacity))
    strm << setw(indent+11) << "capacity = " << setprecision(indent) << m_capacity << '\n';
  if (HasOptionalField(e_genericData))
    strm << setw(indent+14) << "genericData = " << setprecision(indent) << m_genericData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_ResourcesAvailableIndicate::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_ResourcesAvailableIndicate), PInvalidCast);
#endif
  const H225_ResourcesAvailableIndicate & other = (const H225_ResourcesAvailableIndicate &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_protocolIdentifier.Compare(other.m_protocolIdentifier)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_endpointIdentifier.Compare(other.m_endpointIdentifier)) != EqualTo)
    return result;
  if ((result = m_protocols.Compare(other.m_protocols)) != EqualTo)
    return result;
  if ((result = m_almostOutOfResources.Compare(other.m_almostOutOfResources)) != EqualTo)
    return result;
  if ((result = m_tokens.Compare(other.m_tokens)) != EqualTo)
    return result;
  if ((result = m_cryptoTokens.Compare(other.m_cryptoTokens)) != EqualTo)
    return result;
  if ((result = m_integrityCheckValue.Compare(other.m_integrityCheckValue)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_ResourcesAvailableIndicate::GetDataLength() const
{
  PINDEX length = 0;
  length += m_requestSeqNum.GetObjectLength();
  length += m_protocolIdentifier.GetObjectLength();
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  length += m_endpointIdentifier.GetObjectLength();
  length += m_protocols.GetObjectLength();
  length += m_almostOutOfResources.GetObjectLength();
  if (HasOptionalField(e_tokens))
    length += m_tokens.GetObjectLength();
  if (HasOptionalField(e_cryptoTokens))
    length += m_cryptoTokens.GetObjectLength();
  if (HasOptionalField(e_integrityCheckValue))
    length += m_integrityCheckValue.GetObjectLength();
  return length;
}


BOOL H225_ResourcesAvailableIndicate::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_requestSeqNum.Decode(strm))
    return FALSE;
  if (!m_protocolIdentifier.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (!m_endpointIdentifier.Decode(strm))
    return FALSE;
  if (!m_protocols.Decode(strm))
    return FALSE;
  if (!m_almostOutOfResources.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_tokens) && !m_tokens.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_cryptoTokens) && !m_cryptoTokens.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_integrityCheckValue) && !m_integrityCheckValue.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_capacity, m_capacity))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_genericData, m_genericData))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_ResourcesAvailableIndicate::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  m_protocolIdentifier.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  m_endpointIdentifier.Encode(strm);
  m_protocols.Encode(strm);
  m_almostOutOfResources.Encode(strm);
  if (HasOptionalField(e_tokens))
    m_tokens.Encode(strm);
  if (HasOptionalField(e_cryptoTokens))
    m_cryptoTokens.Encode(strm);
  if (HasOptionalField(e_integrityCheckValue))
    m_integrityCheckValue.Encode(strm);
  KnownExtensionEncode(strm, e_capacity, m_capacity);
  KnownExtensionEncode(strm, e_genericData, m_genericData);

  UnknownExtensionsEncode(strm);
}


PObject * H225_ResourcesAvailableIndicate::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ResourcesAvailableIndicate::Class()), PInvalidCast);
#endif
  return new H225_ResourcesAvailableIndicate(*this);
}


//
// H323-UU-PDU
//

H225_H323_UU_PDU::H225_H323_UU_PDU(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 9)
{
  IncludeOptionalField(e_h245Tunneling);
}


#ifndef PASN_NOPRINTON
void H225_H323_UU_PDU::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+20) << "h323_message_body = " << setprecision(indent) << m_h323_message_body << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_h4501SupplementaryService))
    strm << setw(indent+28) << "h4501SupplementaryService = " << setprecision(indent) << m_h4501SupplementaryService << '\n';
  if (HasOptionalField(e_h245Tunneling))
    strm << setw(indent+16) << "h245Tunneling = " << setprecision(indent) << m_h245Tunneling << '\n';
  if (HasOptionalField(e_h245Control))
    strm << setw(indent+14) << "h245Control = " << setprecision(indent) << m_h245Control << '\n';
  if (HasOptionalField(e_nonStandardControl))
    strm << setw(indent+21) << "nonStandardControl = " << setprecision(indent) << m_nonStandardControl << '\n';
  if (HasOptionalField(e_callLinkage))
    strm << setw(indent+14) << "callLinkage = " << setprecision(indent) << m_callLinkage << '\n';
  if (HasOptionalField(e_tunnelledSignallingMessage))
    strm << setw(indent+29) << "tunnelledSignallingMessage = " << setprecision(indent) << m_tunnelledSignallingMessage << '\n';
  if (HasOptionalField(e_provisionalRespToH245Tunneling))
    strm << setw(indent+33) << "provisionalRespToH245Tunneling = " << setprecision(indent) << m_provisionalRespToH245Tunneling << '\n';
  if (HasOptionalField(e_stimulusControl))
    strm << setw(indent+18) << "stimulusControl = " << setprecision(indent) << m_stimulusControl << '\n';
  if (HasOptionalField(e_genericData))
    strm << setw(indent+14) << "genericData = " << setprecision(indent) << m_genericData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_H323_UU_PDU::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_H323_UU_PDU), PInvalidCast);
#endif
  const H225_H323_UU_PDU & other = (const H225_H323_UU_PDU &)obj;

  Comparison result;

  if ((result = m_h323_message_body.Compare(other.m_h323_message_body)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_H323_UU_PDU::GetDataLength() const
{
  PINDEX length = 0;
  length += m_h323_message_body.GetObjectLength();
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  return length;
}


BOOL H225_H323_UU_PDU::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_h323_message_body.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_h4501SupplementaryService, m_h4501SupplementaryService))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_h245Tunneling, m_h245Tunneling))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_h245Control, m_h245Control))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_nonStandardControl, m_nonStandardControl))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_callLinkage, m_callLinkage))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_tunnelledSignallingMessage, m_tunnelledSignallingMessage))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_provisionalRespToH245Tunneling, m_provisionalRespToH245Tunneling))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_stimulusControl, m_stimulusControl))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_genericData, m_genericData))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_H323_UU_PDU::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_h323_message_body.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  KnownExtensionEncode(strm, e_h4501SupplementaryService, m_h4501SupplementaryService);
  KnownExtensionEncode(strm, e_h245Tunneling, m_h245Tunneling);
  KnownExtensionEncode(strm, e_h245Control, m_h245Control);
  KnownExtensionEncode(strm, e_nonStandardControl, m_nonStandardControl);
  KnownExtensionEncode(strm, e_callLinkage, m_callLinkage);
  KnownExtensionEncode(strm, e_tunnelledSignallingMessage, m_tunnelledSignallingMessage);
  KnownExtensionEncode(strm, e_provisionalRespToH245Tunneling, m_provisionalRespToH245Tunneling);
  KnownExtensionEncode(strm, e_stimulusControl, m_stimulusControl);
  KnownExtensionEncode(strm, e_genericData, m_genericData);

  UnknownExtensionsEncode(strm);
}


PObject * H225_H323_UU_PDU::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_H323_UU_PDU::Class()), PInvalidCast);
#endif
  return new H225_H323_UU_PDU(*this);
}


//
// ReleaseComplete-UUIE
//

H225_ReleaseComplete_UUIE::H225_ReleaseComplete_UUIE(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 9)
{
  IncludeOptionalField(e_callIdentifier);
}


#ifndef PASN_NOPRINTON
void H225_ReleaseComplete_UUIE::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+21) << "protocolIdentifier = " << setprecision(indent) << m_protocolIdentifier << '\n';
  if (HasOptionalField(e_reason))
    strm << setw(indent+9) << "reason = " << setprecision(indent) << m_reason << '\n';
  if (HasOptionalField(e_callIdentifier))
    strm << setw(indent+17) << "callIdentifier = " << setprecision(indent) << m_callIdentifier << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_busyAddress))
    strm << setw(indent+14) << "busyAddress = " << setprecision(indent) << m_busyAddress << '\n';
  if (HasOptionalField(e_presentationIndicator))
    strm << setw(indent+24) << "presentationIndicator = " << setprecision(indent) << m_presentationIndicator << '\n';
  if (HasOptionalField(e_screeningIndicator))
    strm << setw(indent+21) << "screeningIndicator = " << setprecision(indent) << m_screeningIndicator << '\n';
  if (HasOptionalField(e_capacity))
    strm << setw(indent+11) << "capacity = " << setprecision(indent) << m_capacity << '\n';
  if (HasOptionalField(e_serviceControl))
    strm << setw(indent+17) << "serviceControl = " << setprecision(indent) << m_serviceControl << '\n';
  if (HasOptionalField(e_featureSet))
    strm << setw(indent+13) << "featureSet = " << setprecision(indent) << m_featureSet << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_ReleaseComplete_UUIE::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_ReleaseComplete_UUIE), PInvalidCast);
#endif
  const H225_ReleaseComplete_UUIE & other = (const H225_ReleaseComplete_UUIE &)obj;

  Comparison result;

  if ((result = m_protocolIdentifier.Compare(other.m_protocolIdentifier)) != EqualTo)
    return result;
  if ((result = m_reason.Compare(other.m_reason)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_ReleaseComplete_UUIE::GetDataLength() const
{
  PINDEX length = 0;
  length += m_protocolIdentifier.GetObjectLength();
  if (HasOptionalField(e_reason))
    length += m_reason.GetObjectLength();
  return length;
}


BOOL H225_ReleaseComplete_UUIE::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_protocolIdentifier.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_reason) && !m_reason.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_callIdentifier, m_callIdentifier))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_tokens, m_tokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_cryptoTokens, m_cryptoTokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_busyAddress, m_busyAddress))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_presentationIndicator, m_presentationIndicator))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_screeningIndicator, m_screeningIndicator))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_capacity, m_capacity))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_serviceControl, m_serviceControl))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_featureSet, m_featureSet))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_ReleaseComplete_UUIE::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_protocolIdentifier.Encode(strm);
  if (HasOptionalField(e_reason))
    m_reason.Encode(strm);
  KnownExtensionEncode(strm, e_callIdentifier, m_callIdentifier);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_busyAddress, m_busyAddress);
  KnownExtensionEncode(strm, e_presentationIndicator, m_presentationIndicator);
  KnownExtensionEncode(strm, e_screeningIndicator, m_screeningIndicator);
  KnownExtensionEncode(strm, e_capacity, m_capacity);
  KnownExtensionEncode(strm, e_serviceControl, m_serviceControl);
  KnownExtensionEncode(strm, e_featureSet, m_featureSet);

  UnknownExtensionsEncode(strm);
}


PObject * H225_ReleaseComplete_UUIE::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_ReleaseComplete_UUIE::Class()), PInvalidCast);
#endif
  return new H225_ReleaseComplete_UUIE(*this);
}


//
// EndpointType
//

H225_EndpointType::H225_EndpointType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 6, TRUE, 2)
{
  m_set.SetConstraints(PASN_Object::FixedConstraint, 32);
}


#ifndef PASN_NOPRINTON
void H225_EndpointType::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_vendor))
    strm << setw(indent+9) << "vendor = " << setprecision(indent) << m_vendor << '\n';
  if (HasOptionalField(e_gatekeeper))
    strm << setw(indent+13) << "gatekeeper = " << setprecision(indent) << m_gatekeeper << '\n';
  if (HasOptionalField(e_gateway))
    strm << setw(indent+10) << "gateway = " << setprecision(indent) << m_gateway << '\n';
  if (HasOptionalField(e_mcu))
    strm << setw(indent+6) << "mcu = " << setprecision(indent) << m_mcu << '\n';
  if (HasOptionalField(e_terminal))
    strm << setw(indent+11) << "terminal = " << setprecision(indent) << m_terminal << '\n';
  strm << setw(indent+5) << "mc = " << setprecision(indent) << m_mc << '\n';
  strm << setw(indent+16) << "undefinedNode = " << setprecision(indent) << m_undefinedNode << '\n';
  if (HasOptionalField(e_set))
    strm << setw(indent+6) << "set = " << setprecision(indent) << m_set << '\n';
  if (HasOptionalField(e_supportedTunnelledProtocols))
    strm << setw(indent+30) << "supportedTunnelledProtocols = " << setprecision(indent) << m_supportedTunnelledProtocols << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_EndpointType::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_EndpointType), PInvalidCast);
#endif
  const H225_EndpointType & other = (const H225_EndpointType &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_vendor.Compare(other.m_vendor)) != EqualTo)
    return result;
  if ((result = m_gatekeeper.Compare(other.m_gatekeeper)) != EqualTo)
    return result;
  if ((result = m_gateway.Compare(other.m_gateway)) != EqualTo)
    return result;
  if ((result = m_mcu.Compare(other.m_mcu)) != EqualTo)
    return result;
  if ((result = m_terminal.Compare(other.m_terminal)) != EqualTo)
    return result;
  if ((result = m_mc.Compare(other.m_mc)) != EqualTo)
    return result;
  if ((result = m_undefinedNode.Compare(other.m_undefinedNode)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_EndpointType::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  if (HasOptionalField(e_vendor))
    length += m_vendor.GetObjectLength();
  if (HasOptionalField(e_gatekeeper))
    length += m_gatekeeper.GetObjectLength();
  if (HasOptionalField(e_gateway))
    length += m_gateway.GetObjectLength();
  if (HasOptionalField(e_mcu))
    length += m_mcu.GetObjectLength();
  if (HasOptionalField(e_terminal))
    length += m_terminal.GetObjectLength();
  length += m_mc.GetObjectLength();
  length += m_undefinedNode.GetObjectLength();
  return length;
}


BOOL H225_EndpointType::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_vendor) && !m_vendor.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_gatekeeper) && !m_gatekeeper.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_gateway) && !m_gateway.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_mcu) && !m_mcu.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_terminal) && !m_terminal.Decode(strm))
    return FALSE;
  if (!m_mc.Decode(strm))
    return FALSE;
  if (!m_undefinedNode.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_set, m_set))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_supportedTunnelledProtocols, m_supportedTunnelledProtocols))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_EndpointType::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  if (HasOptionalField(e_vendor))
    m_vendor.Encode(strm);
  if (HasOptionalField(e_gatekeeper))
    m_gatekeeper.Encode(strm);
  if (HasOptionalField(e_gateway))
    m_gateway.Encode(strm);
  if (HasOptionalField(e_mcu))
    m_mcu.Encode(strm);
  if (HasOptionalField(e_terminal))
    m_terminal.Encode(strm);
  m_mc.Encode(strm);
  m_undefinedNode.Encode(strm);
  KnownExtensionEncode(strm, e_set, m_set);
  KnownExtensionEncode(strm, e_supportedTunnelledProtocols, m_supportedTunnelledProtocols);

  UnknownExtensionsEncode(strm);
}


PObject * H225_EndpointType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_EndpointType::Class()), PInvalidCast);
#endif
  return new H225_EndpointType(*this);
}


//
// CircuitInfo
//

H225_CircuitInfo::H225_CircuitInfo(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_CircuitInfo::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_sourceCircuitID))
    strm << setw(indent+18) << "sourceCircuitID = " << setprecision(indent) << m_sourceCircuitID << '\n';
  if (HasOptionalField(e_destinationCircuitID))
    strm << setw(indent+23) << "destinationCircuitID = " << setprecision(indent) << m_destinationCircuitID << '\n';
  if (HasOptionalField(e_genericData))
    strm << setw(indent+14) << "genericData = " << setprecision(indent) << m_genericData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_CircuitInfo::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_CircuitInfo), PInvalidCast);
#endif
  const H225_CircuitInfo & other = (const H225_CircuitInfo &)obj;

  Comparison result;

  if ((result = m_sourceCircuitID.Compare(other.m_sourceCircuitID)) != EqualTo)
    return result;
  if ((result = m_destinationCircuitID.Compare(other.m_destinationCircuitID)) != EqualTo)
    return result;
  if ((result = m_genericData.Compare(other.m_genericData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_CircuitInfo::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_sourceCircuitID))
    length += m_sourceCircuitID.GetObjectLength();
  if (HasOptionalField(e_destinationCircuitID))
    length += m_destinationCircuitID.GetObjectLength();
  if (HasOptionalField(e_genericData))
    length += m_genericData.GetObjectLength();
  return length;
}


BOOL H225_CircuitInfo::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_sourceCircuitID) && !m_sourceCircuitID.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_destinationCircuitID) && !m_destinationCircuitID.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_genericData) && !m_genericData.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_CircuitInfo::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_sourceCircuitID))
    m_sourceCircuitID.Encode(strm);
  if (HasOptionalField(e_destinationCircuitID))
    m_destinationCircuitID.Encode(strm);
  if (HasOptionalField(e_genericData))
    m_genericData.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_CircuitInfo::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_CircuitInfo::Class()), PInvalidCast);
#endif
  return new H225_CircuitInfo(*this);
}


//
// GatekeeperRequest
//

H225_GatekeeperRequest::H225_GatekeeperRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 4, TRUE, 10)
{
}


#ifndef PASN_NOPRINTON
void H225_GatekeeperRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  strm << setw(indent+21) << "protocolIdentifier = " << setprecision(indent) << m_protocolIdentifier << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  strm << setw(indent+13) << "rasAddress = " << setprecision(indent) << m_rasAddress << '\n';
  strm << setw(indent+15) << "endpointType = " << setprecision(indent) << m_endpointType << '\n';
  if (HasOptionalField(e_gatekeeperIdentifier))
    strm << setw(indent+23) << "gatekeeperIdentifier = " << setprecision(indent) << m_gatekeeperIdentifier << '\n';
  if (HasOptionalField(e_callServices))
    strm << setw(indent+15) << "callServices = " << setprecision(indent) << m_callServices << '\n';
  if (HasOptionalField(e_endpointAlias))
    strm << setw(indent+16) << "endpointAlias = " << setprecision(indent) << m_endpointAlias << '\n';
  if (HasOptionalField(e_alternateEndpoints))
    strm << setw(indent+21) << "alternateEndpoints = " << setprecision(indent) << m_alternateEndpoints << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_authenticationCapability))
    strm << setw(indent+27) << "authenticationCapability = " << setprecision(indent) << m_authenticationCapability << '\n';
  if (HasOptionalField(e_algorithmOIDs))
    strm << setw(indent+16) << "algorithmOIDs = " << setprecision(indent) << m_algorithmOIDs << '\n';
  if (HasOptionalField(e_integrity))
    strm << setw(indent+12) << "integrity = " << setprecision(indent) << m_integrity << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  if (HasOptionalField(e_supportsAltGK))
    strm << setw(indent+16) << "supportsAltGK = " << setprecision(indent) << m_supportsAltGK << '\n';
  if (HasOptionalField(e_featureSet))
    strm << setw(indent+13) << "featureSet = " << setprecision(indent) << m_featureSet << '\n';
  if (HasOptionalField(e_genericData))
    strm << setw(indent+14) << "genericData = " << setprecision(indent) << m_genericData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_GatekeeperRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_GatekeeperRequest), PInvalidCast);
#endif
  const H225_GatekeeperRequest & other = (const H225_GatekeeperRequest &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_protocolIdentifier.Compare(other.m_protocolIdentifier)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_rasAddress.Compare(other.m_rasAddress)) != EqualTo)
    return result;
  if ((result = m_endpointType.Compare(other.m_endpointType)) != EqualTo)
    return result;
  if ((result = m_gatekeeperIdentifier.Compare(other.m_gatekeeperIdentifier)) != EqualTo)
    return result;
  if ((result = m_callServices.Compare(other.m_callServices)) != EqualTo)
    return result;
  if ((result = m_endpointAlias.Compare(other.m_endpointAlias)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_GatekeeperRequest::GetDataLength() const
{
  PINDEX length = 0;
  length += m_requestSeqNum.GetObjectLength();
  length += m_protocolIdentifier.GetObjectLength();
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  length += m_rasAddress.GetObjectLength();
  length += m_endpointType.GetObjectLength();
  if (HasOptionalField(e_gatekeeperIdentifier))
    length += m_gatekeeperIdentifier.GetObjectLength();
  if (HasOptionalField(e_callServices))
    length += m_callServices.GetObjectLength();
  if (HasOptionalField(e_endpointAlias))
    length += m_endpointAlias.GetObjectLength();
  return length;
}


BOOL H225_GatekeeperRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_requestSeqNum.Decode(strm))
    return FALSE;
  if (!m_protocolIdentifier.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (!m_rasAddress.Decode(strm))
    return FALSE;
  if (!m_endpointType.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_gatekeeperIdentifier) && !m_gatekeeperIdentifier.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_callServices) && !m_callServices.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_endpointAlias) && !m_endpointAlias.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_alternateEndpoints, m_alternateEndpoints))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_tokens, m_tokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_cryptoTokens, m_cryptoTokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_authenticationCapability, m_authenticationCapability))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_algorithmOIDs, m_algorithmOIDs))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_integrity, m_integrity))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_integrityCheckValue, m_integrityCheckValue))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_supportsAltGK, m_supportsAltGK))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_featureSet, m_featureSet))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_genericData, m_genericData))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_GatekeeperRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  m_protocolIdentifier.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  m_rasAddress.Encode(strm);
  m_endpointType.Encode(strm);
  if (HasOptionalField(e_gatekeeperIdentifier))
    m_gatekeeperIdentifier.Encode(strm);
  if (HasOptionalField(e_callServices))
    m_callServices.Encode(strm);
  if (HasOptionalField(e_endpointAlias))
    m_endpointAlias.Encode(strm);
  KnownExtensionEncode(strm, e_alternateEndpoints, m_alternateEndpoints);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_authenticationCapability, m_authenticationCapability);
  KnownExtensionEncode(strm, e_algorithmOIDs, m_algorithmOIDs);
  KnownExtensionEncode(strm, e_integrity, m_integrity);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);
  KnownExtensionEncode(strm, e_supportsAltGK, m_supportsAltGK);
  KnownExtensionEncode(strm, e_featureSet, m_featureSet);
  KnownExtensionEncode(strm, e_genericData, m_genericData);

  UnknownExtensionsEncode(strm);
}


PObject * H225_GatekeeperRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_GatekeeperRequest::Class()), PInvalidCast);
#endif
  return new H225_GatekeeperRequest(*this);
}


//
// RegistrationRequest
//

H225_RegistrationRequest::H225_RegistrationRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 23)
{
  IncludeOptionalField(e_keepAlive);
  IncludeOptionalField(e_willSupplyUUIEs);
  IncludeOptionalField(e_maintainConnection);
}


#ifndef PASN_NOPRINTON
void H225_RegistrationRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  strm << setw(indent+21) << "protocolIdentifier = " << setprecision(indent) << m_protocolIdentifier << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  strm << setw(indent+20) << "discoveryComplete = " << setprecision(indent) << m_discoveryComplete << '\n';
  strm << setw(indent+20) << "callSignalAddress = " << setprecision(indent) << m_callSignalAddress << '\n';
  strm << setw(indent+13) << "rasAddress = " << setprecision(indent) << m_rasAddress << '\n';
  strm << setw(indent+15) << "terminalType = " << setprecision(indent) << m_terminalType << '\n';
  if (HasOptionalField(e_terminalAlias))
    strm << setw(indent+16) << "terminalAlias = " << setprecision(indent) << m_terminalAlias << '\n';
  if (HasOptionalField(e_gatekeeperIdentifier))
    strm << setw(indent+23) << "gatekeeperIdentifier = " << setprecision(indent) << m_gatekeeperIdentifier << '\n';
  strm << setw(indent+17) << "endpointVendor = " << setprecision(indent) << m_endpointVendor << '\n';
  if (HasOptionalField(e_alternateEndpoints))
    strm << setw(indent+21) << "alternateEndpoints = " << setprecision(indent) << m_alternateEndpoints << '\n';
  if (HasOptionalField(e_timeToLive))
    strm << setw(indent+13) << "timeToLive = " << setprecision(indent) << m_timeToLive << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  if (HasOptionalField(e_keepAlive))
    strm << setw(indent+12) << "keepAlive = " << setprecision(indent) << m_keepAlive << '\n';
  if (HasOptionalField(e_endpointIdentifier))
    strm << setw(indent+21) << "endpointIdentifier = " << setprecision(indent) << m_endpointIdentifier << '\n';
  if (HasOptionalField(e_willSupplyUUIEs))
    strm << setw(indent+18) << "willSupplyUUIEs = " << setprecision(indent) << m_willSupplyUUIEs << '\n';
  if (HasOptionalField(e_maintainConnection))
    strm << setw(indent+21) << "maintainConnection = " << setprecision(indent) << m_maintainConnection << '\n';
  if (HasOptionalField(e_alternateTransportAddresses))
    strm << setw(indent+30) << "alternateTransportAddresses = " << setprecision(indent) << m_alternateTransportAddresses << '\n';
  if (HasOptionalField(e_additiveRegistration))
    strm << setw(indent+23) << "additiveRegistration = " << setprecision(indent) << m_additiveRegistration << '\n';
  if (HasOptionalField(e_terminalAliasPattern))
    strm << setw(indent+23) << "terminalAliasPattern = " << setprecision(indent) << m_terminalAliasPattern << '\n';
  if (HasOptionalField(e_supportsAltGK))
    strm << setw(indent+16) << "supportsAltGK = " << setprecision(indent) << m_supportsAltGK << '\n';
  if (HasOptionalField(e_usageReportingCapability))
    strm << setw(indent+27) << "usageReportingCapability = " << setprecision(indent) << m_usageReportingCapability << '\n';
  if (HasOptionalField(e_multipleCalls))
    strm << setw(indent+16) << "multipleCalls = " << setprecision(indent) << m_multipleCalls << '\n';
  if (HasOptionalField(e_supportedH248Packages))
    strm << setw(indent+24) << "supportedH248Packages = " << setprecision(indent) << m_supportedH248Packages << '\n';
  if (HasOptionalField(e_callCreditCapability))
    strm << setw(indent+23) << "callCreditCapability = " << setprecision(indent) << m_callCreditCapability << '\n';
  if (HasOptionalField(e_capacityReportingCapability))
    strm << setw(indent+30) << "capacityReportingCapability = " << setprecision(indent) << m_capacityReportingCapability << '\n';
  if (HasOptionalField(e_capacity))
    strm << setw(indent+11) << "capacity = " << setprecision(indent) << m_capacity << '\n';
  if (HasOptionalField(e_featureSet))
    strm << setw(indent+13) << "featureSet = " << setprecision(indent) << m_featureSet << '\n';
  if (HasOptionalField(e_genericData))
    strm << setw(indent+14) << "genericData = " << setprecision(indent) << m_genericData << '\n';
  if (HasOptionalField(e_restart))
    strm << setw(indent+10) << "restart = " << setprecision(indent) << m_restart << '\n';
  if (HasOptionalField(e_supportsACFSequences))
    strm << setw(indent+23) << "supportsACFSequences = " << setprecision(indent) << m_supportsACFSequences << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_RegistrationRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_RegistrationRequest), PInvalidCast);
#endif
  const H225_RegistrationRequest & other = (const H225_RegistrationRequest &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_protocolIdentifier.Compare(other.m_protocolIdentifier)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_discoveryComplete.Compare(other.m_discoveryComplete)) != EqualTo)
    return result;
  if ((result = m_callSignalAddress.Compare(other.m_callSignalAddress)) != EqualTo)
    return result;
  if ((result = m_rasAddress.Compare(other.m_rasAddress)) != EqualTo)
    return result;
  if ((result = m_terminalType.Compare(other.m_terminalType)) != EqualTo)
    return result;
  if ((result = m_terminalAlias.Compare(other.m_terminalAlias)) != EqualTo)
    return result;
  if ((result = m_gatekeeperIdentifier.Compare(other.m_gatekeeperIdentifier)) != EqualTo)
    return result;
  if ((result = m_endpointVendor.Compare(other.m_endpointVendor)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_RegistrationRequest::GetDataLength() const
{
  PINDEX length = 0;
  length += m_requestSeqNum.GetObjectLength();
  length += m_protocolIdentifier.GetObjectLength();
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  length += m_discoveryComplete.GetObjectLength();
  length += m_callSignalAddress.GetObjectLength();
  length += m_rasAddress.GetObjectLength();
  length += m_terminalType.GetObjectLength();
  if (HasOptionalField(e_terminalAlias))
    length += m_terminalAlias.GetObjectLength();
  if (HasOptionalField(e_gatekeeperIdentifier))
    length += m_gatekeeperIdentifier.GetObjectLength();
  length += m_endpointVendor.GetObjectLength();
  return length;
}


BOOL H225_RegistrationRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_requestSeqNum.Decode(strm))
    return FALSE;
  if (!m_protocolIdentifier.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (!m_discoveryComplete.Decode(strm))
    return FALSE;
  if (!m_callSignalAddress.Decode(strm))
    return FALSE;
  if (!m_rasAddress.Decode(strm))
    return FALSE;
  if (!m_terminalType.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_terminalAlias) && !m_terminalAlias.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_gatekeeperIdentifier) && !m_gatekeeperIdentifier.Decode(strm))
    return FALSE;
  if (!m_endpointVendor.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_alternateEndpoints, m_alternateEndpoints))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_timeToLive, m_timeToLive))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_tokens, m_tokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_cryptoTokens, m_cryptoTokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_integrityCheckValue, m_integrityCheckValue))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_keepAlive, m_keepAlive))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_endpointIdentifier, m_endpointIdentifier))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_willSupplyUUIEs, m_willSupplyUUIEs))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_maintainConnection, m_maintainConnection))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_alternateTransportAddresses, m_alternateTransportAddresses))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_additiveRegistration, m_additiveRegistration))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_terminalAliasPattern, m_terminalAliasPattern))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_supportsAltGK, m_supportsAltGK))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_usageReportingCapability, m_usageReportingCapability))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_multipleCalls, m_multipleCalls))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_supportedH248Packages, m_supportedH248Packages))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_callCreditCapability, m_callCreditCapability))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_capacityReportingCapability, m_capacityReportingCapability))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_capacity, m_capacity))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_featureSet, m_featureSet))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_genericData, m_genericData))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_restart, m_restart))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_supportsACFSequences, m_supportsACFSequences))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_RegistrationRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  m_protocolIdentifier.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  m_discoveryComplete.Encode(strm);
  m_callSignalAddress.Encode(strm);
  m_rasAddress.Encode(strm);
  m_terminalType.Encode(strm);
  if (HasOptionalField(e_terminalAlias))
    m_terminalAlias.Encode(strm);
  if (HasOptionalField(e_gatekeeperIdentifier))
    m_gatekeeperIdentifier.Encode(strm);
  m_endpointVendor.Encode(strm);
  KnownExtensionEncode(strm, e_alternateEndpoints, m_alternateEndpoints);
  KnownExtensionEncode(strm, e_timeToLive, m_timeToLive);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);
  KnownExtensionEncode(strm, e_keepAlive, m_keepAlive);
  KnownExtensionEncode(strm, e_endpointIdentifier, m_endpointIdentifier);
  KnownExtensionEncode(strm, e_willSupplyUUIEs, m_willSupplyUUIEs);
  KnownExtensionEncode(strm, e_maintainConnection, m_maintainConnection);
  KnownExtensionEncode(strm, e_alternateTransportAddresses, m_alternateTransportAddresses);
  KnownExtensionEncode(strm, e_additiveRegistration, m_additiveRegistration);
  KnownExtensionEncode(strm, e_terminalAliasPattern, m_terminalAliasPattern);
  KnownExtensionEncode(strm, e_supportsAltGK, m_supportsAltGK);
  KnownExtensionEncode(strm, e_usageReportingCapability, m_usageReportingCapability);
  KnownExtensionEncode(strm, e_multipleCalls, m_multipleCalls);
  KnownExtensionEncode(strm, e_supportedH248Packages, m_supportedH248Packages);
  KnownExtensionEncode(strm, e_callCreditCapability, m_callCreditCapability);
  KnownExtensionEncode(strm, e_capacityReportingCapability, m_capacityReportingCapability);
  KnownExtensionEncode(strm, e_capacity, m_capacity);
  KnownExtensionEncode(strm, e_featureSet, m_featureSet);
  KnownExtensionEncode(strm, e_genericData, m_genericData);
  KnownExtensionEncode(strm, e_restart, m_restart);
  KnownExtensionEncode(strm, e_supportsACFSequences, m_supportsACFSequences);

  UnknownExtensionsEncode(strm);
}


PObject * H225_RegistrationRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_RegistrationRequest::Class()), PInvalidCast);
#endif
  return new H225_RegistrationRequest(*this);
}


//
// AdmissionRequest
//

H225_AdmissionRequest::H225_AdmissionRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 7, TRUE, 19)
{
  IncludeOptionalField(e_canMapAlias);
  IncludeOptionalField(e_callIdentifier);
  IncludeOptionalField(e_willSupplyUUIEs);
  IncludeOptionalField(e_canMapSrcAlias);
}


#ifndef PASN_NOPRINTON
void H225_AdmissionRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  strm << setw(indent+11) << "callType = " << setprecision(indent) << m_callType << '\n';
  if (HasOptionalField(e_callModel))
    strm << setw(indent+12) << "callModel = " << setprecision(indent) << m_callModel << '\n';
  strm << setw(indent+21) << "endpointIdentifier = " << setprecision(indent) << m_endpointIdentifier << '\n';
  if (HasOptionalField(e_destinationInfo))
    strm << setw(indent+18) << "destinationInfo = " << setprecision(indent) << m_destinationInfo << '\n';
  if (HasOptionalField(e_destCallSignalAddress))
    strm << setw(indent+24) << "destCallSignalAddress = " << setprecision(indent) << m_destCallSignalAddress << '\n';
  if (HasOptionalField(e_destExtraCallInfo))
    strm << setw(indent+20) << "destExtraCallInfo = " << setprecision(indent) << m_destExtraCallInfo << '\n';
  strm << setw(indent+10) << "srcInfo = " << setprecision(indent) << m_srcInfo << '\n';
  if (HasOptionalField(e_srcCallSignalAddress))
    strm << setw(indent+23) << "srcCallSignalAddress = " << setprecision(indent) << m_srcCallSignalAddress << '\n';
  strm << setw(indent+12) << "bandWidth = " << setprecision(indent) << m_bandWidth << '\n';
  strm << setw(indent+21) << "callReferenceValue = " << setprecision(indent) << m_callReferenceValue << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_callServices))
    strm << setw(indent+15) << "callServices = " << setprecision(indent) << m_callServices << '\n';
  strm << setw(indent+15) << "conferenceID = " << setprecision(indent) << m_conferenceID << '\n';
  strm << setw(indent+11) << "activeMC = " << setprecision(indent) << m_activeMC << '\n';
  strm << setw(indent+13) << "answerCall = " << setprecision(indent) << m_answerCall << '\n';
  if (HasOptionalField(e_canMapAlias))
    strm << setw(indent+14) << "canMapAlias = " << setprecision(indent) << m_canMapAlias << '\n';
  if (HasOptionalField(e_callIdentifier))
    strm << setw(indent+17) << "callIdentifier = " << setprecision(indent) << m_callIdentifier << '\n';
  if (HasOptionalField(e_srcAlternatives))
    strm << setw(indent+18) << "srcAlternatives = " << setprecision(indent) << m_srcAlternatives << '\n';
  if (HasOptionalField(e_destAlternatives))
    strm << setw(indent+19) << "destAlternatives = " << setprecision(indent) << m_destAlternatives << '\n';
  if (HasOptionalField(e_gatekeeperIdentifier))
    strm << setw(indent+23) << "gatekeeperIdentifier = " << setprecision(indent) << m_gatekeeperIdentifier << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  if (HasOptionalField(e_transportQOS))
    strm << setw(indent+15) << "transportQOS = " << setprecision(indent) << m_transportQOS << '\n';
  if (HasOptionalField(e_willSupplyUUIEs))
    strm << setw(indent+18) << "willSupplyUUIEs = " << setprecision(indent) << m_willSupplyUUIEs << '\n';
  if (HasOptionalField(e_callLinkage))
    strm << setw(indent+14) << "callLinkage = " << setprecision(indent) << m_callLinkage << '\n';
  if (HasOptionalField(e_gatewayDataRate))
    strm << setw(indent+18) << "gatewayDataRate = " << setprecision(indent) << m_gatewayDataRate << '\n';
  if (HasOptionalField(e_capacity))
    strm << setw(indent+11) << "capacity = " << setprecision(indent) << m_capacity << '\n';
  if (HasOptionalField(e_circuitInfo))
    strm << setw(indent+14) << "circuitInfo = " << setprecision(indent) << m_circuitInfo << '\n';
  if (HasOptionalField(e_desiredProtocols))
    strm << setw(indent+19) << "desiredProtocols = " << setprecision(indent) << m_desiredProtocols << '\n';
  if (HasOptionalField(e_desiredTunnelledProtocol))
    strm << setw(indent+27) << "desiredTunnelledProtocol = " << setprecision(indent) << m_desiredTunnelledProtocol << '\n';
  if (HasOptionalField(e_featureSet))
    strm << setw(indent+13) << "featureSet = " << setprecision(indent) << m_featureSet << '\n';
  if (HasOptionalField(e_genericData))
    strm << setw(indent+14) << "genericData = " << setprecision(indent) << m_genericData << '\n';
  if (HasOptionalField(e_canMapSrcAlias))
    strm << setw(indent+17) << "canMapSrcAlias = " << setprecision(indent) << m_canMapSrcAlias << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_AdmissionRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_AdmissionRequest), PInvalidCast);
#endif
  const H225_AdmissionRequest & other = (const H225_AdmissionRequest &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_callType.Compare(other.m_callType)) != EqualTo)
    return result;
  if ((result = m_callModel.Compare(other.m_callModel)) != EqualTo)
    return result;
  if ((result = m_endpointIdentifier.Compare(other.m_endpointIdentifier)) != EqualTo)
    return result;
  if ((result = m_destinationInfo.Compare(other.m_destinationInfo)) != EqualTo)
    return result;
  if ((result = m_destCallSignalAddress.Compare(other.m_destCallSignalAddress)) != EqualTo)
    return result;
  if ((result = m_destExtraCallInfo.Compare(other.m_destExtraCallInfo)) != EqualTo)
    return result;
  if ((result = m_srcInfo.Compare(other.m_srcInfo)) != EqualTo)
    return result;
  if ((result = m_srcCallSignalAddress.Compare(other.m_srcCallSignalAddress)) != EqualTo)
    return result;
  if ((result = m_bandWidth.Compare(other.m_bandWidth)) != EqualTo)
    return result;
  if ((result = m_callReferenceValue.Compare(other.m_callReferenceValue)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_callServices.Compare(other.m_callServices)) != EqualTo)
    return result;
  if ((result = m_conferenceID.Compare(other.m_conferenceID)) != EqualTo)
    return result;
  if ((result = m_activeMC.Compare(other.m_activeMC)) != EqualTo)
    return result;
  if ((result = m_answerCall.Compare(other.m_answerCall)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_AdmissionRequest::GetDataLength() const
{
  PINDEX length = 0;
  length += m_requestSeqNum.GetObjectLength();
  length += m_callType.GetObjectLength();
  if (HasOptionalField(e_callModel))
    length += m_callModel.GetObjectLength();
  length += m_endpointIdentifier.GetObjectLength();
  if (HasOptionalField(e_destinationInfo))
    length += m_destinationInfo.GetObjectLength();
  if (HasOptionalField(e_destCallSignalAddress))
    length += m_destCallSignalAddress.GetObjectLength();
  if (HasOptionalField(e_destExtraCallInfo))
    length += m_destExtraCallInfo.GetObjectLength();
  length += m_srcInfo.GetObjectLength();
  if (HasOptionalField(e_srcCallSignalAddress))
    length += m_srcCallSignalAddress.GetObjectLength();
  length += m_bandWidth.GetObjectLength();
  length += m_callReferenceValue.GetObjectLength();
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  if (HasOptionalField(e_callServices))
    length += m_callServices.GetObjectLength();
  length += m_conferenceID.GetObjectLength();
  length += m_activeMC.GetObjectLength();
  length += m_answerCall.GetObjectLength();
  return length;
}


BOOL H225_AdmissionRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_requestSeqNum.Decode(strm))
    return FALSE;
  if (!m_callType.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_callModel) && !m_callModel.Decode(strm))
    return FALSE;
  if (!m_endpointIdentifier.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_destinationInfo) && !m_destinationInfo.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_destCallSignalAddress) && !m_destCallSignalAddress.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_destExtraCallInfo) && !m_destExtraCallInfo.Decode(strm))
    return FALSE;
  if (!m_srcInfo.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_srcCallSignalAddress) && !m_srcCallSignalAddress.Decode(strm))
    return FALSE;
  if (!m_bandWidth.Decode(strm))
    return FALSE;
  if (!m_callReferenceValue.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_callServices) && !m_callServices.Decode(strm))
    return FALSE;
  if (!m_conferenceID.Decode(strm))
    return FALSE;
  if (!m_activeMC.Decode(strm))
    return FALSE;
  if (!m_answerCall.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_canMapAlias, m_canMapAlias))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_callIdentifier, m_callIdentifier))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_srcAlternatives, m_srcAlternatives))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_destAlternatives, m_destAlternatives))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_gatekeeperIdentifier, m_gatekeeperIdentifier))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_tokens, m_tokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_cryptoTokens, m_cryptoTokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_integrityCheckValue, m_integrityCheckValue))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_transportQOS, m_transportQOS))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_willSupplyUUIEs, m_willSupplyUUIEs))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_callLinkage, m_callLinkage))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_gatewayDataRate, m_gatewayDataRate))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_capacity, m_capacity))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_circuitInfo, m_circuitInfo))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_desiredProtocols, m_desiredProtocols))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_desiredTunnelledProtocol, m_desiredTunnelledProtocol))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_featureSet, m_featureSet))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_genericData, m_genericData))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_canMapSrcAlias, m_canMapSrcAlias))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_AdmissionRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  m_callType.Encode(strm);
  if (HasOptionalField(e_callModel))
    m_callModel.Encode(strm);
  m_endpointIdentifier.Encode(strm);
  if (HasOptionalField(e_destinationInfo))
    m_destinationInfo.Encode(strm);
  if (HasOptionalField(e_destCallSignalAddress))
    m_destCallSignalAddress.Encode(strm);
  if (HasOptionalField(e_destExtraCallInfo))
    m_destExtraCallInfo.Encode(strm);
  m_srcInfo.Encode(strm);
  if (HasOptionalField(e_srcCallSignalAddress))
    m_srcCallSignalAddress.Encode(strm);
  m_bandWidth.Encode(strm);
  m_callReferenceValue.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  if (HasOptionalField(e_callServices))
    m_callServices.Encode(strm);
  m_conferenceID.Encode(strm);
  m_activeMC.Encode(strm);
  m_answerCall.Encode(strm);
  KnownExtensionEncode(strm, e_canMapAlias, m_canMapAlias);
  KnownExtensionEncode(strm, e_callIdentifier, m_callIdentifier);
  KnownExtensionEncode(strm, e_srcAlternatives, m_srcAlternatives);
  KnownExtensionEncode(strm, e_destAlternatives, m_destAlternatives);
  KnownExtensionEncode(strm, e_gatekeeperIdentifier, m_gatekeeperIdentifier);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);
  KnownExtensionEncode(strm, e_transportQOS, m_transportQOS);
  KnownExtensionEncode(strm, e_willSupplyUUIEs, m_willSupplyUUIEs);
  KnownExtensionEncode(strm, e_callLinkage, m_callLinkage);
  KnownExtensionEncode(strm, e_gatewayDataRate, m_gatewayDataRate);
  KnownExtensionEncode(strm, e_capacity, m_capacity);
  KnownExtensionEncode(strm, e_circuitInfo, m_circuitInfo);
  KnownExtensionEncode(strm, e_desiredProtocols, m_desiredProtocols);
  KnownExtensionEncode(strm, e_desiredTunnelledProtocol, m_desiredTunnelledProtocol);
  KnownExtensionEncode(strm, e_featureSet, m_featureSet);
  KnownExtensionEncode(strm, e_genericData, m_genericData);
  KnownExtensionEncode(strm, e_canMapSrcAlias, m_canMapSrcAlias);

  UnknownExtensionsEncode(strm);
}


PObject * H225_AdmissionRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_AdmissionRequest::Class()), PInvalidCast);
#endif
  return new H225_AdmissionRequest(*this);
}


//
// AdmissionConfirm
//

H225_AdmissionConfirm::H225_AdmissionConfirm(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 22)
{
  m_irrFrequency.SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
  IncludeOptionalField(e_willRespondToIRR);
  IncludeOptionalField(e_uuiesRequested);
}


#ifndef PASN_NOPRINTON
void H225_AdmissionConfirm::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  strm << setw(indent+12) << "bandWidth = " << setprecision(indent) << m_bandWidth << '\n';
  strm << setw(indent+12) << "callModel = " << setprecision(indent) << m_callModel << '\n';
  strm << setw(indent+24) << "destCallSignalAddress = " << setprecision(indent) << m_destCallSignalAddress << '\n';
  if (HasOptionalField(e_irrFrequency))
    strm << setw(indent+15) << "irrFrequency = " << setprecision(indent) << m_irrFrequency << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_destinationInfo))
    strm << setw(indent+18) << "destinationInfo = " << setprecision(indent) << m_destinationInfo << '\n';
  if (HasOptionalField(e_destExtraCallInfo))
    strm << setw(indent+20) << "destExtraCallInfo = " << setprecision(indent) << m_destExtraCallInfo << '\n';
  if (HasOptionalField(e_destinationType))
    strm << setw(indent+18) << "destinationType = " << setprecision(indent) << m_destinationType << '\n';
  if (HasOptionalField(e_remoteExtensionAddress))
    strm << setw(indent+25) << "remoteExtensionAddress = " << setprecision(indent) << m_remoteExtensionAddress << '\n';
  if (HasOptionalField(e_alternateEndpoints))
    strm << setw(indent+21) << "alternateEndpoints = " << setprecision(indent) << m_alternateEndpoints << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  if (HasOptionalField(e_transportQOS))
    strm << setw(indent+15) << "transportQOS = " << setprecision(indent) << m_transportQOS << '\n';
  if (HasOptionalField(e_willRespondToIRR))
    strm << setw(indent+19) << "willRespondToIRR = " << setprecision(indent) << m_willRespondToIRR << '\n';
  if (HasOptionalField(e_uuiesRequested))
    strm << setw(indent+17) << "uuiesRequested = " << setprecision(indent) << m_uuiesRequested << '\n';
  if (HasOptionalField(e_language))
    strm << setw(indent+11) << "language = " << setprecision(indent) << m_language << '\n';
  if (HasOptionalField(e_alternateTransportAddresses))
    strm << setw(indent+30) << "alternateTransportAddresses = " << setprecision(indent) << m_alternateTransportAddresses << '\n';
  if (HasOptionalField(e_useSpecifiedTransport))
    strm << setw(indent+24) << "useSpecifiedTransport = " << setprecision(indent) << m_useSpecifiedTransport << '\n';
  if (HasOptionalField(e_circuitInfo))
    strm << setw(indent+14) << "circuitInfo = " << setprecision(indent) << m_circuitInfo << '\n';
  if (HasOptionalField(e_usageSpec))
    strm << setw(indent+12) << "usageSpec = " << setprecision(indent) << m_usageSpec << '\n';
  if (HasOptionalField(e_supportedProtocols))
    strm << setw(indent+21) << "supportedProtocols = " << setprecision(indent) << m_supportedProtocols << '\n';
  if (HasOptionalField(e_serviceControl))
    strm << setw(indent+17) << "serviceControl = " << setprecision(indent) << m_serviceControl << '\n';
  if (HasOptionalField(e_multipleCalls))
    strm << setw(indent+16) << "multipleCalls = " << setprecision(indent) << m_multipleCalls << '\n';
  if (HasOptionalField(e_featureSet))
    strm << setw(indent+13) << "featureSet = " << setprecision(indent) << m_featureSet << '\n';
  if (HasOptionalField(e_genericData))
    strm << setw(indent+14) << "genericData = " << setprecision(indent) << m_genericData << '\n';
  if (HasOptionalField(e_modifiedSrcInfo))
    strm << setw(indent+18) << "modifiedSrcInfo = " << setprecision(indent) << m_modifiedSrcInfo << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_AdmissionConfirm::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_AdmissionConfirm), PInvalidCast);
#endif
  const H225_AdmissionConfirm & other = (const H225_AdmissionConfirm &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_bandWidth.Compare(other.m_bandWidth)) != EqualTo)
    return result;
  if ((result = m_callModel.Compare(other.m_callModel)) != EqualTo)
    return result;
  if ((result = m_destCallSignalAddress.Compare(other.m_destCallSignalAddress)) != EqualTo)
    return result;
  if ((result = m_irrFrequency.Compare(other.m_irrFrequency)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_AdmissionConfirm::GetDataLength() const
{
  PINDEX length = 0;
  length += m_requestSeqNum.GetObjectLength();
  length += m_bandWidth.GetObjectLength();
  length += m_callModel.GetObjectLength();
  length += m_destCallSignalAddress.GetObjectLength();
  if (HasOptionalField(e_irrFrequency))
    length += m_irrFrequency.GetObjectLength();
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  return length;
}


BOOL H225_AdmissionConfirm::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_requestSeqNum.Decode(strm))
    return FALSE;
  if (!m_bandWidth.Decode(strm))
    return FALSE;
  if (!m_callModel.Decode(strm))
    return FALSE;
  if (!m_destCallSignalAddress.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_irrFrequency) && !m_irrFrequency.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_destinationInfo, m_destinationInfo))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_destExtraCallInfo, m_destExtraCallInfo))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_destinationType, m_destinationType))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_remoteExtensionAddress, m_remoteExtensionAddress))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_alternateEndpoints, m_alternateEndpoints))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_tokens, m_tokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_cryptoTokens, m_cryptoTokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_integrityCheckValue, m_integrityCheckValue))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_transportQOS, m_transportQOS))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_willRespondToIRR, m_willRespondToIRR))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_uuiesRequested, m_uuiesRequested))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_language, m_language))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_alternateTransportAddresses, m_alternateTransportAddresses))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_useSpecifiedTransport, m_useSpecifiedTransport))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_circuitInfo, m_circuitInfo))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_usageSpec, m_usageSpec))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_supportedProtocols, m_supportedProtocols))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_serviceControl, m_serviceControl))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_multipleCalls, m_multipleCalls))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_featureSet, m_featureSet))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_genericData, m_genericData))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_modifiedSrcInfo, m_modifiedSrcInfo))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_AdmissionConfirm::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  m_bandWidth.Encode(strm);
  m_callModel.Encode(strm);
  m_destCallSignalAddress.Encode(strm);
  if (HasOptionalField(e_irrFrequency))
    m_irrFrequency.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  KnownExtensionEncode(strm, e_destinationInfo, m_destinationInfo);
  KnownExtensionEncode(strm, e_destExtraCallInfo, m_destExtraCallInfo);
  KnownExtensionEncode(strm, e_destinationType, m_destinationType);
  KnownExtensionEncode(strm, e_remoteExtensionAddress, m_remoteExtensionAddress);
  KnownExtensionEncode(strm, e_alternateEndpoints, m_alternateEndpoints);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);
  KnownExtensionEncode(strm, e_transportQOS, m_transportQOS);
  KnownExtensionEncode(strm, e_willRespondToIRR, m_willRespondToIRR);
  KnownExtensionEncode(strm, e_uuiesRequested, m_uuiesRequested);
  KnownExtensionEncode(strm, e_language, m_language);
  KnownExtensionEncode(strm, e_alternateTransportAddresses, m_alternateTransportAddresses);
  KnownExtensionEncode(strm, e_useSpecifiedTransport, m_useSpecifiedTransport);
  KnownExtensionEncode(strm, e_circuitInfo, m_circuitInfo);
  KnownExtensionEncode(strm, e_usageSpec, m_usageSpec);
  KnownExtensionEncode(strm, e_supportedProtocols, m_supportedProtocols);
  KnownExtensionEncode(strm, e_serviceControl, m_serviceControl);
  KnownExtensionEncode(strm, e_multipleCalls, m_multipleCalls);
  KnownExtensionEncode(strm, e_featureSet, m_featureSet);
  KnownExtensionEncode(strm, e_genericData, m_genericData);
  KnownExtensionEncode(strm, e_modifiedSrcInfo, m_modifiedSrcInfo);

  UnknownExtensionsEncode(strm);
}


PObject * H225_AdmissionConfirm::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_AdmissionConfirm::Class()), PInvalidCast);
#endif
  return new H225_AdmissionConfirm(*this);
}


//
// LocationRequest
//

H225_LocationRequest::H225_LocationRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 16)
{
  IncludeOptionalField(e_canMapAlias);
  m_hopCount.SetConstraints(PASN_Object::FixedConstraint, 1, 255);
  IncludeOptionalField(e_canMapSrcAlias);
}


#ifndef PASN_NOPRINTON
void H225_LocationRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  if (HasOptionalField(e_endpointIdentifier))
    strm << setw(indent+21) << "endpointIdentifier = " << setprecision(indent) << m_endpointIdentifier << '\n';
  strm << setw(indent+18) << "destinationInfo = " << setprecision(indent) << m_destinationInfo << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  strm << setw(indent+15) << "replyAddress = " << setprecision(indent) << m_replyAddress << '\n';
  if (HasOptionalField(e_sourceInfo))
    strm << setw(indent+13) << "sourceInfo = " << setprecision(indent) << m_sourceInfo << '\n';
  if (HasOptionalField(e_canMapAlias))
    strm << setw(indent+14) << "canMapAlias = " << setprecision(indent) << m_canMapAlias << '\n';
  if (HasOptionalField(e_gatekeeperIdentifier))
    strm << setw(indent+23) << "gatekeeperIdentifier = " << setprecision(indent) << m_gatekeeperIdentifier << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  if (HasOptionalField(e_desiredProtocols))
    strm << setw(indent+19) << "desiredProtocols = " << setprecision(indent) << m_desiredProtocols << '\n';
  if (HasOptionalField(e_desiredTunnelledProtocol))
    strm << setw(indent+27) << "desiredTunnelledProtocol = " << setprecision(indent) << m_desiredTunnelledProtocol << '\n';
  if (HasOptionalField(e_featureSet))
    strm << setw(indent+13) << "featureSet = " << setprecision(indent) << m_featureSet << '\n';
  if (HasOptionalField(e_genericData))
    strm << setw(indent+14) << "genericData = " << setprecision(indent) << m_genericData << '\n';
  if (HasOptionalField(e_hopCount))
    strm << setw(indent+11) << "hopCount = " << setprecision(indent) << m_hopCount << '\n';
  if (HasOptionalField(e_circuitInfo))
    strm << setw(indent+14) << "circuitInfo = " << setprecision(indent) << m_circuitInfo << '\n';
  if (HasOptionalField(e_callIdentifier))
    strm << setw(indent+17) << "callIdentifier = " << setprecision(indent) << m_callIdentifier << '\n';
  if (HasOptionalField(e_bandWidth))
    strm << setw(indent+12) << "bandWidth = " << setprecision(indent) << m_bandWidth << '\n';
  if (HasOptionalField(e_sourceEndpointInfo))
    strm << setw(indent+21) << "sourceEndpointInfo = " << setprecision(indent) << m_sourceEndpointInfo << '\n';
  if (HasOptionalField(e_canMapSrcAlias))
    strm << setw(indent+17) << "canMapSrcAlias = " << setprecision(indent) << m_canMapSrcAlias << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_LocationRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_LocationRequest), PInvalidCast);
#endif
  const H225_LocationRequest & other = (const H225_LocationRequest &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_endpointIdentifier.Compare(other.m_endpointIdentifier)) != EqualTo)
    return result;
  if ((result = m_destinationInfo.Compare(other.m_destinationInfo)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_replyAddress.Compare(other.m_replyAddress)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_LocationRequest::GetDataLength() const
{
  PINDEX length = 0;
  length += m_requestSeqNum.GetObjectLength();
  if (HasOptionalField(e_endpointIdentifier))
    length += m_endpointIdentifier.GetObjectLength();
  length += m_destinationInfo.GetObjectLength();
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  length += m_replyAddress.GetObjectLength();
  return length;
}


BOOL H225_LocationRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_requestSeqNum.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_endpointIdentifier) && !m_endpointIdentifier.Decode(strm))
    return FALSE;
  if (!m_destinationInfo.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (!m_replyAddress.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_sourceInfo, m_sourceInfo))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_canMapAlias, m_canMapAlias))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_gatekeeperIdentifier, m_gatekeeperIdentifier))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_tokens, m_tokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_cryptoTokens, m_cryptoTokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_integrityCheckValue, m_integrityCheckValue))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_desiredProtocols, m_desiredProtocols))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_desiredTunnelledProtocol, m_desiredTunnelledProtocol))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_featureSet, m_featureSet))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_genericData, m_genericData))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_hopCount, m_hopCount))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_circuitInfo, m_circuitInfo))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_callIdentifier, m_callIdentifier))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_bandWidth, m_bandWidth))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_sourceEndpointInfo, m_sourceEndpointInfo))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_canMapSrcAlias, m_canMapSrcAlias))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_LocationRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  if (HasOptionalField(e_endpointIdentifier))
    m_endpointIdentifier.Encode(strm);
  m_destinationInfo.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  m_replyAddress.Encode(strm);
  KnownExtensionEncode(strm, e_sourceInfo, m_sourceInfo);
  KnownExtensionEncode(strm, e_canMapAlias, m_canMapAlias);
  KnownExtensionEncode(strm, e_gatekeeperIdentifier, m_gatekeeperIdentifier);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);
  KnownExtensionEncode(strm, e_desiredProtocols, m_desiredProtocols);
  KnownExtensionEncode(strm, e_desiredTunnelledProtocol, m_desiredTunnelledProtocol);
  KnownExtensionEncode(strm, e_featureSet, m_featureSet);
  KnownExtensionEncode(strm, e_genericData, m_genericData);
  KnownExtensionEncode(strm, e_hopCount, m_hopCount);
  KnownExtensionEncode(strm, e_circuitInfo, m_circuitInfo);
  KnownExtensionEncode(strm, e_callIdentifier, m_callIdentifier);
  KnownExtensionEncode(strm, e_bandWidth, m_bandWidth);
  KnownExtensionEncode(strm, e_sourceEndpointInfo, m_sourceEndpointInfo);
  KnownExtensionEncode(strm, e_canMapSrcAlias, m_canMapSrcAlias);

  UnknownExtensionsEncode(strm);
}


PObject * H225_LocationRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_LocationRequest::Class()), PInvalidCast);
#endif
  return new H225_LocationRequest(*this);
}


//
// LocationConfirm
//

H225_LocationConfirm::H225_LocationConfirm(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 17)
{
}


#ifndef PASN_NOPRINTON
void H225_LocationConfirm::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  strm << setw(indent+20) << "callSignalAddress = " << setprecision(indent) << m_callSignalAddress << '\n';
  strm << setw(indent+13) << "rasAddress = " << setprecision(indent) << m_rasAddress << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_destinationInfo))
    strm << setw(indent+18) << "destinationInfo = " << setprecision(indent) << m_destinationInfo << '\n';
  if (HasOptionalField(e_destExtraCallInfo))
    strm << setw(indent+20) << "destExtraCallInfo = " << setprecision(indent) << m_destExtraCallInfo << '\n';
  if (HasOptionalField(e_destinationType))
    strm << setw(indent+18) << "destinationType = " << setprecision(indent) << m_destinationType << '\n';
  if (HasOptionalField(e_remoteExtensionAddress))
    strm << setw(indent+25) << "remoteExtensionAddress = " << setprecision(indent) << m_remoteExtensionAddress << '\n';
  if (HasOptionalField(e_alternateEndpoints))
    strm << setw(indent+21) << "alternateEndpoints = " << setprecision(indent) << m_alternateEndpoints << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  if (HasOptionalField(e_alternateTransportAddresses))
    strm << setw(indent+30) << "alternateTransportAddresses = " << setprecision(indent) << m_alternateTransportAddresses << '\n';
  if (HasOptionalField(e_supportedProtocols))
    strm << setw(indent+21) << "supportedProtocols = " << setprecision(indent) << m_supportedProtocols << '\n';
  if (HasOptionalField(e_multipleCalls))
    strm << setw(indent+16) << "multipleCalls = " << setprecision(indent) << m_multipleCalls << '\n';
  if (HasOptionalField(e_featureSet))
    strm << setw(indent+13) << "featureSet = " << setprecision(indent) << m_featureSet << '\n';
  if (HasOptionalField(e_genericData))
    strm << setw(indent+14) << "genericData = " << setprecision(indent) << m_genericData << '\n';
  if (HasOptionalField(e_circuitInfo))
    strm << setw(indent+14) << "circuitInfo = " << setprecision(indent) << m_circuitInfo << '\n';
  if (HasOptionalField(e_serviceControl))
    strm << setw(indent+17) << "serviceControl = " << setprecision(indent) << m_serviceControl << '\n';
  if (HasOptionalField(e_modifiedSrcInfo))
    strm << setw(indent+18) << "modifiedSrcInfo = " << setprecision(indent) << m_modifiedSrcInfo << '\n';
  if (HasOptionalField(e_bandWidth))
    strm << setw(indent+12) << "bandWidth = " << setprecision(indent) << m_bandWidth << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_LocationConfirm::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_LocationConfirm), PInvalidCast);
#endif
  const H225_LocationConfirm & other = (const H225_LocationConfirm &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_callSignalAddress.Compare(other.m_callSignalAddress)) != EqualTo)
    return result;
  if ((result = m_rasAddress.Compare(other.m_rasAddress)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_LocationConfirm::GetDataLength() const
{
  PINDEX length = 0;
  length += m_requestSeqNum.GetObjectLength();
  length += m_callSignalAddress.GetObjectLength();
  length += m_rasAddress.GetObjectLength();
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  return length;
}


BOOL H225_LocationConfirm::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_requestSeqNum.Decode(strm))
    return FALSE;
  if (!m_callSignalAddress.Decode(strm))
    return FALSE;
  if (!m_rasAddress.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_destinationInfo, m_destinationInfo))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_destExtraCallInfo, m_destExtraCallInfo))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_destinationType, m_destinationType))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_remoteExtensionAddress, m_remoteExtensionAddress))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_alternateEndpoints, m_alternateEndpoints))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_tokens, m_tokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_cryptoTokens, m_cryptoTokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_integrityCheckValue, m_integrityCheckValue))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_alternateTransportAddresses, m_alternateTransportAddresses))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_supportedProtocols, m_supportedProtocols))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_multipleCalls, m_multipleCalls))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_featureSet, m_featureSet))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_genericData, m_genericData))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_circuitInfo, m_circuitInfo))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_serviceControl, m_serviceControl))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_modifiedSrcInfo, m_modifiedSrcInfo))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_bandWidth, m_bandWidth))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_LocationConfirm::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  m_callSignalAddress.Encode(strm);
  m_rasAddress.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  KnownExtensionEncode(strm, e_destinationInfo, m_destinationInfo);
  KnownExtensionEncode(strm, e_destExtraCallInfo, m_destExtraCallInfo);
  KnownExtensionEncode(strm, e_destinationType, m_destinationType);
  KnownExtensionEncode(strm, e_remoteExtensionAddress, m_remoteExtensionAddress);
  KnownExtensionEncode(strm, e_alternateEndpoints, m_alternateEndpoints);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);
  KnownExtensionEncode(strm, e_alternateTransportAddresses, m_alternateTransportAddresses);
  KnownExtensionEncode(strm, e_supportedProtocols, m_supportedProtocols);
  KnownExtensionEncode(strm, e_multipleCalls, m_multipleCalls);
  KnownExtensionEncode(strm, e_featureSet, m_featureSet);
  KnownExtensionEncode(strm, e_genericData, m_genericData);
  KnownExtensionEncode(strm, e_circuitInfo, m_circuitInfo);
  KnownExtensionEncode(strm, e_serviceControl, m_serviceControl);
  KnownExtensionEncode(strm, e_modifiedSrcInfo, m_modifiedSrcInfo);
  KnownExtensionEncode(strm, e_bandWidth, m_bandWidth);

  UnknownExtensionsEncode(strm);
}


PObject * H225_LocationConfirm::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_LocationConfirm::Class()), PInvalidCast);
#endif
  return new H225_LocationConfirm(*this);
}


//
// DisengageRequest
//

H225_DisengageRequest::H225_DisengageRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 13)
{
  IncludeOptionalField(e_callIdentifier);
  IncludeOptionalField(e_answeredCall);
}


#ifndef PASN_NOPRINTON
void H225_DisengageRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  strm << setw(indent+21) << "endpointIdentifier = " << setprecision(indent) << m_endpointIdentifier << '\n';
  strm << setw(indent+15) << "conferenceID = " << setprecision(indent) << m_conferenceID << '\n';
  strm << setw(indent+21) << "callReferenceValue = " << setprecision(indent) << m_callReferenceValue << '\n';
  strm << setw(indent+18) << "disengageReason = " << setprecision(indent) << m_disengageReason << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_callIdentifier))
    strm << setw(indent+17) << "callIdentifier = " << setprecision(indent) << m_callIdentifier << '\n';
  if (HasOptionalField(e_gatekeeperIdentifier))
    strm << setw(indent+23) << "gatekeeperIdentifier = " << setprecision(indent) << m_gatekeeperIdentifier << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  if (HasOptionalField(e_answeredCall))
    strm << setw(indent+15) << "answeredCall = " << setprecision(indent) << m_answeredCall << '\n';
  if (HasOptionalField(e_callLinkage))
    strm << setw(indent+14) << "callLinkage = " << setprecision(indent) << m_callLinkage << '\n';
  if (HasOptionalField(e_capacity))
    strm << setw(indent+11) << "capacity = " << setprecision(indent) << m_capacity << '\n';
  if (HasOptionalField(e_circuitInfo))
    strm << setw(indent+14) << "circuitInfo = " << setprecision(indent) << m_circuitInfo << '\n';
  if (HasOptionalField(e_usageInformation))
    strm << setw(indent+19) << "usageInformation = " << setprecision(indent) << m_usageInformation << '\n';
  if (HasOptionalField(e_terminationCause))
    strm << setw(indent+19) << "terminationCause = " << setprecision(indent) << m_terminationCause << '\n';
  if (HasOptionalField(e_serviceControl))
    strm << setw(indent+17) << "serviceControl = " << setprecision(indent) << m_serviceControl << '\n';
  if (HasOptionalField(e_genericData))
    strm << setw(indent+14) << "genericData = " << setprecision(indent) << m_genericData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_DisengageRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_DisengageRequest), PInvalidCast);
#endif
  const H225_DisengageRequest & other = (const H225_DisengageRequest &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_endpointIdentifier.Compare(other.m_endpointIdentifier)) != EqualTo)
    return result;
  if ((result = m_conferenceID.Compare(other.m_conferenceID)) != EqualTo)
    return result;
  if ((result = m_callReferenceValue.Compare(other.m_callReferenceValue)) != EqualTo)
    return result;
  if ((result = m_disengageReason.Compare(other.m_disengageReason)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_DisengageRequest::GetDataLength() const
{
  PINDEX length = 0;
  length += m_requestSeqNum.GetObjectLength();
  length += m_endpointIdentifier.GetObjectLength();
  length += m_conferenceID.GetObjectLength();
  length += m_callReferenceValue.GetObjectLength();
  length += m_disengageReason.GetObjectLength();
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  return length;
}


BOOL H225_DisengageRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_requestSeqNum.Decode(strm))
    return FALSE;
  if (!m_endpointIdentifier.Decode(strm))
    return FALSE;
  if (!m_conferenceID.Decode(strm))
    return FALSE;
  if (!m_callReferenceValue.Decode(strm))
    return FALSE;
  if (!m_disengageReason.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_callIdentifier, m_callIdentifier))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_gatekeeperIdentifier, m_gatekeeperIdentifier))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_tokens, m_tokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_cryptoTokens, m_cryptoTokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_integrityCheckValue, m_integrityCheckValue))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_answeredCall, m_answeredCall))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_callLinkage, m_callLinkage))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_capacity, m_capacity))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_circuitInfo, m_circuitInfo))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_usageInformation, m_usageInformation))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_terminationCause, m_terminationCause))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_serviceControl, m_serviceControl))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_genericData, m_genericData))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_DisengageRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  m_endpointIdentifier.Encode(strm);
  m_conferenceID.Encode(strm);
  m_callReferenceValue.Encode(strm);
  m_disengageReason.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  KnownExtensionEncode(strm, e_callIdentifier, m_callIdentifier);
  KnownExtensionEncode(strm, e_gatekeeperIdentifier, m_gatekeeperIdentifier);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);
  KnownExtensionEncode(strm, e_answeredCall, m_answeredCall);
  KnownExtensionEncode(strm, e_callLinkage, m_callLinkage);
  KnownExtensionEncode(strm, e_capacity, m_capacity);
  KnownExtensionEncode(strm, e_circuitInfo, m_circuitInfo);
  KnownExtensionEncode(strm, e_usageInformation, m_usageInformation);
  KnownExtensionEncode(strm, e_terminationCause, m_terminationCause);
  KnownExtensionEncode(strm, e_serviceControl, m_serviceControl);
  KnownExtensionEncode(strm, e_genericData, m_genericData);

  UnknownExtensionsEncode(strm);
}


PObject * H225_DisengageRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_DisengageRequest::Class()), PInvalidCast);
#endif
  return new H225_DisengageRequest(*this);
}


//
// DisengageConfirm
//

H225_DisengageConfirm::H225_DisengageConfirm(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 7)
{
}


#ifndef PASN_NOPRINTON
void H225_DisengageConfirm::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  if (HasOptionalField(e_capacity))
    strm << setw(indent+11) << "capacity = " << setprecision(indent) << m_capacity << '\n';
  if (HasOptionalField(e_circuitInfo))
    strm << setw(indent+14) << "circuitInfo = " << setprecision(indent) << m_circuitInfo << '\n';
  if (HasOptionalField(e_usageInformation))
    strm << setw(indent+19) << "usageInformation = " << setprecision(indent) << m_usageInformation << '\n';
  if (HasOptionalField(e_genericData))
    strm << setw(indent+14) << "genericData = " << setprecision(indent) << m_genericData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_DisengageConfirm::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_DisengageConfirm), PInvalidCast);
#endif
  const H225_DisengageConfirm & other = (const H225_DisengageConfirm &)obj;

  Comparison result;

  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_DisengageConfirm::GetDataLength() const
{
  PINDEX length = 0;
  length += m_requestSeqNum.GetObjectLength();
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  return length;
}


BOOL H225_DisengageConfirm::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_requestSeqNum.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_tokens, m_tokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_cryptoTokens, m_cryptoTokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_integrityCheckValue, m_integrityCheckValue))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_capacity, m_capacity))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_circuitInfo, m_circuitInfo))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_usageInformation, m_usageInformation))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_genericData, m_genericData))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_DisengageConfirm::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_requestSeqNum.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);
  KnownExtensionEncode(strm, e_capacity, m_capacity);
  KnownExtensionEncode(strm, e_circuitInfo, m_circuitInfo);
  KnownExtensionEncode(strm, e_usageInformation, m_usageInformation);
  KnownExtensionEncode(strm, e_genericData, m_genericData);

  UnknownExtensionsEncode(strm);
}


PObject * H225_DisengageConfirm::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_DisengageConfirm::Class()), PInvalidCast);
#endif
  return new H225_DisengageConfirm(*this);
}


//
// InfoRequestResponse
//

H225_InfoRequestResponse::H225_InfoRequestResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 8)
{
  IncludeOptionalField(e_needResponse);
  IncludeOptionalField(e_unsolicited);
}


#ifndef PASN_NOPRINTON
void H225_InfoRequestResponse::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  strm << setw(indent+16) << "requestSeqNum = " << setprecision(indent) << m_requestSeqNum << '\n';
  strm << setw(indent+15) << "endpointType = " << setprecision(indent) << m_endpointType << '\n';
  strm << setw(indent+21) << "endpointIdentifier = " << setprecision(indent) << m_endpointIdentifier << '\n';
  strm << setw(indent+13) << "rasAddress = " << setprecision(indent) << m_rasAddress << '\n';
  strm << setw(indent+20) << "callSignalAddress = " << setprecision(indent) << m_callSignalAddress << '\n';
  if (HasOptionalField(e_endpointAlias))
    strm << setw(indent+16) << "endpointAlias = " << setprecision(indent) << m_endpointAlias << '\n';
  if (HasOptionalField(e_perCallInfo))
    strm << setw(indent+14) << "perCallInfo = " << setprecision(indent) << m_perCallInfo << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  if (HasOptionalField(e_needResponse))
    strm << setw(indent+15) << "needResponse = " << setprecision(indent) << m_needResponse << '\n';
  if (HasOptionalField(e_capacity))
    strm << setw(indent+11) << "capacity = " << setprecision(indent) << m_capacity << '\n';
  if (HasOptionalField(e_irrStatus))
    strm << setw(indent+12) << "irrStatus = " << setprecision(indent) << m_irrStatus << '\n';
  if (HasOptionalField(e_unsolicited))
    strm << setw(indent+14) << "unsolicited = " << setprecision(indent) << m_unsolicited << '\n';
  if (HasOptionalField(e_genericData))
    strm << setw(indent+14) << "genericData = " << setprecision(indent) << m_genericData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_InfoRequestResponse::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_InfoRequestResponse), PInvalidCast);
#endif
  const H225_InfoRequestResponse & other = (const H225_InfoRequestResponse &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_requestSeqNum.Compare(other.m_requestSeqNum)) != EqualTo)
    return result;
  if ((result = m_endpointType.Compare(other.m_endpointType)) != EqualTo)
    return result;
  if ((result = m_endpointIdentifier.Compare(other.m_endpointIdentifier)) != EqualTo)
    return result;
  if ((result = m_rasAddress.Compare(other.m_rasAddress)) != EqualTo)
    return result;
  if ((result = m_callSignalAddress.Compare(other.m_callSignalAddress)) != EqualTo)
    return result;
  if ((result = m_endpointAlias.Compare(other.m_endpointAlias)) != EqualTo)
    return result;
  if ((result = m_perCallInfo.Compare(other.m_perCallInfo)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_InfoRequestResponse::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  length += m_requestSeqNum.GetObjectLength();
  length += m_endpointType.GetObjectLength();
  length += m_endpointIdentifier.GetObjectLength();
  length += m_rasAddress.GetObjectLength();
  length += m_callSignalAddress.GetObjectLength();
  if (HasOptionalField(e_endpointAlias))
    length += m_endpointAlias.GetObjectLength();
  if (HasOptionalField(e_perCallInfo))
    length += m_perCallInfo.GetObjectLength();
  return length;
}


BOOL H225_InfoRequestResponse::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (!m_requestSeqNum.Decode(strm))
    return FALSE;
  if (!m_endpointType.Decode(strm))
    return FALSE;
  if (!m_endpointIdentifier.Decode(strm))
    return FALSE;
  if (!m_rasAddress.Decode(strm))
    return FALSE;
  if (!m_callSignalAddress.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_endpointAlias) && !m_endpointAlias.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_perCallInfo) && !m_perCallInfo.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_tokens, m_tokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_cryptoTokens, m_cryptoTokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_integrityCheckValue, m_integrityCheckValue))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_needResponse, m_needResponse))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_capacity, m_capacity))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_irrStatus, m_irrStatus))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_unsolicited, m_unsolicited))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_genericData, m_genericData))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_InfoRequestResponse::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  m_requestSeqNum.Encode(strm);
  m_endpointType.Encode(strm);
  m_endpointIdentifier.Encode(strm);
  m_rasAddress.Encode(strm);
  m_callSignalAddress.Encode(strm);
  if (HasOptionalField(e_endpointAlias))
    m_endpointAlias.Encode(strm);
  if (HasOptionalField(e_perCallInfo))
    m_perCallInfo.Encode(strm);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_integrityCheckValue, m_integrityCheckValue);
  KnownExtensionEncode(strm, e_needResponse, m_needResponse);
  KnownExtensionEncode(strm, e_capacity, m_capacity);
  KnownExtensionEncode(strm, e_irrStatus, m_irrStatus);
  KnownExtensionEncode(strm, e_unsolicited, m_unsolicited);
  KnownExtensionEncode(strm, e_genericData, m_genericData);

  UnknownExtensionsEncode(strm);
}


PObject * H225_InfoRequestResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_InfoRequestResponse::Class()), PInvalidCast);
#endif
  return new H225_InfoRequestResponse(*this);
}


//
// InfoRequestResponse_perCallInfo_subtype
//

H225_InfoRequestResponse_perCallInfo_subtype::H225_InfoRequestResponse_perCallInfo_subtype(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 5, TRUE, 8)
{
  IncludeOptionalField(e_callIdentifier);
  IncludeOptionalField(e_substituteConfIDs);
}


#ifndef PASN_NOPRINTON
void H225_InfoRequestResponse_perCallInfo_subtype::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  strm << setw(indent+21) << "callReferenceValue = " << setprecision(indent) << m_callReferenceValue << '\n';
  strm << setw(indent+15) << "conferenceID = " << setprecision(indent) << m_conferenceID << '\n';
  if (HasOptionalField(e_originator))
    strm << setw(indent+13) << "originator = " << setprecision(indent) << m_originator << '\n';
  if (HasOptionalField(e_audio))
    strm << setw(indent+8) << "audio = " << setprecision(indent) << m_audio << '\n';
  if (HasOptionalField(e_video))
    strm << setw(indent+8) << "video = " << setprecision(indent) << m_video << '\n';
  if (HasOptionalField(e_data))
    strm << setw(indent+7) << "data = " << setprecision(indent) << m_data << '\n';
  strm << setw(indent+7) << "h245 = " << setprecision(indent) << m_h245 << '\n';
  strm << setw(indent+16) << "callSignaling = " << setprecision(indent) << m_callSignaling << '\n';
  strm << setw(indent+11) << "callType = " << setprecision(indent) << m_callType << '\n';
  strm << setw(indent+12) << "bandWidth = " << setprecision(indent) << m_bandWidth << '\n';
  strm << setw(indent+12) << "callModel = " << setprecision(indent) << m_callModel << '\n';
  if (HasOptionalField(e_callIdentifier))
    strm << setw(indent+17) << "callIdentifier = " << setprecision(indent) << m_callIdentifier << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_substituteConfIDs))
    strm << setw(indent+20) << "substituteConfIDs = " << setprecision(indent) << m_substituteConfIDs << '\n';
  if (HasOptionalField(e_pdu))
    strm << setw(indent+6) << "pdu = " << setprecision(indent) << m_pdu << '\n';
  if (HasOptionalField(e_callLinkage))
    strm << setw(indent+14) << "callLinkage = " << setprecision(indent) << m_callLinkage << '\n';
  if (HasOptionalField(e_usageInformation))
    strm << setw(indent+19) << "usageInformation = " << setprecision(indent) << m_usageInformation << '\n';
  if (HasOptionalField(e_circuitInfo))
    strm << setw(indent+14) << "circuitInfo = " << setprecision(indent) << m_circuitInfo << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_InfoRequestResponse_perCallInfo_subtype::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_InfoRequestResponse_perCallInfo_subtype), PInvalidCast);
#endif
  const H225_InfoRequestResponse_perCallInfo_subtype & other = (const H225_InfoRequestResponse_perCallInfo_subtype &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_callReferenceValue.Compare(other.m_callReferenceValue)) != EqualTo)
    return result;
  if ((result = m_conferenceID.Compare(other.m_conferenceID)) != EqualTo)
    return result;
  if ((result = m_originator.Compare(other.m_originator)) != EqualTo)
    return result;
  if ((result = m_audio.Compare(other.m_audio)) != EqualTo)
    return result;
  if ((result = m_video.Compare(other.m_video)) != EqualTo)
    return result;
  if ((result = m_data.Compare(other.m_data)) != EqualTo)
    return result;
  if ((result = m_h245.Compare(other.m_h245)) != EqualTo)
    return result;
  if ((result = m_callSignaling.Compare(other.m_callSignaling)) != EqualTo)
    return result;
  if ((result = m_callType.Compare(other.m_callType)) != EqualTo)
    return result;
  if ((result = m_bandWidth.Compare(other.m_bandWidth)) != EqualTo)
    return result;
  if ((result = m_callModel.Compare(other.m_callModel)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_InfoRequestResponse_perCallInfo_subtype::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  length += m_callReferenceValue.GetObjectLength();
  length += m_conferenceID.GetObjectLength();
  if (HasOptionalField(e_originator))
    length += m_originator.GetObjectLength();
  if (HasOptionalField(e_audio))
    length += m_audio.GetObjectLength();
  if (HasOptionalField(e_video))
    length += m_video.GetObjectLength();
  if (HasOptionalField(e_data))
    length += m_data.GetObjectLength();
  length += m_h245.GetObjectLength();
  length += m_callSignaling.GetObjectLength();
  length += m_callType.GetObjectLength();
  length += m_bandWidth.GetObjectLength();
  length += m_callModel.GetObjectLength();
  return length;
}


BOOL H225_InfoRequestResponse_perCallInfo_subtype::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (!m_callReferenceValue.Decode(strm))
    return FALSE;
  if (!m_conferenceID.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_originator) && !m_originator.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_audio) && !m_audio.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_video) && !m_video.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_data) && !m_data.Decode(strm))
    return FALSE;
  if (!m_h245.Decode(strm))
    return FALSE;
  if (!m_callSignaling.Decode(strm))
    return FALSE;
  if (!m_callType.Decode(strm))
    return FALSE;
  if (!m_bandWidth.Decode(strm))
    return FALSE;
  if (!m_callModel.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_callIdentifier, m_callIdentifier))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_tokens, m_tokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_cryptoTokens, m_cryptoTokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_substituteConfIDs, m_substituteConfIDs))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_pdu, m_pdu))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_callLinkage, m_callLinkage))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_usageInformation, m_usageInformation))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_circuitInfo, m_circuitInfo))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_InfoRequestResponse_perCallInfo_subtype::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  m_callReferenceValue.Encode(strm);
  m_conferenceID.Encode(strm);
  if (HasOptionalField(e_originator))
    m_originator.Encode(strm);
  if (HasOptionalField(e_audio))
    m_audio.Encode(strm);
  if (HasOptionalField(e_video))
    m_video.Encode(strm);
  if (HasOptionalField(e_data))
    m_data.Encode(strm);
  m_h245.Encode(strm);
  m_callSignaling.Encode(strm);
  m_callType.Encode(strm);
  m_bandWidth.Encode(strm);
  m_callModel.Encode(strm);
  KnownExtensionEncode(strm, e_callIdentifier, m_callIdentifier);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_substituteConfIDs, m_substituteConfIDs);
  KnownExtensionEncode(strm, e_pdu, m_pdu);
  KnownExtensionEncode(strm, e_callLinkage, m_callLinkage);
  KnownExtensionEncode(strm, e_usageInformation, m_usageInformation);
  KnownExtensionEncode(strm, e_circuitInfo, m_circuitInfo);

  UnknownExtensionsEncode(strm);
}


PObject * H225_InfoRequestResponse_perCallInfo_subtype::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_InfoRequestResponse_perCallInfo_subtype::Class()), PInvalidCast);
#endif
  return new H225_InfoRequestResponse_perCallInfo_subtype(*this);
}


//
// InfoRequestResponse_perCallInfo_subtype_pdu_subtype
//

H225_InfoRequestResponse_perCallInfo_subtype_pdu_subtype::H225_InfoRequestResponse_perCallInfo_subtype_pdu_subtype(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_InfoRequestResponse_perCallInfo_subtype_pdu_subtype::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+10) << "h323pdu = " << setprecision(indent) << m_h323pdu << '\n';
  strm << setw(indent+7) << "sent = " << setprecision(indent) << m_sent << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_InfoRequestResponse_perCallInfo_subtype_pdu_subtype::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_InfoRequestResponse_perCallInfo_subtype_pdu_subtype), PInvalidCast);
#endif
  const H225_InfoRequestResponse_perCallInfo_subtype_pdu_subtype & other = (const H225_InfoRequestResponse_perCallInfo_subtype_pdu_subtype &)obj;

  Comparison result;

  if ((result = m_h323pdu.Compare(other.m_h323pdu)) != EqualTo)
    return result;
  if ((result = m_sent.Compare(other.m_sent)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_InfoRequestResponse_perCallInfo_subtype_pdu_subtype::GetDataLength() const
{
  PINDEX length = 0;
  length += m_h323pdu.GetObjectLength();
  length += m_sent.GetObjectLength();
  return length;
}


BOOL H225_InfoRequestResponse_perCallInfo_subtype_pdu_subtype::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_h323pdu.Decode(strm))
    return FALSE;
  if (!m_sent.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_InfoRequestResponse_perCallInfo_subtype_pdu_subtype::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_h323pdu.Encode(strm);
  m_sent.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_InfoRequestResponse_perCallInfo_subtype_pdu_subtype::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_InfoRequestResponse_perCallInfo_subtype_pdu_subtype::Class()), PInvalidCast);
#endif
  return new H225_InfoRequestResponse_perCallInfo_subtype_pdu_subtype(*this);
}


//
// H323-UserInformation
//

H225_H323_UserInformation::H225_H323_UserInformation(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H225_H323_UserInformation::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+14) << "h323_uu_pdu = " << setprecision(indent) << m_h323_uu_pdu << '\n';
  if (HasOptionalField(e_user_data))
    strm << setw(indent+12) << "user_data = " << setprecision(indent) << m_user_data << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_H323_UserInformation::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_H323_UserInformation), PInvalidCast);
#endif
  const H225_H323_UserInformation & other = (const H225_H323_UserInformation &)obj;

  Comparison result;

  if ((result = m_h323_uu_pdu.Compare(other.m_h323_uu_pdu)) != EqualTo)
    return result;
  if ((result = m_user_data.Compare(other.m_user_data)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_H323_UserInformation::GetDataLength() const
{
  PINDEX length = 0;
  length += m_h323_uu_pdu.GetObjectLength();
  if (HasOptionalField(e_user_data))
    length += m_user_data.GetObjectLength();
  return length;
}


BOOL H225_H323_UserInformation::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_h323_uu_pdu.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_user_data) && !m_user_data.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_H323_UserInformation::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_h323_uu_pdu.Encode(strm);
  if (HasOptionalField(e_user_data))
    m_user_data.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H225_H323_UserInformation::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_H323_UserInformation::Class()), PInvalidCast);
#endif
  return new H225_H323_UserInformation(*this);
}


//
// Alerting-UUIE
//

H225_Alerting_UUIE::H225_Alerting_UUIE(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 14)
{
  IncludeOptionalField(e_callIdentifier);
  IncludeOptionalField(e_multipleCalls);
  IncludeOptionalField(e_maintainConnection);
}


#ifndef PASN_NOPRINTON
void H225_Alerting_UUIE::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+21) << "protocolIdentifier = " << setprecision(indent) << m_protocolIdentifier << '\n';
  strm << setw(indent+18) << "destinationInfo = " << setprecision(indent) << m_destinationInfo << '\n';
  if (HasOptionalField(e_h245Address))
    strm << setw(indent+14) << "h245Address = " << setprecision(indent) << m_h245Address << '\n';
  if (HasOptionalField(e_callIdentifier))
    strm << setw(indent+17) << "callIdentifier = " << setprecision(indent) << m_callIdentifier << '\n';
  if (HasOptionalField(e_h245SecurityMode))
    strm << setw(indent+19) << "h245SecurityMode = " << setprecision(indent) << m_h245SecurityMode << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_fastStart))
    strm << setw(indent+12) << "fastStart = " << setprecision(indent) << m_fastStart << '\n';
  if (HasOptionalField(e_multipleCalls))
    strm << setw(indent+16) << "multipleCalls = " << setprecision(indent) << m_multipleCalls << '\n';
  if (HasOptionalField(e_maintainConnection))
    strm << setw(indent+21) << "maintainConnection = " << setprecision(indent) << m_maintainConnection << '\n';
  if (HasOptionalField(e_alertingAddress))
    strm << setw(indent+18) << "alertingAddress = " << setprecision(indent) << m_alertingAddress << '\n';
  if (HasOptionalField(e_presentationIndicator))
    strm << setw(indent+24) << "presentationIndicator = " << setprecision(indent) << m_presentationIndicator << '\n';
  if (HasOptionalField(e_screeningIndicator))
    strm << setw(indent+21) << "screeningIndicator = " << setprecision(indent) << m_screeningIndicator << '\n';
  if (HasOptionalField(e_fastConnectRefused))
    strm << setw(indent+21) << "fastConnectRefused = " << setprecision(indent) << m_fastConnectRefused << '\n';
  if (HasOptionalField(e_serviceControl))
    strm << setw(indent+17) << "serviceControl = " << setprecision(indent) << m_serviceControl << '\n';
  if (HasOptionalField(e_capacity))
    strm << setw(indent+11) << "capacity = " << setprecision(indent) << m_capacity << '\n';
  if (HasOptionalField(e_featureSet))
    strm << setw(indent+13) << "featureSet = " << setprecision(indent) << m_featureSet << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_Alerting_UUIE::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_Alerting_UUIE), PInvalidCast);
#endif
  const H225_Alerting_UUIE & other = (const H225_Alerting_UUIE &)obj;

  Comparison result;

  if ((result = m_protocolIdentifier.Compare(other.m_protocolIdentifier)) != EqualTo)
    return result;
  if ((result = m_destinationInfo.Compare(other.m_destinationInfo)) != EqualTo)
    return result;
  if ((result = m_h245Address.Compare(other.m_h245Address)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_Alerting_UUIE::GetDataLength() const
{
  PINDEX length = 0;
  length += m_protocolIdentifier.GetObjectLength();
  length += m_destinationInfo.GetObjectLength();
  if (HasOptionalField(e_h245Address))
    length += m_h245Address.GetObjectLength();
  return length;
}


BOOL H225_Alerting_UUIE::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_protocolIdentifier.Decode(strm))
    return FALSE;
  if (!m_destinationInfo.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_h245Address) && !m_h245Address.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_callIdentifier, m_callIdentifier))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_h245SecurityMode, m_h245SecurityMode))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_tokens, m_tokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_cryptoTokens, m_cryptoTokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_fastStart, m_fastStart))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_multipleCalls, m_multipleCalls))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_maintainConnection, m_maintainConnection))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_alertingAddress, m_alertingAddress))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_presentationIndicator, m_presentationIndicator))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_screeningIndicator, m_screeningIndicator))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_fastConnectRefused, m_fastConnectRefused))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_serviceControl, m_serviceControl))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_capacity, m_capacity))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_featureSet, m_featureSet))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_Alerting_UUIE::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_protocolIdentifier.Encode(strm);
  m_destinationInfo.Encode(strm);
  if (HasOptionalField(e_h245Address))
    m_h245Address.Encode(strm);
  KnownExtensionEncode(strm, e_callIdentifier, m_callIdentifier);
  KnownExtensionEncode(strm, e_h245SecurityMode, m_h245SecurityMode);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_fastStart, m_fastStart);
  KnownExtensionEncode(strm, e_multipleCalls, m_multipleCalls);
  KnownExtensionEncode(strm, e_maintainConnection, m_maintainConnection);
  KnownExtensionEncode(strm, e_alertingAddress, m_alertingAddress);
  KnownExtensionEncode(strm, e_presentationIndicator, m_presentationIndicator);
  KnownExtensionEncode(strm, e_screeningIndicator, m_screeningIndicator);
  KnownExtensionEncode(strm, e_fastConnectRefused, m_fastConnectRefused);
  KnownExtensionEncode(strm, e_serviceControl, m_serviceControl);
  KnownExtensionEncode(strm, e_capacity, m_capacity);
  KnownExtensionEncode(strm, e_featureSet, m_featureSet);

  UnknownExtensionsEncode(strm);
}


PObject * H225_Alerting_UUIE::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_Alerting_UUIE::Class()), PInvalidCast);
#endif
  return new H225_Alerting_UUIE(*this);
}


//
// CallProceeding-UUIE
//

H225_CallProceeding_UUIE::H225_CallProceeding_UUIE(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 9)
{
  IncludeOptionalField(e_callIdentifier);
  IncludeOptionalField(e_multipleCalls);
  IncludeOptionalField(e_maintainConnection);
}


#ifndef PASN_NOPRINTON
void H225_CallProceeding_UUIE::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+21) << "protocolIdentifier = " << setprecision(indent) << m_protocolIdentifier << '\n';
  strm << setw(indent+18) << "destinationInfo = " << setprecision(indent) << m_destinationInfo << '\n';
  if (HasOptionalField(e_h245Address))
    strm << setw(indent+14) << "h245Address = " << setprecision(indent) << m_h245Address << '\n';
  if (HasOptionalField(e_callIdentifier))
    strm << setw(indent+17) << "callIdentifier = " << setprecision(indent) << m_callIdentifier << '\n';
  if (HasOptionalField(e_h245SecurityMode))
    strm << setw(indent+19) << "h245SecurityMode = " << setprecision(indent) << m_h245SecurityMode << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_fastStart))
    strm << setw(indent+12) << "fastStart = " << setprecision(indent) << m_fastStart << '\n';
  if (HasOptionalField(e_multipleCalls))
    strm << setw(indent+16) << "multipleCalls = " << setprecision(indent) << m_multipleCalls << '\n';
  if (HasOptionalField(e_maintainConnection))
    strm << setw(indent+21) << "maintainConnection = " << setprecision(indent) << m_maintainConnection << '\n';
  if (HasOptionalField(e_fastConnectRefused))
    strm << setw(indent+21) << "fastConnectRefused = " << setprecision(indent) << m_fastConnectRefused << '\n';
  if (HasOptionalField(e_featureSet))
    strm << setw(indent+13) << "featureSet = " << setprecision(indent) << m_featureSet << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_CallProceeding_UUIE::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_CallProceeding_UUIE), PInvalidCast);
#endif
  const H225_CallProceeding_UUIE & other = (const H225_CallProceeding_UUIE &)obj;

  Comparison result;

  if ((result = m_protocolIdentifier.Compare(other.m_protocolIdentifier)) != EqualTo)
    return result;
  if ((result = m_destinationInfo.Compare(other.m_destinationInfo)) != EqualTo)
    return result;
  if ((result = m_h245Address.Compare(other.m_h245Address)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_CallProceeding_UUIE::GetDataLength() const
{
  PINDEX length = 0;
  length += m_protocolIdentifier.GetObjectLength();
  length += m_destinationInfo.GetObjectLength();
  if (HasOptionalField(e_h245Address))
    length += m_h245Address.GetObjectLength();
  return length;
}


BOOL H225_CallProceeding_UUIE::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_protocolIdentifier.Decode(strm))
    return FALSE;
  if (!m_destinationInfo.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_h245Address) && !m_h245Address.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_callIdentifier, m_callIdentifier))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_h245SecurityMode, m_h245SecurityMode))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_tokens, m_tokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_cryptoTokens, m_cryptoTokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_fastStart, m_fastStart))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_multipleCalls, m_multipleCalls))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_maintainConnection, m_maintainConnection))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_fastConnectRefused, m_fastConnectRefused))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_featureSet, m_featureSet))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_CallProceeding_UUIE::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_protocolIdentifier.Encode(strm);
  m_destinationInfo.Encode(strm);
  if (HasOptionalField(e_h245Address))
    m_h245Address.Encode(strm);
  KnownExtensionEncode(strm, e_callIdentifier, m_callIdentifier);
  KnownExtensionEncode(strm, e_h245SecurityMode, m_h245SecurityMode);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_fastStart, m_fastStart);
  KnownExtensionEncode(strm, e_multipleCalls, m_multipleCalls);
  KnownExtensionEncode(strm, e_maintainConnection, m_maintainConnection);
  KnownExtensionEncode(strm, e_fastConnectRefused, m_fastConnectRefused);
  KnownExtensionEncode(strm, e_featureSet, m_featureSet);

  UnknownExtensionsEncode(strm);
}


PObject * H225_CallProceeding_UUIE::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_CallProceeding_UUIE::Class()), PInvalidCast);
#endif
  return new H225_CallProceeding_UUIE(*this);
}


//
// Connect-UUIE
//

H225_Connect_UUIE::H225_Connect_UUIE(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 15)
{
  IncludeOptionalField(e_callIdentifier);
  IncludeOptionalField(e_multipleCalls);
  IncludeOptionalField(e_maintainConnection);
}


#ifndef PASN_NOPRINTON
void H225_Connect_UUIE::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+21) << "protocolIdentifier = " << setprecision(indent) << m_protocolIdentifier << '\n';
  if (HasOptionalField(e_h245Address))
    strm << setw(indent+14) << "h245Address = " << setprecision(indent) << m_h245Address << '\n';
  strm << setw(indent+18) << "destinationInfo = " << setprecision(indent) << m_destinationInfo << '\n';
  strm << setw(indent+15) << "conferenceID = " << setprecision(indent) << m_conferenceID << '\n';
  if (HasOptionalField(e_callIdentifier))
    strm << setw(indent+17) << "callIdentifier = " << setprecision(indent) << m_callIdentifier << '\n';
  if (HasOptionalField(e_h245SecurityMode))
    strm << setw(indent+19) << "h245SecurityMode = " << setprecision(indent) << m_h245SecurityMode << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_fastStart))
    strm << setw(indent+12) << "fastStart = " << setprecision(indent) << m_fastStart << '\n';
  if (HasOptionalField(e_multipleCalls))
    strm << setw(indent+16) << "multipleCalls = " << setprecision(indent) << m_multipleCalls << '\n';
  if (HasOptionalField(e_maintainConnection))
    strm << setw(indent+21) << "maintainConnection = " << setprecision(indent) << m_maintainConnection << '\n';
  if (HasOptionalField(e_language))
    strm << setw(indent+11) << "language = " << setprecision(indent) << m_language << '\n';
  if (HasOptionalField(e_connectedAddress))
    strm << setw(indent+19) << "connectedAddress = " << setprecision(indent) << m_connectedAddress << '\n';
  if (HasOptionalField(e_presentationIndicator))
    strm << setw(indent+24) << "presentationIndicator = " << setprecision(indent) << m_presentationIndicator << '\n';
  if (HasOptionalField(e_screeningIndicator))
    strm << setw(indent+21) << "screeningIndicator = " << setprecision(indent) << m_screeningIndicator << '\n';
  if (HasOptionalField(e_fastConnectRefused))
    strm << setw(indent+21) << "fastConnectRefused = " << setprecision(indent) << m_fastConnectRefused << '\n';
  if (HasOptionalField(e_serviceControl))
    strm << setw(indent+17) << "serviceControl = " << setprecision(indent) << m_serviceControl << '\n';
  if (HasOptionalField(e_capacity))
    strm << setw(indent+11) << "capacity = " << setprecision(indent) << m_capacity << '\n';
  if (HasOptionalField(e_featureSet))
    strm << setw(indent+13) << "featureSet = " << setprecision(indent) << m_featureSet << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_Connect_UUIE::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_Connect_UUIE), PInvalidCast);
#endif
  const H225_Connect_UUIE & other = (const H225_Connect_UUIE &)obj;

  Comparison result;

  if ((result = m_protocolIdentifier.Compare(other.m_protocolIdentifier)) != EqualTo)
    return result;
  if ((result = m_h245Address.Compare(other.m_h245Address)) != EqualTo)
    return result;
  if ((result = m_destinationInfo.Compare(other.m_destinationInfo)) != EqualTo)
    return result;
  if ((result = m_conferenceID.Compare(other.m_conferenceID)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_Connect_UUIE::GetDataLength() const
{
  PINDEX length = 0;
  length += m_protocolIdentifier.GetObjectLength();
  if (HasOptionalField(e_h245Address))
    length += m_h245Address.GetObjectLength();
  length += m_destinationInfo.GetObjectLength();
  length += m_conferenceID.GetObjectLength();
  return length;
}


BOOL H225_Connect_UUIE::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_protocolIdentifier.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_h245Address) && !m_h245Address.Decode(strm))
    return FALSE;
  if (!m_destinationInfo.Decode(strm))
    return FALSE;
  if (!m_conferenceID.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_callIdentifier, m_callIdentifier))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_h245SecurityMode, m_h245SecurityMode))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_tokens, m_tokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_cryptoTokens, m_cryptoTokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_fastStart, m_fastStart))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_multipleCalls, m_multipleCalls))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_maintainConnection, m_maintainConnection))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_language, m_language))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_connectedAddress, m_connectedAddress))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_presentationIndicator, m_presentationIndicator))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_screeningIndicator, m_screeningIndicator))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_fastConnectRefused, m_fastConnectRefused))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_serviceControl, m_serviceControl))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_capacity, m_capacity))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_featureSet, m_featureSet))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_Connect_UUIE::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_protocolIdentifier.Encode(strm);
  if (HasOptionalField(e_h245Address))
    m_h245Address.Encode(strm);
  m_destinationInfo.Encode(strm);
  m_conferenceID.Encode(strm);
  KnownExtensionEncode(strm, e_callIdentifier, m_callIdentifier);
  KnownExtensionEncode(strm, e_h245SecurityMode, m_h245SecurityMode);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_fastStart, m_fastStart);
  KnownExtensionEncode(strm, e_multipleCalls, m_multipleCalls);
  KnownExtensionEncode(strm, e_maintainConnection, m_maintainConnection);
  KnownExtensionEncode(strm, e_language, m_language);
  KnownExtensionEncode(strm, e_connectedAddress, m_connectedAddress);
  KnownExtensionEncode(strm, e_presentationIndicator, m_presentationIndicator);
  KnownExtensionEncode(strm, e_screeningIndicator, m_screeningIndicator);
  KnownExtensionEncode(strm, e_fastConnectRefused, m_fastConnectRefused);
  KnownExtensionEncode(strm, e_serviceControl, m_serviceControl);
  KnownExtensionEncode(strm, e_capacity, m_capacity);
  KnownExtensionEncode(strm, e_featureSet, m_featureSet);

  UnknownExtensionsEncode(strm);
}


PObject * H225_Connect_UUIE::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_Connect_UUIE::Class()), PInvalidCast);
#endif
  return new H225_Connect_UUIE(*this);
}


//
// Information-UUIE
//

H225_Information_UUIE::H225_Information_UUIE(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 6)
{
  IncludeOptionalField(e_callIdentifier);
}


#ifndef PASN_NOPRINTON
void H225_Information_UUIE::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+21) << "protocolIdentifier = " << setprecision(indent) << m_protocolIdentifier << '\n';
  if (HasOptionalField(e_callIdentifier))
    strm << setw(indent+17) << "callIdentifier = " << setprecision(indent) << m_callIdentifier << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_fastStart))
    strm << setw(indent+12) << "fastStart = " << setprecision(indent) << m_fastStart << '\n';
  if (HasOptionalField(e_fastConnectRefused))
    strm << setw(indent+21) << "fastConnectRefused = " << setprecision(indent) << m_fastConnectRefused << '\n';
  if (HasOptionalField(e_circuitInfo))
    strm << setw(indent+14) << "circuitInfo = " << setprecision(indent) << m_circuitInfo << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_Information_UUIE::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_Information_UUIE), PInvalidCast);
#endif
  const H225_Information_UUIE & other = (const H225_Information_UUIE &)obj;

  Comparison result;

  if ((result = m_protocolIdentifier.Compare(other.m_protocolIdentifier)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_Information_UUIE::GetDataLength() const
{
  PINDEX length = 0;
  length += m_protocolIdentifier.GetObjectLength();
  return length;
}


BOOL H225_Information_UUIE::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_protocolIdentifier.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_callIdentifier, m_callIdentifier))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_tokens, m_tokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_cryptoTokens, m_cryptoTokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_fastStart, m_fastStart))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_fastConnectRefused, m_fastConnectRefused))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_circuitInfo, m_circuitInfo))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_Information_UUIE::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_protocolIdentifier.Encode(strm);
  KnownExtensionEncode(strm, e_callIdentifier, m_callIdentifier);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_fastStart, m_fastStart);
  KnownExtensionEncode(strm, e_fastConnectRefused, m_fastConnectRefused);
  KnownExtensionEncode(strm, e_circuitInfo, m_circuitInfo);

  UnknownExtensionsEncode(strm);
}


PObject * H225_Information_UUIE::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_Information_UUIE::Class()), PInvalidCast);
#endif
  return new H225_Information_UUIE(*this);
}


//
// Setup-UUIE
//

H225_Setup_UUIE::H225_Setup_UUIE(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 7, TRUE, 27)
{
  IncludeOptionalField(e_callIdentifier);
  IncludeOptionalField(e_mediaWaitForConnect);
  IncludeOptionalField(e_canOverlapSend);
  IncludeOptionalField(e_multipleCalls);
  IncludeOptionalField(e_maintainConnection);
  m_hopCount.SetConstraints(PASN_Object::FixedConstraint, 1, 31);
}


#ifndef PASN_NOPRINTON
void H225_Setup_UUIE::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+21) << "protocolIdentifier = " << setprecision(indent) << m_protocolIdentifier << '\n';
  if (HasOptionalField(e_h245Address))
    strm << setw(indent+14) << "h245Address = " << setprecision(indent) << m_h245Address << '\n';
  if (HasOptionalField(e_sourceAddress))
    strm << setw(indent+16) << "sourceAddress = " << setprecision(indent) << m_sourceAddress << '\n';
  strm << setw(indent+13) << "sourceInfo = " << setprecision(indent) << m_sourceInfo << '\n';
  if (HasOptionalField(e_destinationAddress))
    strm << setw(indent+21) << "destinationAddress = " << setprecision(indent) << m_destinationAddress << '\n';
  if (HasOptionalField(e_destCallSignalAddress))
    strm << setw(indent+24) << "destCallSignalAddress = " << setprecision(indent) << m_destCallSignalAddress << '\n';
  if (HasOptionalField(e_destExtraCallInfo))
    strm << setw(indent+20) << "destExtraCallInfo = " << setprecision(indent) << m_destExtraCallInfo << '\n';
  if (HasOptionalField(e_destExtraCRV))
    strm << setw(indent+15) << "destExtraCRV = " << setprecision(indent) << m_destExtraCRV << '\n';
  strm << setw(indent+11) << "activeMC = " << setprecision(indent) << m_activeMC << '\n';
  strm << setw(indent+15) << "conferenceID = " << setprecision(indent) << m_conferenceID << '\n';
  strm << setw(indent+17) << "conferenceGoal = " << setprecision(indent) << m_conferenceGoal << '\n';
  if (HasOptionalField(e_callServices))
    strm << setw(indent+15) << "callServices = " << setprecision(indent) << m_callServices << '\n';
  strm << setw(indent+11) << "callType = " << setprecision(indent) << m_callType << '\n';
  if (HasOptionalField(e_sourceCallSignalAddress))
    strm << setw(indent+26) << "sourceCallSignalAddress = " << setprecision(indent) << m_sourceCallSignalAddress << '\n';
  if (HasOptionalField(e_remoteExtensionAddress))
    strm << setw(indent+25) << "remoteExtensionAddress = " << setprecision(indent) << m_remoteExtensionAddress << '\n';
  if (HasOptionalField(e_callIdentifier))
    strm << setw(indent+17) << "callIdentifier = " << setprecision(indent) << m_callIdentifier << '\n';
  if (HasOptionalField(e_h245SecurityCapability))
    strm << setw(indent+25) << "h245SecurityCapability = " << setprecision(indent) << m_h245SecurityCapability << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_fastStart))
    strm << setw(indent+12) << "fastStart = " << setprecision(indent) << m_fastStart << '\n';
  if (HasOptionalField(e_mediaWaitForConnect))
    strm << setw(indent+22) << "mediaWaitForConnect = " << setprecision(indent) << m_mediaWaitForConnect << '\n';
  if (HasOptionalField(e_canOverlapSend))
    strm << setw(indent+17) << "canOverlapSend = " << setprecision(indent) << m_canOverlapSend << '\n';
  if (HasOptionalField(e_endpointIdentifier))
    strm << setw(indent+21) << "endpointIdentifier = " << setprecision(indent) << m_endpointIdentifier << '\n';
  if (HasOptionalField(e_multipleCalls))
    strm << setw(indent+16) << "multipleCalls = " << setprecision(indent) << m_multipleCalls << '\n';
  if (HasOptionalField(e_maintainConnection))
    strm << setw(indent+21) << "maintainConnection = " << setprecision(indent) << m_maintainConnection << '\n';
  if (HasOptionalField(e_connectionParameters))
    strm << setw(indent+23) << "connectionParameters = " << setprecision(indent) << m_connectionParameters << '\n';
  if (HasOptionalField(e_language))
    strm << setw(indent+11) << "language = " << setprecision(indent) << m_language << '\n';
  if (HasOptionalField(e_presentationIndicator))
    strm << setw(indent+24) << "presentationIndicator = " << setprecision(indent) << m_presentationIndicator << '\n';
  if (HasOptionalField(e_screeningIndicator))
    strm << setw(indent+21) << "screeningIndicator = " << setprecision(indent) << m_screeningIndicator << '\n';
  if (HasOptionalField(e_serviceControl))
    strm << setw(indent+17) << "serviceControl = " << setprecision(indent) << m_serviceControl << '\n';
  if (HasOptionalField(e_symmetricOperationRequired))
    strm << setw(indent+29) << "symmetricOperationRequired = " << setprecision(indent) << m_symmetricOperationRequired << '\n';
  if (HasOptionalField(e_capacity))
    strm << setw(indent+11) << "capacity = " << setprecision(indent) << m_capacity << '\n';
  if (HasOptionalField(e_circuitInfo))
    strm << setw(indent+14) << "circuitInfo = " << setprecision(indent) << m_circuitInfo << '\n';
  if (HasOptionalField(e_desiredProtocols))
    strm << setw(indent+19) << "desiredProtocols = " << setprecision(indent) << m_desiredProtocols << '\n';
  if (HasOptionalField(e_neededFeatures))
    strm << setw(indent+17) << "neededFeatures = " << setprecision(indent) << m_neededFeatures << '\n';
  if (HasOptionalField(e_desiredFeatures))
    strm << setw(indent+18) << "desiredFeatures = " << setprecision(indent) << m_desiredFeatures << '\n';
  if (HasOptionalField(e_supportedFeatures))
    strm << setw(indent+20) << "supportedFeatures = " << setprecision(indent) << m_supportedFeatures << '\n';
  if (HasOptionalField(e_parallelH245Control))
    strm << setw(indent+22) << "parallelH245Control = " << setprecision(indent) << m_parallelH245Control << '\n';
  if (HasOptionalField(e_additionalSourceAddresses))
    strm << setw(indent+28) << "additionalSourceAddresses = " << setprecision(indent) << m_additionalSourceAddresses << '\n';
  if (HasOptionalField(e_hopCount))
    strm << setw(indent+11) << "hopCount = " << setprecision(indent) << m_hopCount << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_Setup_UUIE::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_Setup_UUIE), PInvalidCast);
#endif
  const H225_Setup_UUIE & other = (const H225_Setup_UUIE &)obj;

  Comparison result;

  if ((result = m_protocolIdentifier.Compare(other.m_protocolIdentifier)) != EqualTo)
    return result;
  if ((result = m_h245Address.Compare(other.m_h245Address)) != EqualTo)
    return result;
  if ((result = m_sourceAddress.Compare(other.m_sourceAddress)) != EqualTo)
    return result;
  if ((result = m_sourceInfo.Compare(other.m_sourceInfo)) != EqualTo)
    return result;
  if ((result = m_destinationAddress.Compare(other.m_destinationAddress)) != EqualTo)
    return result;
  if ((result = m_destCallSignalAddress.Compare(other.m_destCallSignalAddress)) != EqualTo)
    return result;
  if ((result = m_destExtraCallInfo.Compare(other.m_destExtraCallInfo)) != EqualTo)
    return result;
  if ((result = m_destExtraCRV.Compare(other.m_destExtraCRV)) != EqualTo)
    return result;
  if ((result = m_activeMC.Compare(other.m_activeMC)) != EqualTo)
    return result;
  if ((result = m_conferenceID.Compare(other.m_conferenceID)) != EqualTo)
    return result;
  if ((result = m_conferenceGoal.Compare(other.m_conferenceGoal)) != EqualTo)
    return result;
  if ((result = m_callServices.Compare(other.m_callServices)) != EqualTo)
    return result;
  if ((result = m_callType.Compare(other.m_callType)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_Setup_UUIE::GetDataLength() const
{
  PINDEX length = 0;
  length += m_protocolIdentifier.GetObjectLength();
  if (HasOptionalField(e_h245Address))
    length += m_h245Address.GetObjectLength();
  if (HasOptionalField(e_sourceAddress))
    length += m_sourceAddress.GetObjectLength();
  length += m_sourceInfo.GetObjectLength();
  if (HasOptionalField(e_destinationAddress))
    length += m_destinationAddress.GetObjectLength();
  if (HasOptionalField(e_destCallSignalAddress))
    length += m_destCallSignalAddress.GetObjectLength();
  if (HasOptionalField(e_destExtraCallInfo))
    length += m_destExtraCallInfo.GetObjectLength();
  if (HasOptionalField(e_destExtraCRV))
    length += m_destExtraCRV.GetObjectLength();
  length += m_activeMC.GetObjectLength();
  length += m_conferenceID.GetObjectLength();
  length += m_conferenceGoal.GetObjectLength();
  if (HasOptionalField(e_callServices))
    length += m_callServices.GetObjectLength();
  length += m_callType.GetObjectLength();
  return length;
}


BOOL H225_Setup_UUIE::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_protocolIdentifier.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_h245Address) && !m_h245Address.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_sourceAddress) && !m_sourceAddress.Decode(strm))
    return FALSE;
  if (!m_sourceInfo.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_destinationAddress) && !m_destinationAddress.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_destCallSignalAddress) && !m_destCallSignalAddress.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_destExtraCallInfo) && !m_destExtraCallInfo.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_destExtraCRV) && !m_destExtraCRV.Decode(strm))
    return FALSE;
  if (!m_activeMC.Decode(strm))
    return FALSE;
  if (!m_conferenceID.Decode(strm))
    return FALSE;
  if (!m_conferenceGoal.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_callServices) && !m_callServices.Decode(strm))
    return FALSE;
  if (!m_callType.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_sourceCallSignalAddress, m_sourceCallSignalAddress))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_remoteExtensionAddress, m_remoteExtensionAddress))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_callIdentifier, m_callIdentifier))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_h245SecurityCapability, m_h245SecurityCapability))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_tokens, m_tokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_cryptoTokens, m_cryptoTokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_fastStart, m_fastStart))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_mediaWaitForConnect, m_mediaWaitForConnect))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_canOverlapSend, m_canOverlapSend))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_endpointIdentifier, m_endpointIdentifier))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_multipleCalls, m_multipleCalls))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_maintainConnection, m_maintainConnection))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_connectionParameters, m_connectionParameters))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_language, m_language))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_presentationIndicator, m_presentationIndicator))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_screeningIndicator, m_screeningIndicator))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_serviceControl, m_serviceControl))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_symmetricOperationRequired, m_symmetricOperationRequired))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_capacity, m_capacity))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_circuitInfo, m_circuitInfo))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_desiredProtocols, m_desiredProtocols))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_neededFeatures, m_neededFeatures))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_desiredFeatures, m_desiredFeatures))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_supportedFeatures, m_supportedFeatures))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_parallelH245Control, m_parallelH245Control))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_additionalSourceAddresses, m_additionalSourceAddresses))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_hopCount, m_hopCount))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_Setup_UUIE::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_protocolIdentifier.Encode(strm);
  if (HasOptionalField(e_h245Address))
    m_h245Address.Encode(strm);
  if (HasOptionalField(e_sourceAddress))
    m_sourceAddress.Encode(strm);
  m_sourceInfo.Encode(strm);
  if (HasOptionalField(e_destinationAddress))
    m_destinationAddress.Encode(strm);
  if (HasOptionalField(e_destCallSignalAddress))
    m_destCallSignalAddress.Encode(strm);
  if (HasOptionalField(e_destExtraCallInfo))
    m_destExtraCallInfo.Encode(strm);
  if (HasOptionalField(e_destExtraCRV))
    m_destExtraCRV.Encode(strm);
  m_activeMC.Encode(strm);
  m_conferenceID.Encode(strm);
  m_conferenceGoal.Encode(strm);
  if (HasOptionalField(e_callServices))
    m_callServices.Encode(strm);
  m_callType.Encode(strm);
  KnownExtensionEncode(strm, e_sourceCallSignalAddress, m_sourceCallSignalAddress);
  KnownExtensionEncode(strm, e_remoteExtensionAddress, m_remoteExtensionAddress);
  KnownExtensionEncode(strm, e_callIdentifier, m_callIdentifier);
  KnownExtensionEncode(strm, e_h245SecurityCapability, m_h245SecurityCapability);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_fastStart, m_fastStart);
  KnownExtensionEncode(strm, e_mediaWaitForConnect, m_mediaWaitForConnect);
  KnownExtensionEncode(strm, e_canOverlapSend, m_canOverlapSend);
  KnownExtensionEncode(strm, e_endpointIdentifier, m_endpointIdentifier);
  KnownExtensionEncode(strm, e_multipleCalls, m_multipleCalls);
  KnownExtensionEncode(strm, e_maintainConnection, m_maintainConnection);
  KnownExtensionEncode(strm, e_connectionParameters, m_connectionParameters);
  KnownExtensionEncode(strm, e_language, m_language);
  KnownExtensionEncode(strm, e_presentationIndicator, m_presentationIndicator);
  KnownExtensionEncode(strm, e_screeningIndicator, m_screeningIndicator);
  KnownExtensionEncode(strm, e_serviceControl, m_serviceControl);
  KnownExtensionEncode(strm, e_symmetricOperationRequired, m_symmetricOperationRequired);
  KnownExtensionEncode(strm, e_capacity, m_capacity);
  KnownExtensionEncode(strm, e_circuitInfo, m_circuitInfo);
  KnownExtensionEncode(strm, e_desiredProtocols, m_desiredProtocols);
  KnownExtensionEncode(strm, e_neededFeatures, m_neededFeatures);
  KnownExtensionEncode(strm, e_desiredFeatures, m_desiredFeatures);
  KnownExtensionEncode(strm, e_supportedFeatures, m_supportedFeatures);
  KnownExtensionEncode(strm, e_parallelH245Control, m_parallelH245Control);
  KnownExtensionEncode(strm, e_additionalSourceAddresses, m_additionalSourceAddresses);
  KnownExtensionEncode(strm, e_hopCount, m_hopCount);

  UnknownExtensionsEncode(strm);
}


PObject * H225_Setup_UUIE::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_Setup_UUIE::Class()), PInvalidCast);
#endif
  return new H225_Setup_UUIE(*this);
}


//
// Facility-UUIE
//

H225_Facility_UUIE::H225_Facility_UUIE(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 16)
{
  IncludeOptionalField(e_callIdentifier);
  IncludeOptionalField(e_multipleCalls);
  IncludeOptionalField(e_maintainConnection);
}


#ifndef PASN_NOPRINTON
void H225_Facility_UUIE::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+21) << "protocolIdentifier = " << setprecision(indent) << m_protocolIdentifier << '\n';
  if (HasOptionalField(e_alternativeAddress))
    strm << setw(indent+21) << "alternativeAddress = " << setprecision(indent) << m_alternativeAddress << '\n';
  if (HasOptionalField(e_alternativeAliasAddress))
    strm << setw(indent+26) << "alternativeAliasAddress = " << setprecision(indent) << m_alternativeAliasAddress << '\n';
  if (HasOptionalField(e_conferenceID))
    strm << setw(indent+15) << "conferenceID = " << setprecision(indent) << m_conferenceID << '\n';
  strm << setw(indent+9) << "reason = " << setprecision(indent) << m_reason << '\n';
  if (HasOptionalField(e_callIdentifier))
    strm << setw(indent+17) << "callIdentifier = " << setprecision(indent) << m_callIdentifier << '\n';
  if (HasOptionalField(e_destExtraCallInfo))
    strm << setw(indent+20) << "destExtraCallInfo = " << setprecision(indent) << m_destExtraCallInfo << '\n';
  if (HasOptionalField(e_remoteExtensionAddress))
    strm << setw(indent+25) << "remoteExtensionAddress = " << setprecision(indent) << m_remoteExtensionAddress << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_conferences))
    strm << setw(indent+14) << "conferences = " << setprecision(indent) << m_conferences << '\n';
  if (HasOptionalField(e_h245Address))
    strm << setw(indent+14) << "h245Address = " << setprecision(indent) << m_h245Address << '\n';
  if (HasOptionalField(e_fastStart))
    strm << setw(indent+12) << "fastStart = " << setprecision(indent) << m_fastStart << '\n';
  if (HasOptionalField(e_multipleCalls))
    strm << setw(indent+16) << "multipleCalls = " << setprecision(indent) << m_multipleCalls << '\n';
  if (HasOptionalField(e_maintainConnection))
    strm << setw(indent+21) << "maintainConnection = " << setprecision(indent) << m_maintainConnection << '\n';
  if (HasOptionalField(e_fastConnectRefused))
    strm << setw(indent+21) << "fastConnectRefused = " << setprecision(indent) << m_fastConnectRefused << '\n';
  if (HasOptionalField(e_serviceControl))
    strm << setw(indent+17) << "serviceControl = " << setprecision(indent) << m_serviceControl << '\n';
  if (HasOptionalField(e_circuitInfo))
    strm << setw(indent+14) << "circuitInfo = " << setprecision(indent) << m_circuitInfo << '\n';
  if (HasOptionalField(e_featureSet))
    strm << setw(indent+13) << "featureSet = " << setprecision(indent) << m_featureSet << '\n';
  if (HasOptionalField(e_destinationInfo))
    strm << setw(indent+18) << "destinationInfo = " << setprecision(indent) << m_destinationInfo << '\n';
  if (HasOptionalField(e_h245SecurityMode))
    strm << setw(indent+19) << "h245SecurityMode = " << setprecision(indent) << m_h245SecurityMode << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_Facility_UUIE::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_Facility_UUIE), PInvalidCast);
#endif
  const H225_Facility_UUIE & other = (const H225_Facility_UUIE &)obj;

  Comparison result;

  if ((result = m_protocolIdentifier.Compare(other.m_protocolIdentifier)) != EqualTo)
    return result;
  if ((result = m_alternativeAddress.Compare(other.m_alternativeAddress)) != EqualTo)
    return result;
  if ((result = m_alternativeAliasAddress.Compare(other.m_alternativeAliasAddress)) != EqualTo)
    return result;
  if ((result = m_conferenceID.Compare(other.m_conferenceID)) != EqualTo)
    return result;
  if ((result = m_reason.Compare(other.m_reason)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_Facility_UUIE::GetDataLength() const
{
  PINDEX length = 0;
  length += m_protocolIdentifier.GetObjectLength();
  if (HasOptionalField(e_alternativeAddress))
    length += m_alternativeAddress.GetObjectLength();
  if (HasOptionalField(e_alternativeAliasAddress))
    length += m_alternativeAliasAddress.GetObjectLength();
  if (HasOptionalField(e_conferenceID))
    length += m_conferenceID.GetObjectLength();
  length += m_reason.GetObjectLength();
  return length;
}


BOOL H225_Facility_UUIE::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_protocolIdentifier.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_alternativeAddress) && !m_alternativeAddress.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_alternativeAliasAddress) && !m_alternativeAliasAddress.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_conferenceID) && !m_conferenceID.Decode(strm))
    return FALSE;
  if (!m_reason.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_callIdentifier, m_callIdentifier))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_destExtraCallInfo, m_destExtraCallInfo))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_remoteExtensionAddress, m_remoteExtensionAddress))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_tokens, m_tokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_cryptoTokens, m_cryptoTokens))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_conferences, m_conferences))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_h245Address, m_h245Address))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_fastStart, m_fastStart))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_multipleCalls, m_multipleCalls))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_maintainConnection, m_maintainConnection))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_fastConnectRefused, m_fastConnectRefused))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_serviceControl, m_serviceControl))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_circuitInfo, m_circuitInfo))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_featureSet, m_featureSet))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_destinationInfo, m_destinationInfo))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_h245SecurityMode, m_h245SecurityMode))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_Facility_UUIE::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_protocolIdentifier.Encode(strm);
  if (HasOptionalField(e_alternativeAddress))
    m_alternativeAddress.Encode(strm);
  if (HasOptionalField(e_alternativeAliasAddress))
    m_alternativeAliasAddress.Encode(strm);
  if (HasOptionalField(e_conferenceID))
    m_conferenceID.Encode(strm);
  m_reason.Encode(strm);
  KnownExtensionEncode(strm, e_callIdentifier, m_callIdentifier);
  KnownExtensionEncode(strm, e_destExtraCallInfo, m_destExtraCallInfo);
  KnownExtensionEncode(strm, e_remoteExtensionAddress, m_remoteExtensionAddress);
  KnownExtensionEncode(strm, e_tokens, m_tokens);
  KnownExtensionEncode(strm, e_cryptoTokens, m_cryptoTokens);
  KnownExtensionEncode(strm, e_conferences, m_conferences);
  KnownExtensionEncode(strm, e_h245Address, m_h245Address);
  KnownExtensionEncode(strm, e_fastStart, m_fastStart);
  KnownExtensionEncode(strm, e_multipleCalls, m_multipleCalls);
  KnownExtensionEncode(strm, e_maintainConnection, m_maintainConnection);
  KnownExtensionEncode(strm, e_fastConnectRefused, m_fastConnectRefused);
  KnownExtensionEncode(strm, e_serviceControl, m_serviceControl);
  KnownExtensionEncode(strm, e_circuitInfo, m_circuitInfo);
  KnownExtensionEncode(strm, e_featureSet, m_featureSet);
  KnownExtensionEncode(strm, e_destinationInfo, m_destinationInfo);
  KnownExtensionEncode(strm, e_h245SecurityMode, m_h245SecurityMode);

  UnknownExtensionsEncode(strm);
}


PObject * H225_Facility_UUIE::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_Facility_UUIE::Class()), PInvalidCast);
#endif
  return new H225_Facility_UUIE(*this);
}


//
// Progress-UUIE
//

H225_Progress_UUIE::H225_Progress_UUIE(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 5, TRUE, 3)
{
  IncludeOptionalField(e_multipleCalls);
  IncludeOptionalField(e_maintainConnection);
}


#ifndef PASN_NOPRINTON
void H225_Progress_UUIE::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+21) << "protocolIdentifier = " << setprecision(indent) << m_protocolIdentifier << '\n';
  strm << setw(indent+18) << "destinationInfo = " << setprecision(indent) << m_destinationInfo << '\n';
  if (HasOptionalField(e_h245Address))
    strm << setw(indent+14) << "h245Address = " << setprecision(indent) << m_h245Address << '\n';
  strm << setw(indent+17) << "callIdentifier = " << setprecision(indent) << m_callIdentifier << '\n';
  if (HasOptionalField(e_h245SecurityMode))
    strm << setw(indent+19) << "h245SecurityMode = " << setprecision(indent) << m_h245SecurityMode << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_fastStart))
    strm << setw(indent+12) << "fastStart = " << setprecision(indent) << m_fastStart << '\n';
  if (HasOptionalField(e_multipleCalls))
    strm << setw(indent+16) << "multipleCalls = " << setprecision(indent) << m_multipleCalls << '\n';
  if (HasOptionalField(e_maintainConnection))
    strm << setw(indent+21) << "maintainConnection = " << setprecision(indent) << m_maintainConnection << '\n';
  if (HasOptionalField(e_fastConnectRefused))
    strm << setw(indent+21) << "fastConnectRefused = " << setprecision(indent) << m_fastConnectRefused << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_Progress_UUIE::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_Progress_UUIE), PInvalidCast);
#endif
  const H225_Progress_UUIE & other = (const H225_Progress_UUIE &)obj;

  Comparison result;

  if ((result = m_protocolIdentifier.Compare(other.m_protocolIdentifier)) != EqualTo)
    return result;
  if ((result = m_destinationInfo.Compare(other.m_destinationInfo)) != EqualTo)
    return result;
  if ((result = m_h245Address.Compare(other.m_h245Address)) != EqualTo)
    return result;
  if ((result = m_callIdentifier.Compare(other.m_callIdentifier)) != EqualTo)
    return result;
  if ((result = m_h245SecurityMode.Compare(other.m_h245SecurityMode)) != EqualTo)
    return result;
  if ((result = m_tokens.Compare(other.m_tokens)) != EqualTo)
    return result;
  if ((result = m_cryptoTokens.Compare(other.m_cryptoTokens)) != EqualTo)
    return result;
  if ((result = m_fastStart.Compare(other.m_fastStart)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_Progress_UUIE::GetDataLength() const
{
  PINDEX length = 0;
  length += m_protocolIdentifier.GetObjectLength();
  length += m_destinationInfo.GetObjectLength();
  if (HasOptionalField(e_h245Address))
    length += m_h245Address.GetObjectLength();
  length += m_callIdentifier.GetObjectLength();
  if (HasOptionalField(e_h245SecurityMode))
    length += m_h245SecurityMode.GetObjectLength();
  if (HasOptionalField(e_tokens))
    length += m_tokens.GetObjectLength();
  if (HasOptionalField(e_cryptoTokens))
    length += m_cryptoTokens.GetObjectLength();
  if (HasOptionalField(e_fastStart))
    length += m_fastStart.GetObjectLength();
  return length;
}


BOOL H225_Progress_UUIE::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_protocolIdentifier.Decode(strm))
    return FALSE;
  if (!m_destinationInfo.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_h245Address) && !m_h245Address.Decode(strm))
    return FALSE;
  if (!m_callIdentifier.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_h245SecurityMode) && !m_h245SecurityMode.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_tokens) && !m_tokens.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_cryptoTokens) && !m_cryptoTokens.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_fastStart) && !m_fastStart.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_multipleCalls, m_multipleCalls))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_maintainConnection, m_maintainConnection))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_fastConnectRefused, m_fastConnectRefused))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_Progress_UUIE::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_protocolIdentifier.Encode(strm);
  m_destinationInfo.Encode(strm);
  if (HasOptionalField(e_h245Address))
    m_h245Address.Encode(strm);
  m_callIdentifier.Encode(strm);
  if (HasOptionalField(e_h245SecurityMode))
    m_h245SecurityMode.Encode(strm);
  if (HasOptionalField(e_tokens))
    m_tokens.Encode(strm);
  if (HasOptionalField(e_cryptoTokens))
    m_cryptoTokens.Encode(strm);
  if (HasOptionalField(e_fastStart))
    m_fastStart.Encode(strm);
  KnownExtensionEncode(strm, e_multipleCalls, m_multipleCalls);
  KnownExtensionEncode(strm, e_maintainConnection, m_maintainConnection);
  KnownExtensionEncode(strm, e_fastConnectRefused, m_fastConnectRefused);

  UnknownExtensionsEncode(strm);
}


PObject * H225_Progress_UUIE::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_Progress_UUIE::Class()), PInvalidCast);
#endif
  return new H225_Progress_UUIE(*this);
}


//
// Endpoint
//

H225_Endpoint::H225_Endpoint(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 10, TRUE, 3)
{
  m_priority.SetConstraints(PASN_Object::FixedConstraint, 0, 127);
}


#ifndef PASN_NOPRINTON
void H225_Endpoint::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  if (HasOptionalField(e_aliasAddress))
    strm << setw(indent+15) << "aliasAddress = " << setprecision(indent) << m_aliasAddress << '\n';
  if (HasOptionalField(e_callSignalAddress))
    strm << setw(indent+20) << "callSignalAddress = " << setprecision(indent) << m_callSignalAddress << '\n';
  if (HasOptionalField(e_rasAddress))
    strm << setw(indent+13) << "rasAddress = " << setprecision(indent) << m_rasAddress << '\n';
  if (HasOptionalField(e_endpointType))
    strm << setw(indent+15) << "endpointType = " << setprecision(indent) << m_endpointType << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_priority))
    strm << setw(indent+11) << "priority = " << setprecision(indent) << m_priority << '\n';
  if (HasOptionalField(e_remoteExtensionAddress))
    strm << setw(indent+25) << "remoteExtensionAddress = " << setprecision(indent) << m_remoteExtensionAddress << '\n';
  if (HasOptionalField(e_destExtraCallInfo))
    strm << setw(indent+20) << "destExtraCallInfo = " << setprecision(indent) << m_destExtraCallInfo << '\n';
  if (HasOptionalField(e_alternateTransportAddresses))
    strm << setw(indent+30) << "alternateTransportAddresses = " << setprecision(indent) << m_alternateTransportAddresses << '\n';
  if (HasOptionalField(e_circuitInfo))
    strm << setw(indent+14) << "circuitInfo = " << setprecision(indent) << m_circuitInfo << '\n';
  if (HasOptionalField(e_featureSet))
    strm << setw(indent+13) << "featureSet = " << setprecision(indent) << m_featureSet << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H225_Endpoint::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H225_Endpoint), PInvalidCast);
#endif
  const H225_Endpoint & other = (const H225_Endpoint &)obj;

  Comparison result;

  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;
  if ((result = m_aliasAddress.Compare(other.m_aliasAddress)) != EqualTo)
    return result;
  if ((result = m_callSignalAddress.Compare(other.m_callSignalAddress)) != EqualTo)
    return result;
  if ((result = m_rasAddress.Compare(other.m_rasAddress)) != EqualTo)
    return result;
  if ((result = m_endpointType.Compare(other.m_endpointType)) != EqualTo)
    return result;
  if ((result = m_tokens.Compare(other.m_tokens)) != EqualTo)
    return result;
  if ((result = m_cryptoTokens.Compare(other.m_cryptoTokens)) != EqualTo)
    return result;
  if ((result = m_priority.Compare(other.m_priority)) != EqualTo)
    return result;
  if ((result = m_remoteExtensionAddress.Compare(other.m_remoteExtensionAddress)) != EqualTo)
    return result;
  if ((result = m_destExtraCallInfo.Compare(other.m_destExtraCallInfo)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H225_Endpoint::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  if (HasOptionalField(e_aliasAddress))
    length += m_aliasAddress.GetObjectLength();
  if (HasOptionalField(e_callSignalAddress))
    length += m_callSignalAddress.GetObjectLength();
  if (HasOptionalField(e_rasAddress))
    length += m_rasAddress.GetObjectLength();
  if (HasOptionalField(e_endpointType))
    length += m_endpointType.GetObjectLength();
  if (HasOptionalField(e_tokens))
    length += m_tokens.GetObjectLength();
  if (HasOptionalField(e_cryptoTokens))
    length += m_cryptoTokens.GetObjectLength();
  if (HasOptionalField(e_priority))
    length += m_priority.GetObjectLength();
  if (HasOptionalField(e_remoteExtensionAddress))
    length += m_remoteExtensionAddress.GetObjectLength();
  if (HasOptionalField(e_destExtraCallInfo))
    length += m_destExtraCallInfo.GetObjectLength();
  return length;
}


BOOL H225_Endpoint::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_aliasAddress) && !m_aliasAddress.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_callSignalAddress) && !m_callSignalAddress.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_rasAddress) && !m_rasAddress.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_endpointType) && !m_endpointType.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_tokens) && !m_tokens.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_cryptoTokens) && !m_cryptoTokens.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_priority) && !m_priority.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_remoteExtensionAddress) && !m_remoteExtensionAddress.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_destExtraCallInfo) && !m_destExtraCallInfo.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_alternateTransportAddresses, m_alternateTransportAddresses))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_circuitInfo, m_circuitInfo))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_featureSet, m_featureSet))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H225_Endpoint::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);
  if (HasOptionalField(e_aliasAddress))
    m_aliasAddress.Encode(strm);
  if (HasOptionalField(e_callSignalAddress))
    m_callSignalAddress.Encode(strm);
  if (HasOptionalField(e_rasAddress))
    m_rasAddress.Encode(strm);
  if (HasOptionalField(e_endpointType))
    m_endpointType.Encode(strm);
  if (HasOptionalField(e_tokens))
    m_tokens.Encode(strm);
  if (HasOptionalField(e_cryptoTokens))
    m_cryptoTokens.Encode(strm);
  if (HasOptionalField(e_priority))
    m_priority.Encode(strm);
  if (HasOptionalField(e_remoteExtensionAddress))
    m_remoteExtensionAddress.Encode(strm);
  if (HasOptionalField(e_destExtraCallInfo))
    m_destExtraCallInfo.Encode(strm);
  KnownExtensionEncode(strm, e_alternateTransportAddresses, m_alternateTransportAddresses);
  KnownExtensionEncode(strm, e_circuitInfo, m_circuitInfo);
  KnownExtensionEncode(strm, e_featureSet, m_featureSet);

  UnknownExtensionsEncode(strm);
}


PObject * H225_Endpoint::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H225_Endpoint::Class()), PInvalidCast);
#endif
  return new H225_Endpoint(*this);
}


#endif // if ! H323_DISABLE_H225


// End of h225_2.cxx
