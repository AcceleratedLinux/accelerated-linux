//
// h501.cxx
//
// Code automatically generated by asnparse.
//

#ifdef P_USE_PRAGMA
#pragma implementation "h501.h"
#endif

#include <ptlib.h>
#include "h501.h"

#define new PNEW


#if ! H323_DISABLE_H501




#ifndef PASN_NOPRINTON
const static PASN_Names Names_H501_MessageBody[]={
      {"serviceRequest",0}
     ,{"serviceConfirmation",1}
     ,{"serviceRejection",2}
     ,{"serviceRelease",3}
     ,{"descriptorRequest",4}
     ,{"descriptorConfirmation",5}
     ,{"descriptorRejection",6}
     ,{"descriptorIDRequest",7}
     ,{"descriptorIDConfirmation",8}
     ,{"descriptorIDRejection",9}
     ,{"descriptorUpdate",10}
     ,{"descriptorUpdateAck",11}
     ,{"accessRequest",12}
     ,{"accessConfirmation",13}
     ,{"accessRejection",14}
     ,{"requestInProgress",15}
     ,{"nonStandardRequest",16}
     ,{"nonStandardConfirmation",17}
     ,{"nonStandardRejection",18}
     ,{"unknownMessageResponse",19}
     ,{"usageRequest",20}
     ,{"usageConfirmation",21}
     ,{"usageIndication",22}
     ,{"usageIndicationConfirmation",23}
     ,{"usageIndicationRejection",24}
     ,{"usageRejection",25}
     ,{"validationRequest",26}
     ,{"validationConfirmation",27}
     ,{"validationRejection",28}
     ,{"authenticationRequest",29}
     ,{"authenticationConfirmation",30}
     ,{"authenticationRejection",31}
};
#endif
//
// MessageBody
//

H501_MessageBody::H501_MessageBody(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 29, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H501_MessageBody,32
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H501_MessageBody::operator H501_ServiceRequest &() const
#else
H501_MessageBody::operator H501_ServiceRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_ServiceRequest), PInvalidCast);
#endif
  return *(H501_ServiceRequest *)choice;
}


H501_MessageBody::operator const H501_ServiceRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_ServiceRequest), PInvalidCast);
#endif
  return *(H501_ServiceRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H501_MessageBody::operator H501_ServiceConfirmation &() const
#else
H501_MessageBody::operator H501_ServiceConfirmation &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_ServiceConfirmation), PInvalidCast);
#endif
  return *(H501_ServiceConfirmation *)choice;
}


H501_MessageBody::operator const H501_ServiceConfirmation &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_ServiceConfirmation), PInvalidCast);
#endif
  return *(H501_ServiceConfirmation *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H501_MessageBody::operator H501_ServiceRejection &() const
#else
H501_MessageBody::operator H501_ServiceRejection &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_ServiceRejection), PInvalidCast);
#endif
  return *(H501_ServiceRejection *)choice;
}


H501_MessageBody::operator const H501_ServiceRejection &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_ServiceRejection), PInvalidCast);
#endif
  return *(H501_ServiceRejection *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H501_MessageBody::operator H501_ServiceRelease &() const
#else
H501_MessageBody::operator H501_ServiceRelease &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_ServiceRelease), PInvalidCast);
#endif
  return *(H501_ServiceRelease *)choice;
}


H501_MessageBody::operator const H501_ServiceRelease &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_ServiceRelease), PInvalidCast);
#endif
  return *(H501_ServiceRelease *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H501_MessageBody::operator H501_DescriptorRequest &() const
#else
H501_MessageBody::operator H501_DescriptorRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_DescriptorRequest), PInvalidCast);
#endif
  return *(H501_DescriptorRequest *)choice;
}


H501_MessageBody::operator const H501_DescriptorRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_DescriptorRequest), PInvalidCast);
#endif
  return *(H501_DescriptorRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H501_MessageBody::operator H501_DescriptorConfirmation &() const
#else
H501_MessageBody::operator H501_DescriptorConfirmation &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_DescriptorConfirmation), PInvalidCast);
#endif
  return *(H501_DescriptorConfirmation *)choice;
}


H501_MessageBody::operator const H501_DescriptorConfirmation &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_DescriptorConfirmation), PInvalidCast);
#endif
  return *(H501_DescriptorConfirmation *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H501_MessageBody::operator H501_DescriptorRejection &() const
#else
H501_MessageBody::operator H501_DescriptorRejection &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_DescriptorRejection), PInvalidCast);
#endif
  return *(H501_DescriptorRejection *)choice;
}


H501_MessageBody::operator const H501_DescriptorRejection &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_DescriptorRejection), PInvalidCast);
#endif
  return *(H501_DescriptorRejection *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H501_MessageBody::operator H501_DescriptorIDRequest &() const
#else
H501_MessageBody::operator H501_DescriptorIDRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_DescriptorIDRequest), PInvalidCast);
#endif
  return *(H501_DescriptorIDRequest *)choice;
}


H501_MessageBody::operator const H501_DescriptorIDRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_DescriptorIDRequest), PInvalidCast);
#endif
  return *(H501_DescriptorIDRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H501_MessageBody::operator H501_DescriptorIDConfirmation &() const
#else
H501_MessageBody::operator H501_DescriptorIDConfirmation &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_DescriptorIDConfirmation), PInvalidCast);
#endif
  return *(H501_DescriptorIDConfirmation *)choice;
}


H501_MessageBody::operator const H501_DescriptorIDConfirmation &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_DescriptorIDConfirmation), PInvalidCast);
#endif
  return *(H501_DescriptorIDConfirmation *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H501_MessageBody::operator H501_DescriptorIDRejection &() const
#else
H501_MessageBody::operator H501_DescriptorIDRejection &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_DescriptorIDRejection), PInvalidCast);
#endif
  return *(H501_DescriptorIDRejection *)choice;
}


H501_MessageBody::operator const H501_DescriptorIDRejection &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_DescriptorIDRejection), PInvalidCast);
#endif
  return *(H501_DescriptorIDRejection *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H501_MessageBody::operator H501_DescriptorUpdate &() const
#else
H501_MessageBody::operator H501_DescriptorUpdate &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_DescriptorUpdate), PInvalidCast);
#endif
  return *(H501_DescriptorUpdate *)choice;
}


H501_MessageBody::operator const H501_DescriptorUpdate &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_DescriptorUpdate), PInvalidCast);
#endif
  return *(H501_DescriptorUpdate *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H501_MessageBody::operator H501_DescriptorUpdateAck &() const
#else
H501_MessageBody::operator H501_DescriptorUpdateAck &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_DescriptorUpdateAck), PInvalidCast);
#endif
  return *(H501_DescriptorUpdateAck *)choice;
}


H501_MessageBody::operator const H501_DescriptorUpdateAck &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_DescriptorUpdateAck), PInvalidCast);
#endif
  return *(H501_DescriptorUpdateAck *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H501_MessageBody::operator H501_AccessRequest &() const
#else
H501_MessageBody::operator H501_AccessRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_AccessRequest), PInvalidCast);
#endif
  return *(H501_AccessRequest *)choice;
}


H501_MessageBody::operator const H501_AccessRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_AccessRequest), PInvalidCast);
#endif
  return *(H501_AccessRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H501_MessageBody::operator H501_AccessConfirmation &() const
#else
H501_MessageBody::operator H501_AccessConfirmation &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_AccessConfirmation), PInvalidCast);
#endif
  return *(H501_AccessConfirmation *)choice;
}


H501_MessageBody::operator const H501_AccessConfirmation &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_AccessConfirmation), PInvalidCast);
#endif
  return *(H501_AccessConfirmation *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H501_MessageBody::operator H501_AccessRejection &() const
#else
H501_MessageBody::operator H501_AccessRejection &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_AccessRejection), PInvalidCast);
#endif
  return *(H501_AccessRejection *)choice;
}


H501_MessageBody::operator const H501_AccessRejection &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_AccessRejection), PInvalidCast);
#endif
  return *(H501_AccessRejection *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H501_MessageBody::operator H501_RequestInProgress &() const
#else
H501_MessageBody::operator H501_RequestInProgress &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_RequestInProgress), PInvalidCast);
#endif
  return *(H501_RequestInProgress *)choice;
}


H501_MessageBody::operator const H501_RequestInProgress &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_RequestInProgress), PInvalidCast);
#endif
  return *(H501_RequestInProgress *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H501_MessageBody::operator H501_NonStandardRequest &() const
#else
H501_MessageBody::operator H501_NonStandardRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_NonStandardRequest), PInvalidCast);
#endif
  return *(H501_NonStandardRequest *)choice;
}


H501_MessageBody::operator const H501_NonStandardRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_NonStandardRequest), PInvalidCast);
#endif
  return *(H501_NonStandardRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H501_MessageBody::operator H501_NonStandardConfirmation &() const
#else
H501_MessageBody::operator H501_NonStandardConfirmation &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_NonStandardConfirmation), PInvalidCast);
#endif
  return *(H501_NonStandardConfirmation *)choice;
}


H501_MessageBody::operator const H501_NonStandardConfirmation &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_NonStandardConfirmation), PInvalidCast);
#endif
  return *(H501_NonStandardConfirmation *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H501_MessageBody::operator H501_NonStandardRejection &() const
#else
H501_MessageBody::operator H501_NonStandardRejection &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_NonStandardRejection), PInvalidCast);
#endif
  return *(H501_NonStandardRejection *)choice;
}


H501_MessageBody::operator const H501_NonStandardRejection &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_NonStandardRejection), PInvalidCast);
#endif
  return *(H501_NonStandardRejection *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H501_MessageBody::operator H501_UnknownMessageResponse &() const
#else
H501_MessageBody::operator H501_UnknownMessageResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_UnknownMessageResponse), PInvalidCast);
#endif
  return *(H501_UnknownMessageResponse *)choice;
}


H501_MessageBody::operator const H501_UnknownMessageResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_UnknownMessageResponse), PInvalidCast);
#endif
  return *(H501_UnknownMessageResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H501_MessageBody::operator H501_UsageRequest &() const
#else
H501_MessageBody::operator H501_UsageRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_UsageRequest), PInvalidCast);
#endif
  return *(H501_UsageRequest *)choice;
}


H501_MessageBody::operator const H501_UsageRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_UsageRequest), PInvalidCast);
#endif
  return *(H501_UsageRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H501_MessageBody::operator H501_UsageConfirmation &() const
#else
H501_MessageBody::operator H501_UsageConfirmation &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_UsageConfirmation), PInvalidCast);
#endif
  return *(H501_UsageConfirmation *)choice;
}


H501_MessageBody::operator const H501_UsageConfirmation &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_UsageConfirmation), PInvalidCast);
#endif
  return *(H501_UsageConfirmation *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H501_MessageBody::operator H501_UsageIndication &() const
#else
H501_MessageBody::operator H501_UsageIndication &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_UsageIndication), PInvalidCast);
#endif
  return *(H501_UsageIndication *)choice;
}


H501_MessageBody::operator const H501_UsageIndication &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_UsageIndication), PInvalidCast);
#endif
  return *(H501_UsageIndication *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H501_MessageBody::operator H501_UsageIndicationConfirmation &() const
#else
H501_MessageBody::operator H501_UsageIndicationConfirmation &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_UsageIndicationConfirmation), PInvalidCast);
#endif
  return *(H501_UsageIndicationConfirmation *)choice;
}


H501_MessageBody::operator const H501_UsageIndicationConfirmation &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_UsageIndicationConfirmation), PInvalidCast);
#endif
  return *(H501_UsageIndicationConfirmation *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H501_MessageBody::operator H501_UsageIndicationRejection &() const
#else
H501_MessageBody::operator H501_UsageIndicationRejection &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_UsageIndicationRejection), PInvalidCast);
#endif
  return *(H501_UsageIndicationRejection *)choice;
}


H501_MessageBody::operator const H501_UsageIndicationRejection &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_UsageIndicationRejection), PInvalidCast);
#endif
  return *(H501_UsageIndicationRejection *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H501_MessageBody::operator H501_UsageRejection &() const
#else
H501_MessageBody::operator H501_UsageRejection &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_UsageRejection), PInvalidCast);
#endif
  return *(H501_UsageRejection *)choice;
}


H501_MessageBody::operator const H501_UsageRejection &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_UsageRejection), PInvalidCast);
#endif
  return *(H501_UsageRejection *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H501_MessageBody::operator H501_ValidationRequest &() const
#else
H501_MessageBody::operator H501_ValidationRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_ValidationRequest), PInvalidCast);
#endif
  return *(H501_ValidationRequest *)choice;
}


H501_MessageBody::operator const H501_ValidationRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_ValidationRequest), PInvalidCast);
#endif
  return *(H501_ValidationRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H501_MessageBody::operator H501_ValidationConfirmation &() const
#else
H501_MessageBody::operator H501_ValidationConfirmation &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_ValidationConfirmation), PInvalidCast);
#endif
  return *(H501_ValidationConfirmation *)choice;
}


H501_MessageBody::operator const H501_ValidationConfirmation &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_ValidationConfirmation), PInvalidCast);
#endif
  return *(H501_ValidationConfirmation *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H501_MessageBody::operator H501_ValidationRejection &() const
#else
H501_MessageBody::operator H501_ValidationRejection &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_ValidationRejection), PInvalidCast);
#endif
  return *(H501_ValidationRejection *)choice;
}


H501_MessageBody::operator const H501_ValidationRejection &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_ValidationRejection), PInvalidCast);
#endif
  return *(H501_ValidationRejection *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H501_MessageBody::operator H501_AuthenticationRequest &() const
#else
H501_MessageBody::operator H501_AuthenticationRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_AuthenticationRequest), PInvalidCast);
#endif
  return *(H501_AuthenticationRequest *)choice;
}


H501_MessageBody::operator const H501_AuthenticationRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_AuthenticationRequest), PInvalidCast);
#endif
  return *(H501_AuthenticationRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H501_MessageBody::operator H501_AuthenticationConfirmation &() const
#else
H501_MessageBody::operator H501_AuthenticationConfirmation &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_AuthenticationConfirmation), PInvalidCast);
#endif
  return *(H501_AuthenticationConfirmation *)choice;
}


H501_MessageBody::operator const H501_AuthenticationConfirmation &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_AuthenticationConfirmation), PInvalidCast);
#endif
  return *(H501_AuthenticationConfirmation *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H501_MessageBody::operator H501_AuthenticationRejection &() const
#else
H501_MessageBody::operator H501_AuthenticationRejection &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_AuthenticationRejection), PInvalidCast);
#endif
  return *(H501_AuthenticationRejection *)choice;
}


H501_MessageBody::operator const H501_AuthenticationRejection &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_AuthenticationRejection), PInvalidCast);
#endif
  return *(H501_AuthenticationRejection *)choice;
}


BOOL H501_MessageBody::CreateObject()
{
  switch (tag) {
    case e_serviceRequest :
      choice = new H501_ServiceRequest();
      return TRUE;
    case e_serviceConfirmation :
      choice = new H501_ServiceConfirmation();
      return TRUE;
    case e_serviceRejection :
      choice = new H501_ServiceRejection();
      return TRUE;
    case e_serviceRelease :
      choice = new H501_ServiceRelease();
      return TRUE;
    case e_descriptorRequest :
      choice = new H501_DescriptorRequest();
      return TRUE;
    case e_descriptorConfirmation :
      choice = new H501_DescriptorConfirmation();
      return TRUE;
    case e_descriptorRejection :
      choice = new H501_DescriptorRejection();
      return TRUE;
    case e_descriptorIDRequest :
      choice = new H501_DescriptorIDRequest();
      return TRUE;
    case e_descriptorIDConfirmation :
      choice = new H501_DescriptorIDConfirmation();
      return TRUE;
    case e_descriptorIDRejection :
      choice = new H501_DescriptorIDRejection();
      return TRUE;
    case e_descriptorUpdate :
      choice = new H501_DescriptorUpdate();
      return TRUE;
    case e_descriptorUpdateAck :
      choice = new H501_DescriptorUpdateAck();
      return TRUE;
    case e_accessRequest :
      choice = new H501_AccessRequest();
      return TRUE;
    case e_accessConfirmation :
      choice = new H501_AccessConfirmation();
      return TRUE;
    case e_accessRejection :
      choice = new H501_AccessRejection();
      return TRUE;
    case e_requestInProgress :
      choice = new H501_RequestInProgress();
      return TRUE;
    case e_nonStandardRequest :
      choice = new H501_NonStandardRequest();
      return TRUE;
    case e_nonStandardConfirmation :
      choice = new H501_NonStandardConfirmation();
      return TRUE;
    case e_nonStandardRejection :
      choice = new H501_NonStandardRejection();
      return TRUE;
    case e_unknownMessageResponse :
      choice = new H501_UnknownMessageResponse();
      return TRUE;
    case e_usageRequest :
      choice = new H501_UsageRequest();
      return TRUE;
    case e_usageConfirmation :
      choice = new H501_UsageConfirmation();
      return TRUE;
    case e_usageIndication :
      choice = new H501_UsageIndication();
      return TRUE;
    case e_usageIndicationConfirmation :
      choice = new H501_UsageIndicationConfirmation();
      return TRUE;
    case e_usageIndicationRejection :
      choice = new H501_UsageIndicationRejection();
      return TRUE;
    case e_usageRejection :
      choice = new H501_UsageRejection();
      return TRUE;
    case e_validationRequest :
      choice = new H501_ValidationRequest();
      return TRUE;
    case e_validationConfirmation :
      choice = new H501_ValidationConfirmation();
      return TRUE;
    case e_validationRejection :
      choice = new H501_ValidationRejection();
      return TRUE;
    case e_authenticationRequest :
      choice = new H501_AuthenticationRequest();
      return TRUE;
    case e_authenticationConfirmation :
      choice = new H501_AuthenticationConfirmation();
      return TRUE;
    case e_authenticationRejection :
      choice = new H501_AuthenticationRejection();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H501_MessageBody::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_MessageBody::Class()), PInvalidCast);
#endif
  return new H501_MessageBody(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H501_ServiceRejectionReason[]={
      {"serviceUnavailable",0}
     ,{"serviceRedirected",1}
     ,{"security",2}
     ,{"continue",3}
     ,{"undefined",4}
     ,{"unknownServiceID",5}
     ,{"cannotSupportUsageSpec",6}
     ,{"neededFeature",7}
     ,{"genericDataReason",8}
     ,{"usageUnavailable",9}
     ,{"unknownUsageSendTo",10}
};
#endif
//
// ServiceRejectionReason
//

H501_ServiceRejectionReason::H501_ServiceRejectionReason(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 5, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H501_ServiceRejectionReason,11
#endif
)
{
}


BOOL H501_ServiceRejectionReason::CreateObject()
{
  choice = (tag <= e_unknownUsageSendTo) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H501_ServiceRejectionReason::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_ServiceRejectionReason::Class()), PInvalidCast);
#endif
  return new H501_ServiceRejectionReason(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H501_ServiceReleaseReason[]={
      {"outOfService",0}
     ,{"maintenance",1}
     ,{"terminated",2}
     ,{"expired",3}
};
#endif
//
// ServiceReleaseReason
//

H501_ServiceReleaseReason::H501_ServiceReleaseReason(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H501_ServiceReleaseReason,4
#endif
)
{
}


BOOL H501_ServiceReleaseReason::CreateObject()
{
  choice = (tag <= e_expired) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H501_ServiceReleaseReason::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_ServiceReleaseReason::Class()), PInvalidCast);
#endif
  return new H501_ServiceReleaseReason(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H501_DescriptorRejectionReason[]={
      {"packetSizeExceeded",0}
     ,{"illegalID",1}
     ,{"security",2}
     ,{"hopCountExceeded",3}
     ,{"noServiceRelationship",4}
     ,{"undefined",5}
     ,{"neededFeature",6}
     ,{"genericDataReason",7}
     ,{"unknownServiceID",8}
};
#endif
//
// DescriptorRejectionReason
//

H501_DescriptorRejectionReason::H501_DescriptorRejectionReason(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 6, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H501_DescriptorRejectionReason,9
#endif
)
{
}


BOOL H501_DescriptorRejectionReason::CreateObject()
{
  choice = (tag <= e_unknownServiceID) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H501_DescriptorRejectionReason::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_DescriptorRejectionReason::Class()), PInvalidCast);
#endif
  return new H501_DescriptorRejectionReason(*this);
}


//
// DescriptorIDRequest
//

H501_DescriptorIDRequest::H501_DescriptorIDRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H501_DescriptorIDRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PINDEX H501_DescriptorIDRequest::GetDataLength() const
{
  PINDEX length = 0;
  return length;
}


BOOL H501_DescriptorIDRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;


  return UnknownExtensionsDecode(strm);
}


void H501_DescriptorIDRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);


  UnknownExtensionsEncode(strm);
}


PObject * H501_DescriptorIDRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_DescriptorIDRequest::Class()), PInvalidCast);
#endif
  return new H501_DescriptorIDRequest(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H501_DescriptorIDRejectionReason[]={
      {"noDescriptors",0}
     ,{"security",1}
     ,{"hopCountExceeded",2}
     ,{"noServiceRelationship",3}
     ,{"undefined",4}
     ,{"neededFeature",5}
     ,{"genericDataReason",6}
     ,{"unknownServiceID",7}
};
#endif
//
// DescriptorIDRejectionReason
//

H501_DescriptorIDRejectionReason::H501_DescriptorIDRejectionReason(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 5, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H501_DescriptorIDRejectionReason,8
#endif
)
{
}


BOOL H501_DescriptorIDRejectionReason::CreateObject()
{
  choice = (tag <= e_unknownServiceID) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H501_DescriptorIDRejectionReason::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_DescriptorIDRejectionReason::Class()), PInvalidCast);
#endif
  return new H501_DescriptorIDRejectionReason(*this);
}


//
// DescriptorUpdateAck
//

H501_DescriptorUpdateAck::H501_DescriptorUpdateAck(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H501_DescriptorUpdateAck::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PINDEX H501_DescriptorUpdateAck::GetDataLength() const
{
  PINDEX length = 0;
  return length;
}


BOOL H501_DescriptorUpdateAck::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;


  return UnknownExtensionsDecode(strm);
}


void H501_DescriptorUpdateAck::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);


  UnknownExtensionsEncode(strm);
}


PObject * H501_DescriptorUpdateAck::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_DescriptorUpdateAck::Class()), PInvalidCast);
#endif
  return new H501_DescriptorUpdateAck(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H501_AccessRejectionReason[]={
      {"noMatch",0}
     ,{"packetSizeExceeded",1}
     ,{"security",2}
     ,{"hopCountExceeded",3}
     ,{"needCallInformation",4}
     ,{"noServiceRelationship",5}
     ,{"undefined",6}
     ,{"neededFeature",7}
     ,{"genericDataReason",8}
     ,{"destinationUnavailable",9}
     ,{"aliasesInconsistent",10}
     ,{"resourceUnavailable",11}
     ,{"incompleteAddress",12}
     ,{"unknownServiceID",13}
     ,{"usageUnavailable",14}
     ,{"cannotSupportUsageSpec",15}
     ,{"unknownUsageSendTo",16}
};
#endif
//
// AccessRejectionReason
//

H501_AccessRejectionReason::H501_AccessRejectionReason(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 7, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H501_AccessRejectionReason,17
#endif
)
{
}


BOOL H501_AccessRejectionReason::CreateObject()
{
  choice = (tag <= e_unknownUsageSendTo) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H501_AccessRejectionReason::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_AccessRejectionReason::Class()), PInvalidCast);
#endif
  return new H501_AccessRejectionReason(*this);
}


//
// UsageConfirmation
//

H501_UsageConfirmation::H501_UsageConfirmation(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H501_UsageConfirmation::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PINDEX H501_UsageConfirmation::GetDataLength() const
{
  PINDEX length = 0;
  return length;
}


BOOL H501_UsageConfirmation::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;


  return UnknownExtensionsDecode(strm);
}


void H501_UsageConfirmation::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);


  UnknownExtensionsEncode(strm);
}


PObject * H501_UsageConfirmation::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_UsageConfirmation::Class()), PInvalidCast);
#endif
  return new H501_UsageConfirmation(*this);
}


//
// UsageField
//

H501_UsageField::H501_UsageField(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H501_UsageField::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+5) << "id = " << setprecision(indent) << m_id << '\n';
  strm << setw(indent+8) << "value = " << setprecision(indent) << m_value << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H501_UsageField::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H501_UsageField), PInvalidCast);
#endif
  const H501_UsageField & other = (const H501_UsageField &)obj;

  Comparison result;

  if ((result = m_id.Compare(other.m_id)) != EqualTo)
    return result;
  if ((result = m_value.Compare(other.m_value)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H501_UsageField::GetDataLength() const
{
  PINDEX length = 0;
  length += m_id.GetObjectLength();
  length += m_value.GetObjectLength();
  return length;
}


BOOL H501_UsageField::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_id.Decode(strm))
    return FALSE;
  if (!m_value.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H501_UsageField::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_id.Encode(strm);
  m_value.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H501_UsageField::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_UsageField::Class()), PInvalidCast);
#endif
  return new H501_UsageField(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H501_UsageRejectReason[]={
      {"invalidCall",0}
     ,{"unavailable",1}
     ,{"security",2}
     ,{"noServiceRelationship",3}
     ,{"undefined",4}
     ,{"neededFeature",5}
     ,{"genericDataReason",6}
     ,{"unknownServiceID",7}
};
#endif
//
// UsageRejectReason
//

H501_UsageRejectReason::H501_UsageRejectReason(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 5, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H501_UsageRejectReason,8
#endif
)
{
}


BOOL H501_UsageRejectReason::CreateObject()
{
  choice = (tag <= e_unknownServiceID) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H501_UsageRejectReason::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_UsageRejectReason::Class()), PInvalidCast);
#endif
  return new H501_UsageRejectReason(*this);
}


//
// UsageIndicationConfirmation
//

H501_UsageIndicationConfirmation::H501_UsageIndicationConfirmation(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H501_UsageIndicationConfirmation::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PINDEX H501_UsageIndicationConfirmation::GetDataLength() const
{
  PINDEX length = 0;
  return length;
}


BOOL H501_UsageIndicationConfirmation::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;


  return UnknownExtensionsDecode(strm);
}


void H501_UsageIndicationConfirmation::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);


  UnknownExtensionsEncode(strm);
}


PObject * H501_UsageIndicationConfirmation::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_UsageIndicationConfirmation::Class()), PInvalidCast);
#endif
  return new H501_UsageIndicationConfirmation(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H501_UsageIndicationRejectionReason[]={
      {"unknownCall",0}
     ,{"incomplete",1}
     ,{"security",2}
     ,{"noServiceRelationship",3}
     ,{"undefined",4}
     ,{"neededFeature",5}
     ,{"genericDataReason",6}
     ,{"unknownServiceID",7}
};
#endif
//
// UsageIndicationRejectionReason
//

H501_UsageIndicationRejectionReason::H501_UsageIndicationRejectionReason(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 5, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H501_UsageIndicationRejectionReason,8
#endif
)
{
}


BOOL H501_UsageIndicationRejectionReason::CreateObject()
{
  choice = (tag <= e_unknownServiceID) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H501_UsageIndicationRejectionReason::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_UsageIndicationRejectionReason::Class()), PInvalidCast);
#endif
  return new H501_UsageIndicationRejectionReason(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H501_ValidationRejectionReason[]={
      {"tokenNotValid",0}
     ,{"security",1}
     ,{"hopCountExceeded",2}
     ,{"missingSourceInfo",3}
     ,{"missingDestInfo",4}
     ,{"noServiceRelationship",5}
     ,{"undefined",6}
     ,{"neededFeature",7}
     ,{"genericDataReason",8}
     ,{"unknownServiceID",9}
};
#endif
//
// ValidationRejectionReason
//

H501_ValidationRejectionReason::H501_ValidationRejectionReason(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 7, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H501_ValidationRejectionReason,10
#endif
)
{
}


BOOL H501_ValidationRejectionReason::CreateObject()
{
  choice = (tag <= e_unknownServiceID) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H501_ValidationRejectionReason::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_ValidationRejectionReason::Class()), PInvalidCast);
#endif
  return new H501_ValidationRejectionReason(*this);
}


//
// NonStandardRequest
//

H501_NonStandardRequest::H501_NonStandardRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H501_NonStandardRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PINDEX H501_NonStandardRequest::GetDataLength() const
{
  PINDEX length = 0;
  return length;
}


BOOL H501_NonStandardRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;


  return UnknownExtensionsDecode(strm);
}


void H501_NonStandardRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);


  UnknownExtensionsEncode(strm);
}


PObject * H501_NonStandardRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_NonStandardRequest::Class()), PInvalidCast);
#endif
  return new H501_NonStandardRequest(*this);
}


//
// NonStandardConfirmation
//

H501_NonStandardConfirmation::H501_NonStandardConfirmation(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H501_NonStandardConfirmation::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PINDEX H501_NonStandardConfirmation::GetDataLength() const
{
  PINDEX length = 0;
  return length;
}


BOOL H501_NonStandardConfirmation::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;


  return UnknownExtensionsDecode(strm);
}


void H501_NonStandardConfirmation::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);


  UnknownExtensionsEncode(strm);
}


PObject * H501_NonStandardConfirmation::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_NonStandardConfirmation::Class()), PInvalidCast);
#endif
  return new H501_NonStandardConfirmation(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H501_NonStandardRejectionReason[]={
      {"notSupported",0}
     ,{"noServiceRelationship",1}
     ,{"undefined",2}
     ,{"neededFeature",3}
     ,{"genericDataReason",4}
     ,{"unknownServiceID",5}
};
#endif
//
// NonStandardRejectionReason
//

H501_NonStandardRejectionReason::H501_NonStandardRejectionReason(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H501_NonStandardRejectionReason,6
#endif
)
{
}


BOOL H501_NonStandardRejectionReason::CreateObject()
{
  choice = (tag <= e_unknownServiceID) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H501_NonStandardRejectionReason::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_NonStandardRejectionReason::Class()), PInvalidCast);
#endif
  return new H501_NonStandardRejectionReason(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H501_UnknownMessageReason[]={
      {"notUnderstood",0}
     ,{"undefined",1}
};
#endif
//
// UnknownMessageReason
//

H501_UnknownMessageReason::H501_UnknownMessageReason(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H501_UnknownMessageReason,2
#endif
)
{
}


BOOL H501_UnknownMessageReason::CreateObject()
{
  choice = (tag <= e_undefined) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H501_UnknownMessageReason::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_UnknownMessageReason::Class()), PInvalidCast);
#endif
  return new H501_UnknownMessageReason(*this);
}


//
// ApplicationMessage
//

H501_ApplicationMessage::H501_ApplicationMessage(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_OctetString(tag, tagClass)
{
}


H501_ApplicationMessage::H501_ApplicationMessage(const char * v)
{
  SetValue(v);
}


H501_ApplicationMessage::H501_ApplicationMessage(const PString & v)
{
  SetValue(v);
}


H501_ApplicationMessage::H501_ApplicationMessage(const PBYTEArray & v)
{
  SetValue(v);
}


H501_ApplicationMessage & H501_ApplicationMessage::operator=(const char * v)
{
  SetValue(v);
  return *this;
}


H501_ApplicationMessage & H501_ApplicationMessage::operator=(const PString & v)
{
  SetValue(v);
  return *this;
}


H501_ApplicationMessage & H501_ApplicationMessage::operator=(const PBYTEArray & v)
{
  SetValue(v);
  return *this;
}


PObject * H501_ApplicationMessage::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_ApplicationMessage::Class()), PInvalidCast);
#endif
  return new H501_ApplicationMessage(*this);
}


//
// AuthenticationConfirmation
//

H501_AuthenticationConfirmation::H501_AuthenticationConfirmation(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H501_AuthenticationConfirmation::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PINDEX H501_AuthenticationConfirmation::GetDataLength() const
{
  PINDEX length = 0;
  return length;
}


BOOL H501_AuthenticationConfirmation::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;


  return UnknownExtensionsDecode(strm);
}


void H501_AuthenticationConfirmation::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);


  UnknownExtensionsEncode(strm);
}


PObject * H501_AuthenticationConfirmation::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_AuthenticationConfirmation::Class()), PInvalidCast);
#endif
  return new H501_AuthenticationConfirmation(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H501_AuthenticationRejectionReason[]={
      {"security",0}
     ,{"hopCountExceeded",1}
     ,{"noServiceRelationship",2}
     ,{"undefined",3}
     ,{"neededFeature",4}
     ,{"genericDataReason",5}
     ,{"unknownServiceID",6}
     ,{"securityWrongSyncTime",7}
     ,{"securityReplay",8}
     ,{"securityWrongGeneralID",9}
     ,{"securityWrongSendersID",10}
     ,{"securityIntegrityFailed",11}
     ,{"securityWrongOID",12}
};
#endif
//
// AuthenticationRejectionReason
//

H501_AuthenticationRejectionReason::H501_AuthenticationRejectionReason(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 13, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H501_AuthenticationRejectionReason,13
#endif
)
{
}


BOOL H501_AuthenticationRejectionReason::CreateObject()
{
  choice = (tag <= e_securityWrongOID) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H501_AuthenticationRejectionReason::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_AuthenticationRejectionReason::Class()), PInvalidCast);
#endif
  return new H501_AuthenticationRejectionReason(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H501_Pattern[]={
      {"specific",0}
     ,{"wildcard",1}
     ,{"range",2}
};
#endif
//
// Pattern
//

H501_Pattern::H501_Pattern(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H501_Pattern,3
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H501_Pattern::operator H225_AliasAddress &() const
#else
H501_Pattern::operator H225_AliasAddress &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H225_AliasAddress), PInvalidCast);
#endif
  return *(H225_AliasAddress *)choice;
}


H501_Pattern::operator const H225_AliasAddress &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H225_AliasAddress), PInvalidCast);
#endif
  return *(H225_AliasAddress *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H501_Pattern::operator H501_Pattern_range &() const
#else
H501_Pattern::operator H501_Pattern_range &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_Pattern_range), PInvalidCast);
#endif
  return *(H501_Pattern_range *)choice;
}


H501_Pattern::operator const H501_Pattern_range &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_Pattern_range), PInvalidCast);
#endif
  return *(H501_Pattern_range *)choice;
}


BOOL H501_Pattern::CreateObject()
{
  switch (tag) {
    case e_specific :
    case e_wildcard :
      choice = new H225_AliasAddress();
      return TRUE;
    case e_range :
      choice = new H501_Pattern_range();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H501_Pattern::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_Pattern::Class()), PInvalidCast);
#endif
  return new H501_Pattern(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H501_AccessToken[]={
      {"token",0}
     ,{"cryptoToken",1}
     ,{"genericData",2}
};
#endif
//
// AccessToken
//

H501_AccessToken::H501_AccessToken(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H501_AccessToken,3
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H501_AccessToken::operator H235_ClearToken &() const
#else
H501_AccessToken::operator H235_ClearToken &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H235_ClearToken), PInvalidCast);
#endif
  return *(H235_ClearToken *)choice;
}


H501_AccessToken::operator const H235_ClearToken &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H235_ClearToken), PInvalidCast);
#endif
  return *(H235_ClearToken *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H501_AccessToken::operator H225_CryptoH323Token &() const
#else
H501_AccessToken::operator H225_CryptoH323Token &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H225_CryptoH323Token), PInvalidCast);
#endif
  return *(H225_CryptoH323Token *)choice;
}


H501_AccessToken::operator const H225_CryptoH323Token &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H225_CryptoH323Token), PInvalidCast);
#endif
  return *(H225_CryptoH323Token *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H501_AccessToken::operator H225_GenericData &() const
#else
H501_AccessToken::operator H225_GenericData &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H225_GenericData), PInvalidCast);
#endif
  return *(H225_GenericData *)choice;
}


H501_AccessToken::operator const H225_GenericData &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H225_GenericData), PInvalidCast);
#endif
  return *(H225_GenericData *)choice;
}


BOOL H501_AccessToken::CreateObject()
{
  switch (tag) {
    case e_token :
      choice = new H235_ClearToken();
      return TRUE;
    case e_cryptoToken :
      choice = new H225_CryptoH323Token();
      return TRUE;
    case e_genericData :
      choice = new H225_GenericData();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H501_AccessToken::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_AccessToken::Class()), PInvalidCast);
#endif
  return new H501_AccessToken(*this);
}


//
// CallInformation
//

H501_CallInformation::H501_CallInformation(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 1)
{
}


#ifndef PASN_NOPRINTON
void H501_CallInformation::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "callIdentifier = " << setprecision(indent) << m_callIdentifier << '\n';
  strm << setw(indent+15) << "conferenceID = " << setprecision(indent) << m_conferenceID << '\n';
  if (HasOptionalField(e_circuitID))
    strm << setw(indent+12) << "circuitID = " << setprecision(indent) << m_circuitID << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H501_CallInformation::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H501_CallInformation), PInvalidCast);
#endif
  const H501_CallInformation & other = (const H501_CallInformation &)obj;

  Comparison result;

  if ((result = m_callIdentifier.Compare(other.m_callIdentifier)) != EqualTo)
    return result;
  if ((result = m_conferenceID.Compare(other.m_conferenceID)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H501_CallInformation::GetDataLength() const
{
  PINDEX length = 0;
  length += m_callIdentifier.GetObjectLength();
  length += m_conferenceID.GetObjectLength();
  return length;
}


BOOL H501_CallInformation::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_callIdentifier.Decode(strm))
    return FALSE;
  if (!m_conferenceID.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_circuitID, m_circuitID))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H501_CallInformation::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_callIdentifier.Encode(strm);
  m_conferenceID.Encode(strm);
  KnownExtensionEncode(strm, e_circuitID, m_circuitID);

  UnknownExtensionsEncode(strm);
}


PObject * H501_CallInformation::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_CallInformation::Class()), PInvalidCast);
#endif
  return new H501_CallInformation(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H501_UsageCallStatus[]={
      {"preConnect",0}
     ,{"callInProgress",1}
     ,{"callEnded",2}
     ,{"registrationLost",3}
};
#endif
//
// UsageCallStatus
//

H501_UsageCallStatus::H501_UsageCallStatus(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H501_UsageCallStatus,4
#endif
)
{
}


BOOL H501_UsageCallStatus::CreateObject()
{
  choice = (tag <= e_registrationLost) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H501_UsageCallStatus::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_UsageCallStatus::Class()), PInvalidCast);
#endif
  return new H501_UsageCallStatus(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H501_Role[]={
      {"originator",0}
     ,{"destination",1}
     ,{"nonStandardData",2}
};
#endif
//
// Role
//

H501_Role::H501_Role(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H501_Role,3
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H501_Role::operator H225_NonStandardParameter &() const
#else
H501_Role::operator H225_NonStandardParameter &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H225_NonStandardParameter), PInvalidCast);
#endif
  return *(H225_NonStandardParameter *)choice;
}


H501_Role::operator const H225_NonStandardParameter &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H225_NonStandardParameter), PInvalidCast);
#endif
  return *(H225_NonStandardParameter *)choice;
}


BOOL H501_Role::CreateObject()
{
  switch (tag) {
    case e_originator :
    case e_destination :
      choice = new PASN_Null();
      return TRUE;
    case e_nonStandardData :
      choice = new H225_NonStandardParameter();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H501_Role::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_Role::Class()), PInvalidCast);
#endif
  return new H501_Role(*this);
}


//
// TimeZone
//

H501_TimeZone::H501_TimeZone(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Integer(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, -43200, 43200);
}


H501_TimeZone & H501_TimeZone::operator=(int v)
{
  SetValue(v);
  return *this;
}


H501_TimeZone & H501_TimeZone::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H501_TimeZone::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_TimeZone::Class()), PInvalidCast);
#endif
  return new H501_TimeZone(*this);
}


//
// TerminationCause
//

H501_TerminationCause::H501_TerminationCause(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
  m_causeIE.SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
}


#ifndef PASN_NOPRINTON
void H501_TerminationCause::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+24) << "releaseCompleteReason = " << setprecision(indent) << m_releaseCompleteReason << '\n';
  if (HasOptionalField(e_causeIE))
    strm << setw(indent+10) << "causeIE = " << setprecision(indent) << m_causeIE << '\n';
  if (HasOptionalField(e_nonStandardData))
    strm << setw(indent+18) << "nonStandardData = " << setprecision(indent) << m_nonStandardData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H501_TerminationCause::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H501_TerminationCause), PInvalidCast);
#endif
  const H501_TerminationCause & other = (const H501_TerminationCause &)obj;

  Comparison result;

  if ((result = m_releaseCompleteReason.Compare(other.m_releaseCompleteReason)) != EqualTo)
    return result;
  if ((result = m_causeIE.Compare(other.m_causeIE)) != EqualTo)
    return result;
  if ((result = m_nonStandardData.Compare(other.m_nonStandardData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H501_TerminationCause::GetDataLength() const
{
  PINDEX length = 0;
  length += m_releaseCompleteReason.GetObjectLength();
  if (HasOptionalField(e_causeIE))
    length += m_causeIE.GetObjectLength();
  if (HasOptionalField(e_nonStandardData))
    length += m_nonStandardData.GetObjectLength();
  return length;
}


BOOL H501_TerminationCause::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_releaseCompleteReason.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_causeIE) && !m_causeIE.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_nonStandardData) && !m_nonStandardData.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H501_TerminationCause::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_releaseCompleteReason.Encode(strm);
  if (HasOptionalField(e_causeIE))
    m_causeIE.Encode(strm);
  if (HasOptionalField(e_nonStandardData))
    m_nonStandardData.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H501_TerminationCause::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_TerminationCause::Class()), PInvalidCast);
#endif
  return new H501_TerminationCause(*this);
}


//
// ProtocolVersion
//

H501_ProtocolVersion::H501_ProtocolVersion(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_ObjectId(tag, tagClass)
{
}


PObject * H501_ProtocolVersion::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_ProtocolVersion::Class()), PInvalidCast);
#endif
  return new H501_ProtocolVersion(*this);
}


//
// ElementIdentifier
//

H501_ElementIdentifier::H501_ElementIdentifier(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_BMPString(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 1, 128);
}


H501_ElementIdentifier & H501_ElementIdentifier::operator=(const char * v)
{
  SetValue(v);
  return *this;
}


H501_ElementIdentifier & H501_ElementIdentifier::operator=(const PString & v)
{
  SetValue(v);
  return *this;
}


H501_ElementIdentifier & H501_ElementIdentifier::operator=(const PWORDArray & v)
{
  SetValue(v);
  return *this;
}


H501_ElementIdentifier & H501_ElementIdentifier::operator=(const PASN_BMPString & v)
{
  SetValue(v);
  return *this;
}


PObject * H501_ElementIdentifier::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_ElementIdentifier::Class()), PInvalidCast);
#endif
  return new H501_ElementIdentifier(*this);
}


//
// GlobalTimeStamp
//

H501_GlobalTimeStamp::H501_GlobalTimeStamp(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_IA5String(tag, tagClass)
{
  SetConstraints(PASN_Object::FixedConstraint, 14);
}


H501_GlobalTimeStamp & H501_GlobalTimeStamp::operator=(const char * v)
{
  SetValue(v);
  return *this;
}


H501_GlobalTimeStamp & H501_GlobalTimeStamp::operator=(const PString & v)
{
  SetValue(v);
  return *this;
}


PObject * H501_GlobalTimeStamp::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_GlobalTimeStamp::Class()), PInvalidCast);
#endif
  return new H501_GlobalTimeStamp(*this);
}


//
// ArrayOf_TransportAddress
//

H501_ArrayOf_TransportAddress::H501_ArrayOf_TransportAddress(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H501_ArrayOf_TransportAddress::CreateObject() const
{
  return new H225_TransportAddress;
}


H225_TransportAddress & H501_ArrayOf_TransportAddress::operator[](PINDEX i) const
{
  return (H225_TransportAddress &)array[i];
}


PObject * H501_ArrayOf_TransportAddress::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_ArrayOf_TransportAddress::Class()), PInvalidCast);
#endif
  return new H501_ArrayOf_TransportAddress(*this);
}


//
// ArrayOf_ClearToken
//

H501_ArrayOf_ClearToken::H501_ArrayOf_ClearToken(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H501_ArrayOf_ClearToken::CreateObject() const
{
  return new H235_ClearToken;
}


H235_ClearToken & H501_ArrayOf_ClearToken::operator[](PINDEX i) const
{
  return (H235_ClearToken &)array[i];
}


PObject * H501_ArrayOf_ClearToken::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_ArrayOf_ClearToken::Class()), PInvalidCast);
#endif
  return new H501_ArrayOf_ClearToken(*this);
}


//
// ArrayOf_CryptoH323Token
//

H501_ArrayOf_CryptoH323Token::H501_ArrayOf_CryptoH323Token(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H501_ArrayOf_CryptoH323Token::CreateObject() const
{
  return new H225_CryptoH323Token;
}


H225_CryptoH323Token & H501_ArrayOf_CryptoH323Token::operator[](PINDEX i) const
{
  return (H225_CryptoH323Token &)array[i];
}


PObject * H501_ArrayOf_CryptoH323Token::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_ArrayOf_CryptoH323Token::Class()), PInvalidCast);
#endif
  return new H501_ArrayOf_CryptoH323Token(*this);
}


//
// ArrayOf_NonStandardParameter
//

H501_ArrayOf_NonStandardParameter::H501_ArrayOf_NonStandardParameter(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H501_ArrayOf_NonStandardParameter::CreateObject() const
{
  return new H225_NonStandardParameter;
}


H225_NonStandardParameter & H501_ArrayOf_NonStandardParameter::operator[](PINDEX i) const
{
  return (H225_NonStandardParameter &)array[i];
}


PObject * H501_ArrayOf_NonStandardParameter::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_ArrayOf_NonStandardParameter::Class()), PInvalidCast);
#endif
  return new H501_ArrayOf_NonStandardParameter(*this);
}


//
// ArrayOf_GenericData
//

H501_ArrayOf_GenericData::H501_ArrayOf_GenericData(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H501_ArrayOf_GenericData::CreateObject() const
{
  return new H225_GenericData;
}


H225_GenericData & H501_ArrayOf_GenericData::operator[](PINDEX i) const
{
  return (H225_GenericData &)array[i];
}


PObject * H501_ArrayOf_GenericData::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_ArrayOf_GenericData::Class()), PInvalidCast);
#endif
  return new H501_ArrayOf_GenericData(*this);
}


//
// ArrayOf_SecurityMode
//

H501_ArrayOf_SecurityMode::H501_ArrayOf_SecurityMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H501_ArrayOf_SecurityMode::CreateObject() const
{
  return new H501_SecurityMode;
}


H501_SecurityMode & H501_ArrayOf_SecurityMode::operator[](PINDEX i) const
{
  return (H501_SecurityMode &)array[i];
}


PObject * H501_ArrayOf_SecurityMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_ArrayOf_SecurityMode::Class()), PInvalidCast);
#endif
  return new H501_ArrayOf_SecurityMode(*this);
}


//
// ArrayOf_PASN_ObjectId
//

H501_ArrayOf_PASN_ObjectId::H501_ArrayOf_PASN_ObjectId(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H501_ArrayOf_PASN_ObjectId::CreateObject() const
{
  return new PASN_ObjectId;
}


PASN_ObjectId & H501_ArrayOf_PASN_ObjectId::operator[](PINDEX i) const
{
  return (PASN_ObjectId &)array[i];
}


PObject * H501_ArrayOf_PASN_ObjectId::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_ArrayOf_PASN_ObjectId::Class()), PInvalidCast);
#endif
  return new H501_ArrayOf_PASN_ObjectId(*this);
}


//
// ArrayOf_GloballyUniqueID
//

H501_ArrayOf_GloballyUniqueID::H501_ArrayOf_GloballyUniqueID(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H501_ArrayOf_GloballyUniqueID::CreateObject() const
{
  return new H225_GloballyUniqueID;
}


H225_GloballyUniqueID & H501_ArrayOf_GloballyUniqueID::operator[](PINDEX i) const
{
  return (H225_GloballyUniqueID &)array[i];
}


PObject * H501_ArrayOf_GloballyUniqueID::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_ArrayOf_GloballyUniqueID::Class()), PInvalidCast);
#endif
  return new H501_ArrayOf_GloballyUniqueID(*this);
}


//
// ArrayOf_Descriptor
//

H501_ArrayOf_Descriptor::H501_ArrayOf_Descriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H501_ArrayOf_Descriptor::CreateObject() const
{
  return new H501_Descriptor;
}


H501_Descriptor & H501_ArrayOf_Descriptor::operator[](PINDEX i) const
{
  return (H501_Descriptor &)array[i];
}


PObject * H501_ArrayOf_Descriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_ArrayOf_Descriptor::Class()), PInvalidCast);
#endif
  return new H501_ArrayOf_Descriptor(*this);
}


//
// ArrayOf_DescriptorInfo
//

H501_ArrayOf_DescriptorInfo::H501_ArrayOf_DescriptorInfo(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H501_ArrayOf_DescriptorInfo::CreateObject() const
{
  return new H501_DescriptorInfo;
}


H501_DescriptorInfo & H501_ArrayOf_DescriptorInfo::operator[](PINDEX i) const
{
  return (H501_DescriptorInfo &)array[i];
}


PObject * H501_ArrayOf_DescriptorInfo::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_ArrayOf_DescriptorInfo::Class()), PInvalidCast);
#endif
  return new H501_ArrayOf_DescriptorInfo(*this);
}


//
// ArrayOf_UpdateInformation
//

H501_ArrayOf_UpdateInformation::H501_ArrayOf_UpdateInformation(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H501_ArrayOf_UpdateInformation::CreateObject() const
{
  return new H501_UpdateInformation;
}


H501_UpdateInformation & H501_ArrayOf_UpdateInformation::operator[](PINDEX i) const
{
  return (H501_UpdateInformation &)array[i];
}


PObject * H501_ArrayOf_UpdateInformation::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_ArrayOf_UpdateInformation::Class()), PInvalidCast);
#endif
  return new H501_ArrayOf_UpdateInformation(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H501_UpdateInformation_descriptorInfo[]={
      {"descriptorID",0}
     ,{"descriptor",1}
};
#endif
//
// UpdateInformation_descriptorInfo
//

H501_UpdateInformation_descriptorInfo::H501_UpdateInformation_descriptorInfo(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H501_UpdateInformation_descriptorInfo,2
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H501_UpdateInformation_descriptorInfo::operator H225_GloballyUniqueID &() const
#else
H501_UpdateInformation_descriptorInfo::operator H225_GloballyUniqueID &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H225_GloballyUniqueID), PInvalidCast);
#endif
  return *(H225_GloballyUniqueID *)choice;
}


H501_UpdateInformation_descriptorInfo::operator const H225_GloballyUniqueID &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H225_GloballyUniqueID), PInvalidCast);
#endif
  return *(H225_GloballyUniqueID *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H501_UpdateInformation_descriptorInfo::operator H501_Descriptor &() const
#else
H501_UpdateInformation_descriptorInfo::operator H501_Descriptor &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_Descriptor), PInvalidCast);
#endif
  return *(H501_Descriptor *)choice;
}


H501_UpdateInformation_descriptorInfo::operator const H501_Descriptor &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H501_Descriptor), PInvalidCast);
#endif
  return *(H501_Descriptor *)choice;
}


BOOL H501_UpdateInformation_descriptorInfo::CreateObject()
{
  switch (tag) {
    case e_descriptorID :
      choice = new H225_GloballyUniqueID();
      return TRUE;
    case e_descriptor :
      choice = new H501_Descriptor();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H501_UpdateInformation_descriptorInfo::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_UpdateInformation_descriptorInfo::Class()), PInvalidCast);
#endif
  return new H501_UpdateInformation_descriptorInfo(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H501_UpdateInformation_updateType[]={
      {"added",0}
     ,{"deleted",1}
     ,{"changed",2}
};
#endif
//
// UpdateInformation_updateType
//

H501_UpdateInformation_updateType::H501_UpdateInformation_updateType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H501_UpdateInformation_updateType,3
#endif
)
{
}


BOOL H501_UpdateInformation_updateType::CreateObject()
{
  choice = (tag <= e_changed) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H501_UpdateInformation_updateType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_UpdateInformation_updateType::Class()), PInvalidCast);
#endif
  return new H501_UpdateInformation_updateType(*this);
}


//
// ArrayOf_SupportedProtocols
//

H501_ArrayOf_SupportedProtocols::H501_ArrayOf_SupportedProtocols(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H501_ArrayOf_SupportedProtocols::CreateObject() const
{
  return new H225_SupportedProtocols;
}


H225_SupportedProtocols & H501_ArrayOf_SupportedProtocols::operator[](PINDEX i) const
{
  return (H225_SupportedProtocols &)array[i];
}


PObject * H501_ArrayOf_SupportedProtocols::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_ArrayOf_SupportedProtocols::Class()), PInvalidCast);
#endif
  return new H501_ArrayOf_SupportedProtocols(*this);
}


//
// ArrayOf_AddressTemplate
//

H501_ArrayOf_AddressTemplate::H501_ArrayOf_AddressTemplate(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H501_ArrayOf_AddressTemplate::CreateObject() const
{
  return new H501_AddressTemplate;
}


H501_AddressTemplate & H501_ArrayOf_AddressTemplate::operator[](PINDEX i) const
{
  return (H501_AddressTemplate &)array[i];
}


PObject * H501_ArrayOf_AddressTemplate::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_ArrayOf_AddressTemplate::Class()), PInvalidCast);
#endif
  return new H501_ArrayOf_AddressTemplate(*this);
}


//
// ArrayOf_ServiceControlSession
//

H501_ArrayOf_ServiceControlSession::H501_ArrayOf_ServiceControlSession(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H501_ArrayOf_ServiceControlSession::CreateObject() const
{
  return new H225_ServiceControlSession;
}


H225_ServiceControlSession & H501_ArrayOf_ServiceControlSession::operator[](PINDEX i) const
{
  return (H225_ServiceControlSession &)array[i];
}


PObject * H501_ArrayOf_ServiceControlSession::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_ArrayOf_ServiceControlSession::Class()), PInvalidCast);
#endif
  return new H501_ArrayOf_ServiceControlSession(*this);
}


//
// ArrayOf_AccessToken
//

H501_ArrayOf_AccessToken::H501_ArrayOf_AccessToken(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H501_ArrayOf_AccessToken::CreateObject() const
{
  return new H501_AccessToken;
}


H501_AccessToken & H501_ArrayOf_AccessToken::operator[](PINDEX i) const
{
  return (H501_AccessToken &)array[i];
}


PObject * H501_ArrayOf_AccessToken::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_ArrayOf_AccessToken::Class()), PInvalidCast);
#endif
  return new H501_ArrayOf_AccessToken(*this);
}


//
// ArrayOf_UsageField
//

H501_ArrayOf_UsageField::H501_ArrayOf_UsageField(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H501_ArrayOf_UsageField::CreateObject() const
{
  return new H501_UsageField;
}


H501_UsageField & H501_ArrayOf_UsageField::operator[](PINDEX i) const
{
  return (H501_UsageField &)array[i];
}


PObject * H501_ArrayOf_UsageField::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_ArrayOf_UsageField::Class()), PInvalidCast);
#endif
  return new H501_ArrayOf_UsageField(*this);
}


//
// ArrayOf_Pattern
//

H501_ArrayOf_Pattern::H501_ArrayOf_Pattern(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H501_ArrayOf_Pattern::CreateObject() const
{
  return new H501_Pattern;
}


H501_Pattern & H501_ArrayOf_Pattern::operator[](PINDEX i) const
{
  return (H501_Pattern &)array[i];
}


PObject * H501_ArrayOf_Pattern::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_ArrayOf_Pattern::Class()), PInvalidCast);
#endif
  return new H501_ArrayOf_Pattern(*this);
}


//
// ArrayOf_RouteInformation
//

H501_ArrayOf_RouteInformation::H501_ArrayOf_RouteInformation(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H501_ArrayOf_RouteInformation::CreateObject() const
{
  return new H501_RouteInformation;
}


H501_RouteInformation & H501_ArrayOf_RouteInformation::operator[](PINDEX i) const
{
  return (H501_RouteInformation &)array[i];
}


PObject * H501_ArrayOf_RouteInformation::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_ArrayOf_RouteInformation::Class()), PInvalidCast);
#endif
  return new H501_ArrayOf_RouteInformation(*this);
}


//
// Pattern_range
//

H501_Pattern_range::H501_Pattern_range(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, FALSE, 0)
{
}


#ifndef PASN_NOPRINTON
void H501_Pattern_range::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "startOfRange = " << setprecision(indent) << m_startOfRange << '\n';
  strm << setw(indent+13) << "endOfRange = " << setprecision(indent) << m_endOfRange << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H501_Pattern_range::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H501_Pattern_range), PInvalidCast);
#endif
  const H501_Pattern_range & other = (const H501_Pattern_range &)obj;

  Comparison result;

  if ((result = m_startOfRange.Compare(other.m_startOfRange)) != EqualTo)
    return result;
  if ((result = m_endOfRange.Compare(other.m_endOfRange)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H501_Pattern_range::GetDataLength() const
{
  PINDEX length = 0;
  length += m_startOfRange.GetObjectLength();
  length += m_endOfRange.GetObjectLength();
  return length;
}


BOOL H501_Pattern_range::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_startOfRange.Decode(strm))
    return FALSE;
  if (!m_endOfRange.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H501_Pattern_range::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_startOfRange.Encode(strm);
  m_endOfRange.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H501_Pattern_range::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_Pattern_range::Class()), PInvalidCast);
#endif
  return new H501_Pattern_range(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H501_RouteInformation_messageType[]={
      {"sendAccessRequest",0}
     ,{"sendSetup",1}
     ,{"nonExistent",2}
};
#endif
//
// RouteInformation_messageType
//

H501_RouteInformation_messageType::H501_RouteInformation_messageType(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 3, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H501_RouteInformation_messageType,3
#endif
)
{
}


BOOL H501_RouteInformation_messageType::CreateObject()
{
  choice = (tag <= e_nonExistent) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H501_RouteInformation_messageType::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_RouteInformation_messageType::Class()), PInvalidCast);
#endif
  return new H501_RouteInformation_messageType(*this);
}


//
// ArrayOf_PriceInfoSpec
//

H501_ArrayOf_PriceInfoSpec::H501_ArrayOf_PriceInfoSpec(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H501_ArrayOf_PriceInfoSpec::CreateObject() const
{
  return new H501_PriceInfoSpec;
}


H501_PriceInfoSpec & H501_ArrayOf_PriceInfoSpec::operator[](PINDEX i) const
{
  return (H501_PriceInfoSpec &)array[i];
}


PObject * H501_ArrayOf_PriceInfoSpec::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_ArrayOf_PriceInfoSpec::Class()), PInvalidCast);
#endif
  return new H501_ArrayOf_PriceInfoSpec(*this);
}


//
// ArrayOf_ContactInformation
//

H501_ArrayOf_ContactInformation::H501_ArrayOf_ContactInformation(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H501_ArrayOf_ContactInformation::CreateObject() const
{
  return new H501_ContactInformation;
}


H501_ContactInformation & H501_ArrayOf_ContactInformation::operator[](PINDEX i) const
{
  return (H501_ContactInformation &)array[i];
}


PObject * H501_ArrayOf_ContactInformation::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_ArrayOf_ContactInformation::Class()), PInvalidCast);
#endif
  return new H501_ArrayOf_ContactInformation(*this);
}


//
// ArrayOf_CircuitIdentifier
//

H501_ArrayOf_CircuitIdentifier::H501_ArrayOf_CircuitIdentifier(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H501_ArrayOf_CircuitIdentifier::CreateObject() const
{
  return new H225_CircuitIdentifier;
}


H225_CircuitIdentifier & H501_ArrayOf_CircuitIdentifier::operator[](PINDEX i) const
{
  return (H225_CircuitIdentifier &)array[i];
}


PObject * H501_ArrayOf_CircuitIdentifier::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_ArrayOf_CircuitIdentifier::Class()), PInvalidCast);
#endif
  return new H501_ArrayOf_CircuitIdentifier(*this);
}


//
// ArrayOf_PriceElement
//

H501_ArrayOf_PriceElement::H501_ArrayOf_PriceElement(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H501_ArrayOf_PriceElement::CreateObject() const
{
  return new H501_PriceElement;
}


H501_PriceElement & H501_ArrayOf_PriceElement::operator[](PINDEX i) const
{
  return (H501_PriceElement &)array[i];
}


PObject * H501_ArrayOf_PriceElement::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_ArrayOf_PriceElement::Class()), PInvalidCast);
#endif
  return new H501_ArrayOf_PriceElement(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H501_PriceElement_units[]={
      {"seconds",0}
     ,{"packets",1}
     ,{"bytes",2}
     ,{"initial",3}
     ,{"minimum",4}
     ,{"maximum",5}
};
#endif
//
// PriceElement_units
//

H501_PriceElement_units::H501_PriceElement_units(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 6, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H501_PriceElement_units,6
#endif
)
{
}


BOOL H501_PriceElement_units::CreateObject()
{
  choice = (tag <= e_maximum) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H501_PriceElement_units::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_PriceElement_units::Class()), PInvalidCast);
#endif
  return new H501_PriceElement_units(*this);
}


//
// ArrayOf_AlternatePE
//

H501_ArrayOf_AlternatePE::H501_ArrayOf_AlternatePE(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H501_ArrayOf_AlternatePE::CreateObject() const
{
  return new H501_AlternatePE;
}


H501_AlternatePE & H501_ArrayOf_AlternatePE::operator[](PINDEX i) const
{
  return (H501_AlternatePE &)array[i];
}


PObject * H501_ArrayOf_AlternatePE::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_ArrayOf_AlternatePE::Class()), PInvalidCast);
#endif
  return new H501_ArrayOf_AlternatePE(*this);
}


//
// UsageSpecification_when
//

H501_UsageSpecification_when::H501_UsageSpecification_when(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 5, TRUE, 0)
{
  m_period.SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
}


#ifndef PASN_NOPRINTON
void H501_UsageSpecification_when::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_never))
    strm << setw(indent+8) << "never = " << setprecision(indent) << m_never << '\n';
  if (HasOptionalField(e_start))
    strm << setw(indent+8) << "start = " << setprecision(indent) << m_start << '\n';
  if (HasOptionalField(e_end))
    strm << setw(indent+6) << "end = " << setprecision(indent) << m_end << '\n';
  if (HasOptionalField(e_period))
    strm << setw(indent+9) << "period = " << setprecision(indent) << m_period << '\n';
  if (HasOptionalField(e_failures))
    strm << setw(indent+11) << "failures = " << setprecision(indent) << m_failures << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H501_UsageSpecification_when::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H501_UsageSpecification_when), PInvalidCast);
#endif
  const H501_UsageSpecification_when & other = (const H501_UsageSpecification_when &)obj;

  Comparison result;

  if ((result = m_never.Compare(other.m_never)) != EqualTo)
    return result;
  if ((result = m_start.Compare(other.m_start)) != EqualTo)
    return result;
  if ((result = m_end.Compare(other.m_end)) != EqualTo)
    return result;
  if ((result = m_period.Compare(other.m_period)) != EqualTo)
    return result;
  if ((result = m_failures.Compare(other.m_failures)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H501_UsageSpecification_when::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_never))
    length += m_never.GetObjectLength();
  if (HasOptionalField(e_start))
    length += m_start.GetObjectLength();
  if (HasOptionalField(e_end))
    length += m_end.GetObjectLength();
  if (HasOptionalField(e_period))
    length += m_period.GetObjectLength();
  if (HasOptionalField(e_failures))
    length += m_failures.GetObjectLength();
  return length;
}


BOOL H501_UsageSpecification_when::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_never) && !m_never.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_start) && !m_start.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_end) && !m_end.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_period) && !m_period.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_failures) && !m_failures.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H501_UsageSpecification_when::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_never))
    m_never.Encode(strm);
  if (HasOptionalField(e_start))
    m_start.Encode(strm);
  if (HasOptionalField(e_end))
    m_end.Encode(strm);
  if (HasOptionalField(e_period))
    m_period.Encode(strm);
  if (HasOptionalField(e_failures))
    m_failures.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H501_UsageSpecification_when::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_UsageSpecification_when::Class()), PInvalidCast);
#endif
  return new H501_UsageSpecification_when(*this);
}


//
// ArrayOf_AliasAddress
//

H501_ArrayOf_AliasAddress::H501_ArrayOf_AliasAddress(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H501_ArrayOf_AliasAddress::CreateObject() const
{
  return new H225_AliasAddress;
}


H225_AliasAddress & H501_ArrayOf_AliasAddress::operator[](PINDEX i) const
{
  return (H225_AliasAddress &)array[i];
}


PObject * H501_ArrayOf_AliasAddress::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_ArrayOf_AliasAddress::Class()), PInvalidCast);
#endif
  return new H501_ArrayOf_AliasAddress(*this);
}


//
// MessageCommonInfo
//

H501_MessageCommonInfo::H501_MessageCommonInfo(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 5, TRUE, 4)
{
  m_sequenceNumber.SetConstraints(PASN_Object::FixedConstraint, 0, 65535);
  m_hopCount.SetConstraints(PASN_Object::FixedConstraint, 1, 255);
  IncludeOptionalField(e_version);
}


#ifndef PASN_NOPRINTON
void H501_MessageCommonInfo::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "sequenceNumber = " << setprecision(indent) << m_sequenceNumber << '\n';
  strm << setw(indent+16) << "annexGversion = " << setprecision(indent) << m_annexGversion << '\n';
  strm << setw(indent+11) << "hopCount = " << setprecision(indent) << m_hopCount << '\n';
  if (HasOptionalField(e_replyAddress))
    strm << setw(indent+15) << "replyAddress = " << setprecision(indent) << m_replyAddress << '\n';
  if (HasOptionalField(e_integrityCheckValue))
    strm << setw(indent+22) << "integrityCheckValue = " << setprecision(indent) << m_integrityCheckValue << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  if (HasOptionalField(e_nonStandard))
    strm << setw(indent+14) << "nonStandard = " << setprecision(indent) << m_nonStandard << '\n';
  if (HasOptionalField(e_serviceID))
    strm << setw(indent+12) << "serviceID = " << setprecision(indent) << m_serviceID << '\n';
  if (HasOptionalField(e_genericData))
    strm << setw(indent+14) << "genericData = " << setprecision(indent) << m_genericData << '\n';
  if (HasOptionalField(e_featureSet))
    strm << setw(indent+13) << "featureSet = " << setprecision(indent) << m_featureSet << '\n';
  if (HasOptionalField(e_version))
    strm << setw(indent+10) << "version = " << setprecision(indent) << m_version << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H501_MessageCommonInfo::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H501_MessageCommonInfo), PInvalidCast);
#endif
  const H501_MessageCommonInfo & other = (const H501_MessageCommonInfo &)obj;

  Comparison result;

  if ((result = m_sequenceNumber.Compare(other.m_sequenceNumber)) != EqualTo)
    return result;
  if ((result = m_annexGversion.Compare(other.m_annexGversion)) != EqualTo)
    return result;
  if ((result = m_hopCount.Compare(other.m_hopCount)) != EqualTo)
    return result;
  if ((result = m_replyAddress.Compare(other.m_replyAddress)) != EqualTo)
    return result;
  if ((result = m_integrityCheckValue.Compare(other.m_integrityCheckValue)) != EqualTo)
    return result;
  if ((result = m_tokens.Compare(other.m_tokens)) != EqualTo)
    return result;
  if ((result = m_cryptoTokens.Compare(other.m_cryptoTokens)) != EqualTo)
    return result;
  if ((result = m_nonStandard.Compare(other.m_nonStandard)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H501_MessageCommonInfo::GetDataLength() const
{
  PINDEX length = 0;
  length += m_sequenceNumber.GetObjectLength();
  length += m_annexGversion.GetObjectLength();
  length += m_hopCount.GetObjectLength();
  if (HasOptionalField(e_replyAddress))
    length += m_replyAddress.GetObjectLength();
  if (HasOptionalField(e_integrityCheckValue))
    length += m_integrityCheckValue.GetObjectLength();
  if (HasOptionalField(e_tokens))
    length += m_tokens.GetObjectLength();
  if (HasOptionalField(e_cryptoTokens))
    length += m_cryptoTokens.GetObjectLength();
  if (HasOptionalField(e_nonStandard))
    length += m_nonStandard.GetObjectLength();
  return length;
}


BOOL H501_MessageCommonInfo::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_sequenceNumber.Decode(strm))
    return FALSE;
  if (!m_annexGversion.Decode(strm))
    return FALSE;
  if (!m_hopCount.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_replyAddress) && !m_replyAddress.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_integrityCheckValue) && !m_integrityCheckValue.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_tokens) && !m_tokens.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_cryptoTokens) && !m_cryptoTokens.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_nonStandard) && !m_nonStandard.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_serviceID, m_serviceID))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_genericData, m_genericData))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_featureSet, m_featureSet))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_version, m_version))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H501_MessageCommonInfo::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_sequenceNumber.Encode(strm);
  m_annexGversion.Encode(strm);
  m_hopCount.Encode(strm);
  if (HasOptionalField(e_replyAddress))
    m_replyAddress.Encode(strm);
  if (HasOptionalField(e_integrityCheckValue))
    m_integrityCheckValue.Encode(strm);
  if (HasOptionalField(e_tokens))
    m_tokens.Encode(strm);
  if (HasOptionalField(e_cryptoTokens))
    m_cryptoTokens.Encode(strm);
  if (HasOptionalField(e_nonStandard))
    m_nonStandard.Encode(strm);
  KnownExtensionEncode(strm, e_serviceID, m_serviceID);
  KnownExtensionEncode(strm, e_genericData, m_genericData);
  KnownExtensionEncode(strm, e_featureSet, m_featureSet);
  KnownExtensionEncode(strm, e_version, m_version);

  UnknownExtensionsEncode(strm);
}


PObject * H501_MessageCommonInfo::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_MessageCommonInfo::Class()), PInvalidCast);
#endif
  return new H501_MessageCommonInfo(*this);
}


//
// SecurityMode
//

H501_SecurityMode::H501_SecurityMode(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H501_SecurityMode::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_authentication))
    strm << setw(indent+17) << "authentication = " << setprecision(indent) << m_authentication << '\n';
  if (HasOptionalField(e_integrity))
    strm << setw(indent+12) << "integrity = " << setprecision(indent) << m_integrity << '\n';
  if (HasOptionalField(e_algorithmOIDs))
    strm << setw(indent+16) << "algorithmOIDs = " << setprecision(indent) << m_algorithmOIDs << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H501_SecurityMode::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H501_SecurityMode), PInvalidCast);
#endif
  const H501_SecurityMode & other = (const H501_SecurityMode &)obj;

  Comparison result;

  if ((result = m_authentication.Compare(other.m_authentication)) != EqualTo)
    return result;
  if ((result = m_integrity.Compare(other.m_integrity)) != EqualTo)
    return result;
  if ((result = m_algorithmOIDs.Compare(other.m_algorithmOIDs)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H501_SecurityMode::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_authentication))
    length += m_authentication.GetObjectLength();
  if (HasOptionalField(e_integrity))
    length += m_integrity.GetObjectLength();
  if (HasOptionalField(e_algorithmOIDs))
    length += m_algorithmOIDs.GetObjectLength();
  return length;
}


BOOL H501_SecurityMode::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_authentication) && !m_authentication.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_integrity) && !m_integrity.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_algorithmOIDs) && !m_algorithmOIDs.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H501_SecurityMode::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_authentication))
    m_authentication.Encode(strm);
  if (HasOptionalField(e_integrity))
    m_integrity.Encode(strm);
  if (HasOptionalField(e_algorithmOIDs))
    m_algorithmOIDs.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H501_SecurityMode::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_SecurityMode::Class()), PInvalidCast);
#endif
  return new H501_SecurityMode(*this);
}


//
// DescriptorRequest
//

H501_DescriptorRequest::H501_DescriptorRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H501_DescriptorRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "descriptorID = " << setprecision(indent) << m_descriptorID << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H501_DescriptorRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H501_DescriptorRequest), PInvalidCast);
#endif
  const H501_DescriptorRequest & other = (const H501_DescriptorRequest &)obj;

  Comparison result;

  if ((result = m_descriptorID.Compare(other.m_descriptorID)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H501_DescriptorRequest::GetDataLength() const
{
  PINDEX length = 0;
  length += m_descriptorID.GetObjectLength();
  return length;
}


BOOL H501_DescriptorRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_descriptorID.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H501_DescriptorRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_descriptorID.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H501_DescriptorRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_DescriptorRequest::Class()), PInvalidCast);
#endif
  return new H501_DescriptorRequest(*this);
}


//
// DescriptorConfirmation
//

H501_DescriptorConfirmation::H501_DescriptorConfirmation(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H501_DescriptorConfirmation::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+13) << "descriptor = " << setprecision(indent) << m_descriptor << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H501_DescriptorConfirmation::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H501_DescriptorConfirmation), PInvalidCast);
#endif
  const H501_DescriptorConfirmation & other = (const H501_DescriptorConfirmation &)obj;

  Comparison result;

  if ((result = m_descriptor.Compare(other.m_descriptor)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H501_DescriptorConfirmation::GetDataLength() const
{
  PINDEX length = 0;
  length += m_descriptor.GetObjectLength();
  return length;
}


BOOL H501_DescriptorConfirmation::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_descriptor.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H501_DescriptorConfirmation::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_descriptor.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H501_DescriptorConfirmation::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_DescriptorConfirmation::Class()), PInvalidCast);
#endif
  return new H501_DescriptorConfirmation(*this);
}


//
// DescriptorRejection
//

H501_DescriptorRejection::H501_DescriptorRejection(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H501_DescriptorRejection::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+9) << "reason = " << setprecision(indent) << m_reason << '\n';
  if (HasOptionalField(e_descriptorID))
    strm << setw(indent+15) << "descriptorID = " << setprecision(indent) << m_descriptorID << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H501_DescriptorRejection::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H501_DescriptorRejection), PInvalidCast);
#endif
  const H501_DescriptorRejection & other = (const H501_DescriptorRejection &)obj;

  Comparison result;

  if ((result = m_reason.Compare(other.m_reason)) != EqualTo)
    return result;
  if ((result = m_descriptorID.Compare(other.m_descriptorID)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H501_DescriptorRejection::GetDataLength() const
{
  PINDEX length = 0;
  length += m_reason.GetObjectLength();
  if (HasOptionalField(e_descriptorID))
    length += m_descriptorID.GetObjectLength();
  return length;
}


BOOL H501_DescriptorRejection::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_reason.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_descriptorID) && !m_descriptorID.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H501_DescriptorRejection::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_reason.Encode(strm);
  if (HasOptionalField(e_descriptorID))
    m_descriptorID.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H501_DescriptorRejection::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_DescriptorRejection::Class()), PInvalidCast);
#endif
  return new H501_DescriptorRejection(*this);
}


//
// DescriptorIDConfirmation
//

H501_DescriptorIDConfirmation::H501_DescriptorIDConfirmation(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H501_DescriptorIDConfirmation::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "descriptorInfo = " << setprecision(indent) << m_descriptorInfo << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H501_DescriptorIDConfirmation::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H501_DescriptorIDConfirmation), PInvalidCast);
#endif
  const H501_DescriptorIDConfirmation & other = (const H501_DescriptorIDConfirmation &)obj;

  Comparison result;

  if ((result = m_descriptorInfo.Compare(other.m_descriptorInfo)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H501_DescriptorIDConfirmation::GetDataLength() const
{
  PINDEX length = 0;
  length += m_descriptorInfo.GetObjectLength();
  return length;
}


BOOL H501_DescriptorIDConfirmation::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_descriptorInfo.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H501_DescriptorIDConfirmation::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_descriptorInfo.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H501_DescriptorIDConfirmation::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_DescriptorIDConfirmation::Class()), PInvalidCast);
#endif
  return new H501_DescriptorIDConfirmation(*this);
}


//
// DescriptorIDRejection
//

H501_DescriptorIDRejection::H501_DescriptorIDRejection(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H501_DescriptorIDRejection::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+9) << "reason = " << setprecision(indent) << m_reason << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H501_DescriptorIDRejection::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H501_DescriptorIDRejection), PInvalidCast);
#endif
  const H501_DescriptorIDRejection & other = (const H501_DescriptorIDRejection &)obj;

  Comparison result;

  if ((result = m_reason.Compare(other.m_reason)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H501_DescriptorIDRejection::GetDataLength() const
{
  PINDEX length = 0;
  length += m_reason.GetObjectLength();
  return length;
}


BOOL H501_DescriptorIDRejection::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_reason.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H501_DescriptorIDRejection::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_reason.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H501_DescriptorIDRejection::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_DescriptorIDRejection::Class()), PInvalidCast);
#endif
  return new H501_DescriptorIDRejection(*this);
}


//
// DescriptorUpdate
//

H501_DescriptorUpdate::H501_DescriptorUpdate(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H501_DescriptorUpdate::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+9) << "sender = " << setprecision(indent) << m_sender << '\n';
  strm << setw(indent+13) << "updateInfo = " << setprecision(indent) << m_updateInfo << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H501_DescriptorUpdate::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H501_DescriptorUpdate), PInvalidCast);
#endif
  const H501_DescriptorUpdate & other = (const H501_DescriptorUpdate &)obj;

  Comparison result;

  if ((result = m_sender.Compare(other.m_sender)) != EqualTo)
    return result;
  if ((result = m_updateInfo.Compare(other.m_updateInfo)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H501_DescriptorUpdate::GetDataLength() const
{
  PINDEX length = 0;
  length += m_sender.GetObjectLength();
  length += m_updateInfo.GetObjectLength();
  return length;
}


BOOL H501_DescriptorUpdate::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_sender.Decode(strm))
    return FALSE;
  if (!m_updateInfo.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H501_DescriptorUpdate::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_sender.Encode(strm);
  m_updateInfo.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H501_DescriptorUpdate::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_DescriptorUpdate::Class()), PInvalidCast);
#endif
  return new H501_DescriptorUpdate(*this);
}


//
// UpdateInformation
//

H501_UpdateInformation::H501_UpdateInformation(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H501_UpdateInformation::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "descriptorInfo = " << setprecision(indent) << m_descriptorInfo << '\n';
  strm << setw(indent+13) << "updateType = " << setprecision(indent) << m_updateType << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H501_UpdateInformation::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H501_UpdateInformation), PInvalidCast);
#endif
  const H501_UpdateInformation & other = (const H501_UpdateInformation &)obj;

  Comparison result;

  if ((result = m_descriptorInfo.Compare(other.m_descriptorInfo)) != EqualTo)
    return result;
  if ((result = m_updateType.Compare(other.m_updateType)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H501_UpdateInformation::GetDataLength() const
{
  PINDEX length = 0;
  length += m_descriptorInfo.GetObjectLength();
  length += m_updateType.GetObjectLength();
  return length;
}


BOOL H501_UpdateInformation::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_descriptorInfo.Decode(strm))
    return FALSE;
  if (!m_updateType.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H501_UpdateInformation::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_descriptorInfo.Encode(strm);
  m_updateType.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H501_UpdateInformation::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_UpdateInformation::Class()), PInvalidCast);
#endif
  return new H501_UpdateInformation(*this);
}


//
// AccessConfirmation
//

H501_AccessConfirmation::H501_AccessConfirmation(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 2)
{
}


#ifndef PASN_NOPRINTON
void H501_AccessConfirmation::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+12) << "templates = " << setprecision(indent) << m_templates << '\n';
  strm << setw(indent+18) << "partialResponse = " << setprecision(indent) << m_partialResponse << '\n';
  if (HasOptionalField(e_supportedProtocols))
    strm << setw(indent+21) << "supportedProtocols = " << setprecision(indent) << m_supportedProtocols << '\n';
  if (HasOptionalField(e_serviceControl))
    strm << setw(indent+17) << "serviceControl = " << setprecision(indent) << m_serviceControl << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H501_AccessConfirmation::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H501_AccessConfirmation), PInvalidCast);
#endif
  const H501_AccessConfirmation & other = (const H501_AccessConfirmation &)obj;

  Comparison result;

  if ((result = m_templates.Compare(other.m_templates)) != EqualTo)
    return result;
  if ((result = m_partialResponse.Compare(other.m_partialResponse)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H501_AccessConfirmation::GetDataLength() const
{
  PINDEX length = 0;
  length += m_templates.GetObjectLength();
  length += m_partialResponse.GetObjectLength();
  return length;
}


BOOL H501_AccessConfirmation::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_templates.Decode(strm))
    return FALSE;
  if (!m_partialResponse.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_supportedProtocols, m_supportedProtocols))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_serviceControl, m_serviceControl))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H501_AccessConfirmation::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_templates.Encode(strm);
  m_partialResponse.Encode(strm);
  KnownExtensionEncode(strm, e_supportedProtocols, m_supportedProtocols);
  KnownExtensionEncode(strm, e_serviceControl, m_serviceControl);

  UnknownExtensionsEncode(strm);
}


PObject * H501_AccessConfirmation::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_AccessConfirmation::Class()), PInvalidCast);
#endif
  return new H501_AccessConfirmation(*this);
}


//
// AccessRejection
//

H501_AccessRejection::H501_AccessRejection(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 1)
{
}


#ifndef PASN_NOPRINTON
void H501_AccessRejection::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+9) << "reason = " << setprecision(indent) << m_reason << '\n';
  if (HasOptionalField(e_serviceControl))
    strm << setw(indent+17) << "serviceControl = " << setprecision(indent) << m_serviceControl << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H501_AccessRejection::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H501_AccessRejection), PInvalidCast);
#endif
  const H501_AccessRejection & other = (const H501_AccessRejection &)obj;

  Comparison result;

  if ((result = m_reason.Compare(other.m_reason)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H501_AccessRejection::GetDataLength() const
{
  PINDEX length = 0;
  length += m_reason.GetObjectLength();
  return length;
}


BOOL H501_AccessRejection::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_reason.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_serviceControl, m_serviceControl))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H501_AccessRejection::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_reason.Encode(strm);
  KnownExtensionEncode(strm, e_serviceControl, m_serviceControl);

  UnknownExtensionsEncode(strm);
}


PObject * H501_AccessRejection::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_AccessRejection::Class()), PInvalidCast);
#endif
  return new H501_AccessRejection(*this);
}


//
// UsageRejection
//

H501_UsageRejection::H501_UsageRejection(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H501_UsageRejection::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+9) << "reason = " << setprecision(indent) << m_reason << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H501_UsageRejection::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H501_UsageRejection), PInvalidCast);
#endif
  const H501_UsageRejection & other = (const H501_UsageRejection &)obj;

  Comparison result;

  if ((result = m_reason.Compare(other.m_reason)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H501_UsageRejection::GetDataLength() const
{
  PINDEX length = 0;
  length += m_reason.GetObjectLength();
  return length;
}


BOOL H501_UsageRejection::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_reason.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H501_UsageRejection::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_reason.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H501_UsageRejection::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_UsageRejection::Class()), PInvalidCast);
#endif
  return new H501_UsageRejection(*this);
}


//
// UsageIndicationRejection
//

H501_UsageIndicationRejection::H501_UsageIndicationRejection(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H501_UsageIndicationRejection::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+9) << "reason = " << setprecision(indent) << m_reason << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H501_UsageIndicationRejection::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H501_UsageIndicationRejection), PInvalidCast);
#endif
  const H501_UsageIndicationRejection & other = (const H501_UsageIndicationRejection &)obj;

  Comparison result;

  if ((result = m_reason.Compare(other.m_reason)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H501_UsageIndicationRejection::GetDataLength() const
{
  PINDEX length = 0;
  length += m_reason.GetObjectLength();
  return length;
}


BOOL H501_UsageIndicationRejection::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_reason.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H501_UsageIndicationRejection::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_reason.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H501_UsageIndicationRejection::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_UsageIndicationRejection::Class()), PInvalidCast);
#endif
  return new H501_UsageIndicationRejection(*this);
}


//
// ValidationRejection
//

H501_ValidationRejection::H501_ValidationRejection(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H501_ValidationRejection::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+9) << "reason = " << setprecision(indent) << m_reason << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H501_ValidationRejection::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H501_ValidationRejection), PInvalidCast);
#endif
  const H501_ValidationRejection & other = (const H501_ValidationRejection &)obj;

  Comparison result;

  if ((result = m_reason.Compare(other.m_reason)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H501_ValidationRejection::GetDataLength() const
{
  PINDEX length = 0;
  length += m_reason.GetObjectLength();
  return length;
}


BOOL H501_ValidationRejection::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_reason.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H501_ValidationRejection::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_reason.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H501_ValidationRejection::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_ValidationRejection::Class()), PInvalidCast);
#endif
  return new H501_ValidationRejection(*this);
}


//
// RequestInProgress
//

H501_RequestInProgress::H501_RequestInProgress(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 1)
{
  m_delay.SetConstraints(PASN_Object::FixedConstraint, 1, 65535);
}


#ifndef PASN_NOPRINTON
void H501_RequestInProgress::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+8) << "delay = " << setprecision(indent) << m_delay << '\n';
  if (HasOptionalField(e_serviceControl))
    strm << setw(indent+17) << "serviceControl = " << setprecision(indent) << m_serviceControl << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H501_RequestInProgress::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H501_RequestInProgress), PInvalidCast);
#endif
  const H501_RequestInProgress & other = (const H501_RequestInProgress &)obj;

  Comparison result;

  if ((result = m_delay.Compare(other.m_delay)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H501_RequestInProgress::GetDataLength() const
{
  PINDEX length = 0;
  length += m_delay.GetObjectLength();
  return length;
}


BOOL H501_RequestInProgress::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_delay.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_serviceControl, m_serviceControl))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H501_RequestInProgress::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_delay.Encode(strm);
  KnownExtensionEncode(strm, e_serviceControl, m_serviceControl);

  UnknownExtensionsEncode(strm);
}


PObject * H501_RequestInProgress::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_RequestInProgress::Class()), PInvalidCast);
#endif
  return new H501_RequestInProgress(*this);
}


//
// NonStandardRejection
//

H501_NonStandardRejection::H501_NonStandardRejection(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H501_NonStandardRejection::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+9) << "reason = " << setprecision(indent) << m_reason << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H501_NonStandardRejection::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H501_NonStandardRejection), PInvalidCast);
#endif
  const H501_NonStandardRejection & other = (const H501_NonStandardRejection &)obj;

  Comparison result;

  if ((result = m_reason.Compare(other.m_reason)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H501_NonStandardRejection::GetDataLength() const
{
  PINDEX length = 0;
  length += m_reason.GetObjectLength();
  return length;
}


BOOL H501_NonStandardRejection::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_reason.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H501_NonStandardRejection::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_reason.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H501_NonStandardRejection::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_NonStandardRejection::Class()), PInvalidCast);
#endif
  return new H501_NonStandardRejection(*this);
}


//
// UnknownMessageResponse
//

H501_UnknownMessageResponse::H501_UnknownMessageResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H501_UnknownMessageResponse::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "unknownMessage = " << setprecision(indent) << m_unknownMessage << '\n';
  strm << setw(indent+9) << "reason = " << setprecision(indent) << m_reason << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H501_UnknownMessageResponse::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H501_UnknownMessageResponse), PInvalidCast);
#endif
  const H501_UnknownMessageResponse & other = (const H501_UnknownMessageResponse &)obj;

  Comparison result;

  if ((result = m_unknownMessage.Compare(other.m_unknownMessage)) != EqualTo)
    return result;
  if ((result = m_reason.Compare(other.m_reason)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H501_UnknownMessageResponse::GetDataLength() const
{
  PINDEX length = 0;
  length += m_unknownMessage.GetObjectLength();
  length += m_reason.GetObjectLength();
  return length;
}


BOOL H501_UnknownMessageResponse::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_unknownMessage.Decode(strm))
    return FALSE;
  if (!m_reason.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H501_UnknownMessageResponse::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_unknownMessage.Encode(strm);
  m_reason.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H501_UnknownMessageResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_UnknownMessageResponse::Class()), PInvalidCast);
#endif
  return new H501_UnknownMessageResponse(*this);
}


//
// AuthenticationRequest
//

H501_AuthenticationRequest::H501_AuthenticationRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H501_AuthenticationRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+21) << "applicationMessage = " << setprecision(indent) << m_applicationMessage << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H501_AuthenticationRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H501_AuthenticationRequest), PInvalidCast);
#endif
  const H501_AuthenticationRequest & other = (const H501_AuthenticationRequest &)obj;

  Comparison result;

  if ((result = m_applicationMessage.Compare(other.m_applicationMessage)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H501_AuthenticationRequest::GetDataLength() const
{
  PINDEX length = 0;
  length += m_applicationMessage.GetObjectLength();
  return length;
}


BOOL H501_AuthenticationRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_applicationMessage.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H501_AuthenticationRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_applicationMessage.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H501_AuthenticationRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_AuthenticationRequest::Class()), PInvalidCast);
#endif
  return new H501_AuthenticationRequest(*this);
}


//
// AuthenticationRejection
//

H501_AuthenticationRejection::H501_AuthenticationRejection(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H501_AuthenticationRejection::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+9) << "reason = " << setprecision(indent) << m_reason << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H501_AuthenticationRejection::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H501_AuthenticationRejection), PInvalidCast);
#endif
  const H501_AuthenticationRejection & other = (const H501_AuthenticationRejection &)obj;

  Comparison result;

  if ((result = m_reason.Compare(other.m_reason)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H501_AuthenticationRejection::GetDataLength() const
{
  PINDEX length = 0;
  length += m_reason.GetObjectLength();
  return length;
}


BOOL H501_AuthenticationRejection::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_reason.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H501_AuthenticationRejection::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_reason.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H501_AuthenticationRejection::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_AuthenticationRejection::Class()), PInvalidCast);
#endif
  return new H501_AuthenticationRejection(*this);
}


//
// AddressTemplate
//

H501_AddressTemplate::H501_AddressTemplate(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 2)
{
  m_timeToLive.SetConstraints(PASN_Object::FixedConstraint, 1, 4294967295U);
}


#ifndef PASN_NOPRINTON
void H501_AddressTemplate::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+10) << "pattern = " << setprecision(indent) << m_pattern << '\n';
  strm << setw(indent+12) << "routeInfo = " << setprecision(indent) << m_routeInfo << '\n';
  strm << setw(indent+13) << "timeToLive = " << setprecision(indent) << m_timeToLive << '\n';
  if (HasOptionalField(e_supportedProtocols))
    strm << setw(indent+21) << "supportedProtocols = " << setprecision(indent) << m_supportedProtocols << '\n';
  if (HasOptionalField(e_featureSet))
    strm << setw(indent+13) << "featureSet = " << setprecision(indent) << m_featureSet << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H501_AddressTemplate::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H501_AddressTemplate), PInvalidCast);
#endif
  const H501_AddressTemplate & other = (const H501_AddressTemplate &)obj;

  Comparison result;

  if ((result = m_pattern.Compare(other.m_pattern)) != EqualTo)
    return result;
  if ((result = m_routeInfo.Compare(other.m_routeInfo)) != EqualTo)
    return result;
  if ((result = m_timeToLive.Compare(other.m_timeToLive)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H501_AddressTemplate::GetDataLength() const
{
  PINDEX length = 0;
  length += m_pattern.GetObjectLength();
  length += m_routeInfo.GetObjectLength();
  length += m_timeToLive.GetObjectLength();
  return length;
}


BOOL H501_AddressTemplate::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_pattern.Decode(strm))
    return FALSE;
  if (!m_routeInfo.Decode(strm))
    return FALSE;
  if (!m_timeToLive.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_supportedProtocols, m_supportedProtocols))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_featureSet, m_featureSet))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H501_AddressTemplate::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_pattern.Encode(strm);
  m_routeInfo.Encode(strm);
  m_timeToLive.Encode(strm);
  KnownExtensionEncode(strm, e_supportedProtocols, m_supportedProtocols);
  KnownExtensionEncode(strm, e_featureSet, m_featureSet);

  UnknownExtensionsEncode(strm);
}


PObject * H501_AddressTemplate::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_AddressTemplate::Class()), PInvalidCast);
#endif
  return new H501_AddressTemplate(*this);
}


//
// ContactInformation
//

H501_ContactInformation::H501_ContactInformation(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 4)
{
  m_priority.SetConstraints(PASN_Object::FixedConstraint, 0, 127);
}


#ifndef PASN_NOPRINTON
void H501_ContactInformation::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+19) << "transportAddress = " << setprecision(indent) << m_transportAddress << '\n';
  strm << setw(indent+11) << "priority = " << setprecision(indent) << m_priority << '\n';
  if (HasOptionalField(e_transportQoS))
    strm << setw(indent+15) << "transportQoS = " << setprecision(indent) << m_transportQoS << '\n';
  if (HasOptionalField(e_security))
    strm << setw(indent+11) << "security = " << setprecision(indent) << m_security << '\n';
  if (HasOptionalField(e_accessTokens))
    strm << setw(indent+15) << "accessTokens = " << setprecision(indent) << m_accessTokens << '\n';
  if (HasOptionalField(e_multipleCalls))
    strm << setw(indent+16) << "multipleCalls = " << setprecision(indent) << m_multipleCalls << '\n';
  if (HasOptionalField(e_featureSet))
    strm << setw(indent+13) << "featureSet = " << setprecision(indent) << m_featureSet << '\n';
  if (HasOptionalField(e_circuitID))
    strm << setw(indent+12) << "circuitID = " << setprecision(indent) << m_circuitID << '\n';
  if (HasOptionalField(e_supportedCircuits))
    strm << setw(indent+20) << "supportedCircuits = " << setprecision(indent) << m_supportedCircuits << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H501_ContactInformation::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H501_ContactInformation), PInvalidCast);
#endif
  const H501_ContactInformation & other = (const H501_ContactInformation &)obj;

  Comparison result;

  if ((result = m_transportAddress.Compare(other.m_transportAddress)) != EqualTo)
    return result;
  if ((result = m_priority.Compare(other.m_priority)) != EqualTo)
    return result;
  if ((result = m_transportQoS.Compare(other.m_transportQoS)) != EqualTo)
    return result;
  if ((result = m_security.Compare(other.m_security)) != EqualTo)
    return result;
  if ((result = m_accessTokens.Compare(other.m_accessTokens)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H501_ContactInformation::GetDataLength() const
{
  PINDEX length = 0;
  length += m_transportAddress.GetObjectLength();
  length += m_priority.GetObjectLength();
  if (HasOptionalField(e_transportQoS))
    length += m_transportQoS.GetObjectLength();
  if (HasOptionalField(e_security))
    length += m_security.GetObjectLength();
  if (HasOptionalField(e_accessTokens))
    length += m_accessTokens.GetObjectLength();
  return length;
}


BOOL H501_ContactInformation::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_transportAddress.Decode(strm))
    return FALSE;
  if (!m_priority.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_transportQoS) && !m_transportQoS.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_security) && !m_security.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_accessTokens) && !m_accessTokens.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_multipleCalls, m_multipleCalls))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_featureSet, m_featureSet))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_circuitID, m_circuitID))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_supportedCircuits, m_supportedCircuits))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H501_ContactInformation::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_transportAddress.Encode(strm);
  m_priority.Encode(strm);
  if (HasOptionalField(e_transportQoS))
    m_transportQoS.Encode(strm);
  if (HasOptionalField(e_security))
    m_security.Encode(strm);
  if (HasOptionalField(e_accessTokens))
    m_accessTokens.Encode(strm);
  KnownExtensionEncode(strm, e_multipleCalls, m_multipleCalls);
  KnownExtensionEncode(strm, e_featureSet, m_featureSet);
  KnownExtensionEncode(strm, e_circuitID, m_circuitID);
  KnownExtensionEncode(strm, e_supportedCircuits, m_supportedCircuits);

  UnknownExtensionsEncode(strm);
}


PObject * H501_ContactInformation::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_ContactInformation::Class()), PInvalidCast);
#endif
  return new H501_ContactInformation(*this);
}


//
// PriceInfoSpec
//

H501_PriceInfoSpec::H501_PriceInfoSpec(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 6, TRUE, 0)
{
  m_currency.SetConstraints(PASN_Object::FixedConstraint, 3);
  m_currencyScale.SetConstraints(PASN_Object::FixedConstraint, -127, 127);
  m_hoursFrom.SetConstraints(PASN_Object::FixedConstraint, 6);
  m_hoursUntil.SetConstraints(PASN_Object::FixedConstraint, 6);
  m_priceFormula.SetConstraints(PASN_Object::FixedConstraint, 1, 2048);
}


#ifndef PASN_NOPRINTON
void H501_PriceInfoSpec::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "currency = " << setprecision(indent) << m_currency << '\n';
  strm << setw(indent+16) << "currencyScale = " << setprecision(indent) << m_currencyScale << '\n';
  if (HasOptionalField(e_validFrom))
    strm << setw(indent+12) << "validFrom = " << setprecision(indent) << m_validFrom << '\n';
  if (HasOptionalField(e_validUntil))
    strm << setw(indent+13) << "validUntil = " << setprecision(indent) << m_validUntil << '\n';
  if (HasOptionalField(e_hoursFrom))
    strm << setw(indent+12) << "hoursFrom = " << setprecision(indent) << m_hoursFrom << '\n';
  if (HasOptionalField(e_hoursUntil))
    strm << setw(indent+13) << "hoursUntil = " << setprecision(indent) << m_hoursUntil << '\n';
  if (HasOptionalField(e_priceElement))
    strm << setw(indent+15) << "priceElement = " << setprecision(indent) << m_priceElement << '\n';
  if (HasOptionalField(e_priceFormula))
    strm << setw(indent+15) << "priceFormula = " << setprecision(indent) << m_priceFormula << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H501_PriceInfoSpec::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H501_PriceInfoSpec), PInvalidCast);
#endif
  const H501_PriceInfoSpec & other = (const H501_PriceInfoSpec &)obj;

  Comparison result;

  if ((result = m_currency.Compare(other.m_currency)) != EqualTo)
    return result;
  if ((result = m_currencyScale.Compare(other.m_currencyScale)) != EqualTo)
    return result;
  if ((result = m_validFrom.Compare(other.m_validFrom)) != EqualTo)
    return result;
  if ((result = m_validUntil.Compare(other.m_validUntil)) != EqualTo)
    return result;
  if ((result = m_hoursFrom.Compare(other.m_hoursFrom)) != EqualTo)
    return result;
  if ((result = m_hoursUntil.Compare(other.m_hoursUntil)) != EqualTo)
    return result;
  if ((result = m_priceElement.Compare(other.m_priceElement)) != EqualTo)
    return result;
  if ((result = m_priceFormula.Compare(other.m_priceFormula)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H501_PriceInfoSpec::GetDataLength() const
{
  PINDEX length = 0;
  length += m_currency.GetObjectLength();
  length += m_currencyScale.GetObjectLength();
  if (HasOptionalField(e_validFrom))
    length += m_validFrom.GetObjectLength();
  if (HasOptionalField(e_validUntil))
    length += m_validUntil.GetObjectLength();
  if (HasOptionalField(e_hoursFrom))
    length += m_hoursFrom.GetObjectLength();
  if (HasOptionalField(e_hoursUntil))
    length += m_hoursUntil.GetObjectLength();
  if (HasOptionalField(e_priceElement))
    length += m_priceElement.GetObjectLength();
  if (HasOptionalField(e_priceFormula))
    length += m_priceFormula.GetObjectLength();
  return length;
}


BOOL H501_PriceInfoSpec::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_currency.Decode(strm))
    return FALSE;
  if (!m_currencyScale.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_validFrom) && !m_validFrom.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_validUntil) && !m_validUntil.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_hoursFrom) && !m_hoursFrom.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_hoursUntil) && !m_hoursUntil.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_priceElement) && !m_priceElement.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_priceFormula) && !m_priceFormula.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H501_PriceInfoSpec::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_currency.Encode(strm);
  m_currencyScale.Encode(strm);
  if (HasOptionalField(e_validFrom))
    m_validFrom.Encode(strm);
  if (HasOptionalField(e_validUntil))
    m_validUntil.Encode(strm);
  if (HasOptionalField(e_hoursFrom))
    m_hoursFrom.Encode(strm);
  if (HasOptionalField(e_hoursUntil))
    m_hoursUntil.Encode(strm);
  if (HasOptionalField(e_priceElement))
    m_priceElement.Encode(strm);
  if (HasOptionalField(e_priceFormula))
    m_priceFormula.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H501_PriceInfoSpec::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_PriceInfoSpec::Class()), PInvalidCast);
#endif
  return new H501_PriceInfoSpec(*this);
}


//
// PriceElement
//

H501_PriceElement::H501_PriceElement(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_amount.SetConstraints(PASN_Object::FixedConstraint, 0, 4294967295U);
  m_quantum.SetConstraints(PASN_Object::FixedConstraint, 0, 4294967295U);
}


#ifndef PASN_NOPRINTON
void H501_PriceElement::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+9) << "amount = " << setprecision(indent) << m_amount << '\n';
  strm << setw(indent+10) << "quantum = " << setprecision(indent) << m_quantum << '\n';
  strm << setw(indent+8) << "units = " << setprecision(indent) << m_units << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H501_PriceElement::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H501_PriceElement), PInvalidCast);
#endif
  const H501_PriceElement & other = (const H501_PriceElement &)obj;

  Comparison result;

  if ((result = m_amount.Compare(other.m_amount)) != EqualTo)
    return result;
  if ((result = m_quantum.Compare(other.m_quantum)) != EqualTo)
    return result;
  if ((result = m_units.Compare(other.m_units)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H501_PriceElement::GetDataLength() const
{
  PINDEX length = 0;
  length += m_amount.GetObjectLength();
  length += m_quantum.GetObjectLength();
  length += m_units.GetObjectLength();
  return length;
}


BOOL H501_PriceElement::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_amount.Decode(strm))
    return FALSE;
  if (!m_quantum.Decode(strm))
    return FALSE;
  if (!m_units.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H501_PriceElement::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_amount.Encode(strm);
  m_quantum.Encode(strm);
  m_units.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H501_PriceElement::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_PriceElement::Class()), PInvalidCast);
#endif
  return new H501_PriceElement(*this);
}


//
// DescriptorInfo
//

H501_DescriptorInfo::H501_DescriptorInfo(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H501_DescriptorInfo::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "descriptorID = " << setprecision(indent) << m_descriptorID << '\n';
  strm << setw(indent+14) << "lastChanged = " << setprecision(indent) << m_lastChanged << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H501_DescriptorInfo::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H501_DescriptorInfo), PInvalidCast);
#endif
  const H501_DescriptorInfo & other = (const H501_DescriptorInfo &)obj;

  Comparison result;

  if ((result = m_descriptorID.Compare(other.m_descriptorID)) != EqualTo)
    return result;
  if ((result = m_lastChanged.Compare(other.m_lastChanged)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H501_DescriptorInfo::GetDataLength() const
{
  PINDEX length = 0;
  length += m_descriptorID.GetObjectLength();
  length += m_lastChanged.GetObjectLength();
  return length;
}


BOOL H501_DescriptorInfo::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_descriptorID.Decode(strm))
    return FALSE;
  if (!m_lastChanged.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H501_DescriptorInfo::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_descriptorID.Encode(strm);
  m_lastChanged.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H501_DescriptorInfo::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_DescriptorInfo::Class()), PInvalidCast);
#endif
  return new H501_DescriptorInfo(*this);
}


//
// AlternatePEInfo
//

H501_AlternatePEInfo::H501_AlternatePEInfo(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H501_AlternatePEInfo::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+14) << "alternatePE = " << setprecision(indent) << m_alternatePE << '\n';
  strm << setw(indent+23) << "alternateIsPermanent = " << setprecision(indent) << m_alternateIsPermanent << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H501_AlternatePEInfo::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H501_AlternatePEInfo), PInvalidCast);
#endif
  const H501_AlternatePEInfo & other = (const H501_AlternatePEInfo &)obj;

  Comparison result;

  if ((result = m_alternatePE.Compare(other.m_alternatePE)) != EqualTo)
    return result;
  if ((result = m_alternateIsPermanent.Compare(other.m_alternateIsPermanent)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H501_AlternatePEInfo::GetDataLength() const
{
  PINDEX length = 0;
  length += m_alternatePE.GetObjectLength();
  length += m_alternateIsPermanent.GetObjectLength();
  return length;
}


BOOL H501_AlternatePEInfo::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_alternatePE.Decode(strm))
    return FALSE;
  if (!m_alternateIsPermanent.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H501_AlternatePEInfo::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_alternatePE.Encode(strm);
  m_alternateIsPermanent.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H501_AlternatePEInfo::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_AlternatePEInfo::Class()), PInvalidCast);
#endif
  return new H501_AlternatePEInfo(*this);
}


//
// AlternatePE
//

H501_AlternatePE::H501_AlternatePE(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
  m_priority.SetConstraints(PASN_Object::FixedConstraint, 1, 127);
}


#ifndef PASN_NOPRINTON
void H501_AlternatePE::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "contactAddress = " << setprecision(indent) << m_contactAddress << '\n';
  strm << setw(indent+11) << "priority = " << setprecision(indent) << m_priority << '\n';
  if (HasOptionalField(e_elementIdentifier))
    strm << setw(indent+20) << "elementIdentifier = " << setprecision(indent) << m_elementIdentifier << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H501_AlternatePE::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H501_AlternatePE), PInvalidCast);
#endif
  const H501_AlternatePE & other = (const H501_AlternatePE &)obj;

  Comparison result;

  if ((result = m_contactAddress.Compare(other.m_contactAddress)) != EqualTo)
    return result;
  if ((result = m_priority.Compare(other.m_priority)) != EqualTo)
    return result;
  if ((result = m_elementIdentifier.Compare(other.m_elementIdentifier)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H501_AlternatePE::GetDataLength() const
{
  PINDEX length = 0;
  length += m_contactAddress.GetObjectLength();
  length += m_priority.GetObjectLength();
  if (HasOptionalField(e_elementIdentifier))
    length += m_elementIdentifier.GetObjectLength();
  return length;
}


BOOL H501_AlternatePE::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_contactAddress.Decode(strm))
    return FALSE;
  if (!m_priority.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_elementIdentifier) && !m_elementIdentifier.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H501_AlternatePE::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_contactAddress.Encode(strm);
  m_priority.Encode(strm);
  if (HasOptionalField(e_elementIdentifier))
    m_elementIdentifier.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H501_AlternatePE::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_AlternatePE::Class()), PInvalidCast);
#endif
  return new H501_AlternatePE(*this);
}


//
// UserInformation
//

H501_UserInformation::H501_UserInformation(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H501_UserInformation::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "userIdentifier = " << setprecision(indent) << m_userIdentifier << '\n';
  if (HasOptionalField(e_userAuthenticator))
    strm << setw(indent+20) << "userAuthenticator = " << setprecision(indent) << m_userAuthenticator << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H501_UserInformation::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H501_UserInformation), PInvalidCast);
#endif
  const H501_UserInformation & other = (const H501_UserInformation &)obj;

  Comparison result;

  if ((result = m_userIdentifier.Compare(other.m_userIdentifier)) != EqualTo)
    return result;
  if ((result = m_userAuthenticator.Compare(other.m_userAuthenticator)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H501_UserInformation::GetDataLength() const
{
  PINDEX length = 0;
  length += m_userIdentifier.GetObjectLength();
  if (HasOptionalField(e_userAuthenticator))
    length += m_userAuthenticator.GetObjectLength();
  return length;
}


BOOL H501_UserInformation::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_userIdentifier.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_userAuthenticator) && !m_userAuthenticator.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H501_UserInformation::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_userIdentifier.Encode(strm);
  if (HasOptionalField(e_userAuthenticator))
    m_userAuthenticator.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H501_UserInformation::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_UserInformation::Class()), PInvalidCast);
#endif
  return new H501_UserInformation(*this);
}


//
// UsageSpecification
//

H501_UsageSpecification::H501_UsageSpecification(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 1)
{
}


#ifndef PASN_NOPRINTON
void H501_UsageSpecification::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+9) << "sendTo = " << setprecision(indent) << m_sendTo << '\n';
  strm << setw(indent+7) << "when = " << setprecision(indent) << m_when << '\n';
  strm << setw(indent+11) << "required = " << setprecision(indent) << m_required << '\n';
  strm << setw(indent+12) << "preferred = " << setprecision(indent) << m_preferred << '\n';
  if (HasOptionalField(e_sendToPEAddress))
    strm << setw(indent+18) << "sendToPEAddress = " << setprecision(indent) << m_sendToPEAddress << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H501_UsageSpecification::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H501_UsageSpecification), PInvalidCast);
#endif
  const H501_UsageSpecification & other = (const H501_UsageSpecification &)obj;

  Comparison result;

  if ((result = m_sendTo.Compare(other.m_sendTo)) != EqualTo)
    return result;
  if ((result = m_when.Compare(other.m_when)) != EqualTo)
    return result;
  if ((result = m_required.Compare(other.m_required)) != EqualTo)
    return result;
  if ((result = m_preferred.Compare(other.m_preferred)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H501_UsageSpecification::GetDataLength() const
{
  PINDEX length = 0;
  length += m_sendTo.GetObjectLength();
  length += m_when.GetObjectLength();
  length += m_required.GetObjectLength();
  length += m_preferred.GetObjectLength();
  return length;
}


BOOL H501_UsageSpecification::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_sendTo.Decode(strm))
    return FALSE;
  if (!m_when.Decode(strm))
    return FALSE;
  if (!m_required.Decode(strm))
    return FALSE;
  if (!m_preferred.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_sendToPEAddress, m_sendToPEAddress))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H501_UsageSpecification::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_sendTo.Encode(strm);
  m_when.Encode(strm);
  m_required.Encode(strm);
  m_preferred.Encode(strm);
  KnownExtensionEncode(strm, e_sendToPEAddress, m_sendToPEAddress);

  UnknownExtensionsEncode(strm);
}


PObject * H501_UsageSpecification::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_UsageSpecification::Class()), PInvalidCast);
#endif
  return new H501_UsageSpecification(*this);
}


//
// PartyInformation
//

H501_PartyInformation::H501_PartyInformation(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 5, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H501_PartyInformation::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+19) << "logicalAddresses = " << setprecision(indent) << m_logicalAddresses << '\n';
  if (HasOptionalField(e_domainIdentifier))
    strm << setw(indent+19) << "domainIdentifier = " << setprecision(indent) << m_domainIdentifier << '\n';
  if (HasOptionalField(e_transportAddress))
    strm << setw(indent+19) << "transportAddress = " << setprecision(indent) << m_transportAddress << '\n';
  if (HasOptionalField(e_endpointType))
    strm << setw(indent+15) << "endpointType = " << setprecision(indent) << m_endpointType << '\n';
  if (HasOptionalField(e_userInfo))
    strm << setw(indent+11) << "userInfo = " << setprecision(indent) << m_userInfo << '\n';
  if (HasOptionalField(e_timeZone))
    strm << setw(indent+11) << "timeZone = " << setprecision(indent) << m_timeZone << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H501_PartyInformation::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H501_PartyInformation), PInvalidCast);
#endif
  const H501_PartyInformation & other = (const H501_PartyInformation &)obj;

  Comparison result;

  if ((result = m_logicalAddresses.Compare(other.m_logicalAddresses)) != EqualTo)
    return result;
  if ((result = m_domainIdentifier.Compare(other.m_domainIdentifier)) != EqualTo)
    return result;
  if ((result = m_transportAddress.Compare(other.m_transportAddress)) != EqualTo)
    return result;
  if ((result = m_endpointType.Compare(other.m_endpointType)) != EqualTo)
    return result;
  if ((result = m_userInfo.Compare(other.m_userInfo)) != EqualTo)
    return result;
  if ((result = m_timeZone.Compare(other.m_timeZone)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H501_PartyInformation::GetDataLength() const
{
  PINDEX length = 0;
  length += m_logicalAddresses.GetObjectLength();
  if (HasOptionalField(e_domainIdentifier))
    length += m_domainIdentifier.GetObjectLength();
  if (HasOptionalField(e_transportAddress))
    length += m_transportAddress.GetObjectLength();
  if (HasOptionalField(e_endpointType))
    length += m_endpointType.GetObjectLength();
  if (HasOptionalField(e_userInfo))
    length += m_userInfo.GetObjectLength();
  if (HasOptionalField(e_timeZone))
    length += m_timeZone.GetObjectLength();
  return length;
}


BOOL H501_PartyInformation::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_logicalAddresses.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_domainIdentifier) && !m_domainIdentifier.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_transportAddress) && !m_transportAddress.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_endpointType) && !m_endpointType.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_userInfo) && !m_userInfo.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_timeZone) && !m_timeZone.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H501_PartyInformation::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_logicalAddresses.Encode(strm);
  if (HasOptionalField(e_domainIdentifier))
    m_domainIdentifier.Encode(strm);
  if (HasOptionalField(e_transportAddress))
    m_transportAddress.Encode(strm);
  if (HasOptionalField(e_endpointType))
    m_endpointType.Encode(strm);
  if (HasOptionalField(e_userInfo))
    m_userInfo.Encode(strm);
  if (HasOptionalField(e_timeZone))
    m_timeZone.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H501_PartyInformation::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_PartyInformation::Class()), PInvalidCast);
#endif
  return new H501_PartyInformation(*this);
}


//
// Message
//

H501_Message::H501_Message(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H501_Message::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+7) << "body = " << setprecision(indent) << m_body << '\n';
  strm << setw(indent+9) << "common = " << setprecision(indent) << m_common << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H501_Message::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H501_Message), PInvalidCast);
#endif
  const H501_Message & other = (const H501_Message &)obj;

  Comparison result;

  if ((result = m_body.Compare(other.m_body)) != EqualTo)
    return result;
  if ((result = m_common.Compare(other.m_common)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H501_Message::GetDataLength() const
{
  PINDEX length = 0;
  length += m_body.GetObjectLength();
  length += m_common.GetObjectLength();
  return length;
}


BOOL H501_Message::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_body.Decode(strm))
    return FALSE;
  if (!m_common.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H501_Message::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_body.Encode(strm);
  m_common.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H501_Message::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_Message::Class()), PInvalidCast);
#endif
  return new H501_Message(*this);
}


//
// ServiceRequest
//

H501_ServiceRequest::H501_ServiceRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 4, TRUE, 1)
{
  m_timeToLive.SetConstraints(PASN_Object::FixedConstraint, 1, 4294967295U);
}


#ifndef PASN_NOPRINTON
void H501_ServiceRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_elementIdentifier))
    strm << setw(indent+20) << "elementIdentifier = " << setprecision(indent) << m_elementIdentifier << '\n';
  if (HasOptionalField(e_domainIdentifier))
    strm << setw(indent+19) << "domainIdentifier = " << setprecision(indent) << m_domainIdentifier << '\n';
  if (HasOptionalField(e_securityMode))
    strm << setw(indent+15) << "securityMode = " << setprecision(indent) << m_securityMode << '\n';
  if (HasOptionalField(e_timeToLive))
    strm << setw(indent+13) << "timeToLive = " << setprecision(indent) << m_timeToLive << '\n';
  if (HasOptionalField(e_usageSpec))
    strm << setw(indent+12) << "usageSpec = " << setprecision(indent) << m_usageSpec << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H501_ServiceRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H501_ServiceRequest), PInvalidCast);
#endif
  const H501_ServiceRequest & other = (const H501_ServiceRequest &)obj;

  Comparison result;

  if ((result = m_elementIdentifier.Compare(other.m_elementIdentifier)) != EqualTo)
    return result;
  if ((result = m_domainIdentifier.Compare(other.m_domainIdentifier)) != EqualTo)
    return result;
  if ((result = m_securityMode.Compare(other.m_securityMode)) != EqualTo)
    return result;
  if ((result = m_timeToLive.Compare(other.m_timeToLive)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H501_ServiceRequest::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_elementIdentifier))
    length += m_elementIdentifier.GetObjectLength();
  if (HasOptionalField(e_domainIdentifier))
    length += m_domainIdentifier.GetObjectLength();
  if (HasOptionalField(e_securityMode))
    length += m_securityMode.GetObjectLength();
  if (HasOptionalField(e_timeToLive))
    length += m_timeToLive.GetObjectLength();
  return length;
}


BOOL H501_ServiceRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_elementIdentifier) && !m_elementIdentifier.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_domainIdentifier) && !m_domainIdentifier.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_securityMode) && !m_securityMode.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_timeToLive) && !m_timeToLive.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_usageSpec, m_usageSpec))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H501_ServiceRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_elementIdentifier))
    m_elementIdentifier.Encode(strm);
  if (HasOptionalField(e_domainIdentifier))
    m_domainIdentifier.Encode(strm);
  if (HasOptionalField(e_securityMode))
    m_securityMode.Encode(strm);
  if (HasOptionalField(e_timeToLive))
    m_timeToLive.Encode(strm);
  KnownExtensionEncode(strm, e_usageSpec, m_usageSpec);

  UnknownExtensionsEncode(strm);
}


PObject * H501_ServiceRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_ServiceRequest::Class()), PInvalidCast);
#endif
  return new H501_ServiceRequest(*this);
}


//
// ServiceConfirmation
//

H501_ServiceConfirmation::H501_ServiceConfirmation(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 1)
{
  m_timeToLive.SetConstraints(PASN_Object::FixedConstraint, 1, 4294967295U);
}


#ifndef PASN_NOPRINTON
void H501_ServiceConfirmation::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+20) << "elementIdentifier = " << setprecision(indent) << m_elementIdentifier << '\n';
  strm << setw(indent+19) << "domainIdentifier = " << setprecision(indent) << m_domainIdentifier << '\n';
  if (HasOptionalField(e_alternates))
    strm << setw(indent+13) << "alternates = " << setprecision(indent) << m_alternates << '\n';
  if (HasOptionalField(e_securityMode))
    strm << setw(indent+15) << "securityMode = " << setprecision(indent) << m_securityMode << '\n';
  if (HasOptionalField(e_timeToLive))
    strm << setw(indent+13) << "timeToLive = " << setprecision(indent) << m_timeToLive << '\n';
  if (HasOptionalField(e_usageSpec))
    strm << setw(indent+12) << "usageSpec = " << setprecision(indent) << m_usageSpec << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H501_ServiceConfirmation::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H501_ServiceConfirmation), PInvalidCast);
#endif
  const H501_ServiceConfirmation & other = (const H501_ServiceConfirmation &)obj;

  Comparison result;

  if ((result = m_elementIdentifier.Compare(other.m_elementIdentifier)) != EqualTo)
    return result;
  if ((result = m_domainIdentifier.Compare(other.m_domainIdentifier)) != EqualTo)
    return result;
  if ((result = m_alternates.Compare(other.m_alternates)) != EqualTo)
    return result;
  if ((result = m_securityMode.Compare(other.m_securityMode)) != EqualTo)
    return result;
  if ((result = m_timeToLive.Compare(other.m_timeToLive)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H501_ServiceConfirmation::GetDataLength() const
{
  PINDEX length = 0;
  length += m_elementIdentifier.GetObjectLength();
  length += m_domainIdentifier.GetObjectLength();
  if (HasOptionalField(e_alternates))
    length += m_alternates.GetObjectLength();
  if (HasOptionalField(e_securityMode))
    length += m_securityMode.GetObjectLength();
  if (HasOptionalField(e_timeToLive))
    length += m_timeToLive.GetObjectLength();
  return length;
}


BOOL H501_ServiceConfirmation::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_elementIdentifier.Decode(strm))
    return FALSE;
  if (!m_domainIdentifier.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_alternates) && !m_alternates.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_securityMode) && !m_securityMode.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_timeToLive) && !m_timeToLive.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_usageSpec, m_usageSpec))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H501_ServiceConfirmation::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_elementIdentifier.Encode(strm);
  m_domainIdentifier.Encode(strm);
  if (HasOptionalField(e_alternates))
    m_alternates.Encode(strm);
  if (HasOptionalField(e_securityMode))
    m_securityMode.Encode(strm);
  if (HasOptionalField(e_timeToLive))
    m_timeToLive.Encode(strm);
  KnownExtensionEncode(strm, e_usageSpec, m_usageSpec);

  UnknownExtensionsEncode(strm);
}


PObject * H501_ServiceConfirmation::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_ServiceConfirmation::Class()), PInvalidCast);
#endif
  return new H501_ServiceConfirmation(*this);
}


//
// ServiceRejection
//

H501_ServiceRejection::H501_ServiceRejection(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H501_ServiceRejection::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+9) << "reason = " << setprecision(indent) << m_reason << '\n';
  if (HasOptionalField(e_alternates))
    strm << setw(indent+13) << "alternates = " << setprecision(indent) << m_alternates << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H501_ServiceRejection::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H501_ServiceRejection), PInvalidCast);
#endif
  const H501_ServiceRejection & other = (const H501_ServiceRejection &)obj;

  Comparison result;

  if ((result = m_reason.Compare(other.m_reason)) != EqualTo)
    return result;
  if ((result = m_alternates.Compare(other.m_alternates)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H501_ServiceRejection::GetDataLength() const
{
  PINDEX length = 0;
  length += m_reason.GetObjectLength();
  if (HasOptionalField(e_alternates))
    length += m_alternates.GetObjectLength();
  return length;
}


BOOL H501_ServiceRejection::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_reason.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_alternates) && !m_alternates.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H501_ServiceRejection::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_reason.Encode(strm);
  if (HasOptionalField(e_alternates))
    m_alternates.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H501_ServiceRejection::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_ServiceRejection::Class()), PInvalidCast);
#endif
  return new H501_ServiceRejection(*this);
}


//
// ServiceRelease
//

H501_ServiceRelease::H501_ServiceRelease(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H501_ServiceRelease::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+9) << "reason = " << setprecision(indent) << m_reason << '\n';
  if (HasOptionalField(e_alternates))
    strm << setw(indent+13) << "alternates = " << setprecision(indent) << m_alternates << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H501_ServiceRelease::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H501_ServiceRelease), PInvalidCast);
#endif
  const H501_ServiceRelease & other = (const H501_ServiceRelease &)obj;

  Comparison result;

  if ((result = m_reason.Compare(other.m_reason)) != EqualTo)
    return result;
  if ((result = m_alternates.Compare(other.m_alternates)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H501_ServiceRelease::GetDataLength() const
{
  PINDEX length = 0;
  length += m_reason.GetObjectLength();
  if (HasOptionalField(e_alternates))
    length += m_alternates.GetObjectLength();
  return length;
}


BOOL H501_ServiceRelease::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_reason.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_alternates) && !m_alternates.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H501_ServiceRelease::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_reason.Encode(strm);
  if (HasOptionalField(e_alternates))
    m_alternates.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H501_ServiceRelease::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_ServiceRelease::Class()), PInvalidCast);
#endif
  return new H501_ServiceRelease(*this);
}


//
// AccessRequest
//

H501_AccessRequest::H501_AccessRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 1)
{
}


#ifndef PASN_NOPRINTON
void H501_AccessRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+18) << "destinationInfo = " << setprecision(indent) << m_destinationInfo << '\n';
  if (HasOptionalField(e_sourceInfo))
    strm << setw(indent+13) << "sourceInfo = " << setprecision(indent) << m_sourceInfo << '\n';
  if (HasOptionalField(e_callInfo))
    strm << setw(indent+11) << "callInfo = " << setprecision(indent) << m_callInfo << '\n';
  if (HasOptionalField(e_usageSpec))
    strm << setw(indent+12) << "usageSpec = " << setprecision(indent) << m_usageSpec << '\n';
  if (HasOptionalField(e_desiredProtocols))
    strm << setw(indent+19) << "desiredProtocols = " << setprecision(indent) << m_desiredProtocols << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H501_AccessRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H501_AccessRequest), PInvalidCast);
#endif
  const H501_AccessRequest & other = (const H501_AccessRequest &)obj;

  Comparison result;

  if ((result = m_destinationInfo.Compare(other.m_destinationInfo)) != EqualTo)
    return result;
  if ((result = m_sourceInfo.Compare(other.m_sourceInfo)) != EqualTo)
    return result;
  if ((result = m_callInfo.Compare(other.m_callInfo)) != EqualTo)
    return result;
  if ((result = m_usageSpec.Compare(other.m_usageSpec)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H501_AccessRequest::GetDataLength() const
{
  PINDEX length = 0;
  length += m_destinationInfo.GetObjectLength();
  if (HasOptionalField(e_sourceInfo))
    length += m_sourceInfo.GetObjectLength();
  if (HasOptionalField(e_callInfo))
    length += m_callInfo.GetObjectLength();
  if (HasOptionalField(e_usageSpec))
    length += m_usageSpec.GetObjectLength();
  return length;
}


BOOL H501_AccessRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_destinationInfo.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_sourceInfo) && !m_sourceInfo.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_callInfo) && !m_callInfo.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_usageSpec) && !m_usageSpec.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_desiredProtocols, m_desiredProtocols))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H501_AccessRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_destinationInfo.Encode(strm);
  if (HasOptionalField(e_sourceInfo))
    m_sourceInfo.Encode(strm);
  if (HasOptionalField(e_callInfo))
    m_callInfo.Encode(strm);
  if (HasOptionalField(e_usageSpec))
    m_usageSpec.Encode(strm);
  KnownExtensionEncode(strm, e_desiredProtocols, m_desiredProtocols);

  UnknownExtensionsEncode(strm);
}


PObject * H501_AccessRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_AccessRequest::Class()), PInvalidCast);
#endif
  return new H501_AccessRequest(*this);
}


//
// UsageRequest
//

H501_UsageRequest::H501_UsageRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H501_UsageRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "callInfo = " << setprecision(indent) << m_callInfo << '\n';
  strm << setw(indent+12) << "usageSpec = " << setprecision(indent) << m_usageSpec << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H501_UsageRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H501_UsageRequest), PInvalidCast);
#endif
  const H501_UsageRequest & other = (const H501_UsageRequest &)obj;

  Comparison result;

  if ((result = m_callInfo.Compare(other.m_callInfo)) != EqualTo)
    return result;
  if ((result = m_usageSpec.Compare(other.m_usageSpec)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H501_UsageRequest::GetDataLength() const
{
  PINDEX length = 0;
  length += m_callInfo.GetObjectLength();
  length += m_usageSpec.GetObjectLength();
  return length;
}


BOOL H501_UsageRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_callInfo.Decode(strm))
    return FALSE;
  if (!m_usageSpec.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H501_UsageRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_callInfo.Encode(strm);
  m_usageSpec.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H501_UsageRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_UsageRequest::Class()), PInvalidCast);
#endif
  return new H501_UsageRequest(*this);
}


//
// UsageIndication
//

H501_UsageIndication::H501_UsageIndication(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 5, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H501_UsageIndication::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "callInfo = " << setprecision(indent) << m_callInfo << '\n';
  if (HasOptionalField(e_accessTokens))
    strm << setw(indent+15) << "accessTokens = " << setprecision(indent) << m_accessTokens << '\n';
  strm << setw(indent+13) << "senderRole = " << setprecision(indent) << m_senderRole << '\n';
  strm << setw(indent+18) << "usageCallStatus = " << setprecision(indent) << m_usageCallStatus << '\n';
  if (HasOptionalField(e_srcInfo))
    strm << setw(indent+10) << "srcInfo = " << setprecision(indent) << m_srcInfo << '\n';
  strm << setw(indent+14) << "destAddress = " << setprecision(indent) << m_destAddress << '\n';
  if (HasOptionalField(e_startTime))
    strm << setw(indent+12) << "startTime = " << setprecision(indent) << m_startTime << '\n';
  if (HasOptionalField(e_endTime))
    strm << setw(indent+10) << "endTime = " << setprecision(indent) << m_endTime << '\n';
  if (HasOptionalField(e_terminationCause))
    strm << setw(indent+19) << "terminationCause = " << setprecision(indent) << m_terminationCause << '\n';
  strm << setw(indent+14) << "usageFields = " << setprecision(indent) << m_usageFields << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H501_UsageIndication::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H501_UsageIndication), PInvalidCast);
#endif
  const H501_UsageIndication & other = (const H501_UsageIndication &)obj;

  Comparison result;

  if ((result = m_callInfo.Compare(other.m_callInfo)) != EqualTo)
    return result;
  if ((result = m_accessTokens.Compare(other.m_accessTokens)) != EqualTo)
    return result;
  if ((result = m_senderRole.Compare(other.m_senderRole)) != EqualTo)
    return result;
  if ((result = m_usageCallStatus.Compare(other.m_usageCallStatus)) != EqualTo)
    return result;
  if ((result = m_srcInfo.Compare(other.m_srcInfo)) != EqualTo)
    return result;
  if ((result = m_destAddress.Compare(other.m_destAddress)) != EqualTo)
    return result;
  if ((result = m_startTime.Compare(other.m_startTime)) != EqualTo)
    return result;
  if ((result = m_endTime.Compare(other.m_endTime)) != EqualTo)
    return result;
  if ((result = m_terminationCause.Compare(other.m_terminationCause)) != EqualTo)
    return result;
  if ((result = m_usageFields.Compare(other.m_usageFields)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H501_UsageIndication::GetDataLength() const
{
  PINDEX length = 0;
  length += m_callInfo.GetObjectLength();
  if (HasOptionalField(e_accessTokens))
    length += m_accessTokens.GetObjectLength();
  length += m_senderRole.GetObjectLength();
  length += m_usageCallStatus.GetObjectLength();
  if (HasOptionalField(e_srcInfo))
    length += m_srcInfo.GetObjectLength();
  length += m_destAddress.GetObjectLength();
  if (HasOptionalField(e_startTime))
    length += m_startTime.GetObjectLength();
  if (HasOptionalField(e_endTime))
    length += m_endTime.GetObjectLength();
  if (HasOptionalField(e_terminationCause))
    length += m_terminationCause.GetObjectLength();
  length += m_usageFields.GetObjectLength();
  return length;
}


BOOL H501_UsageIndication::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_callInfo.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_accessTokens) && !m_accessTokens.Decode(strm))
    return FALSE;
  if (!m_senderRole.Decode(strm))
    return FALSE;
  if (!m_usageCallStatus.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_srcInfo) && !m_srcInfo.Decode(strm))
    return FALSE;
  if (!m_destAddress.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_startTime) && !m_startTime.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_endTime) && !m_endTime.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_terminationCause) && !m_terminationCause.Decode(strm))
    return FALSE;
  if (!m_usageFields.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H501_UsageIndication::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_callInfo.Encode(strm);
  if (HasOptionalField(e_accessTokens))
    m_accessTokens.Encode(strm);
  m_senderRole.Encode(strm);
  m_usageCallStatus.Encode(strm);
  if (HasOptionalField(e_srcInfo))
    m_srcInfo.Encode(strm);
  m_destAddress.Encode(strm);
  if (HasOptionalField(e_startTime))
    m_startTime.Encode(strm);
  if (HasOptionalField(e_endTime))
    m_endTime.Encode(strm);
  if (HasOptionalField(e_terminationCause))
    m_terminationCause.Encode(strm);
  m_usageFields.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H501_UsageIndication::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_UsageIndication::Class()), PInvalidCast);
#endif
  return new H501_UsageIndication(*this);
}


//
// ValidationRequest
//

H501_ValidationRequest::H501_ValidationRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 4, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H501_ValidationRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_accessToken))
    strm << setw(indent+14) << "accessToken = " << setprecision(indent) << m_accessToken << '\n';
  if (HasOptionalField(e_destinationInfo))
    strm << setw(indent+18) << "destinationInfo = " << setprecision(indent) << m_destinationInfo << '\n';
  if (HasOptionalField(e_sourceInfo))
    strm << setw(indent+13) << "sourceInfo = " << setprecision(indent) << m_sourceInfo << '\n';
  strm << setw(indent+11) << "callInfo = " << setprecision(indent) << m_callInfo << '\n';
  if (HasOptionalField(e_usageSpec))
    strm << setw(indent+12) << "usageSpec = " << setprecision(indent) << m_usageSpec << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H501_ValidationRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H501_ValidationRequest), PInvalidCast);
#endif
  const H501_ValidationRequest & other = (const H501_ValidationRequest &)obj;

  Comparison result;

  if ((result = m_accessToken.Compare(other.m_accessToken)) != EqualTo)
    return result;
  if ((result = m_destinationInfo.Compare(other.m_destinationInfo)) != EqualTo)
    return result;
  if ((result = m_sourceInfo.Compare(other.m_sourceInfo)) != EqualTo)
    return result;
  if ((result = m_callInfo.Compare(other.m_callInfo)) != EqualTo)
    return result;
  if ((result = m_usageSpec.Compare(other.m_usageSpec)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H501_ValidationRequest::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_accessToken))
    length += m_accessToken.GetObjectLength();
  if (HasOptionalField(e_destinationInfo))
    length += m_destinationInfo.GetObjectLength();
  if (HasOptionalField(e_sourceInfo))
    length += m_sourceInfo.GetObjectLength();
  length += m_callInfo.GetObjectLength();
  if (HasOptionalField(e_usageSpec))
    length += m_usageSpec.GetObjectLength();
  return length;
}


BOOL H501_ValidationRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_accessToken) && !m_accessToken.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_destinationInfo) && !m_destinationInfo.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_sourceInfo) && !m_sourceInfo.Decode(strm))
    return FALSE;
  if (!m_callInfo.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_usageSpec) && !m_usageSpec.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H501_ValidationRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_accessToken))
    m_accessToken.Encode(strm);
  if (HasOptionalField(e_destinationInfo))
    m_destinationInfo.Encode(strm);
  if (HasOptionalField(e_sourceInfo))
    m_sourceInfo.Encode(strm);
  m_callInfo.Encode(strm);
  if (HasOptionalField(e_usageSpec))
    m_usageSpec.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H501_ValidationRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_ValidationRequest::Class()), PInvalidCast);
#endif
  return new H501_ValidationRequest(*this);
}


//
// ValidationConfirmation
//

H501_ValidationConfirmation::H501_ValidationConfirmation(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H501_ValidationConfirmation::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_destinationInfo))
    strm << setw(indent+18) << "destinationInfo = " << setprecision(indent) << m_destinationInfo << '\n';
  if (HasOptionalField(e_usageSpec))
    strm << setw(indent+12) << "usageSpec = " << setprecision(indent) << m_usageSpec << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H501_ValidationConfirmation::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H501_ValidationConfirmation), PInvalidCast);
#endif
  const H501_ValidationConfirmation & other = (const H501_ValidationConfirmation &)obj;

  Comparison result;

  if ((result = m_destinationInfo.Compare(other.m_destinationInfo)) != EqualTo)
    return result;
  if ((result = m_usageSpec.Compare(other.m_usageSpec)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H501_ValidationConfirmation::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_destinationInfo))
    length += m_destinationInfo.GetObjectLength();
  if (HasOptionalField(e_usageSpec))
    length += m_usageSpec.GetObjectLength();
  return length;
}


BOOL H501_ValidationConfirmation::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_destinationInfo) && !m_destinationInfo.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_usageSpec) && !m_usageSpec.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H501_ValidationConfirmation::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_destinationInfo))
    m_destinationInfo.Encode(strm);
  if (HasOptionalField(e_usageSpec))
    m_usageSpec.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H501_ValidationConfirmation::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_ValidationConfirmation::Class()), PInvalidCast);
#endif
  return new H501_ValidationConfirmation(*this);
}


//
// RouteInformation
//

H501_RouteInformation::H501_RouteInformation(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 3)
{
}


#ifndef PASN_NOPRINTON
void H501_RouteInformation::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+14) << "messageType = " << setprecision(indent) << m_messageType << '\n';
  strm << setw(indent+15) << "callSpecific = " << setprecision(indent) << m_callSpecific << '\n';
  if (HasOptionalField(e_usageSpec))
    strm << setw(indent+12) << "usageSpec = " << setprecision(indent) << m_usageSpec << '\n';
  if (HasOptionalField(e_priceInfo))
    strm << setw(indent+12) << "priceInfo = " << setprecision(indent) << m_priceInfo << '\n';
  strm << setw(indent+11) << "contacts = " << setprecision(indent) << m_contacts << '\n';
  if (HasOptionalField(e_type))
    strm << setw(indent+7) << "type = " << setprecision(indent) << m_type << '\n';
  if (HasOptionalField(e_featureSet))
    strm << setw(indent+13) << "featureSet = " << setprecision(indent) << m_featureSet << '\n';
  if (HasOptionalField(e_circuitID))
    strm << setw(indent+12) << "circuitID = " << setprecision(indent) << m_circuitID << '\n';
  if (HasOptionalField(e_supportedCircuits))
    strm << setw(indent+20) << "supportedCircuits = " << setprecision(indent) << m_supportedCircuits << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H501_RouteInformation::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H501_RouteInformation), PInvalidCast);
#endif
  const H501_RouteInformation & other = (const H501_RouteInformation &)obj;

  Comparison result;

  if ((result = m_messageType.Compare(other.m_messageType)) != EqualTo)
    return result;
  if ((result = m_callSpecific.Compare(other.m_callSpecific)) != EqualTo)
    return result;
  if ((result = m_usageSpec.Compare(other.m_usageSpec)) != EqualTo)
    return result;
  if ((result = m_priceInfo.Compare(other.m_priceInfo)) != EqualTo)
    return result;
  if ((result = m_contacts.Compare(other.m_contacts)) != EqualTo)
    return result;
  if ((result = m_type.Compare(other.m_type)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H501_RouteInformation::GetDataLength() const
{
  PINDEX length = 0;
  length += m_messageType.GetObjectLength();
  length += m_callSpecific.GetObjectLength();
  if (HasOptionalField(e_usageSpec))
    length += m_usageSpec.GetObjectLength();
  if (HasOptionalField(e_priceInfo))
    length += m_priceInfo.GetObjectLength();
  length += m_contacts.GetObjectLength();
  if (HasOptionalField(e_type))
    length += m_type.GetObjectLength();
  return length;
}


BOOL H501_RouteInformation::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_messageType.Decode(strm))
    return FALSE;
  if (!m_callSpecific.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_usageSpec) && !m_usageSpec.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_priceInfo) && !m_priceInfo.Decode(strm))
    return FALSE;
  if (!m_contacts.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_type) && !m_type.Decode(strm))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_featureSet, m_featureSet))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_circuitID, m_circuitID))
    return FALSE;
  if (!KnownExtensionDecode(strm, e_supportedCircuits, m_supportedCircuits))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H501_RouteInformation::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_messageType.Encode(strm);
  m_callSpecific.Encode(strm);
  if (HasOptionalField(e_usageSpec))
    m_usageSpec.Encode(strm);
  if (HasOptionalField(e_priceInfo))
    m_priceInfo.Encode(strm);
  m_contacts.Encode(strm);
  if (HasOptionalField(e_type))
    m_type.Encode(strm);
  KnownExtensionEncode(strm, e_featureSet, m_featureSet);
  KnownExtensionEncode(strm, e_circuitID, m_circuitID);
  KnownExtensionEncode(strm, e_supportedCircuits, m_supportedCircuits);

  UnknownExtensionsEncode(strm);
}


PObject * H501_RouteInformation::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_RouteInformation::Class()), PInvalidCast);
#endif
  return new H501_RouteInformation(*this);
}


//
// Descriptor
//

H501_Descriptor::H501_Descriptor(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H501_Descriptor::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "descriptorInfo = " << setprecision(indent) << m_descriptorInfo << '\n';
  strm << setw(indent+12) << "templates = " << setprecision(indent) << m_templates << '\n';
  if (HasOptionalField(e_gatekeeperID))
    strm << setw(indent+15) << "gatekeeperID = " << setprecision(indent) << m_gatekeeperID << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H501_Descriptor::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H501_Descriptor), PInvalidCast);
#endif
  const H501_Descriptor & other = (const H501_Descriptor &)obj;

  Comparison result;

  if ((result = m_descriptorInfo.Compare(other.m_descriptorInfo)) != EqualTo)
    return result;
  if ((result = m_templates.Compare(other.m_templates)) != EqualTo)
    return result;
  if ((result = m_gatekeeperID.Compare(other.m_gatekeeperID)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H501_Descriptor::GetDataLength() const
{
  PINDEX length = 0;
  length += m_descriptorInfo.GetObjectLength();
  length += m_templates.GetObjectLength();
  if (HasOptionalField(e_gatekeeperID))
    length += m_gatekeeperID.GetObjectLength();
  return length;
}


BOOL H501_Descriptor::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_descriptorInfo.Decode(strm))
    return FALSE;
  if (!m_templates.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_gatekeeperID) && !m_gatekeeperID.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H501_Descriptor::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_descriptorInfo.Encode(strm);
  m_templates.Encode(strm);
  if (HasOptionalField(e_gatekeeperID))
    m_gatekeeperID.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H501_Descriptor::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H501_Descriptor::Class()), PInvalidCast);
#endif
  return new H501_Descriptor(*this);
}


#endif // if ! H323_DISABLE_H501


// End of h501.cxx
