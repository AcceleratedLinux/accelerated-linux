<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>stringprep</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"><LINK
REL="HOME"
TITLE="GNU Libidn API Reference Manual"
HREF="index.html"><LINK
REL="UP"
TITLE="GNU Libidn API Reference Manual"
HREF="c4.html"><LINK
REL="PREVIOUS"
TITLE="GNU Libidn API Reference Manual"
HREF="c4.html"><LINK
REL="NEXT"
TITLE="punycode"
HREF="libidn-punycode.html"><STYLE
TYPE="text/css"
>.synopsis, .classsynopsis {
    background: #eeeeee;
    border: solid 1px #aaaaaa;
    padding: 0.5em;
}
.programlisting {
    background: #eeeeff;
    border: solid 1px #aaaaff;
    padding: 0.5em;
}
.variablelist {
    padding: 4px;
    margin-left: 3em;
}
.navigation {
    background: #ffeeee;
    border: solid 1px #ffaaaa;
    margin-top: 0.5em;
    margin-bottom: 0.5em;
}
.navigation a {
    color: #770000;
}
.navigation a:visited {
    color: #550000;
}
.navigation .title {
    font-size: 200%;
}</STYLE
></HEAD
><BODY
CLASS="REFENTRY"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><TABLE
WIDTH="100%"
CLASS="navigation"
SUMMARY="Navigation header"
CELLPADDING="2"
CELLSPACING="2"
><TR
VALIGN="middle"
><TD
><A
ACCESSKEY="p"
HREF="c4.html"
><IMG
SRC="left.png"
WIDTH="24"
HEIGHT="24"
BORDER="0"
ALT="Prev"></A
></TD
><TD
><A
ACCESSKEY="u"
HREF="c4.html"
><IMG
SRC="up.png"
WIDTH="24"
HEIGHT="24"
BORDER="0"
ALT="Up"></A
></TD
><TD
><A
ACCESSKEY="h"
HREF="index.html"
><IMG
SRC="home.png"
WIDTH="24"
HEIGHT="24"
BORDER="0"
ALT="Home"></A
></TD
><TH
WIDTH="100%"
align="center"
>GNU Libidn API Reference Manual</TH
><TD
><A
ACCESSKEY="n"
HREF="libidn-punycode.html"
><IMG
SRC="right.png"
WIDTH="24"
HEIGHT="24"
BORDER="0"
ALT="Next"></A
></TD
></TR
></TABLE
><H1
><A
NAME="LIBIDN-STRINGPREP"
></A
>stringprep</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN16"
></A
><H2
>Name</H2
>stringprep&nbsp;--&nbsp;</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN19"
></A
><H2
>Synopsis</H2
><PRE
CLASS="SYNOPSIS"
>&#13;

#define     <A
HREF="libidn-stringprep.html#STRINGPREP-VERSION-CAPS"
>STRINGPREP_VERSION</A
>
enum        <A
HREF="libidn-stringprep.html#STRINGPREP-RC"
>Stringprep_rc</A
>;
enum        <A
HREF="libidn-stringprep.html#STRINGPREP-PROFILE-FLAGS"
>Stringprep_profile_flags</A
>;
enum        <A
HREF="libidn-stringprep.html#STRINGPREP-PROFILE-STEPS"
>Stringprep_profile_steps</A
>;
#define     <A
HREF="libidn-stringprep.html#STRINGPREP-MAX-MAP-CHARS-CAPS"
>STRINGPREP_MAX_MAP_CHARS</A
>
#define     <A
HREF="libidn-stringprep.html#STRINGPREP-NAMEPREP"
>stringprep_nameprep</A
>             (in, maxlen)
#define     <A
HREF="libidn-stringprep.html#STRINGPREP-NAMEPREP-NO-UNASSIGNED"
>stringprep_nameprep_no_unassigned</A
>(in, maxlen)
#define     <A
HREF="libidn-stringprep.html#STRINGPREP-PLAIN"
>stringprep_plain</A
>                (in, maxlen)
#define     <A
HREF="libidn-stringprep.html#STRINGPREP-KERBEROS5"
>stringprep_kerberos5</A
>            (in, maxlen)
#define     <A
HREF="libidn-stringprep.html#STRINGPREP-XMPP-NODEPREP"
>stringprep_xmpp_nodeprep</A
>        (in, maxlen)
#define     <A
HREF="libidn-stringprep.html#STRINGPREP-XMPP-RESOURCEPREP"
>stringprep_xmpp_resourceprep</A
>    (in, maxlen)
#define     <A
HREF="libidn-stringprep.html#STRINGPREP-ISCSI"
>stringprep_iscsi</A
>                (in, maxlen)
int         <A
HREF="libidn-stringprep.html#STRINGPREP-4I"
>stringprep_4i</A
>                   (uint32_t *ucs4,
                                             size_t *len,
                                             size_t maxucs4len,
                                             <A
HREF="libidn-stringprep.html#STRINGPREP-PROFILE-FLAGS"
>Stringprep_profile_flags</A
> flags,
                                             const <A
HREF="libidn-stringprep.html#STRINGPREP-PROFILE"
>Stringprep_profile</A
> *profile);
int         <A
HREF="libidn-stringprep.html#STRINGPREP-4ZI"
>stringprep_4zi</A
>                  (uint32_t *ucs4,
                                             size_t maxucs4len,
                                             <A
HREF="libidn-stringprep.html#STRINGPREP-PROFILE-FLAGS"
>Stringprep_profile_flags</A
> flags,
                                             const <A
HREF="libidn-stringprep.html#STRINGPREP-PROFILE"
>Stringprep_profile</A
> *profile);
int         <A
HREF="libidn-stringprep.html#STRINGPREP"
>stringprep</A
>                      (char *in,
                                             size_t maxlen,
                                             <A
HREF="libidn-stringprep.html#STRINGPREP-PROFILE-FLAGS"
>Stringprep_profile_flags</A
> flags,
                                             const <A
HREF="libidn-stringprep.html#STRINGPREP-PROFILE"
>Stringprep_profile</A
> *profile);
int         <A
HREF="libidn-stringprep.html#STRINGPREP-PROFILE"
>stringprep_profile</A
>              (const char *in,
                                             char **out,
                                             const char *profile,
                                             <A
HREF="libidn-stringprep.html#STRINGPREP-PROFILE-FLAGS"
>Stringprep_profile_flags</A
> flags);
const char* <A
HREF="libidn-stringprep.html#STRINGPREP-CHECK-VERSION"
>stringprep_check_version</A
>        (const char *req_version);
int         <A
HREF="libidn-stringprep.html#STRINGPREP-UNICHAR-TO-UTF8"
>stringprep_unichar_to_utf8</A
>      (uint32_t c,
                                             char *outbuf);
uint32_t    <A
HREF="libidn-stringprep.html#STRINGPREP-UTF8-TO-UNICHAR"
>stringprep_utf8_to_unichar</A
>      (const char *p);
uint32_t*   <A
HREF="libidn-stringprep.html#STRINGPREP-UTF8-TO-UCS4"
>stringprep_utf8_to_ucs4</A
>         (const char *str,
                                             ssize_t len,
                                             size_t *items_written);
char*       <A
HREF="libidn-stringprep.html#STRINGPREP-UCS4-TO-UTF8"
>stringprep_ucs4_to_utf8</A
>         (const uint32_t *str,
                                             ssize_t len,
                                             size_t *items_read,
                                             size_t *items_written);
char*       <A
HREF="libidn-stringprep.html#STRINGPREP-UTF8-NFKC-NORMALIZE"
>stringprep_utf8_nfkc_normalize</A
>  (const char *str,
                                             ssize_t len);
uint32_t*   <A
HREF="libidn-stringprep.html#STRINGPREP-UCS4-NFKC-NORMALIZE"
>stringprep_ucs4_nfkc_normalize</A
>  (uint32_t *str,
                                             ssize_t len);
const char* <A
HREF="libidn-stringprep.html#STRINGPREP-LOCALE-CHARSET"
>stringprep_locale_charset</A
>       (void);
char*       <A
HREF="libidn-stringprep.html#STRINGPREP-CONVERT"
>stringprep_convert</A
>              (const char *str,
                                             const char *to_codeset,
                                             const char *from_codeset);
char*       <A
HREF="libidn-stringprep.html#STRINGPREP-LOCALE-TO-UTF8"
>stringprep_locale_to_utf8</A
>       (const char *str);
char*       <A
HREF="libidn-stringprep.html#STRINGPREP-UTF8-TO-LOCALE"
>stringprep_utf8_to_locale</A
>       (const char *str);</PRE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN101"
></A
><H2
>Description</H2
><P
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN104"
></A
><H2
>Details</H2
><DIV
CLASS="REFSECT2"
><A
NAME="AEN106"
></A
><H3
><A
NAME="STRINGPREP-VERSION-CAPS"
></A
>STRINGPREP_VERSION</H3
><PRE
CLASS="PROGRAMLISTING"
>#define STRINGPREP_VERSION "0.5.2"</PRE
><P
>String defined via CPP denoting the header file version number.
Used together with <A
HREF="libidn-stringprep.html#STRINGPREP-CHECK-VERSION"
><CODE
CLASS="FUNCTION"
>stringprep_check_version()</CODE
></A
> to verify header file
and run-time library consistency.</P
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN116"
></A
><H3
><A
NAME="STRINGPREP-RC"
></A
>enum Stringprep_rc</H3
><PRE
CLASS="PROGRAMLISTING"
>  typedef enum
  {
    STRINGPREP_OK = 0,
    /* Stringprep errors. */
    STRINGPREP_CONTAINS_UNASSIGNED = 1,
    STRINGPREP_CONTAINS_PROHIBITED = 2,
    STRINGPREP_BIDI_BOTH_L_AND_RAL = 3,
    STRINGPREP_BIDI_LEADTRAIL_NOT_RAL = 4,
    STRINGPREP_BIDI_CONTAINS_PROHIBITED = 5,
    /* Error in calling application. */
    STRINGPREP_TOO_SMALL_BUFFER = 100,
    STRINGPREP_PROFILE_ERROR = 101,
    STRINGPREP_FLAG_ERROR = 102,
    STRINGPREP_UNKNOWN_PROFILE = 103,
    /* Internal errors. */
    STRINGPREP_NFKC_FAILED = 200,
    STRINGPREP_MALLOC_ERROR = 201
  } Stringprep_rc;</PRE
><P
>Enumerated return codes of <A
HREF="libidn-stringprep.html#STRINGPREP"
><CODE
CLASS="FUNCTION"
>stringprep()</CODE
></A
>, <A
HREF="libidn-stringprep.html#STRINGPREP-PROFILE"
><CODE
CLASS="FUNCTION"
>stringprep_profile()</CODE
></A
>
functions (and macros using those functions).  The value 0 is
guaranteed to always correspond to success.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN129"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="LITERAL"
>STRINGPREP_OK</VAR
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> Successful operation.  This value is guaranteed to
  always be zero, the remaining ones are only guaranteed to hold
  non-zero values, for logical comparison purposes.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN134"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="LITERAL"
>STRINGPREP_CONTAINS_UNASSIGNED</VAR
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> String contain unassigned Unicode
  code points, which is forbidden by the profile.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN139"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="LITERAL"
>STRINGPREP_CONTAINS_PROHIBITED</VAR
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> String contain code points
  prohibited by the profile.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN144"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="LITERAL"
>STRINGPREP_BIDI_BOTH_L_AND_RAL</VAR
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> String contain code points with
  conflicting bidirection category.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN149"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="LITERAL"
>STRINGPREP_BIDI_LEADTRAIL_NOT_RAL</VAR
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> Leading and trailing character
  in string not of proper bidirectional category.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN154"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="LITERAL"
>STRINGPREP_BIDI_CONTAINS_PROHIBITED</VAR
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> Contains prohibited code
  points detected by bidirectional code.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN159"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="LITERAL"
>STRINGPREP_TOO_SMALL_BUFFER</VAR
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> Buffer handed to function was too
  small.  This usually indicate a problem in the calling
  application.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN164"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="LITERAL"
>STRINGPREP_PROFILE_ERROR</VAR
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> The stringprep profile was inconsistent.
  This usually indicate an internal error in the library.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN169"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="LITERAL"
>STRINGPREP_FLAG_ERROR</VAR
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> The supplied flag conflicted with profile.
  This usually indicate a problem in the calling application.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN174"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="LITERAL"
>STRINGPREP_UNKNOWN_PROFILE</VAR
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> The supplied profile name was not
  known to the library.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN179"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="LITERAL"
>STRINGPREP_NFKC_FAILED</VAR
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> The Unicode NFKC operation failed.  This
  usually indicate an internal error in the library.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN184"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="LITERAL"
>STRINGPREP_MALLOC_ERROR</VAR
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> The <GTKDOCLINK
HREF="MALLOC"
><CODE
CLASS="FUNCTION"
>malloc()</CODE
></GTKDOCLINK
> was out of memory.  This is
  usually a fatal error.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN191"
></A
><H3
><A
NAME="STRINGPREP-PROFILE-FLAGS"
></A
>enum Stringprep_profile_flags</H3
><PRE
CLASS="PROGRAMLISTING"
>  typedef enum
  {
    STRINGPREP_NO_NFKC = 1,
    STRINGPREP_NO_BIDI = 2,
    STRINGPREP_NO_UNASSIGNED = 4
  } Stringprep_profile_flags;</PRE
><P
>Stringprep profile flags.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN200"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="LITERAL"
>STRINGPREP_NO_NFKC</VAR
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> Disable the NFKC normalization, as well as
  selecting the non-NFKC case folding tables.  Usually the profile
  specifies BIDI and NFKC settings, and applications should not
  override it unless in special situations.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN205"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="LITERAL"
>STRINGPREP_NO_BIDI</VAR
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> Disable the BIDI step.  Usually the profile
  specifies BIDI and NFKC settings, and applications should not
  override it unless in special situations.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN210"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="LITERAL"
>STRINGPREP_NO_UNASSIGNED</VAR
></SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> Make the library return with an error if
  string contains unassigned characters according to profile.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN215"
></A
><H3
><A
NAME="STRINGPREP-PROFILE-STEPS"
></A
>enum Stringprep_profile_steps</H3
><PRE
CLASS="PROGRAMLISTING"
>  typedef enum
  {
    STRINGPREP_NFKC = 1,
    STRINGPREP_BIDI = 2,
    STRINGPREP_MAP_TABLE = 3,
    STRINGPREP_UNASSIGNED_TABLE = 4,
    STRINGPREP_PROHIBIT_TABLE = 5,
    STRINGPREP_BIDI_PROHIBIT_TABLE = 6,
    STRINGPREP_BIDI_RAL_TABLE = 7,
    STRINGPREP_BIDI_L_TABLE = 8
  } Stringprep_profile_steps;</PRE
><P
>Various steps in the stringprep algorithm.  You really want to
study the source code to understand this one.  Only useful if you
want to add another profile.</P
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN223"
></A
><H3
><A
NAME="STRINGPREP-MAX-MAP-CHARS-CAPS"
></A
>STRINGPREP_MAX_MAP_CHARS</H3
><PRE
CLASS="PROGRAMLISTING"
>#define STRINGPREP_MAX_MAP_CHARS 4</PRE
><P
>Maximum number of code points that can replace a single code point,
during stringprep mapping.</P
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN231"
></A
><H3
><A
NAME="STRINGPREP-NAMEPREP"
></A
>stringprep_nameprep()</H3
><PRE
CLASS="PROGRAMLISTING"
>#define     stringprep_nameprep(in, maxlen)</PRE
><P
>Prepare the input UTF-8 string according to the nameprep profile.
The AllowUnassigned flag is true, use
<A
HREF="libidn-stringprep.html#STRINGPREP-NAMEPREP-NO-UNASSIGNED"
><CODE
CLASS="FUNCTION"
>stringprep_nameprep_no_unassigned()</CODE
></A
> if you want a false
AllowUnassigned.  Returns 0 iff successful, or an error code.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN242"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>in</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> input/ouput array with string to prepare.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN247"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>maxlen</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> maximum length of input/output array.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN252"
></A
><H3
><A
NAME="STRINGPREP-NAMEPREP-NO-UNASSIGNED"
></A
>stringprep_nameprep_no_unassigned()</H3
><PRE
CLASS="PROGRAMLISTING"
>#define     stringprep_nameprep_no_unassigned(in, maxlen)</PRE
><P
>Prepare the input UTF-8 string according to the nameprep profile.
The AllowUnassigned flag is false, use <A
HREF="libidn-stringprep.html#STRINGPREP-NAMEPREP"
><CODE
CLASS="FUNCTION"
>stringprep_nameprep()</CODE
></A
> for
true AllowUnassigned.  Returns 0 iff successful, or an error code.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN263"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>in</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> input/ouput array with string to prepare.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN268"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>maxlen</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> maximum length of input/output array.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN273"
></A
><H3
><A
NAME="STRINGPREP-PLAIN"
></A
>stringprep_plain()</H3
><PRE
CLASS="PROGRAMLISTING"
>#define     stringprep_plain(in, maxlen)</PRE
><P
>Prepare the input UTF-8 string according to the draft SASL
ANONYMOUS profile.  Returns 0 iff successful, or an error code.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN282"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>in</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> input/ouput array with string to prepare.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN287"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>maxlen</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> maximum length of input/output array.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN292"
></A
><H3
><A
NAME="STRINGPREP-KERBEROS5"
></A
>stringprep_kerberos5()</H3
><PRE
CLASS="PROGRAMLISTING"
>#define     stringprep_kerberos5(in, maxlen)</PRE
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN300"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>in</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN305"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>maxlen</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN310"
></A
><H3
><A
NAME="STRINGPREP-XMPP-NODEPREP"
></A
>stringprep_xmpp_nodeprep()</H3
><PRE
CLASS="PROGRAMLISTING"
>#define     stringprep_xmpp_nodeprep(in, maxlen)</PRE
><P
>Prepare the input UTF-8 string according to the draft XMPP node
identifier profile.  Returns 0 iff successful, or an error code.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN319"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>in</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> input/ouput array with string to prepare.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN324"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>maxlen</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> maximum length of input/output array.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN329"
></A
><H3
><A
NAME="STRINGPREP-XMPP-RESOURCEPREP"
></A
>stringprep_xmpp_resourceprep()</H3
><PRE
CLASS="PROGRAMLISTING"
>#define     stringprep_xmpp_resourceprep(in, maxlen)</PRE
><P
>Prepare the input UTF-8 string according to the draft XMPP resource
identifier profile.  Returns 0 iff successful, or an error code.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN338"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>in</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> input/ouput array with string to prepare.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN343"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>maxlen</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> maximum length of input/output array.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN348"
></A
><H3
><A
NAME="STRINGPREP-ISCSI"
></A
>stringprep_iscsi()</H3
><PRE
CLASS="PROGRAMLISTING"
>#define     stringprep_iscsi(in, maxlen)</PRE
><P
>Prepare the input UTF-8 string according to the draft iSCSI
stringprep profile.  Returns 0 iff successful, or an error code.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN357"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>in</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> input/ouput array with string to prepare.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN362"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>maxlen</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> maximum length of input/output array.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN367"
></A
><H3
><A
NAME="STRINGPREP-4I"
></A
>stringprep_4i ()</H3
><PRE
CLASS="PROGRAMLISTING"
>int         stringprep_4i                   (uint32_t *ucs4,
                                             size_t *len,
                                             size_t maxucs4len,
                                             <A
HREF="libidn-stringprep.html#STRINGPREP-PROFILE-FLAGS"
>Stringprep_profile_flags</A
> flags,
                                             const <A
HREF="libidn-stringprep.html#STRINGPREP-PROFILE"
>Stringprep_profile</A
> *profile);</PRE
><P
>Prepare the input UCS-4 string according to the stringprep profile,
and write back the result to the input string.</P
><P
>The input is not required to be zero terminated (<VAR
CLASS="PARAMETER"
>ucs4</VAR
>[<VAR
CLASS="PARAMETER"
>len</VAR
>] = 0).
The output will not be zero terminated unless <VAR
CLASS="PARAMETER"
>ucs4</VAR
>[<VAR
CLASS="PARAMETER"
>len</VAR
>] = 0.
Instead, see <A
HREF="libidn-stringprep.html#STRINGPREP-4ZI"
><CODE
CLASS="FUNCTION"
>stringprep_4zi()</CODE
></A
> if your input is zero terminated or
if you want the output to be.</P
><P
>Since the stringprep operation can expand the string, <VAR
CLASS="PARAMETER"
>maxucs4len</VAR
>
indicate how large the buffer holding the string is.  This function
will not read or write to code points outside that size.</P
><P
>The <VAR
CLASS="PARAMETER"
>flags</VAR
> are one of Stringprep_profile_flags, or 0.</P
><P
>The <VAR
CLASS="PARAMETER"
>profile</VAR
> contain the instructions to perform.  Your application
can define new profiles, possibly re-using the generic stringprep
tables that always will be part of the library, or use one of the
currently supported profiles.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN395"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>ucs4</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> input/output array with string to prepare.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN400"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>len</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> on input, length of input array with Unicode code points,
         on exit, length of output array with Unicode code points.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN405"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>maxucs4len</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> maximum length of input/output array.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN410"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>flags</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> stringprep profile flags, or 0.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN415"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>profile</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> pointer to stringprep profile to use.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN420"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> Returns <VAR
CLASS="LITERAL"
>STRINGPREP_OK</VAR
> iff successful, or an error code.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN426"
></A
><H3
><A
NAME="STRINGPREP-4ZI"
></A
>stringprep_4zi ()</H3
><PRE
CLASS="PROGRAMLISTING"
>int         stringprep_4zi                  (uint32_t *ucs4,
                                             size_t maxucs4len,
                                             <A
HREF="libidn-stringprep.html#STRINGPREP-PROFILE-FLAGS"
>Stringprep_profile_flags</A
> flags,
                                             const <A
HREF="libidn-stringprep.html#STRINGPREP-PROFILE"
>Stringprep_profile</A
> *profile);</PRE
><P
>Prepare the input zero terminated UCS-4 string according to the
stringprep profile, and write back the result to the input string.</P
><P
>Since the stringprep operation can expand the string, <VAR
CLASS="PARAMETER"
>maxucs4len</VAR
>
indicate how large the buffer holding the string is.  This function
will not read or write to code points outside that size.</P
><P
>The <VAR
CLASS="PARAMETER"
>flags</VAR
> are one of Stringprep_profile_flags, or 0.</P
><P
>The <VAR
CLASS="PARAMETER"
>profile</VAR
> contain the instructions to perform.  Your application
can define new profiles, possibly re-using the generic stringprep
tables that always will be part of the library, or use one of the
currently supported profiles.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN446"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>ucs4</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> input/output array with zero terminated string to prepare.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN451"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>maxucs4len</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> maximum length of input/output array.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN456"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>flags</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> stringprep profile flags, or 0.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN461"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>profile</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> pointer to stringprep profile to use.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN466"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> Returns <VAR
CLASS="LITERAL"
>STRINGPREP_OK</VAR
> iff successful, or an error code.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN472"
></A
><H3
><A
NAME="STRINGPREP"
></A
>stringprep ()</H3
><PRE
CLASS="PROGRAMLISTING"
>int         stringprep                      (char *in,
                                             size_t maxlen,
                                             <A
HREF="libidn-stringprep.html#STRINGPREP-PROFILE-FLAGS"
>Stringprep_profile_flags</A
> flags,
                                             const <A
HREF="libidn-stringprep.html#STRINGPREP-PROFILE"
>Stringprep_profile</A
> *profile);</PRE
><P
>Prepare the input zero terminated UTF-8 string according to the
stringprep profile, and write back the result to the input string.</P
><P
>Note that you must convert strings entered in the systems locale
into UTF-8 before using this function, see
<A
HREF="libidn-stringprep.html#STRINGPREP-LOCALE-TO-UTF8"
><CODE
CLASS="FUNCTION"
>stringprep_locale_to_utf8()</CODE
></A
>.</P
><P
>Since the stringprep operation can expand the string, <VAR
CLASS="PARAMETER"
>maxlen</VAR
>
indicate how large the buffer holding the string is.  This function
will not read or write to characters outside that size.</P
><P
>The <VAR
CLASS="PARAMETER"
>flags</VAR
> are one of Stringprep_profile_flags, or 0.</P
><P
>The <VAR
CLASS="PARAMETER"
>profile</VAR
> contain the instructions to perform.  Your application
can define new profiles, possibly re-using the generic stringprep
tables that always will be part of the library, or use one of the
currently supported profiles.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN495"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>in</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> input/ouput array with string to prepare.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN500"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>maxlen</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> maximum length of input/output array.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN505"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>flags</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> stringprep profile flags, or 0.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN510"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>profile</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> pointer to stringprep profile to use.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN515"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> Returns <VAR
CLASS="LITERAL"
>STRINGPREP_OK</VAR
> iff successful, or an error code.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN521"
></A
><H3
><A
NAME="STRINGPREP-PROFILE"
></A
>stringprep_profile ()</H3
><PRE
CLASS="PROGRAMLISTING"
>int         stringprep_profile              (const char *in,
                                             char **out,
                                             const char *profile,
                                             <A
HREF="libidn-stringprep.html#STRINGPREP-PROFILE-FLAGS"
>Stringprep_profile_flags</A
> flags);</PRE
><P
>Prepare the input zero terminated UTF-8 string according to the
stringprep profile, and return the result in a newly allocated
variable.</P
><P
>Note that you must convert strings entered in the systems locale
into UTF-8 before using this function, see
<A
HREF="libidn-stringprep.html#STRINGPREP-LOCALE-TO-UTF8"
><CODE
CLASS="FUNCTION"
>stringprep_locale_to_utf8()</CODE
></A
>.</P
><P
>The output <VAR
CLASS="PARAMETER"
>out</VAR
> variable must be deallocated by the caller.</P
><P
>The <VAR
CLASS="PARAMETER"
>flags</VAR
> are one of Stringprep_profile_flags, or 0.</P
><P
>The <VAR
CLASS="PARAMETER"
>profile</VAR
> specifies the name of the stringprep profile to use.
It must be one of the internally supported stringprep profiles.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN544"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>in</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> input array with UTF-8 string to prepare.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN549"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>out</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> output variable with pointer to newly allocate string.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN554"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>profile</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> name of stringprep profile to use.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN559"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>flags</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> stringprep profile flags, or 0.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN564"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> Returns <VAR
CLASS="LITERAL"
>STRINGPREP_OK</VAR
> iff successful, or an error code.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN570"
></A
><H3
><A
NAME="STRINGPREP-CHECK-VERSION"
></A
>stringprep_check_version ()</H3
><PRE
CLASS="PROGRAMLISTING"
>const char* stringprep_check_version        (const char *req_version);</PRE
><P
>Check that the the version of the library is at minimum the requested one
and return the version string; return NULL if the condition is not
satisfied.  If a NULL is passed to this function, no check is done,
but the version string is simply returned.</P
><P
>See <VAR
CLASS="LITERAL"
>STRINGPREP_VERSION</VAR
> for a suitable <VAR
CLASS="PARAMETER"
>req_version</VAR
> string.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN584"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>req_version</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> Required version number, or NULL.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN589"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> Version string of run-time library, or NULL if the
run-time library does not meet the required version number.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN594"
></A
><H3
><A
NAME="STRINGPREP-UNICHAR-TO-UTF8"
></A
>stringprep_unichar_to_utf8 ()</H3
><PRE
CLASS="PROGRAMLISTING"
>int         stringprep_unichar_to_utf8      (uint32_t c,
                                             char *outbuf);</PRE
><P
>Converts a single character to UTF-8.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN606"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>c</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> a ISO10646 character code</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN611"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>outbuf</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> output buffer, must have at least 6 bytes of space.
      If <VAR
CLASS="LITERAL"
>NULL</VAR
>, the length will be computed and returned
      and nothing will be written to <VAR
CLASS="PARAMETER"
>outbuf</VAR
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN618"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> number of bytes written.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN623"
></A
><H3
><A
NAME="STRINGPREP-UTF8-TO-UNICHAR"
></A
>stringprep_utf8_to_unichar ()</H3
><PRE
CLASS="PROGRAMLISTING"
>uint32_t    stringprep_utf8_to_unichar      (const char *p);</PRE
><P
>Converts a sequence of bytes encoded as UTF-8 to a Unicode character.
If <VAR
CLASS="PARAMETER"
>p</VAR
> does not point to a valid UTF-8 encoded character, results are
undefined.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN635"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>p</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> a pointer to Unicode character encoded as UTF-8</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN640"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> the resulting character.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN645"
></A
><H3
><A
NAME="STRINGPREP-UTF8-TO-UCS4"
></A
>stringprep_utf8_to_ucs4 ()</H3
><PRE
CLASS="PROGRAMLISTING"
>uint32_t*   stringprep_utf8_to_ucs4         (const char *str,
                                             ssize_t len,
                                             size_t *items_written);</PRE
><P
>Convert a string from UTF-8 to a 32-bit fixed width
representation as UCS-4, assuming valid UTF-8 input.
This function does no error checking on the input.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN658"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>str</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> a UTF-8 encoded string</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN663"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>len</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> the maximum length of <VAR
CLASS="PARAMETER"
>str</VAR
> to use. If <VAR
CLASS="PARAMETER"
>len</VAR
> &lt; 0, then
      the string is nul-terminated.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN670"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>items_written</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> location to store the number of characters in the
                result, or <VAR
CLASS="LITERAL"
>NULL</VAR
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN676"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> a pointer to a newly allocated UCS-4 string.
              This value must be freed with <GTKDOCLINK
HREF="FREE"
><CODE
CLASS="FUNCTION"
>free()</CODE
></GTKDOCLINK
>.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN683"
></A
><H3
><A
NAME="STRINGPREP-UCS4-TO-UTF8"
></A
>stringprep_ucs4_to_utf8 ()</H3
><PRE
CLASS="PROGRAMLISTING"
>char*       stringprep_ucs4_to_utf8         (const uint32_t *str,
                                             ssize_t len,
                                             size_t *items_read,
                                             size_t *items_written);</PRE
><P
>Convert a string from a 32-bit fixed width representation as UCS-4.
to UTF-8. The result will be terminated with a 0 byte.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN697"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>str</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> a UCS-4 encoded string</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN702"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>len</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> the maximum length of <VAR
CLASS="PARAMETER"
>str</VAR
> to use. If <VAR
CLASS="PARAMETER"
>len</VAR
> &lt; 0, then
      the string is terminated with a 0 character.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN709"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>items_read</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> location to store number of characters read read, or <VAR
CLASS="LITERAL"
>NULL</VAR
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN715"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>items_written</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> location to store number of bytes written or <VAR
CLASS="LITERAL"
>NULL</VAR
>.
                The value here stored does not include the trailing 0
                byte.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN721"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> a pointer to a newly allocated UTF-8 string.
              This value must be freed with <GTKDOCLINK
HREF="FREE"
><CODE
CLASS="FUNCTION"
>free()</CODE
></GTKDOCLINK
>. If an
              error occurs, <VAR
CLASS="LITERAL"
>NULL</VAR
> will be returned and
              <VAR
CLASS="PARAMETER"
>error</VAR
> set.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN730"
></A
><H3
><A
NAME="STRINGPREP-UTF8-NFKC-NORMALIZE"
></A
>stringprep_utf8_nfkc_normalize ()</H3
><PRE
CLASS="PROGRAMLISTING"
>char*       stringprep_utf8_nfkc_normalize  (const char *str,
                                             ssize_t len);</PRE
><P
>Converts a string into canonical form, standardizing
such issues as whether a character with an accent
is represented as a base character and combining
accent or as a single precomposed character.</P
><P
>The normalization mode is NFKC (ALL COMPOSE).  It standardizes
differences that do not affect the text content, such as the
above-mentioned accent representation. It standardizes the
"compatibility" characters in Unicode, such as SUPERSCRIPT THREE to
the standard forms (in this case DIGIT THREE). Formatting
information may be lost but for most text operations such
characters should be considered the same. It returns a result with
composed forms rather than a maximally decomposed form.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN743"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>str</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> a UTF-8 encoded string.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN748"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>len</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> length of <VAR
CLASS="PARAMETER"
>str</VAR
>, in bytes, or -1 if <VAR
CLASS="PARAMETER"
>str</VAR
> is nul-terminated.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN755"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> a newly allocated string, that is the
  NFKC normalized form of <VAR
CLASS="PARAMETER"
>str</VAR
>.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN761"
></A
><H3
><A
NAME="STRINGPREP-UCS4-NFKC-NORMALIZE"
></A
>stringprep_ucs4_nfkc_normalize ()</H3
><PRE
CLASS="PROGRAMLISTING"
>uint32_t*   stringprep_ucs4_nfkc_normalize  (uint32_t *str,
                                             ssize_t len);</PRE
><P
>Converts UCS4 string into UTF-8 and runs
<A
HREF="libidn-stringprep.html#STRINGPREP-UTF8-NFKC-NORMALIZE"
><CODE
CLASS="FUNCTION"
>stringprep_utf8_nfkc_normalize()</CODE
></A
>.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN775"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>str</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> a Unicode string.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN780"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>len</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> length of <VAR
CLASS="PARAMETER"
>str</VAR
> array, or -1 if <VAR
CLASS="PARAMETER"
>str</VAR
> is nul-terminated.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN787"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> a newly allocated Unicode string, that is the NFKC
  normalized form of <VAR
CLASS="PARAMETER"
>str</VAR
>.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN793"
></A
><H3
><A
NAME="STRINGPREP-LOCALE-CHARSET"
></A
>stringprep_locale_charset ()</H3
><PRE
CLASS="PROGRAMLISTING"
>const char* stringprep_locale_charset       (void);</PRE
><P
>Find out current locale charset.  The function respect the CHARSET
environment variable, but typically uses nl_langinfo(CODESET) when
it is supported.  It fall back on "ASCII" if CHARSET isn't set and
nl_langinfo isn't supported or return anything.</P
><P
>Note that this function return the application's locale's preferred
charset (or thread's locale's preffered charset, if your system
support thread-specific locales).  It does not return what the
system may be using.  Thus, if you receive data from external
sources you cannot in general use this function to guess what
charset it is encoded in.  Use stringprep_convert from the external
representation into the charset returned by this function, to have
data in the locale encoding.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN804"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> Return the character set used by the current locale.
  It will never return NULL, but use "ASCII" as a fallback.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN809"
></A
><H3
><A
NAME="STRINGPREP-CONVERT"
></A
>stringprep_convert ()</H3
><PRE
CLASS="PROGRAMLISTING"
>char*       stringprep_convert              (const char *str,
                                             const char *to_codeset,
                                             const char *from_codeset);</PRE
><P
>Convert the string from one character set to another using the
system's <GTKDOCLINK
HREF="ICONV"
><CODE
CLASS="FUNCTION"
>iconv()</CODE
></GTKDOCLINK
> function.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN824"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>str</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> input zero-terminated string.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN829"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>to_codeset</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> name of destination character set.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN834"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>from_codeset</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> name of origin character set, as used by <VAR
CLASS="PARAMETER"
>str</VAR
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN840"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> Returns newly allocated zero-terminated string which
  is <VAR
CLASS="PARAMETER"
>str</VAR
> transcoded into to_codeset.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN846"
></A
><H3
><A
NAME="STRINGPREP-LOCALE-TO-UTF8"
></A
>stringprep_locale_to_utf8 ()</H3
><PRE
CLASS="PROGRAMLISTING"
>char*       stringprep_locale_to_utf8       (const char *str);</PRE
><P
>Convert string encoded in the locale's character set into UTF-8 by
using <A
HREF="libidn-stringprep.html#STRINGPREP-CONVERT"
><CODE
CLASS="FUNCTION"
>stringprep_convert()</CODE
></A
>.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN859"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>str</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> input zero terminated string.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN864"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> Returns newly allocated zero-terminated string which
  is <VAR
CLASS="PARAMETER"
>str</VAR
> transcoded into UTF-8.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN870"
></A
><H3
><A
NAME="STRINGPREP-UTF8-TO-LOCALE"
></A
>stringprep_utf8_to_locale ()</H3
><PRE
CLASS="PROGRAMLISTING"
>char*       stringprep_utf8_to_locale       (const char *str);</PRE
><P
>Convert string encoded in UTF-8 into the locale's character set by
using <A
HREF="libidn-stringprep.html#STRINGPREP-CONVERT"
><CODE
CLASS="FUNCTION"
>stringprep_convert()</CODE
></A
>.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN883"><SPAN
STYLE="white-space: nowrap"
><VAR
CLASS="PARAMETER"
>str</VAR
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> input zero terminated string.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN888"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> Returns newly allocated zero-terminated string which
  is <VAR
CLASS="PARAMETER"
>str</VAR
> transcoded into the locale's character set.</P
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><TABLE
CLASS="navigation"
WIDTH="100%"
SUMMARY="Navigation footer"
CELLPADDING="2"
CELLSPACING="2"
><TR
VALIGN="middle"
><TD
ALIGN="left"
><A
ACCESSKEY="p"
HREF="c4.html"
><B
>&lt;&lt;&lt;&nbsp;GNU Libidn API Reference Manual</B
></A
></TD
><TD
ALIGN="right"
><A
ACCESSKEY="n"
HREF="libidn-punycode.html"
><B
>punycode&nbsp;&gt;&gt;&gt;</B
></A
></TD
></TR
></TABLE
></BODY
></HTML
>